{
	"title": "What is Ownership? - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html",
	"markdown": "# What is Ownership? - The Rust Programming Language\n\n_Ownership_ is a set of rules that govern how a Rust program manages memory. All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that regularly looks for no-longer-used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program won’t compile. None of the features of ownership will slow down your program while it’s running.\n\nBecause ownership is a new concept for many programmers, it does take some time to get used to. The good news is that the more experienced you become with Rust and the rules of the ownership system, the easier you’ll find it to naturally develop code that is safe and efficient. Keep at it!\n\nWhen you understand ownership, you’ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you’ll learn ownership by working through some examples that focus on a very common data structure: strings.\n\n### [The Stack and the Heap](#the-stack-and-the-heap)\n\nMany programming languages don’t require you to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap affects how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.\n\nBoth the stack and the heap are parts of memory available to your code to use at runtime, but they are structured in different ways. The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as _last in, first out_. Think of a stack of plates: when you add more plates, you put them on top of the pile, and when you need a plate, you take one off the top. Adding or removing plates from the middle or bottom wouldn’t work as well! Adding data is called _pushing onto the stack_, and removing data is called _popping off the stack_. All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.\n\nThe heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a _pointer_, which is the address of that location. This process is called _allocating on the heap_ and is sometimes abbreviated as just _allocating_ (pushing values onto the stack is not considered allocating). Because the pointer to the heap is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer. Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the host finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you’ve been seated to find you.\n\nPushing to the stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; that location is always at the top of the stack. Comparatively, allocating space on the heap requires more work because the allocator must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.\n\nAccessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It’s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that’s close to other data (as it is on the stack) rather than farther away (as it can be on the heap).\n\nWhen your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.\n\nKeeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. Once you understand ownership, you won’t need to think about the stack and the heap very often, but knowing that the main purpose of ownership is to manage heap data can help explain why it works the way it does.\n\n### [Ownership Rules](#ownership-rules)\n\nFirst, let’s take a look at the ownership rules. Keep these rules in mind as we work through the examples that illustrate them:\n\n-   Each value in Rust has an _owner_.\n-   There can only be one owner at a time.\n-   When the owner goes out of scope, the value will be dropped.\n\n### [Variable Scope](#variable-scope)\n\nNow that we’re past basic Rust syntax, we won’t include all the `fn main() {` code in examples, so if you’re following along, make sure to put the following examples inside a `main` function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.\n\nAs a first example of ownership, we’ll look at the _scope_ of some variables. A scope is the range within a program for which an item is valid. Take the following variable:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet s = \"hello\";\n}\n```\n\nThe variable `s` refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it’s declared until the end of the current _scope_. Listing 4-1 shows a program with comments annotating where the variable `s` would be valid.\n\n```rust\nfn main() {\n    {                      // s is not valid here, it’s not yet declared\n        let s = \"hello\";   // s is valid from this point forward\n\n        // do stuff with s\n    }                      // this scope is now over, and s is no longer valid\n}\n```\n\nListing 4-1: A variable and the scope in which it is valid\n\nIn other words, there are two important points in time here:\n\n-   When `s` comes _into_ scope, it is valid.\n-   It remains valid until it goes _out of_ scope.\n\nAt this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we’ll build on top of this understanding by introducing the `String` type.\n\n### [The `String` Type](#the-string-type)\n\nTo illustrate the rules of ownership, we need a data type that is more complex than those we covered in the [“Data Types”](about:blank/ch03-02-data-types.html#data-types) section of Chapter 3. The types covered previously are of a known size, can be stored on the stack and popped off the stack when their scope is over, and can be quickly and trivially copied to make a new, independent instance if another part of code needs to use the same value in a different scope. But we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data, and the `String` type is a great example.\n\nWe’ll concentrate on the parts of `String` that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We’ll discuss `String` in more depth in [Chapter 8](ch08-02-strings.html).\n\nWe’ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren’t suitable for every situation in which we may want to use text. One reason is that they’re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, `String`. This type manages data allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a `String` from a string literal using the `from` function, like so:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet s = String::from(\"hello\");\n}\n```\n\nThe double colon `::` operator allows us to namespace this particular `from` function under the `String` type rather than using some sort of name like `string_from`. We’ll discuss this syntax more in the [“Method Syntax”](about:blank/ch05-03-method-syntax.html#method-syntax) section of Chapter 5, and when we talk about namespacing with modules in [“Paths for Referring to an Item in the Module Tree”](ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html) in Chapter 7.\n\nThis kind of string _can_ be mutated:\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    s.push_str(\", world!\"); // push_str() appends a literal to a String\n\n    println!(\"{s}\"); // This will print `hello, world!`\n}\n```\n\nSo, what’s the difference here? Why can `String` be mutated but literals cannot? The difference is in how these two types deal with memory.\n\n### [Memory and Allocation](#memory-and-allocation)\n\nIn the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal’s immutability. Unfortunately, we can’t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.\n\nWith the `String` type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:\n\n-   The memory must be requested from the memory allocator at runtime.\n-   We need a way of returning this memory to the allocator when we’re done with our `String`.\n\nThat first part is done by us: when we call `String::from`, its implementation requests the memory it needs. This is pretty much universal in programming languages.\n\nHowever, the second part is different. In languages with a _garbage collector (GC)_, the GC keeps track of and cleans up memory that isn’t being used anymore, and we don’t need to think about it. In most languages without a GC, it’s our responsibility to identify when memory is no longer being used and to call code to explicitly free it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we’ll waste memory. If we do it too early, we’ll have an invalid variable. If we do it twice, that’s a bug too. We need to pair exactly one `allocate` with exactly one `free`.\n\nRust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope. Here’s a version of our scope example from Listing 4-1 using a `String` instead of a string literal:\n\n```rust\nfn main() {\n    {\n        let s = String::from(\"hello\"); // s is valid from this point forward\n\n        // do stuff with s\n    }                                  // this scope is now over, and s is no\n                                       // longer valid\n}\n```\n\nThere is a natural point at which we can return the memory our `String` needs to the allocator: when `s` goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called [`drop`](about:blank/std/ops/trait.Drop.html#tymethod.drop), and it’s where the author of `String` can put the code to return the memory. Rust calls `drop` automatically at the closing curly bracket.\n\nNote: In C++, this pattern of deallocating resources at the end of an item’s lifetime is sometimes called _Resource Acquisition Is Initialization (RAII)_. The `drop` function in Rust will be familiar to you if you’ve used RAII patterns.\n\nThis pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we’ve allocated on the heap. Let’s explore some of those situations now.\n\n#### [Variables and Data Interacting with Move](#variables-and-data-interacting-with-move)\n\nMultiple variables can interact with the same data in different ways in Rust. Let’s look at an example using an integer in Listing 4-2.\n\n```rust\nfn main() {\n    let x = 5;\n    let y = x;\n}\n```\n\nListing 4-2: Assigning the integer value of variable `x` to `y`\n\nWe can probably guess what this is doing: “bind the value `5` to `x`; then make a copy of the value in `x` and bind it to `y`.” We now have two variables, `x` and `y`, and both equal `5`. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two `5` values are pushed onto the stack.\n\nNow let’s look at the `String` version:\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n}\n```\n\nThis looks very similar, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in `s1` and bind it to `s2`. But this isn’t quite what happens.\n\nTake a look at Figure 4-1 to see what is happening to `String` under the covers. A `String` is made up of three parts, shown on the left: a pointer to the memory that holds the contents of the string, a length, and a capacity. This group of data is stored on the stack. On the right is the memory on the heap that holds the contents.\n\n![Two tables: the first table contains the representation of s1 on the\nstack, consisting of its length (5), capacity (5), and a pointer to the first\nvalue in the second table. The second table contains the representation of the\nstring data on the heap, byte by byte.](img/trpl04-01.svg)\n\nFigure 4-1: Representation in memory of a `String` holding the value `\"hello\"` bound to `s1`\n\nThe length is how much memory, in bytes, the contents of the `String` are currently using. The capacity is the total amount of memory, in bytes, that the `String` has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it’s fine to ignore the capacity.\n\nWhen we assign `s1` to `s2`, the `String` data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.\n\n![Three tables: tables s1 and s2 representing those strings on the\nstack, respectively, and both pointing to the same string data on the heap.](img/trpl04-02.svg)\n\nFigure 4-2: Representation in memory of the variable `s2` that has a copy of the pointer, length, and capacity of `s1`\n\nThe representation does _not_ look like Figure 4-3, which is what memory would look like if Rust instead copied the heap data as well. If Rust did this, the operation `s2 = s1` could be very expensive in terms of runtime performance if the data on the heap were large.\n\n![Four tables: two tables representing the stack data for s1 and s2,\nand each points to its own copy of string data on the heap.](img/trpl04-03.svg)\n\nFigure 4-3: Another possibility for what `s2 = s1` might do if Rust copied the heap data as well\n\nEarlier, we said that when a variable goes out of scope, Rust automatically calls the `drop` function and cleans up the heap memory for that variable. But Figure 4-2 shows both data pointers pointing to the same location. This is a problem: when `s2` and `s1` go out of scope, they will both try to free the same memory. This is known as a _double free_ error and is one of the memory safety bugs we mentioned previously. Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.\n\nTo ensure memory safety, after the line `let s2 = s1;`, Rust considers `s1` as no longer valid. Therefore, Rust doesn’t need to free anything when `s1` goes out of scope. Check out what happens when you try to use `s1` after `s2` is created; it won’t work:\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n\n    println!(\"{s1}, world!\");\n}\n```\n\nYou’ll get an error like this because Rust prevents you from using the invalidated reference:\n\n```console\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0382]: borrow of moved value: `s1`\n --> src/main.rs:5:15\n  |\n2 |     let s1 = String::from(\"hello\");\n  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait\n3 |     let s2 = s1;\n  |              -- value moved here\n4 |\n5 |     println!(\"{s1}, world!\");\n  |               ^^^^ value borrowed here after move\n  |\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n3 |     let s2 = s1.clone();\n  |                ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `ownership` (bin \"ownership\") due to 1 previous error\n\n```\n\nIf you’ve heard the terms _shallow copy_ and _deep copy_ while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it’s known as a _move_. In this example, we would say that `s1` was _moved_ into `s2`. So, what actually happens is shown in Figure 4-4.\n\n![Three tables: tables s1 and s2 representing those strings on the\nstack, respectively, and both pointing to the same string data on the heap.\nTable s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to\naccess the heap data.](img/trpl04-04.svg)\n\nFigure 4-4: Representation in memory after `s1` has been invalidated\n\nThat solves our problem! With only `s2` valid, when it goes out of scope it alone will free the memory, and we’re done.\n\nIn addition, there’s a design choice that’s implied by this: Rust will never automatically create “deep” copies of your data. Therefore, any _automatic_ copying can be assumed to be inexpensive in terms of runtime performance.\n\n#### [Variables and Data Interacting with Clone](#variables-and-data-interacting-with-clone)\n\nIf we _do_ want to deeply copy the heap data of the `String`, not just the stack data, we can use a common method called `clone`. We’ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you’ve probably seen them before.\n\nHere’s an example of the `clone` method in action:\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n\n    println!(\"s1 = {s1}, s2 = {s2}\");\n}\n```\n\nThis works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data _does_ get copied.\n\nWhen you see a call to `clone`, you know that some arbitrary code is being executed and that code may be expensive. It’s a visual indicator that something different is going on.\n\n#### [Stack-Only Data: Copy](#stack-only-data-copy)\n\nThere’s another wrinkle we haven’t talked about yet. This code using integers—part of which was shown in Listing 4-2—works and is valid:\n\n```rust\nfn main() {\n    let x = 5;\n    let y = x;\n\n    println!(\"x = {x}, y = {y}\");\n}\n```\n\nBut this code seems to contradict what we just learned: we don’t have a call to `clone`, but `x` is still valid and wasn’t moved into `y`.\n\nThe reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there’s no reason we would want to prevent `x` from being valid after we create the variable `y`. In other words, there’s no difference between deep and shallow copying here, so calling `clone` wouldn’t do anything different from the usual shallow copying, and we can leave it out.\n\nRust has a special annotation called the `Copy` trait that we can place on types that are stored on the stack, as integers are (we’ll talk more about traits in [Chapter 10](ch10-02-traits.html)). If a type implements the `Copy` trait, variables that use it do not move, but rather are trivially copied, making them still valid after assignment to another variable.\n\nRust won’t let us annotate a type with `Copy` if the type, or any of its parts, has implemented the `Drop` trait. If the type needs something special to happen when the value goes out of scope and we add the `Copy` annotation to that type, we’ll get a compile-time error. To learn about how to add the `Copy` annotation to your type to implement the trait, see [“Derivable Traits”](appendix-03-derivable-traits.html) in Appendix C.\n\nSo, what types implement the `Copy` trait? You can check the documentation for the given type to be sure, but as a general rule, any group of simple scalar values can implement `Copy`, and nothing that requires allocation or is some form of resource can implement `Copy`. Here are some of the types that implement `Copy`:\n\n-   All the integer types, such as `u32`.\n-   The Boolean type, `bool`, with values `true` and `false`.\n-   All the floating-point types, such as `f64`.\n-   The character type, `char`.\n-   Tuples, if they only contain types that also implement `Copy`. For example, `(i32, i32)` implements `Copy`, but `(i32, String)` does not.\n\n### [Ownership and Functions](#ownership-and-functions)\n\nThe mechanics of passing a value to a function are similar to those when assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");  // s comes into scope\n\n    takes_ownership(s);             // s's value moves into the function...\n                                    // ... and so is no longer valid here\n\n    let x = 5;                      // x comes into scope\n\n    makes_copy(x);                  // x would move into the function,\n                                    // but i32 is Copy, so it's okay to still\n                                    // use x afterward\n\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!(\"{some_string}\");\n} // Here, some_string goes out of scope and `drop` is called. The backing\n  // memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!(\"{some_integer}\");\n} // Here, some_integer goes out of scope. Nothing special happens.\n```\n\nListing 4-3: Functions with ownership and scope annotated\n\nIf we tried to use `s` after the call to `takes_ownership`, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to `main` that uses `s` and `x` to see where you can use them and where the ownership rules prevent you from doing so.\n\n### [Return Values and Scope](#return-values-and-scope)\n\nReturning values can also transfer ownership. Listing 4-4 shows an example of a function that returns some value, with similar annotations as those in Listing 4-3.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let s1 = gives_ownership();         // gives_ownership moves its return\n                                        // value into s1\n\n    let s2 = String::from(\"hello\");     // s2 comes into scope\n\n    let s3 = takes_and_gives_back(s2);  // s2 is moved into\n                                        // takes_and_gives_back, which also\n                                        // moves its return value into s3\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\nfn gives_ownership() -> String {             // gives_ownership will move its\n                                             // return value into the function\n                                             // that calls it\n\n    let some_string = String::from(\"yours\"); // some_string comes into scope\n\n    some_string                              // some_string is returned and\n                                             // moves out to the calling\n                                             // function\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -> String { // a_string comes into\n                                                      // scope\n\n    a_string  // a_string is returned and moves out to the calling function\n}\n```\n\nListing 4-4: Transferring ownership of return values\n\nThe ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by `drop` unless ownership of the data has been moved to another variable.\n\nWhile this works, taking ownership and then returning ownership with every function is a bit tedious. What if we want to let a function use a value but not take ownership? It’s quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well.\n\nRust does let us return multiple values using a tuple, as shown in Listing 4-5.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let (s2, len) = calculate_length(s1);\n\n    println!(\"The length of '{s2}' is {len}.\");\n}\n\nfn calculate_length(s: String) -> (String, usize) {\n    let length = s.len(); // len() returns the length of a String\n\n    (s, length)\n}\n```\n\nListing 4-5: Returning ownership of parameters\n\nBut this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Rust has a feature for using a value without transferring ownership, called _references_.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>What is Ownership? - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"what-is-ownership\"><a class=\"header\" href=\"#what-is-ownership\">What Is Ownership?</a></h2>\n<p><em>Ownership</em> is a set of rules that govern how a Rust program manages memory.\nAll programs have to manage the way they use a computer’s memory while running.\nSome languages have garbage collection that regularly looks for no-longer-used\nmemory as the program runs; in other languages, the programmer must explicitly\nallocate and free the memory. Rust uses a third approach: memory is managed\nthrough a system of ownership with a set of rules that the compiler checks. If\nany of the rules are violated, the program won’t compile. None of the features\nof ownership will slow down your program while it’s running.</p>\n<p>Because ownership is a new concept for many programmers, it does take some time\nto get used to. The good news is that the more experienced you become with Rust\nand the rules of the ownership system, the easier you’ll find it to naturally\ndevelop code that is safe and efficient. Keep at it!</p>\n<p>When you understand ownership, you’ll have a solid foundation for understanding\nthe features that make Rust unique. In this chapter, you’ll learn ownership by\nworking through some examples that focus on a very common data structure:\nstrings.</p>\n<section class=\"note\" aria-role=\"note\">\n<h3 id=\"the-stack-and-the-heap\"><a class=\"header\" href=\"#the-stack-and-the-heap\">The Stack and the Heap</a></h3>\n<p>Many programming languages don’t require you to think about the stack and the\nheap very often. But in a systems programming language like Rust, whether a\nvalue is on the stack or the heap affects how the language behaves and why\nyou have to make certain decisions. Parts of ownership will be described in\nrelation to the stack and the heap later in this chapter, so here is a brief\nexplanation in preparation.</p>\n<p>Both the stack and the heap are parts of memory available to your code to use\nat runtime, but they are structured in different ways. The stack stores\nvalues in the order it gets them and removes the values in the opposite\norder. This is referred to as <em>last in, first out</em>. Think of a stack of\nplates: when you add more plates, you put them on top of the pile, and when\nyou need a plate, you take one off the top. Adding or removing plates from\nthe middle or bottom wouldn’t work as well! Adding data is called <em>pushing\nonto the stack</em>, and removing data is called <em>popping off the stack</em>. All\ndata stored on the stack must have a known, fixed size. Data with an unknown\nsize at compile time or a size that might change must be stored on the heap\ninstead.</p>\n<p>The heap is less organized: when you put data on the heap, you request a\ncertain amount of space. The memory allocator finds an empty spot in the heap\nthat is big enough, marks it as being in use, and returns a <em>pointer</em>, which\nis the address of that location. This process is called <em>allocating on the\nheap</em> and is sometimes abbreviated as just <em>allocating</em> (pushing values onto\nthe stack is not considered allocating). Because the pointer to the heap is a\nknown, fixed size, you can store the pointer on the stack, but when you want\nthe actual data, you must follow the pointer. Think of being seated at a\nrestaurant. When you enter, you state the number of people in your group, and\nthe host finds an empty table that fits everyone and leads you there. If\nsomeone in your group comes late, they can ask where you’ve been seated to\nfind you.</p>\n<p>Pushing to the stack is faster than allocating on the heap because the\nallocator never has to search for a place to store new data; that location is\nalways at the top of the stack. Comparatively, allocating space on the heap\nrequires more work because the allocator must first find a big enough space\nto hold the data and then perform bookkeeping to prepare for the next\nallocation.</p>\n<p>Accessing data in the heap is slower than accessing data on the stack because\nyou have to follow a pointer to get there. Contemporary processors are faster\nif they jump around less in memory. Continuing the analogy, consider a server\nat a restaurant taking orders from many tables. It’s most efficient to get\nall the orders at one table before moving on to the next table. Taking an\norder from table A, then an order from table B, then one from A again, and\nthen one from B again would be a much slower process. By the same token, a\nprocessor can do its job better if it works on data that’s close to other\ndata (as it is on the stack) rather than farther away (as it can be on the\nheap).</p>\n<p>When your code calls a function, the values passed into the function\n(including, potentially, pointers to data on the heap) and the function’s\nlocal variables get pushed onto the stack. When the function is over, those\nvalues get popped off the stack.</p>\n<p>Keeping track of what parts of code are using what data on the heap,\nminimizing the amount of duplicate data on the heap, and cleaning up unused\ndata on the heap so you don’t run out of space are all problems that ownership\naddresses. Once you understand ownership, you won’t need to think about the\nstack and the heap very often, but knowing that the main purpose of ownership\nis to manage heap data can help explain why it works the way it does.</p>\n</section>\n<h3 id=\"ownership-rules\"><a class=\"header\" href=\"#ownership-rules\">Ownership Rules</a></h3>\n<p>First, let’s take a look at the ownership rules. Keep these rules in mind as we\nwork through the examples that illustrate them:</p>\n<ul>\n<li>Each value in Rust has an <em>owner</em>.</li>\n<li>There can only be one owner at a time.</li>\n<li>When the owner goes out of scope, the value will be dropped.</li>\n</ul>\n<h3 id=\"variable-scope\"><a class=\"header\" href=\"#variable-scope\">Variable Scope</a></h3>\n<p>Now that we’re past basic Rust syntax, we won’t include all the <code class=\"hljs\">fn main() {</code>\ncode in examples, so if you’re following along, make sure to put the following\nexamples inside a <code class=\"hljs\">main</code> function manually. As a result, our examples will be a\nbit more concise, letting us focus on the actual details rather than\nboilerplate code.</p>\n<p>As a first example of ownership, we’ll look at the <em>scope</em> of some variables. A\nscope is the range within a program for which an item is valid. Take the\nfollowing variable:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-string\">\"hello\"</span>;\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The variable <code class=\"hljs\">s</code> refers to a string literal, where the value of the string is\nhardcoded into the text of our program. The variable is valid from the point at\nwhich it’s declared until the end of the current <em>scope</em>. Listing 4-1 shows a\nprogram with comments annotating where the variable <code class=\"hljs\">s</code> would be valid.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    {                      <span class=\"hljs-comment\">// s is not valid here, it’s not yet declared</span>\n        <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-string\">\"hello\"</span>;   <span class=\"hljs-comment\">// s is valid from this point forward</span>\n\n        <span class=\"hljs-comment\">// do stuff with s</span>\n    }                      <span class=\"hljs-comment\">// this scope is now over, and s is no longer valid</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 4-1: A variable and the scope in which it is\nvalid</span></p>\n<p>In other words, there are two important points in time here:</p>\n<ul>\n<li>When <code class=\"hljs\">s</code> comes <em>into</em> scope, it is valid.</li>\n<li>It remains valid until it goes <em>out of</em> scope.</li>\n</ul>\n<p>At this point, the relationship between scopes and when variables are valid is\nsimilar to that in other programming languages. Now we’ll build on top of this\nunderstanding by introducing the <code class=\"hljs\">String</code> type.</p>\n<h3 id=\"the-string-type\"><a class=\"header\" href=\"#the-string-type\">The <code>String</code> Type</a></h3>\n<p>To illustrate the rules of ownership, we need a data type that is more complex\nthan those we covered in the <a href=\"ch03-02-data-types.html#data-types\">“Data Types”</a><!-- ignore --> section\nof Chapter 3. The types covered previously are of a known size, can be stored\non the stack and popped off the stack when their scope is over, and can be\nquickly and trivially copied to make a new, independent instance if another\npart of code needs to use the same value in a different scope. But we want to\nlook at data that is stored on the heap and explore how Rust knows when to\nclean up that data, and the <code class=\"hljs\">String</code> type is a great example.</p>\n<p>We’ll concentrate on the parts of <code class=\"hljs\">String</code> that relate to ownership. These\naspects also apply to other complex data types, whether they are provided by\nthe standard library or created by you. We’ll discuss <code class=\"hljs\">String</code> in more depth in\n<a href=\"ch08-02-strings.html\">Chapter 8</a><!-- ignore -->.</p>\n<p>We’ve already seen string literals, where a string value is hardcoded into our\nprogram. String literals are convenient, but they aren’t suitable for every\nsituation in which we may want to use text. One reason is that they’re\nimmutable. Another is that not every string value can be known when we write\nour code: for example, what if we want to take user input and store it? For\nthese situations, Rust has a second string type, <code class=\"hljs\">String</code>. This type manages\ndata allocated on the heap and as such is able to store an amount of text that\nis unknown to us at compile time. You can create a <code class=\"hljs\">String</code> from a string\nliteral using the <code class=\"hljs\">from</code> function, like so:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The double colon <code class=\"hljs\">::</code> operator allows us to namespace this particular <code class=\"hljs\">from</code>\nfunction under the <code class=\"hljs\">String</code> type rather than using some sort of name like\n<code class=\"hljs\">string_from</code>. We’ll discuss this syntax more in the <a href=\"ch05-03-method-syntax.html#method-syntax\">“Method\nSyntax”</a><!-- ignore --> section of Chapter 5, and when we talk\nabout namespacing with modules in <a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\">“Paths for Referring to an Item in the\nModule Tree”</a><!-- ignore --> in Chapter 7.</p>\n<p>This kind of string <em>can</em> be mutated:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> s = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>);\n\n    s.push_str(<span class=\"hljs-string\">\", world!\"</span>); <span class=\"hljs-comment\">// push_str() appends a literal to a String</span>\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{s}\"</span>); <span class=\"hljs-comment\">// This will print `hello, world!`</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p>So, what’s the difference here? Why can <code class=\"hljs\">String</code> be mutated but literals\ncannot? The difference is in how these two types deal with memory.</p>\n<h3 id=\"memory-and-allocation\"><a class=\"header\" href=\"#memory-and-allocation\">Memory and Allocation</a></h3>\n<p>In the case of a string literal, we know the contents at compile time, so the\ntext is hardcoded directly into the final executable. This is why string\nliterals are fast and efficient. But these properties only come from the string\nliteral’s immutability. Unfortunately, we can’t put a blob of memory into the\nbinary for each piece of text whose size is unknown at compile time and whose\nsize might change while running the program.</p>\n<p>With the <code class=\"hljs\">String</code> type, in order to support a mutable, growable piece of text,\nwe need to allocate an amount of memory on the heap, unknown at compile time,\nto hold the contents. This means:</p>\n<ul>\n<li>The memory must be requested from the memory allocator at runtime.</li>\n<li>We need a way of returning this memory to the allocator when we’re done with\nour <code class=\"hljs\">String</code>.</li>\n</ul>\n<p>That first part is done by us: when we call <code class=\"hljs\">String::from</code>, its implementation\nrequests the memory it needs. This is pretty much universal in programming\nlanguages.</p>\n<p>However, the second part is different. In languages with a <em>garbage collector\n(GC)</em>, the GC keeps track of and cleans up memory that isn’t being used\nanymore, and we don’t need to think about it. In most languages without a GC,\nit’s our responsibility to identify when memory is no longer being used and to\ncall code to explicitly free it, just as we did to request it. Doing this\ncorrectly has historically been a difficult programming problem. If we forget,\nwe’ll waste memory. If we do it too early, we’ll have an invalid variable. If\nwe do it twice, that’s a bug too. We need to pair exactly one <code class=\"hljs\">allocate</code> with\nexactly one <code class=\"hljs\">free</code>.</p>\n<p>Rust takes a different path: the memory is automatically returned once the\nvariable that owns it goes out of scope. Here’s a version of our scope example\nfrom Listing 4-1 using a <code class=\"hljs\">String</code> instead of a string literal:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    {\n        <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>); <span class=\"hljs-comment\">// s is valid from this point forward</span>\n\n        <span class=\"hljs-comment\">// do stuff with s</span>\n    }                                  <span class=\"hljs-comment\">// this scope is now over, and s is no</span>\n                                       <span class=\"hljs-comment\">// longer valid</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p>There is a natural point at which we can return the memory our <code class=\"hljs\">String</code> needs\nto the allocator: when <code class=\"hljs\">s</code> goes out of scope. When a variable goes out of\nscope, Rust calls a special function for us. This function is called\n<a href=\"../std/ops/trait.Drop.html#tymethod.drop\"><code class=\"hljs\">drop</code></a><!-- ignore -->, and it’s where the author of <code class=\"hljs\">String</code> can put\nthe code to return the memory. Rust calls <code class=\"hljs\">drop</code> automatically at the closing\ncurly bracket.</p>\n<section class=\"note\" aria-role=\"note\">\n<p>Note: In C++, this pattern of deallocating resources at the end of an item’s\nlifetime is sometimes called <em>Resource Acquisition Is Initialization (RAII)</em>.\nThe <code class=\"hljs\">drop</code> function in Rust will be familiar to you if you’ve used RAII\npatterns.</p>\n</section>\n<p>This pattern has a profound impact on the way Rust code is written. It may seem\nsimple right now, but the behavior of code can be unexpected in more\ncomplicated situations when we want to have multiple variables use the data\nwe’ve allocated on the heap. Let’s explore some of those situations now.</p>\n<!-- Old heading. Do not remove or links may break. -->\n<p><a id=\"ways-variables-and-data-interact-move\"></a></p>\n<h4 id=\"variables-and-data-interacting-with-move\"><a class=\"header\" href=\"#variables-and-data-interacting-with-move\">Variables and Data Interacting with Move</a></h4>\n<p>Multiple variables can interact with the same data in different ways in Rust.\nLet’s look at an example using an integer in Listing 4-2.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> y = x;\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 4-2: Assigning the integer value of variable <code class=\"hljs\">x</code>\nto <code class=\"hljs\">y</code></span></p>\n<p>We can probably guess what this is doing: “bind the value <code class=\"hljs\">5</code> to <code class=\"hljs\">x</code>; then make\na copy of the value in <code class=\"hljs\">x</code> and bind it to <code class=\"hljs\">y</code>.” We now have two variables, <code class=\"hljs\">x</code>\nand <code class=\"hljs\">y</code>, and both equal <code class=\"hljs\">5</code>. This is indeed what is happening, because integers\nare simple values with a known, fixed size, and these two <code class=\"hljs\">5</code> values are pushed\nonto the stack.</p>\n<p>Now let’s look at the <code class=\"hljs\">String</code> version:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>);\n    <span class=\"hljs-keyword\">let</span> s2 = s1;\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This looks very similar, so we might assume that the way it works would be the\nsame: that is, the second line would make a copy of the value in <code class=\"hljs\">s1</code> and bind\nit to <code class=\"hljs\">s2</code>. But this isn’t quite what happens.</p>\n<p>Take a look at Figure 4-1 to see what is happening to <code class=\"hljs\">String</code> under the\ncovers. A <code class=\"hljs\">String</code> is made up of three parts, shown on the left: a pointer to\nthe memory that holds the contents of the string, a length, and a capacity.\nThis group of data is stored on the stack. On the right is the memory on the\nheap that holds the contents.</p>\n<p><img alt=\"Two tables: the first table contains the representation of s1 on the\nstack, consisting of its length (5), capacity (5), and a pointer to the first\nvalue in the second table. The second table contains the representation of the\nstring data on the heap, byte by byte.\" src=\"img/trpl04-01.svg\" class=\"center\" style=\"width: 50%;\"></p>\n<p><span class=\"caption\">Figure 4-1: Representation in memory of a <code class=\"hljs\">String</code>\nholding the value <code class=\"hljs\">\"hello\"</code> bound to <code class=\"hljs\">s1</code></span></p>\n<p>The length is how much memory, in bytes, the contents of the <code class=\"hljs\">String</code> are\ncurrently using. The capacity is the total amount of memory, in bytes, that the\n<code class=\"hljs\">String</code> has received from the allocator. The difference between length and\ncapacity matters, but not in this context, so for now, it’s fine to ignore the\ncapacity.</p>\n<p>When we assign <code class=\"hljs\">s1</code> to <code class=\"hljs\">s2</code>, the <code class=\"hljs\">String</code> data is copied, meaning we copy the\npointer, the length, and the capacity that are on the stack. We do not copy the\ndata on the heap that the pointer refers to. In other words, the data\nrepresentation in memory looks like Figure 4-2.</p>\n<p><img alt=\"Three tables: tables s1 and s2 representing those strings on the\nstack, respectively, and both pointing to the same string data on the heap.\" src=\"img/trpl04-02.svg\" class=\"center\" style=\"width: 50%;\"></p>\n<p><span class=\"caption\">Figure 4-2: Representation in memory of the variable <code class=\"hljs\">s2</code>\nthat has a copy of the pointer, length, and capacity of <code class=\"hljs\">s1</code></span></p>\n<p>The representation does <em>not</em> look like Figure 4-3, which is what memory would\nlook like if Rust instead copied the heap data as well. If Rust did this, the\noperation <code class=\"hljs\">s2 = s1</code> could be very expensive in terms of runtime performance if\nthe data on the heap were large.</p>\n<p><img alt=\"Four tables: two tables representing the stack data for s1 and s2,\nand each points to its own copy of string data on the heap.\" src=\"img/trpl04-03.svg\" class=\"center\" style=\"width: 50%;\"></p>\n<p><span class=\"caption\">Figure 4-3: Another possibility for what <code class=\"hljs\">s2 = s1</code> might\ndo if Rust copied the heap data as well</span></p>\n<p>Earlier, we said that when a variable goes out of scope, Rust automatically\ncalls the <code class=\"hljs\">drop</code> function and cleans up the heap memory for that variable. But\nFigure 4-2 shows both data pointers pointing to the same location. This is a\nproblem: when <code class=\"hljs\">s2</code> and <code class=\"hljs\">s1</code> go out of scope, they will both try to free the\nsame memory. This is known as a <em>double free</em> error and is one of the memory\nsafety bugs we mentioned previously. Freeing memory twice can lead to memory\ncorruption, which can potentially lead to security vulnerabilities.</p>\n<p>To ensure memory safety, after the line <code class=\"hljs\">let s2 = s1;</code>, Rust considers <code class=\"hljs\">s1</code> as\nno longer valid. Therefore, Rust doesn’t need to free anything when <code class=\"hljs\">s1</code> goes\nout of scope. Check out what happens when you try to use <code class=\"hljs\">s1</code> after <code class=\"hljs\">s2</code> is\ncreated; it won’t work:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>);\n    <span class=\"hljs-keyword\">let</span> s2 = s1;\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{s1}, world!\"</span>);\n<span class=\"boring\">}</span></code></pre>\n<p>You’ll get an error like this because Rust prevents you from using the\ninvalidated reference:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0382]: borrow of moved value: `s1`\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:5:15</span>\n  |\n2 |     let s1 = String::from(\"hello\");\n  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait\n3 |     let s2 = s1;\n  |              -- value moved here\n4 |\n5 |     println!(\"{s1}, world!\");\n  |               ^^^^ value borrowed here after move\n  |\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n3 |     let s2 = s1.clone();\n  |                ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `ownership` (bin \"ownership\") due to 1 previous error\n</code></pre>\n<p>If you’ve heard the terms <em>shallow copy</em> and <em>deep copy</em> while working with\nother languages, the concept of copying the pointer, length, and capacity\nwithout copying the data probably sounds like making a shallow copy. But\nbecause Rust also invalidates the first variable, instead of being called a\nshallow copy, it’s known as a <em>move</em>. In this example, we would say that <code class=\"hljs\">s1</code>\nwas <em>moved</em> into <code class=\"hljs\">s2</code>. So, what actually happens is shown in Figure 4-4.</p>\n<p><img alt=\"Three tables: tables s1 and s2 representing those strings on the\nstack, respectively, and both pointing to the same string data on the heap.\nTable s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to\naccess the heap data.\" src=\"img/trpl04-04.svg\" class=\"center\" style=\"width:\n50%;\"></p>\n<p><span class=\"caption\">Figure 4-4: Representation in memory after <code class=\"hljs\">s1</code> has been\ninvalidated</span></p>\n<p>That solves our problem! With only <code class=\"hljs\">s2</code> valid, when it goes out of scope it\nalone will free the memory, and we’re done.</p>\n<p>In addition, there’s a design choice that’s implied by this: Rust will never\nautomatically create “deep” copies of your data. Therefore, any <em>automatic</em>\ncopying can be assumed to be inexpensive in terms of runtime performance.</p>\n<!-- Old heading. Do not remove or links may break. -->\n<p><a id=\"ways-variables-and-data-interact-clone\"></a></p>\n<h4 id=\"variables-and-data-interacting-with-clone\"><a class=\"header\" href=\"#variables-and-data-interacting-with-clone\">Variables and Data Interacting with Clone</a></h4>\n<p>If we <em>do</em> want to deeply copy the heap data of the <code class=\"hljs\">String</code>, not just the\nstack data, we can use a common method called <code class=\"hljs\">clone</code>. We’ll discuss method\nsyntax in Chapter 5, but because methods are a common feature in many\nprogramming languages, you’ve probably seen them before.</p>\n<p>Here’s an example of the <code class=\"hljs\">clone</code> method in action:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>);\n    <span class=\"hljs-keyword\">let</span> s2 = s1.clone();\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"s1 = {s1}, s2 = {s2}\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This works just fine and explicitly produces the behavior shown in Figure 4-3,\nwhere the heap data <em>does</em> get copied.</p>\n<p>When you see a call to <code class=\"hljs\">clone</code>, you know that some arbitrary code is being\nexecuted and that code may be expensive. It’s a visual indicator that something\ndifferent is going on.</p>\n<h4 id=\"stack-only-data-copy\"><a class=\"header\" href=\"#stack-only-data-copy\">Stack-Only Data: Copy</a></h4>\n<p>There’s another wrinkle we haven’t talked about yet. This code using\nintegers—part of which was shown in Listing 4-2—works and is valid:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> y = x;\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"x = {x}, y = {y}\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>But this code seems to contradict what we just learned: we don’t have a call to\n<code class=\"hljs\">clone</code>, but <code class=\"hljs\">x</code> is still valid and wasn’t moved into <code class=\"hljs\">y</code>.</p>\n<p>The reason is that types such as integers that have a known size at compile\ntime are stored entirely on the stack, so copies of the actual values are quick\nto make. That means there’s no reason we would want to prevent <code class=\"hljs\">x</code> from being\nvalid after we create the variable <code class=\"hljs\">y</code>. In other words, there’s no difference\nbetween deep and shallow copying here, so calling <code class=\"hljs\">clone</code> wouldn’t do anything\ndifferent from the usual shallow copying, and we can leave it out.</p>\n<p>Rust has a special annotation called the <code class=\"hljs\">Copy</code> trait that we can place on\ntypes that are stored on the stack, as integers are (we’ll talk more about\ntraits in <a href=\"ch10-02-traits.html\">Chapter 10</a><!-- ignore -->). If a type implements the <code class=\"hljs\">Copy</code>\ntrait, variables that use it do not move, but rather are trivially copied,\nmaking them still valid after assignment to another variable.</p>\n<p>Rust won’t let us annotate a type with <code class=\"hljs\">Copy</code> if the type, or any of its parts,\nhas implemented the <code class=\"hljs\">Drop</code> trait. If the type needs something special to happen\nwhen the value goes out of scope and we add the <code class=\"hljs\">Copy</code> annotation to that type,\nwe’ll get a compile-time error. To learn about how to add the <code class=\"hljs\">Copy</code> annotation\nto your type to implement the trait, see <a href=\"appendix-03-derivable-traits.html\">“Derivable\nTraits”</a><!-- ignore --> in Appendix C.</p>\n<p>So, what types implement the <code class=\"hljs\">Copy</code> trait? You can check the documentation for\nthe given type to be sure, but as a general rule, any group of simple scalar\nvalues can implement <code class=\"hljs\">Copy</code>, and nothing that requires allocation or is some\nform of resource can implement <code class=\"hljs\">Copy</code>. Here are some of the types that\nimplement <code class=\"hljs\">Copy</code>:</p>\n<ul>\n<li>All the integer types, such as <code class=\"hljs\">u32</code>.</li>\n<li>The Boolean type, <code class=\"hljs\">bool</code>, with values <code class=\"hljs\">true</code> and <code class=\"hljs\">false</code>.</li>\n<li>All the floating-point types, such as <code class=\"hljs\">f64</code>.</li>\n<li>The character type, <code class=\"hljs\">char</code>.</li>\n<li>Tuples, if they only contain types that also implement <code class=\"hljs\">Copy</code>. For example,\n<code class=\"hljs\">(i32, i32)</code> implements <code class=\"hljs\">Copy</code>, but <code class=\"hljs\">(i32, String)</code> does not.</li>\n</ul>\n<h3 id=\"ownership-and-functions\"><a class=\"header\" href=\"#ownership-and-functions\">Ownership and Functions</a></h3>\n<p>The mechanics of passing a value to a function are similar to those when\nassigning a value to a variable. Passing a variable to a function will move or\ncopy, just as assignment does. Listing 4-3 has an example with some annotations\nshowing where variables go into and out of scope.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>);  <span class=\"hljs-comment\">// s comes into scope</span>\n\n    takes_ownership(s);             <span class=\"hljs-comment\">// s's value moves into the function...</span>\n                                    <span class=\"hljs-comment\">// ... and so is no longer valid here</span>\n\n    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;                      <span class=\"hljs-comment\">// x comes into scope</span>\n\n    makes_copy(x);                  <span class=\"hljs-comment\">// x would move into the function,</span>\n                                    <span class=\"hljs-comment\">// but i32 is Copy, so it's okay to still</span>\n                                    <span class=\"hljs-comment\">// use x afterward</span>\n\n} <span class=\"hljs-comment\">// Here, x goes out of scope, then s. But because s's value was moved, nothing</span>\n  <span class=\"hljs-comment\">// special happens.</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">takes_ownership</span></span>(some_string: <span class=\"hljs-built_in\">String</span>) { <span class=\"hljs-comment\">// some_string comes into scope</span>\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{some_string}\"</span>);\n} <span class=\"hljs-comment\">// Here, some_string goes out of scope and `drop` is called. The backing</span>\n  <span class=\"hljs-comment\">// memory is freed.</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">makes_copy</span></span>(some_integer: <span class=\"hljs-built_in\">i32</span>) { <span class=\"hljs-comment\">// some_integer comes into scope</span>\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{some_integer}\"</span>);\n} <span class=\"hljs-comment\">// Here, some_integer goes out of scope. Nothing special happens.</span></code></pre></pre>\n<p><span class=\"caption\">Listing 4-3: Functions with ownership and scope\nannotated</span></p>\n<p>If we tried to use <code class=\"hljs\">s</code> after the call to <code class=\"hljs\">takes_ownership</code>, Rust would throw a\ncompile-time error. These static checks protect us from mistakes. Try adding\ncode to <code class=\"hljs\">main</code> that uses <code class=\"hljs\">s</code> and <code class=\"hljs\">x</code> to see where you can use them and where\nthe ownership rules prevent you from doing so.</p>\n<h3 id=\"return-values-and-scope\"><a class=\"header\" href=\"#return-values-and-scope\">Return Values and Scope</a></h3>\n<p>Returning values can also transfer ownership. Listing 4-4 shows an example of a\nfunction that returns some value, with similar annotations as those in Listing\n4-3.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s1 = gives_ownership();         <span class=\"hljs-comment\">// gives_ownership moves its return</span>\n                                        <span class=\"hljs-comment\">// value into s1</span>\n\n    <span class=\"hljs-keyword\">let</span> s2 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>);     <span class=\"hljs-comment\">// s2 comes into scope</span>\n\n    <span class=\"hljs-keyword\">let</span> s3 = takes_and_gives_back(s2);  <span class=\"hljs-comment\">// s2 is moved into</span>\n                                        <span class=\"hljs-comment\">// takes_and_gives_back, which also</span>\n                                        <span class=\"hljs-comment\">// moves its return value into s3</span>\n} <span class=\"hljs-comment\">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span>\n  <span class=\"hljs-comment\">// happens. s1 goes out of scope and is dropped.</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">gives_ownership</span></span>() -&gt; <span class=\"hljs-built_in\">String</span> {             <span class=\"hljs-comment\">// gives_ownership will move its</span>\n                                             <span class=\"hljs-comment\">// return value into the function</span>\n                                             <span class=\"hljs-comment\">// that calls it</span>\n\n    <span class=\"hljs-keyword\">let</span> some_string = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"yours\"</span>); <span class=\"hljs-comment\">// some_string comes into scope</span>\n\n    some_string                              <span class=\"hljs-comment\">// some_string is returned and</span>\n                                             <span class=\"hljs-comment\">// moves out to the calling</span>\n                                             <span class=\"hljs-comment\">// function</span>\n}\n\n<span class=\"hljs-comment\">// This function takes a String and returns one</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">takes_and_gives_back</span></span>(a_string: <span class=\"hljs-built_in\">String</span>) -&gt; <span class=\"hljs-built_in\">String</span> { <span class=\"hljs-comment\">// a_string comes into</span>\n                                                      <span class=\"hljs-comment\">// scope</span>\n\n    a_string  <span class=\"hljs-comment\">// a_string is returned and moves out to the calling function</span>\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 4-4: Transferring ownership of return\nvalues</span></p>\n<p>The ownership of a variable follows the same pattern every time: assigning a\nvalue to another variable moves it. When a variable that includes data on the\nheap goes out of scope, the value will be cleaned up by <code class=\"hljs\">drop</code> unless ownership\nof the data has been moved to another variable.</p>\n<p>While this works, taking ownership and then returning ownership with every\nfunction is a bit tedious. What if we want to let a function use a value but\nnot take ownership? It’s quite annoying that anything we pass in also needs to\nbe passed back if we want to use it again, in addition to any data resulting\nfrom the body of the function that we might want to return as well.</p>\n<p>Rust does let us return multiple values using a tuple, as shown in Listing 4-5.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> (s2, len) = calculate_length(s1);\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The length of '{s2}' is {len}.\"</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">calculate_length</span></span>(s: <span class=\"hljs-built_in\">String</span>) -&gt; (<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">usize</span>) {\n    <span class=\"hljs-keyword\">let</span> length = s.len(); <span class=\"hljs-comment\">// len() returns the length of a String</span>\n\n    (s, length)\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 4-5: Returning ownership of parameters</span></p>\n<p>But this is too much ceremony and a lot of work for a concept that should be\ncommon. Luckily for us, Rust has a feature for using a value without\ntransferring ownership, called <em>references</em>.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch04-00-understanding-ownership.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch04-02-references-and-borrowing.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch04-00-understanding-ownership.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch04-02-references-and-borrowing.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:14.593Z"
}