{
	"title": "Macros - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/book/ch19-06-macros.html",
	"markdown": "# Macros - The Rust Programming Language\n\nWe’ve used macros like `println!` throughout this book, but we haven’t fully explored what a macro is and how it works. The term _macro_ refers to a family of features in Rust: _declarative_ macros with `macro_rules!` and three kinds of _procedural_ macros:\n\n-   Custom `#[derive]` macros that specify code added with the `derive` attribute used on structs and enums\n-   Attribute-like macros that define custom attributes usable on any item\n-   Function-like macros that look like function calls but operate on the tokens specified as their argument\n\nWe’ll talk about each of these in turn, but first, let’s look at why we even need macros when we already have functions.\n\n### [The Difference Between Macros and Functions](#the-difference-between-macros-and-functions)\n\nFundamentally, macros are a way of writing code that writes other code, which is known as _metaprogramming_. In Appendix C, we discuss the `derive` attribute, which generates an implementation of various traits for you. We’ve also used the `println!` and `vec!` macros throughout the book. All of these macros _expand_ to produce more code than the code you’ve written manually.\n\nMetaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t.\n\nA function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call `println!(\"hello\")` with one argument or `println!(\"hello {}\", name)` with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.\n\nThe downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you’re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.\n\nAnother important difference between macros and functions is that you must define macros or bring them into scope _before_ you call them in a file, as opposed to functions you can define anywhere and call anywhere.\n\n### [Declarative Macros with `macro_rules!` for General Metaprogramming](#declarative-macros-with-macro_rules-for-general-metaprogramming)\n\nThe most widely used form of macros in Rust is the _declarative macro_. These are also sometimes referred to as “macros by example,” “`macro_rules!` macros,” or just plain “macros.” At their core, declarative macros allow you to write something similar to a Rust `match` expression. As discussed in Chapter 6, `match` expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.\n\nTo define a macro, you use the `macro_rules!` construct. Let’s explore how to use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8 covered how we can use the `vec!` macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet v: Vec<u32> = vec![1, 2, 3];\n}\n```\n\nWe could also use the `vec!` macro to make a vector of two integers or a vector of five string slices. We wouldn’t be able to use a function to do the same because we wouldn’t know the number or type of values up front.\n\nListing 19-28 shows a slightly simplified definition of the `vec!` macro.\n\nFilename: src/lib.rs\n\n```rust\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n```\n\nListing 19-28: A simplified version of the `vec!` macro definition\n\nNote: The actual definition of the `vec!` macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don’t include here to make the example simpler.\n\nThe `#[macro_export]` annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can’t be brought into scope.\n\nWe then start the macro definition with `macro_rules!` and the name of the macro we’re defining _without_ the exclamation mark. The name, in this case `vec`, is followed by curly brackets denoting the body of the macro definition.\n\nThe structure in the `vec!` body is similar to the structure of a `match` expression. Here we have one arm with the pattern `( $( $x:expr ),* )`, followed by `=>` and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.\n\nValid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let’s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see the [Rust Reference](../reference/macros-by-example.html).\n\nFirst, we use a set of parentheses to encompass the whole pattern. We use a dollar sign (`$`) to declare a variable in the macro system that will contain the Rust code matching the pattern. The dollar sign makes it clear this is a macro variable as opposed to a regular Rust variable. Next comes a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. Within `$()` is `$x:expr`, which matches any Rust expression and gives the expression the name `$x`.\n\nThe comma following `$()` indicates that a literal comma separator character could optionally appear after the code that matches the code in `$()`. The `*` specifies that the pattern matches zero or more of whatever precedes the `*`.\n\nWhen we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches three times with the three expressions `1`, `2`, and `3`.\n\nNow let’s look at the pattern in the body of the code associated with this arm: `temp_vec.push()` within `$()*` is generated for each part that matches `$()` in the pattern zero or more times depending on how many times the pattern matches. The `$x` is replaced with each expression matched. When we call this macro with `vec![1, 2, 3];`, the code generated that replaces this macro call will be the following:\n\n```rust\n{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n```\n\nWe’ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.\n\nTo learn more about how to write macros, consult the online documentation or other resources, such as [“The Little Book of Rust Macros”](https://veykril.github.io/tlborm/) started by Daniel Keep and continued by Lukas Wirth.\n\n### [Procedural Macros for Generating Code from Attributes](#procedural-macros-for-generating-code-from-attributes)\n\nThe second form of macros is the _procedural macro_, which acts more like a function (and is a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do. The three kinds of procedural macros are custom derive, attribute-like, and function-like, and all work in a similar fashion.\n\nWhen creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. In Listing 19-29, we show how to define a procedural macro, where `some_attribute` is a placeholder for using a specific macro variety.\n\nFilename: src/lib.rs\n\n```rust\nuse proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -> TokenStream {\n}\n```\n\nListing 19-29: An example of defining a procedural macro\n\nThe function that defines a procedural macro takes a `TokenStream` as an input and produces a `TokenStream` as an output. The `TokenStream` type is defined by the `proc_macro` crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input `TokenStream`, and the code the macro produces is the output `TokenStream`. The function also has an attribute attached to it that specifies which kind of procedural macro we’re creating. We can have multiple kinds of procedural macros in the same crate.\n\nLet’s look at the different kinds of procedural macros. We’ll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.\n\n### [How to Write a Custom `derive` Macro](#how-to-write-a-custom-derive-macro)\n\nLet’s create a crate named `hello_macro` that defines a trait named `HelloMacro` with one associated function named `hello_macro`. Rather than making our users implement the `HelloMacro` trait for each of their types, we’ll provide a procedural macro so users can annotate their type with `#[derive(HelloMacro)]` to get a default implementation of the `hello_macro` function. The default implementation will print `Hello, Macro! My name is TypeName!` where `TypeName` is the name of the type on which this trait has been defined. In other words, we’ll write a crate that enables another programmer to write code like Listing 19-30 using our crate.\n\nFilename: src/main.rs\n\n```rust\nuse hello_macro::HelloMacro;\nuse hello_macro_derive::HelloMacro;\n\n#[derive(HelloMacro)]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_macro();\n}\n```\n\nListing 19-30: The code a user of our crate will be able to write when using our procedural macro\n\nThis code will print `Hello, Macro! My name is Pancakes!` when we’re done. The first step is to make a new library crate, like this:\n\n```console\n$ cargo new hello_macro --lib\n\n```\n\nNext, we’ll define the `HelloMacro` trait and its associated function:\n\nFilename: src/lib.rs\n\n```rust\npub trait HelloMacro {\n    fn hello_macro();\n}\n```\n\nWe have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:\n\n```rust\nuse hello_macro::HelloMacro;\n\nstruct Pancakes;\n\nimpl HelloMacro for Pancakes {\n    fn hello_macro() {\n        println!(\"Hello, Macro! My name is Pancakes!\");\n    }\n}\n\nfn main() {\n    Pancakes::hello_macro();\n}\n```\n\nHowever, they would need to write the implementation block for each type they wanted to use with `hello_macro`; we want to spare them from having to do this work.\n\nAdditionally, we can’t yet provide the `hello_macro` function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime. We need a macro to generate code at compile time.\n\nThe next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named `foo`, a custom derive procedural macro crate is called `foo_derive`. Let’s start a new crate called `hello_macro_derive` inside our `hello_macro` project:\n\n```console\n$ cargo new hello_macro_derive --lib\n\n```\n\nOur two crates are tightly related, so we create the procedural macro crate within the directory of our `hello_macro` crate. If we change the trait definition in `hello_macro`, we’ll have to change the implementation of the procedural macro in `hello_macro_derive` as well. The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. We could instead have the `hello_macro` crate use `hello_macro_derive` as a dependency and re-export the procedural macro code. However, the way we’ve structured the project makes it possible for programmers to use `hello_macro` even if they don’t want the `derive` functionality.\n\nWe need to declare the `hello_macro_derive` crate as a procedural macro crate. We’ll also need functionality from the `syn` and `quote` crates, as you’ll see in a moment, so we need to add them as dependencies. Add the following to the _Cargo.toml_ file for `hello_macro_derive`:\n\nFilename: hello\\_macro\\_derive/Cargo.toml\n\n```toml\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = \"2.0\"\nquote = \"1.0\"\n\n```\n\nTo start defining the procedural macro, place the code in Listing 19-31 into your _src/lib.rs_ file for the `hello_macro_derive` crate. Note that this code won’t compile until we add a definition for the `impl_hello_macro` function.\n\nFilename: hello\\_macro\\_derive/src/lib.rs\n\n```rust\nuse proc_macro::TokenStream;\nuse quote::quote;\n\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n    // Construct a representation of Rust code as a syntax tree\n    // that we can manipulate\n    let ast = syn::parse(input).unwrap();\n\n    // Build the trait implementation\n    impl_hello_macro(&ast)\n}\n```\n\nListing 19-31: Code that most procedural macro crates will require in order to process Rust code\n\nNotice that we’ve split the code into the `hello_macro_derive` function, which is responsible for parsing the `TokenStream`, and the `impl_hello_macro` function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (`hello_macro_derive` in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (`impl_hello_macro` in this case) will be different depending on your procedural macro’s purpose.\n\nWe’ve introduced three new crates: `proc_macro`, [`syn`](https://crates.io/crates/syn), and [`quote`](https://crates.io/crates/quote). The `proc_macro` crate comes with Rust, so we didn’t need to add that to the dependencies in _Cargo.toml_. The `proc_macro` crate is the compiler’s API that allows us to read and manipulate Rust code from our code.\n\nThe `syn` crate parses Rust code from a string into a data structure that we can perform operations on. The `quote` crate turns `syn` data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.\n\nThe `hello_macro_derive` function will be called when a user of our library specifies `#[derive(HelloMacro)]` on a type. This is possible because we’ve annotated the `hello_macro_derive` function here with `proc_macro_derive` and specified the name `HelloMacro`, which matches our trait name; this is the convention most procedural macros follow.\n\nThe `hello_macro_derive` function first converts the `input` from a `TokenStream` to a data structure that we can then interpret and perform operations on. This is where `syn` comes into play. The `parse` function in `syn` takes a `TokenStream` and returns a `DeriveInput` struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the `DeriveInput` struct we get from parsing the `struct Pancakes;` string:\n\n```rust\nDeriveInput {\n    // --snip--\n\n    ident: Ident {\n        ident: \"Pancakes\",\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\n```\n\nListing 19-32: The `DeriveInput` instance we get when parsing the code that has the macro’s attribute in Listing 19-30\n\nThe fields of this struct show that the Rust code we’ve parsed is a unit struct with the `ident` (identifier, meaning the name) of `Pancakes`. There are more fields on this struct for describing all sorts of Rust code; check the [`syn` documentation for `DeriveInput`](https://docs.rs/syn/2.0/syn/struct.DeriveInput.html) for more information.\n\nSoon we’ll define the `impl_hello_macro` function, which is where we’ll build the new Rust code we want to include. But before we do, note that the output for our derive macro is also a `TokenStream`. The returned `TokenStream` is added to the code that our crate users write, so when they compile their crate, they’ll get the extra functionality that we provide in the modified `TokenStream`.\n\nYou might have noticed that we’re calling `unwrap` to cause the `hello_macro_derive` function to panic if the call to the `syn::parse` function fails here. It’s necessary for our procedural macro to panic on errors because `proc_macro_derive` functions must return `TokenStream` rather than `Result` to conform to the procedural macro API. We’ve simplified this example by using `unwrap`; in production code, you should provide more specific error messages about what went wrong by using `panic!` or `expect`.\n\nNow that we have the code to turn the annotated Rust code from a `TokenStream` into a `DeriveInput` instance, let’s generate the code that implements the `HelloMacro` trait on the annotated type, as shown in Listing 19-33.\n\nFilename: hello\\_macro\\_derive/src/lib.rs\n\n```rust\nuse proc_macro::TokenStream;\nuse quote::quote;\n\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n    // Construct a representation of Rust code as a syntax tree\n    // that we can manipulate\n    let ast = syn::parse(input).unwrap();\n\n    // Build the trait implementation\n    impl_hello_macro(&ast)\n}\n\nfn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {\n    let name = &ast.ident;\n    let gen = quote! {\n        impl HelloMacro for #name {\n            fn hello_macro() {\n                println!(\"Hello, Macro! My name is {}!\", stringify!(#name));\n            }\n        }\n    };\n    gen.into()\n}\n```\n\nListing 19-33: Implementing the `HelloMacro` trait using the parsed Rust code\n\nWe get an `Ident` struct instance containing the name (identifier) of the annotated type using `ast.ident`. The struct in Listing 19-32 shows that when we run the `impl_hello_macro` function on the code in Listing 19-30, the `ident` we get will have the `ident` field with a value of `\"Pancakes\"`. Thus, the `name` variable in Listing 19-33 will contain an `Ident` struct instance that, when printed, will be the string `\"Pancakes\"`, the name of the struct in Listing 19-30.\n\nThe `quote!` macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the `quote!` macro’s execution, so we need to convert it to a `TokenStream`. We do this by calling the `into` method, which consumes this intermediate representation and returns a value of the required `TokenStream` type.\n\nThe `quote!` macro also provides some very cool templating mechanics: we can enter `#name`, and `quote!` will replace it with the value in the variable `name`. You can even do some repetition similar to the way regular macros work. Check out [the `quote` crate’s docs](https://docs.rs/quote) for a thorough introduction.\n\nWe want our procedural macro to generate an implementation of our `HelloMacro` trait for the type the user annotated, which we can get by using `#name`. The trait implementation has the one function `hello_macro`, whose body contains the functionality we want to provide: printing `Hello, Macro! My name is` and then the name of the annotated type.\n\nThe `stringify!` macro used here is built into Rust. It takes a Rust expression, such as `1 + 2`, and at compile time turns the expression into a string literal, such as `\"1 + 2\"`. This is different than `format!` or `println!`, macros which evaluate the expression and then turn the result into a `String`. There is a possibility that the `#name` input might be an expression to print literally, so we use `stringify!`. Using `stringify!` also saves an allocation by converting `#name` to a string literal at compile time.\n\nAt this point, `cargo build` should complete successfully in both `hello_macro` and `hello_macro_derive`. Let’s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your _projects_ directory using `cargo new pancakes`. We need to add `hello_macro` and `hello_macro_derive` as dependencies in the `pancakes` crate’s _Cargo.toml_. If you’re publishing your versions of `hello_macro` and `hello_macro_derive` to [crates.io](https://crates.io/), they would be regular dependencies; if not, you can specify them as `path` dependencies as follows:\n\n```toml\nhello_macro = { path = \"../hello_macro\" }\nhello_macro_derive = { path = \"../hello_macro/hello_macro_derive\" }\n\n```\n\nPut the code in Listing 19-30 into _src/main.rs_, and run `cargo run`: it should print `Hello, Macro! My name is Pancakes!` The implementation of the `HelloMacro` trait from the procedural macro was included without the `pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added the trait implementation.\n\nNext, let’s explore how the other kinds of procedural macros differ from custom derive macros.\n\n### [Attribute-like macros](#attribute-like-macros)\n\nAttribute-like macros are similar to custom derive macros, but instead of generating code for the `derive` attribute, they allow you to create new attributes. They’re also more flexible: `derive` only works for structs and enums; attributes can be applied to other items as well, such as functions. Here’s an example of using an attribute-like macro: say you have an attribute named `route` that annotates functions when using a web application framework:\n\n```rust\n#[route(GET, \"/\")]\nfn index() {\n```\n\nThis `#[route]` attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:\n\n```rust\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\n```\n\nHere, we have two parameters of type `TokenStream`. The first is for the contents of the attribute: the `GET, \"/\"` part. The second is the body of the item the attribute is attached to: in this case, `fn index() {}` and the rest of the function’s body.\n\nOther than that, attribute-like macros work the same way as custom derive macros: you create a crate with the `proc-macro` crate type and implement a function that generates the code you want!\n\n### [Function-like macros](#function-like-macros)\n\nFunction-like macros define macros that look like function calls. Similarly to `macro_rules!` macros, they’re more flexible than functions; for example, they can take an unknown number of arguments. However, `macro_rules!` macros can be defined only using the match-like syntax we discussed in the section [“Declarative Macros with `macro_rules!` for General Metaprogramming”](#declarative-macros-with-macro_rules-for-general-metaprogramming) earlier. Function-like macros take a `TokenStream` parameter and their definition manipulates that `TokenStream` using Rust code as the other two types of procedural macros do. An example of a function-like macro is an `sql!` macro that might be called like so:\n\n```rust\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n```\n\nThis macro would parse the SQL statement inside it and check that it’s syntactically correct, which is much more complex processing than a `macro_rules!` macro can do. The `sql!` macro would be defined like this:\n\n```rust\n#[proc_macro]\npub fn sql(input: TokenStream) -> TokenStream {\n```\n\nThis definition is similar to the custom derive macro’s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.\n\n## [Summary](#summary)\n\nWhew! Now you have some Rust features in your toolbox that you likely won’t use often, but you’ll know they’re available in very particular circumstances. We’ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples’ code, you’ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.\n\nNext, we’ll put everything we’ve discussed throughout the book into practice and do one more project!",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Macros - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"macros\"><a class=\"header\" href=\"#macros\">Macros</a></h2>\n<p>We’ve used macros like <code class=\"hljs\">println!</code> throughout this book, but we haven’t fully\nexplored what a macro is and how it works. The term <em>macro</em> refers to a family\nof features in Rust: <em>declarative</em> macros with <code class=\"hljs\">macro_rules!</code> and three kinds\nof <em>procedural</em> macros:</p>\n<ul>\n<li>Custom <code class=\"hljs\">#[derive]</code> macros that specify code added with the <code class=\"hljs\">derive</code> attribute\nused on structs and enums</li>\n<li>Attribute-like macros that define custom attributes usable on any item</li>\n<li>Function-like macros that look like function calls but operate on the tokens\nspecified as their argument</li>\n</ul>\n<p>We’ll talk about each of these in turn, but first, let’s look at why we even\nneed macros when we already have functions.</p>\n<h3 id=\"the-difference-between-macros-and-functions\"><a class=\"header\" href=\"#the-difference-between-macros-and-functions\">The Difference Between Macros and Functions</a></h3>\n<p>Fundamentally, macros are a way of writing code that writes other code, which\nis known as <em>metaprogramming</em>. In Appendix C, we discuss the <code class=\"hljs\">derive</code>\nattribute, which generates an implementation of various traits for you. We’ve\nalso used the <code class=\"hljs\">println!</code> and <code class=\"hljs\">vec!</code> macros throughout the book. All of these\nmacros <em>expand</em> to produce more code than the code you’ve written manually.</p>\n<p>Metaprogramming is useful for reducing the amount of code you have to write and\nmaintain, which is also one of the roles of functions. However, macros have\nsome additional powers that functions don’t.</p>\n<p>A function signature must declare the number and type of parameters the\nfunction has. Macros, on the other hand, can take a variable number of\nparameters: we can call <code class=\"hljs\">println!(\"hello\")</code> with one argument or\n<code class=\"hljs\">println!(\"hello {}\", name)</code> with two arguments. Also, macros are expanded\nbefore the compiler interprets the meaning of the code, so a macro can, for\nexample, implement a trait on a given type. A function can’t, because it gets\ncalled at runtime and a trait needs to be implemented at compile time.</p>\n<p>The downside to implementing a macro instead of a function is that macro\ndefinitions are more complex than function definitions because you’re writing\nRust code that writes Rust code. Due to this indirection, macro definitions are\ngenerally more difficult to read, understand, and maintain than function\ndefinitions.</p>\n<p>Another important difference between macros and functions is that you must\ndefine macros or bring them into scope <em>before</em> you call them in a file, as\nopposed to functions you can define anywhere and call anywhere.</p>\n<h3 id=\"declarative-macros-with-macro_rules-for-general-metaprogramming\"><a class=\"header\" href=\"#declarative-macros-with-macro_rules-for-general-metaprogramming\">Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</a></h3>\n<p>The most widely used form of macros in Rust is the <em>declarative macro</em>. These\nare also sometimes referred to as “macros by example,” “<code class=\"hljs\">macro_rules!</code> macros,”\nor just plain “macros.” At their core, declarative macros allow you to write\nsomething similar to a Rust <code class=\"hljs\">match</code> expression. As discussed in Chapter 6,\n<code class=\"hljs\">match</code> expressions are control structures that take an expression, compare the\nresulting value of the expression to patterns, and then run the code associated\nwith the matching pattern. Macros also compare a value to patterns that are\nassociated with particular code: in this situation, the value is the literal\nRust source code passed to the macro; the patterns are compared with the\nstructure of that source code; and the code associated with each pattern, when\nmatched, replaces the code passed to the macro. This all happens during\ncompilation.</p>\n<p>To define a macro, you use the <code class=\"hljs\">macro_rules!</code> construct. Let’s explore how to\nuse <code class=\"hljs\">macro_rules!</code> by looking at how the <code class=\"hljs\">vec!</code> macro is defined. Chapter 8\ncovered how we can use the <code class=\"hljs\">vec!</code> macro to create a new vector with particular\nvalues. For example, the following macro creates a new vector containing three\nintegers:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> v: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">u32</span>&gt; = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"boring\">}</span></code></pre></pre>\n<p>We could also use the <code class=\"hljs\">vec!</code> macro to make a vector of two integers or a vector\nof five string slices. We wouldn’t be able to use a function to do the same\nbecause we wouldn’t know the number or type of values up front.</p>\n<p>Listing 19-28 shows a slightly simplified definition of the <code class=\"hljs\">vec!</code> macro.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-meta\">#[macro_export]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> vec {\n    ( $( $x:expr ),* ) =&gt; {\n        {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> temp_vec = <span class=\"hljs-built_in\">Vec</span>::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}</code></pre>\n<p><span class=\"caption\">Listing 19-28: A simplified version of the <code class=\"hljs\">vec!</code> macro\ndefinition</span></p>\n<section class=\"note\" aria-role=\"note\">\n<p>Note: The actual definition of the <code class=\"hljs\">vec!</code> macro in the standard library\nincludes code to preallocate the correct amount of memory up front. That code\nis an optimization that we don’t include here to make the example simpler.</p>\n</section>\n<p>The <code class=\"hljs\">#[macro_export]</code> annotation indicates that this macro should be made\navailable whenever the crate in which the macro is defined is brought into\nscope. Without this annotation, the macro can’t be brought into scope.</p>\n<p>We then start the macro definition with <code class=\"hljs\">macro_rules!</code> and the name of the\nmacro we’re defining <em>without</em> the exclamation mark. The name, in this case\n<code class=\"hljs\">vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>\n<p>The structure in the <code class=\"hljs\">vec!</code> body is similar to the structure of a <code class=\"hljs\">match</code>\nexpression. Here we have one arm with the pattern <code class=\"hljs\">( $( $x:expr ),* )</code>,\nfollowed by <code class=\"hljs\">=&gt;</code> and the block of code associated with this pattern. If the\npattern matches, the associated block of code will be emitted. Given that this\nis the only pattern in this macro, there is only one valid way to match; any\nother pattern will result in an error. More complex macros will have more than\none arm.</p>\n<p>Valid pattern syntax in macro definitions is different than the pattern syntax\ncovered in Chapter 18 because macro patterns are matched against Rust code\nstructure rather than values. Let’s walk through what the pattern pieces in\nListing 19-28 mean; for the full macro pattern syntax, see the <a href=\"../reference/macros-by-example.html\">Rust\nReference</a>.</p>\n<p>First, we use a set of parentheses to encompass the whole pattern. We use a\ndollar sign (<code class=\"hljs\">$</code>) to declare a variable in the macro system that will contain\nthe Rust code matching the pattern. The dollar sign makes it clear this is a\nmacro variable as opposed to a regular Rust variable. Next comes a set of\nparentheses that captures values that match the pattern within the parentheses\nfor use in the replacement code. Within <code class=\"hljs\">$()</code> is <code class=\"hljs\">$x:expr</code>, which matches any\nRust expression and gives the expression the name <code class=\"hljs\">$x</code>.</p>\n<p>The comma following <code class=\"hljs\">$()</code> indicates that a literal comma separator character\ncould optionally appear after the code that matches the code in <code class=\"hljs\">$()</code>. The <code class=\"hljs\">*</code>\nspecifies that the pattern matches zero or more of whatever precedes the <code class=\"hljs\">*</code>.</p>\n<p>When we call this macro with <code class=\"hljs\">vec![1, 2, 3];</code>, the <code class=\"hljs\">$x</code> pattern matches three\ntimes with the three expressions <code class=\"hljs\">1</code>, <code class=\"hljs\">2</code>, and <code class=\"hljs\">3</code>.</p>\n<p>Now let’s look at the pattern in the body of the code associated with this arm:\n<code class=\"hljs\">temp_vec.push()</code> within <code class=\"hljs\">$()*</code> is generated for each part that matches <code class=\"hljs\">$()</code>\nin the pattern zero or more times depending on how many times the pattern\nmatches. The <code class=\"hljs\">$x</code> is replaced with each expression matched. When we call this\nmacro with <code class=\"hljs\">vec![1, 2, 3];</code>, the code generated that replaces this macro call\nwill be the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">{\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> temp_vec = <span class=\"hljs-built_in\">Vec</span>::new();\n    temp_vec.push(<span class=\"hljs-number\">1</span>);\n    temp_vec.push(<span class=\"hljs-number\">2</span>);\n    temp_vec.push(<span class=\"hljs-number\">3</span>);\n    temp_vec\n}</code></pre>\n<p>We’ve defined a macro that can take any number of arguments of any type and can\ngenerate code to create a vector containing the specified elements.</p>\n<p>To learn more about how to write macros, consult the online documentation or\nother resources, such as <a href=\"https://veykril.github.io/tlborm/\">“The Little Book of Rust Macros”</a> started by\nDaniel Keep and continued by Lukas Wirth.</p>\n<h3 id=\"procedural-macros-for-generating-code-from-attributes\"><a class=\"header\" href=\"#procedural-macros-for-generating-code-from-attributes\">Procedural Macros for Generating Code from Attributes</a></h3>\n<p>The second form of macros is the <em>procedural macro</em>, which acts more like a\nfunction (and is a type of procedure). Procedural macros accept some code as an\ninput, operate on that code, and produce some code as an output rather than\nmatching against patterns and replacing the code with other code as declarative\nmacros do. The three kinds of procedural macros are custom derive,\nattribute-like, and function-like, and all work in a similar fashion.</p>\n<p>When creating procedural macros, the definitions must reside in their own crate\nwith a special crate type. This is for complex technical reasons that we hope\nto eliminate in the future. In Listing 19-29, we show how to define a\nprocedural macro, where <code class=\"hljs\">some_attribute</code> is a placeholder for using a specific\nmacro variety.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> proc_macro;\n\n<span class=\"hljs-meta\">#[some_attribute]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">some_name</span></span>(input: TokenStream) -&gt; TokenStream {\n}</code></pre>\n<p><span class=\"caption\">Listing 19-29: An example of defining a procedural\nmacro</span></p>\n<p>The function that defines a procedural macro takes a <code class=\"hljs\">TokenStream</code> as an input\nand produces a <code class=\"hljs\">TokenStream</code> as an output. The <code class=\"hljs\">TokenStream</code> type is defined by\nthe <code class=\"hljs\">proc_macro</code> crate that is included with Rust and represents a sequence of\ntokens. This is the core of the macro: the source code that the macro is\noperating on makes up the input <code class=\"hljs\">TokenStream</code>, and the code the macro produces\nis the output <code class=\"hljs\">TokenStream</code>. The function also has an attribute attached to it\nthat specifies which kind of procedural macro we’re creating. We can have\nmultiple kinds of procedural macros in the same crate.</p>\n<p>Let’s look at the different kinds of procedural macros. We’ll start with a\ncustom derive macro and then explain the small dissimilarities that make the\nother forms different.</p>\n<h3 id=\"how-to-write-a-custom-derive-macro\"><a class=\"header\" href=\"#how-to-write-a-custom-derive-macro\">How to Write a Custom <code>derive</code> Macro</a></h3>\n<p>Let’s create a crate named <code class=\"hljs\">hello_macro</code> that defines a trait named\n<code class=\"hljs\">HelloMacro</code> with one associated function named <code class=\"hljs\">hello_macro</code>. Rather than\nmaking our users implement the <code class=\"hljs\">HelloMacro</code> trait for each of their types,\nwe’ll provide a procedural macro so users can annotate their type with\n<code class=\"hljs\">#[derive(HelloMacro)]</code> to get a default implementation of the <code class=\"hljs\">hello_macro</code>\nfunction. The default implementation will print <code class=\"hljs\">Hello, Macro! My name is TypeName!</code> where <code class=\"hljs\">TypeName</code> is the name of the type on which this trait has\nbeen defined. In other words, we’ll write a crate that enables another\nprogrammer to write code like Listing 19-30 using our crate.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-keyword\">use</span> hello_macro::HelloMacro;\n<span class=\"hljs-keyword\">use</span> hello_macro_derive::HelloMacro;\n\n<span class=\"hljs-meta\">#[derive(HelloMacro)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Pancakes</span></span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    Pancakes::hello_macro();\n}</code></pre>\n<p><span class=\"caption\">Listing 19-30: The code a user of our crate will be able\nto write when using our procedural macro</span></p>\n<p>This code will print <code class=\"hljs\">Hello, Macro! My name is Pancakes!</code> when we’re done. The\nfirst step is to make a new library crate, like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo new hello_macro --lib</span>\n</code></pre>\n<p>Next, we’ll define the <code class=\"hljs\">HelloMacro</code> trait and its associated function:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">HelloMacro</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello_macro</span></span>();\n}</code></pre>\n<p>We have a trait and its function. At this point, our crate user could implement\nthe trait to achieve the desired functionality, like so:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> hello_macro::HelloMacro;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Pancakes</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> HelloMacro <span class=\"hljs-keyword\">for</span> Pancakes {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello_macro</span></span>() {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Hello, Macro! My name is Pancakes!\"</span>);\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    Pancakes::hello_macro();\n}</code></pre>\n<p>However, they would need to write the implementation block for each type they\nwanted to use with <code class=\"hljs\">hello_macro</code>; we want to spare them from having to do this\nwork.</p>\n<p>Additionally, we can’t yet provide the <code class=\"hljs\">hello_macro</code> function with default\nimplementation that will print the name of the type the trait is implemented\non: Rust doesn’t have reflection capabilities, so it can’t look up the type’s\nname at runtime. We need a macro to generate code at compile time.</p>\n<p>The next step is to define the procedural macro. At the time of this writing,\nprocedural macros need to be in their own crate. Eventually, this restriction\nmight be lifted. The convention for structuring crates and macro crates is as\nfollows: for a crate named <code class=\"hljs\">foo</code>, a custom derive procedural macro crate is\ncalled <code class=\"hljs\">foo_derive</code>. Let’s start a new crate called <code class=\"hljs\">hello_macro_derive</code> inside\nour <code class=\"hljs\">hello_macro</code> project:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo new hello_macro_derive --lib</span>\n</code></pre>\n<p>Our two crates are tightly related, so we create the procedural macro crate\nwithin the directory of our <code class=\"hljs\">hello_macro</code> crate. If we change the trait\ndefinition in <code class=\"hljs\">hello_macro</code>, we’ll have to change the implementation of the\nprocedural macro in <code class=\"hljs\">hello_macro_derive</code> as well. The two crates will need to\nbe published separately, and programmers using these crates will need to add\nboth as dependencies and bring them both into scope. We could instead have the\n<code class=\"hljs\">hello_macro</code> crate use <code class=\"hljs\">hello_macro_derive</code> as a dependency and re-export the\nprocedural macro code. However, the way we’ve structured the project makes it\npossible for programmers to use <code class=\"hljs\">hello_macro</code> even if they don’t want the\n<code class=\"hljs\">derive</code> functionality.</p>\n<p>We need to declare the <code class=\"hljs\">hello_macro_derive</code> crate as a procedural macro crate.\nWe’ll also need functionality from the <code class=\"hljs\">syn</code> and <code class=\"hljs\">quote</code> crates, as you’ll see\nin a moment, so we need to add them as dependencies. Add the following to the\n<em>Cargo.toml</em> file for <code class=\"hljs\">hello_macro_derive</code>:</p>\n<p><span class=\"filename\">Filename: hello_macro_derive/Cargo.toml</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[lib]</span>\n<span class=\"hljs-attr\">proc-macro</span> = <span class=\"hljs-literal\">true</span>\n\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">syn</span> = <span class=\"hljs-string\">\"2.0\"</span>\n<span class=\"hljs-attr\">quote</span> = <span class=\"hljs-string\">\"1.0\"</span>\n</code></pre>\n<p>To start defining the procedural macro, place the code in Listing 19-31 into\nyour <em>src/lib.rs</em> file for the <code class=\"hljs\">hello_macro_derive</code> crate. Note that this code\nwon’t compile until we add a definition for the <code class=\"hljs\">impl_hello_macro</code> function.</p>\n<p><span class=\"filename\">Filename: hello_macro_derive/src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-keyword\">use</span> proc_macro::TokenStream;\n<span class=\"hljs-keyword\">use</span> quote::quote;\n\n<span class=\"hljs-meta\">#[proc_macro_derive(HelloMacro)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello_macro_derive</span></span>(input: TokenStream) -&gt; TokenStream {\n    <span class=\"hljs-comment\">// Construct a representation of Rust code as a syntax tree</span>\n    <span class=\"hljs-comment\">// that we can manipulate</span>\n    <span class=\"hljs-keyword\">let</span> ast = syn::parse(input).unwrap();\n\n    <span class=\"hljs-comment\">// Build the trait implementation</span>\n    impl_hello_macro(&amp;ast)\n}</code></pre>\n<p><span class=\"caption\">Listing 19-31: Code that most procedural macro crates\nwill require in order to process Rust code</span></p>\n<p>Notice that we’ve split the code into the <code class=\"hljs\">hello_macro_derive</code> function, which\nis responsible for parsing the <code class=\"hljs\">TokenStream</code>, and the <code class=\"hljs\">impl_hello_macro</code>\nfunction, which is responsible for transforming the syntax tree: this makes\nwriting a procedural macro more convenient. The code in the outer function\n(<code class=\"hljs\">hello_macro_derive</code> in this case) will be the same for almost every\nprocedural macro crate you see or create. The code you specify in the body of\nthe inner function (<code class=\"hljs\">impl_hello_macro</code> in this case) will be different\ndepending on your procedural macro’s purpose.</p>\n<p>We’ve introduced three new crates: <code class=\"hljs\">proc_macro</code>, <a href=\"https://crates.io/crates/syn\"><code class=\"hljs\">syn</code></a>, and <a href=\"https://crates.io/crates/quote\"><code class=\"hljs\">quote</code></a>. The\n<code class=\"hljs\">proc_macro</code> crate comes with Rust, so we didn’t need to add that to the\ndependencies in <em>Cargo.toml</em>. The <code class=\"hljs\">proc_macro</code> crate is the compiler’s API that\nallows us to read and manipulate Rust code from our code.</p>\n<p>The <code class=\"hljs\">syn</code> crate parses Rust code from a string into a data structure that we\ncan perform operations on. The <code class=\"hljs\">quote</code> crate turns <code class=\"hljs\">syn</code> data structures back\ninto Rust code. These crates make it much simpler to parse any sort of Rust\ncode we might want to handle: writing a full parser for Rust code is no simple\ntask.</p>\n<p>The <code class=\"hljs\">hello_macro_derive</code> function will be called when a user of our library\nspecifies <code class=\"hljs\">#[derive(HelloMacro)]</code> on a type. This is possible because we’ve\nannotated the <code class=\"hljs\">hello_macro_derive</code> function here with <code class=\"hljs\">proc_macro_derive</code> and\nspecified the name <code class=\"hljs\">HelloMacro</code>, which matches our trait name; this is the\nconvention most procedural macros follow.</p>\n<p>The <code class=\"hljs\">hello_macro_derive</code> function first converts the <code class=\"hljs\">input</code> from a\n<code class=\"hljs\">TokenStream</code> to a data structure that we can then interpret and perform\noperations on. This is where <code class=\"hljs\">syn</code> comes into play. The <code class=\"hljs\">parse</code> function in\n<code class=\"hljs\">syn</code> takes a <code class=\"hljs\">TokenStream</code> and returns a <code class=\"hljs\">DeriveInput</code> struct representing the\nparsed Rust code. Listing 19-32 shows the relevant parts of the <code class=\"hljs\">DeriveInput</code>\nstruct we get from parsing the <code class=\"hljs\">struct Pancakes;</code> string:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">DeriveInput {\n    <span class=\"hljs-comment\">// --snip--</span>\n\n    ident: Ident {\n        ident: <span class=\"hljs-string\">\"Pancakes\"</span>,\n        span: #<span class=\"hljs-number\">0</span> bytes(<span class=\"hljs-number\">95</span>..<span class=\"hljs-number\">103</span>)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: <span class=\"hljs-literal\">Some</span>(\n                Semi\n            )\n        }\n    )\n}</code></pre>\n<p><span class=\"caption\">Listing 19-32: The <code class=\"hljs\">DeriveInput</code> instance we get when\nparsing the code that has the macro’s attribute in Listing 19-30</span></p>\n<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct\nwith the <code class=\"hljs\">ident</code> (identifier, meaning the name) of <code class=\"hljs\">Pancakes</code>. There are more\nfields on this struct for describing all sorts of Rust code; check the <a href=\"https://docs.rs/syn/2.0/syn/struct.DeriveInput.html\"><code class=\"hljs\">syn</code>\ndocumentation for <code class=\"hljs\">DeriveInput</code></a> for more information.</p>\n<p>Soon we’ll define the <code class=\"hljs\">impl_hello_macro</code> function, which is where we’ll build\nthe new Rust code we want to include. But before we do, note that the output\nfor our derive macro is also a <code class=\"hljs\">TokenStream</code>. The returned <code class=\"hljs\">TokenStream</code> is\nadded to the code that our crate users write, so when they compile their crate,\nthey’ll get the extra functionality that we provide in the modified\n<code class=\"hljs\">TokenStream</code>.</p>\n<p>You might have noticed that we’re calling <code class=\"hljs\">unwrap</code> to cause the\n<code class=\"hljs\">hello_macro_derive</code> function to panic if the call to the <code class=\"hljs\">syn::parse</code> function\nfails here. It’s necessary for our procedural macro to panic on errors because\n<code class=\"hljs\">proc_macro_derive</code> functions must return <code class=\"hljs\">TokenStream</code> rather than <code class=\"hljs\">Result</code> to\nconform to the procedural macro API. We’ve simplified this example by using\n<code class=\"hljs\">unwrap</code>; in production code, you should provide more specific error messages\nabout what went wrong by using <code class=\"hljs\">panic!</code> or <code class=\"hljs\">expect</code>.</p>\n<p>Now that we have the code to turn the annotated Rust code from a <code class=\"hljs\">TokenStream</code>\ninto a <code class=\"hljs\">DeriveInput</code> instance, let’s generate the code that implements the\n<code class=\"hljs\">HelloMacro</code> trait on the annotated type, as shown in Listing 19-33.</p>\n<p><span class=\"filename\">Filename: hello_macro_derive/src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> proc_macro::TokenStream;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> quote::quote;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[proc_macro_derive(HelloMacro)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello_macro_derive</span></span>(input: TokenStream) -&gt; TokenStream {\n</span><span class=\"boring\">    <span class=\"hljs-comment\">// Construct a representation of Rust code as a syntax tree</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">// that we can manipulate</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> ast = syn::parse(input).unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-comment\">// Build the trait implementation</span>\n</span><span class=\"boring\">    impl_hello_macro(&amp;ast)\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">impl_hello_macro</span></span>(ast: &amp;syn::DeriveInput) -&gt; TokenStream {\n    <span class=\"hljs-keyword\">let</span> name = &amp;ast.ident;\n    <span class=\"hljs-keyword\">let</span> gen = quote! {\n        <span class=\"hljs-keyword\">impl</span> HelloMacro <span class=\"hljs-keyword\">for</span> #name {\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello_macro</span></span>() {\n                <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Hello, Macro! My name is {}!\"</span>, <span class=\"hljs-built_in\">stringify!</span>(#name));\n            }\n        }\n    };\n    gen.into()\n}</code></pre>\n<p><span class=\"caption\">Listing 19-33: Implementing the <code class=\"hljs\">HelloMacro</code> trait using\nthe parsed Rust code</span></p>\n<p>We get an <code class=\"hljs\">Ident</code> struct instance containing the name (identifier) of the\nannotated type using <code class=\"hljs\">ast.ident</code>. The struct in Listing 19-32 shows that when\nwe run the <code class=\"hljs\">impl_hello_macro</code> function on the code in Listing 19-30, the\n<code class=\"hljs\">ident</code> we get will have the <code class=\"hljs\">ident</code> field with a value of <code class=\"hljs\">\"Pancakes\"</code>. Thus,\nthe <code class=\"hljs\">name</code> variable in Listing 19-33 will contain an <code class=\"hljs\">Ident</code> struct instance\nthat, when printed, will be the string <code class=\"hljs\">\"Pancakes\"</code>, the name of the struct in\nListing 19-30.</p>\n<p>The <code class=\"hljs\">quote!</code> macro lets us define the Rust code that we want to return. The\ncompiler expects something different to the direct result of the <code class=\"hljs\">quote!</code>\nmacro’s execution, so we need to convert it to a <code class=\"hljs\">TokenStream</code>. We do this by\ncalling the <code class=\"hljs\">into</code> method, which consumes this intermediate representation and\nreturns a value of the required <code class=\"hljs\">TokenStream</code> type.</p>\n<p>The <code class=\"hljs\">quote!</code> macro also provides some very cool templating mechanics: we can\nenter <code class=\"hljs\">#name</code>, and <code class=\"hljs\">quote!</code> will replace it with the value in the variable\n<code class=\"hljs\">name</code>. You can even do some repetition similar to the way regular macros work.\nCheck out <a href=\"https://docs.rs/quote\">the <code class=\"hljs\">quote</code> crate’s docs</a> for a thorough introduction.</p>\n<p>We want our procedural macro to generate an implementation of our <code class=\"hljs\">HelloMacro</code>\ntrait for the type the user annotated, which we can get by using <code class=\"hljs\">#name</code>. The\ntrait implementation has the one function <code class=\"hljs\">hello_macro</code>, whose body contains the\nfunctionality we want to provide: printing <code class=\"hljs\">Hello, Macro! My name is</code> and then\nthe name of the annotated type.</p>\n<p>The <code class=\"hljs\">stringify!</code> macro used here is built into Rust. It takes a Rust\nexpression, such as <code class=\"hljs\">1 + 2</code>, and at compile time turns the expression into a\nstring literal, such as <code class=\"hljs\">\"1 + 2\"</code>. This is different than <code class=\"hljs\">format!</code> or\n<code class=\"hljs\">println!</code>, macros which evaluate the expression and then turn the result into\na <code class=\"hljs\">String</code>. There is a possibility that the <code class=\"hljs\">#name</code> input might be an\nexpression to print literally, so we use <code class=\"hljs\">stringify!</code>. Using <code class=\"hljs\">stringify!</code> also\nsaves an allocation by converting <code class=\"hljs\">#name</code> to a string literal at compile time.</p>\n<p>At this point, <code class=\"hljs\">cargo build</code> should complete successfully in both <code class=\"hljs\">hello_macro</code>\nand <code class=\"hljs\">hello_macro_derive</code>. Let’s hook up these crates to the code in Listing\n19-30 to see the procedural macro in action! Create a new binary project in\nyour <em>projects</em> directory using <code class=\"hljs\">cargo new pancakes</code>. We need to add\n<code class=\"hljs\">hello_macro</code> and <code class=\"hljs\">hello_macro_derive</code> as dependencies in the <code class=\"hljs\">pancakes</code>\ncrate’s <em>Cargo.toml</em>. If you’re publishing your versions of <code class=\"hljs\">hello_macro</code> and\n<code class=\"hljs\">hello_macro_derive</code> to <a href=\"https://crates.io/\">crates.io</a>, they would be regular\ndependencies; if not, you can specify them as <code class=\"hljs\">path</code> dependencies as follows:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-attr\">hello_macro</span> = { path = <span class=\"hljs-string\">\"../hello_macro\"</span> }\n<span class=\"hljs-attr\">hello_macro_derive</span> = { path = <span class=\"hljs-string\">\"../hello_macro/hello_macro_derive\"</span> }\n</code></pre>\n<p>Put the code in Listing 19-30 into <em>src/main.rs</em>, and run <code class=\"hljs\">cargo run</code>: it\nshould print <code class=\"hljs\">Hello, Macro! My name is Pancakes!</code> The implementation of the\n<code class=\"hljs\">HelloMacro</code> trait from the procedural macro was included without the\n<code class=\"hljs\">pancakes</code> crate needing to implement it; the <code class=\"hljs\">#[derive(HelloMacro)]</code> added the\ntrait implementation.</p>\n<p>Next, let’s explore how the other kinds of procedural macros differ from custom\nderive macros.</p>\n<h3 id=\"attribute-like-macros\"><a class=\"header\" href=\"#attribute-like-macros\">Attribute-like macros</a></h3>\n<p>Attribute-like macros are similar to custom derive macros, but instead of\ngenerating code for the <code class=\"hljs\">derive</code> attribute, they allow you to create new\nattributes. They’re also more flexible: <code class=\"hljs\">derive</code> only works for structs and\nenums; attributes can be applied to other items as well, such as functions.\nHere’s an example of using an attribute-like macro: say you have an attribute\nnamed <code class=\"hljs\">route</code> that annotates functions when using a web application framework:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[route(GET, <span class=\"hljs-meta-string\">\"/\"</span>)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">index</span></span>() {</code></pre>\n<p>This <code class=\"hljs\">#[route]</code> attribute would be defined by the framework as a procedural\nmacro. The signature of the macro definition function would look like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[proc_macro_attribute]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">route</span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>\n<p>Here, we have two parameters of type <code class=\"hljs\">TokenStream</code>. The first is for the\ncontents of the attribute: the <code class=\"hljs\">GET, \"/\"</code> part. The second is the body of the\nitem the attribute is attached to: in this case, <code class=\"hljs\">fn index() {}</code> and the rest\nof the function’s body.</p>\n<p>Other than that, attribute-like macros work the same way as custom derive\nmacros: you create a crate with the <code class=\"hljs\">proc-macro</code> crate type and implement a\nfunction that generates the code you want!</p>\n<h3 id=\"function-like-macros\"><a class=\"header\" href=\"#function-like-macros\">Function-like macros</a></h3>\n<p>Function-like macros define macros that look like function calls. Similarly to\n<code class=\"hljs\">macro_rules!</code> macros, they’re more flexible than functions; for example, they\ncan take an unknown number of arguments. However, <code class=\"hljs\">macro_rules!</code> macros can be\ndefined only using the match-like syntax we discussed in the section\n<a href=\"#declarative-macros-with-macro_rules-for-general-metaprogramming\">“Declarative Macros with <code class=\"hljs\">macro_rules!</code> for General\nMetaprogramming”</a><!-- ignore --> earlier. Function-like macros take a\n<code class=\"hljs\">TokenStream</code> parameter and their definition manipulates that <code class=\"hljs\">TokenStream</code>\nusing Rust code as the other two types of procedural macros do. An example of a\nfunction-like macro is an <code class=\"hljs\">sql!</code> macro that might be called like so:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> sql = sql!(SELECT * FROM posts WHERE id=<span class=\"hljs-number\">1</span>);</code></pre>\n<p>This macro would parse the SQL statement inside it and check that it’s\nsyntactically correct, which is much more complex processing than a\n<code class=\"hljs\">macro_rules!</code> macro can do. The <code class=\"hljs\">sql!</code> macro would be defined like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[proc_macro]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">sql</span></span>(input: TokenStream) -&gt; TokenStream {</code></pre>\n<p>This definition is similar to the custom derive macro’s signature: we receive\nthe tokens that are inside the parentheses and return the code we wanted to\ngenerate.</p>\n<h2 id=\"summary\"><a class=\"header\" href=\"#summary\">Summary</a></h2>\n<p>Whew! Now you have some Rust features in your toolbox that you likely won’t use\noften, but you’ll know they’re available in very particular circumstances.\nWe’ve introduced several complex topics so that when you encounter them in\nerror message suggestions or in other peoples’ code, you’ll be able to\nrecognize these concepts and syntax. Use this chapter as a reference to guide\nyou to solutions.</p>\n<p>Next, we’ll put everything we’ve discussed throughout the book into practice\nand do one more project!</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch19-05-advanced-functions-and-closures.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch20-00-final-project-a-web-server.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch19-05-advanced-functions-and-closures.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch20-00-final-project-a-web-server.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:20:37.897Z"
}