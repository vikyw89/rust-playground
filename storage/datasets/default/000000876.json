{
	"title": "Exotically Sized Types - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/exotic-sizes.html",
	"markdown": "# Exotically Sized Types - The Rustonomicon\n\nMost of the time, we expect types to have a statically known and positive size. This isn't always the case in Rust.\n\n## [Dynamically Sized Types (DSTs)](#dynamically-sized-types-dsts)\n\nRust supports Dynamically Sized Types (DSTs): types without a statically known size or alignment. On the surface, this is a bit nonsensical: Rust _must_ know the size and alignment of something in order to correctly work with it! In this regard, DSTs are not normal types. Because they lack a statically known size, these types can only exist behind a pointer. Any pointer to a DST consequently becomes a _wide_ pointer consisting of the pointer and the information that \"completes\" them (more on this below).\n\nThere are two major DSTs exposed by the language:\n\n-   trait objects: `dyn MyTrait`\n-   slices: [`[T]`](../std/primitive.slice.html), [`str`](../std/primitive.str.html), and others\n\nA trait object represents some type that implements the traits it specifies. The exact original type is _erased_ in favor of runtime reflection with a vtable containing all the information necessary to use the type. The information that completes a trait object pointer is the vtable pointer. The runtime size of the pointee can be dynamically requested from the vtable.\n\nA slice is simply a view into some contiguous storage -- typically an array or `Vec`. The information that completes a slice pointer is just the number of elements it points to. The runtime size of the pointee is just the statically known size of an element multiplied by the number of elements.\n\nStructs can actually store a single DST directly as their last field, but this makes them a DST as well:\n\n```rust\n#![allow(unused)]\nfn main() {\n// Can't be stored on the stack directly\nstruct MySuperSlice {\n    info: u32,\n    data: [u8],\n}\n}\n```\n\nAlthough such a type is largely useless without a way to construct it. Currently the only properly supported way to create a custom DST is by making your type generic and performing an _unsizing coercion_:\n\n```rust\nstruct MySuperSliceable<T: ?Sized> {\n    info: u32,\n    data: T,\n}\n\nfn main() {\n    let sized: MySuperSliceable<[u8; 8]> = MySuperSliceable {\n        info: 17,\n        data: [0; 8],\n    };\n\n    let dynamic: &MySuperSliceable<[u8]> = &sized;\n\n    // prints: \"17 [0, 0, 0, 0, 0, 0, 0, 0]\"\n    println!(\"{} {:?}\", dynamic.info, &dynamic.data);\n}\n```\n\n(Yes, custom DSTs are a largely half-baked feature for now.)\n\n## [Zero Sized Types (ZSTs)](#zero-sized-types-zsts)\n\nRust also allows types to be specified that occupy no space:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Nothing; // No fields = no size\n\n// All fields have no size = no size\nstruct LotsOfNothing {\n    foo: Nothing,\n    qux: (),      // empty tuple has no size\n    baz: [u8; 0], // empty array has no size\n}\n}\n```\n\nOn their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless. However as with many curious layout choices in Rust, their potential is realized in a generic context: Rust largely understands that any operation that produces or stores a ZST can be reduced to a no-op. First off, storing it doesn't even make sense -- it doesn't occupy any space. Also there's only one value of that type, so anything that loads it can just produce it from the aether -- which is also a no-op since it doesn't occupy any space.\n\nOne of the most extreme examples of this is Sets and Maps. Given a `Map<Key, Value>`, it is common to implement a `Set<Key>` as just a thin wrapper around `Map<Key, UselessJunk>`. In many languages, this would necessitate allocating space for UselessJunk and doing work to store and load UselessJunk only to discard it. Proving this unnecessary would be a difficult analysis for the compiler.\n\nHowever in Rust, we can just say that `Set<Key> = Map<Key, ()>`. Now Rust statically knows that every load and store is useless, and no allocation has any size. The result is that the monomorphized code is basically a custom implementation of a HashSet with none of the overhead that HashMap would have to support values.\n\nSafe code need not worry about ZSTs, but _unsafe_ code must be careful about the consequence of types with no size. In particular, pointer offsets are no-ops, and allocators typically [require a non-zero size](about:blank/std/alloc/trait.GlobalAlloc.html#tymethod.alloc).\n\nNote that references to ZSTs (including empty slices), just like all other references, must be non-null and suitably aligned. Dereferencing a null or unaligned pointer to a ZST is [undefined behavior](what-unsafe-does.html), just like for any other type.\n\n## [Empty Types](#empty-types)\n\nRust also enables types to be declared that _cannot even be instantiated_. These types can only be talked about at the type level, and never at the value level. Empty types can be declared by specifying an enum with no variants:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Void {} // No variants = EMPTY\n}\n```\n\nEmpty types are even more marginal than ZSTs. The primary motivating example for an empty type is type-level unreachability. For instance, suppose an API needs to return a Result in general, but a specific case actually is infallible. It's actually possible to communicate this at the type level by returning a `Result<T, Void>`. Consumers of the API can confidently unwrap such a Result knowing that it's _statically impossible_ for this value to be an `Err`, as this would require providing a value of type `Void`.\n\nIn principle, Rust can do some interesting analyses and optimizations based on this fact. For instance, `Result<T, Void>` is represented as just `T`, because the `Err` case doesn't actually exist (strictly speaking, this is only an optimization that is not guaranteed, so for example transmuting one into the other is still Undefined Behavior).\n\nThe following _could_ also compile:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Void {}\n\nlet res: Result<u32, Void> = Ok(0);\n\n// Err doesn't exist anymore, so Ok is actually irrefutable.\nlet Ok(num) = res;\n}\n```\n\nBut this trick doesn't work yet.\n\nOne final subtle detail about empty types is that raw pointers to them are actually valid to construct, but dereferencing them is Undefined Behavior because that wouldn't make sense.\n\nWe recommend against modelling C's `void*` type with `*const Void`. A lot of people started doing that but quickly ran into trouble because Rust doesn't really have any safety guards against trying to instantiate empty types with unsafe code, and if you do it, it's Undefined Behavior. This was especially problematic because developers had a habit of converting raw pointers to references and `&Void` is _also_ Undefined Behavior to construct.\n\n`*const ()` (or equivalent) works reasonably well for `void*`, and can be made into a reference without any safety problems. It still doesn't prevent you from trying to read or write values, but at least it compiles to a no-op instead of Undefined Behavior.\n\n## [Extern Types](#extern-types)\n\nThere is [an accepted RFC](https://github.com/rust-lang/rfcs/blob/master/text/1861-extern-types.md) to add proper types with an unknown size, called _extern types_, which would let Rust developers model things like C's `void*` and other \"declared but never defined\" types more accurately. However as of Rust 2018, [the feature is stuck in limbo over how `size_of_val::<MyExternType>()` should behave](https://github.com/rust-lang/rust/issues/43467).",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Exotically Sized Types - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"exotically-sized-types\"><a class=\"header\" href=\"#exotically-sized-types\">Exotically Sized Types</a></h1>\n<p>Most of the time, we expect types to have a statically known and positive size.\nThis isn't always the case in Rust.</p>\n<h2 id=\"dynamically-sized-types-dsts\"><a class=\"header\" href=\"#dynamically-sized-types-dsts\">Dynamically Sized Types (DSTs)</a></h2>\n<p>Rust supports Dynamically Sized Types (DSTs): types without a statically\nknown size or alignment. On the surface, this is a bit nonsensical: Rust <em>must</em>\nknow the size and alignment of something in order to correctly work with it! In\nthis regard, DSTs are not normal types. Because they lack a statically known\nsize, these types can only exist behind a pointer. Any pointer to a\nDST consequently becomes a <em>wide</em> pointer consisting of the pointer and the\ninformation that \"completes\" them (more on this below).</p>\n<p>There are two major DSTs exposed by the language:</p>\n<ul>\n<li>trait objects: <code class=\"hljs\">dyn MyTrait</code></li>\n<li>slices: <a href=\"../std/primitive.slice.html\"><code class=\"hljs\">[T]</code></a>, <a href=\"../std/primitive.str.html\"><code class=\"hljs\">str</code></a>, and others</li>\n</ul>\n<p>A trait object represents some type that implements the traits it specifies.\nThe exact original type is <em>erased</em> in favor of runtime reflection\nwith a vtable containing all the information necessary to use the type.\nThe information that completes a trait object pointer is the vtable pointer.\nThe runtime size of the pointee can be dynamically requested from the vtable.</p>\n<p>A slice is simply a view into some contiguous storage -- typically an array or\n<code class=\"hljs\">Vec</code>. The information that completes a slice pointer is just the number of elements\nit points to. The runtime size of the pointee is just the statically known size\nof an element multiplied by the number of elements.</p>\n<p>Structs can actually store a single DST directly as their last field, but this\nmakes them a DST as well:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// Can't be stored on the stack directly</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MySuperSlice</span></span> {\n    info: <span class=\"hljs-built_in\">u32</span>,\n    data: [<span class=\"hljs-built_in\">u8</span>],\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Although such a type is largely useless without a way to construct it. Currently the\nonly properly supported way to create a custom DST is by making your type generic\nand performing an <em>unsizing coercion</em>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MySuperSliceable</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; {\n    info: <span class=\"hljs-built_in\">u32</span>,\n    data: T,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> sized: MySuperSliceable&lt;[<span class=\"hljs-built_in\">u8</span>; <span class=\"hljs-number\">8</span>]&gt; = MySuperSliceable {\n        info: <span class=\"hljs-number\">17</span>,\n        data: [<span class=\"hljs-number\">0</span>; <span class=\"hljs-number\">8</span>],\n    };\n\n    <span class=\"hljs-keyword\">let</span> dynamic: &amp;MySuperSliceable&lt;[<span class=\"hljs-built_in\">u8</span>]&gt; = &amp;sized;\n\n    <span class=\"hljs-comment\">// prints: \"17 [0, 0, 0, 0, 0, 0, 0, 0]\"</span>\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{} {:?}\"</span>, dynamic.info, &amp;dynamic.data);\n}</code></pre></pre>\n<p>(Yes, custom DSTs are a largely half-baked feature for now.)</p>\n<h2 id=\"zero-sized-types-zsts\"><a class=\"header\" href=\"#zero-sized-types-zsts\">Zero Sized Types (ZSTs)</a></h2>\n<p>Rust also allows types to be specified that occupy no space:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Nothing</span></span>; <span class=\"hljs-comment\">// No fields = no size</span>\n\n<span class=\"hljs-comment\">// All fields have no size = no size</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">LotsOfNothing</span></span> {\n    foo: Nothing,\n    qux: (),      <span class=\"hljs-comment\">// empty tuple has no size</span>\n    baz: [<span class=\"hljs-built_in\">u8</span>; <span class=\"hljs-number\">0</span>], <span class=\"hljs-comment\">// empty array has no size</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless.\nHowever as with many curious layout choices in Rust, their potential is realized\nin a generic context: Rust largely understands that any operation that produces\nor stores a ZST can be reduced to a no-op. First off, storing it doesn't even\nmake sense -- it doesn't occupy any space. Also there's only one value of that\ntype, so anything that loads it can just produce it from the aether -- which is\nalso a no-op since it doesn't occupy any space.</p>\n<p>One of the most extreme examples of this is Sets and Maps. Given a\n<code class=\"hljs\">Map&lt;Key, Value&gt;</code>, it is common to implement a <code class=\"hljs\">Set&lt;Key&gt;</code> as just a thin wrapper\naround <code class=\"hljs\">Map&lt;Key, UselessJunk&gt;</code>. In many languages, this would necessitate\nallocating space for UselessJunk and doing work to store and load UselessJunk\nonly to discard it. Proving this unnecessary would be a difficult analysis for\nthe compiler.</p>\n<p>However in Rust, we can just say that  <code class=\"hljs\">Set&lt;Key&gt; = Map&lt;Key, ()&gt;</code>. Now Rust\nstatically knows that every load and store is useless, and no allocation has any\nsize. The result is that the monomorphized code is basically a custom\nimplementation of a HashSet with none of the overhead that HashMap would have to\nsupport values.</p>\n<p>Safe code need not worry about ZSTs, but <em>unsafe</em> code must be careful about the\nconsequence of types with no size. In particular, pointer offsets are no-ops,\nand allocators typically <a href=\"../std/alloc/trait.GlobalAlloc.html#tymethod.alloc\">require a non-zero size</a>.</p>\n<p>Note that references to ZSTs (including empty slices), just like all other\nreferences, must be non-null and suitably aligned. Dereferencing a null or\nunaligned pointer to a ZST is <a href=\"what-unsafe-does.html\">undefined behavior</a>, just like for any other\ntype.</p>\n<h2 id=\"empty-types\"><a class=\"header\" href=\"#empty-types\">Empty Types</a></h2>\n<p>Rust also enables types to be declared that <em>cannot even be instantiated</em>. These\ntypes can only be talked about at the type level, and never at the value level.\nEmpty types can be declared by specifying an enum with no variants:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Void</span></span> {} <span class=\"hljs-comment\">// No variants = EMPTY</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Empty types are even more marginal than ZSTs. The primary motivating example for\nan empty type is type-level unreachability. For instance, suppose an API needs to\nreturn a Result in general, but a specific case actually is infallible. It's\nactually possible to communicate this at the type level by returning a\n<code class=\"hljs\">Result&lt;T, Void&gt;</code>. Consumers of the API can confidently unwrap such a Result\nknowing that it's <em>statically impossible</em> for this value to be an <code class=\"hljs\">Err</code>, as\nthis would require providing a value of type <code class=\"hljs\">Void</code>.</p>\n<p>In principle, Rust can do some interesting analyses and optimizations based\non this fact. For instance, <code class=\"hljs\">Result&lt;T, Void&gt;</code> is represented as just <code class=\"hljs\">T</code>,\nbecause the <code class=\"hljs\">Err</code> case doesn't actually exist (strictly speaking, this is only\nan optimization that is not guaranteed, so for example transmuting one into the\nother is still Undefined Behavior).</p>\n<p>The following <em>could</em> also compile:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Void</span></span> {}\n\n<span class=\"hljs-keyword\">let</span> res: <span class=\"hljs-built_in\">Result</span>&lt;<span class=\"hljs-built_in\">u32</span>, Void&gt; = <span class=\"hljs-literal\">Ok</span>(<span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-comment\">// Err doesn't exist anymore, so Ok is actually irrefutable.</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Ok</span>(num) = res;\n<span class=\"boring\">}</span></code></pre></pre>\n<p>But this trick doesn't work yet.</p>\n<p>One final subtle detail about empty types is that raw pointers to them are\nactually valid to construct, but dereferencing them is Undefined Behavior\nbecause that wouldn't make sense.</p>\n<p>We recommend against modelling C's <code class=\"hljs\">void*</code> type with <code class=\"hljs\">*const Void</code>.\nA lot of people started doing that but quickly ran into trouble because\nRust doesn't really have any safety guards against trying to instantiate\nempty types with unsafe code, and if you do it, it's Undefined Behavior.\nThis was especially problematic because developers had a habit of converting\nraw pointers to references and <code class=\"hljs\">&amp;Void</code> is <em>also</em> Undefined Behavior to\nconstruct.</p>\n<p><code class=\"hljs\">*const ()</code> (or equivalent) works reasonably well for <code class=\"hljs\">void*</code>, and can be made\ninto a reference without any safety problems. It still doesn't prevent you from\ntrying to read or write values, but at least it compiles to a no-op instead\nof Undefined Behavior.</p>\n<h2 id=\"extern-types\"><a class=\"header\" href=\"#extern-types\">Extern Types</a></h2>\n<p>There is <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1861-extern-types.md\">an accepted RFC</a> to add proper types with an unknown size,\ncalled <em>extern types</em>, which would let Rust developers model things like C's <code class=\"hljs\">void*</code>\nand other \"declared but never defined\" types more accurately. However as of\nRust 2018, <a href=\"https://github.com/rust-lang/rust/issues/43467\">the feature is stuck in limbo over how <code class=\"hljs\">size_of_val::&lt;MyExternType&gt;()</code>\nshould behave</a>.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"repr-rust.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"other-reprs.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"repr-rust.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"other-reprs.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:05.704Z"
}