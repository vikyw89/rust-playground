{
	"title": "std::ffi - Rust",
	"url": "https://doc.rust-lang.org/stable/std/ffi/index.html",
	"markdown": "# std::ffi - Rust\n\n## Module [std](../index.html)::[ffi](#)\n\n1.0.0 · [source](about:blank/src/std/ffi/mod.rs.html#1-213) ·\n\nExpand description\n\nUtilities related to FFI bindings.\n\nThis module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system. It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.\n\n## [§](#overview)Overview\n\nRust represents owned strings with the [`String`](../string/struct.String.html \"struct std::string::String\") type, and borrowed slices of strings with the [`str`](../primitive.str.html \"primitive str\") primitive. Both are always in UTF-8 encoding, and may contain nul bytes in the middle, i.e., if you look at the bytes that make up the string, there may be a `\\0` among them. Both `String` and `str` store their length explicitly; there are no nul terminators at the end of strings like in C.\n\nC strings are different from Rust strings:\n\n-   **Encodings** - Rust strings are UTF-8, but C strings may use other encodings. If you are using a string from C, you should check its encoding explicitly, rather than just assuming that it is UTF-8 like you can do in Rust.\n    \n-   **Character size** - C strings may use `char` or `wchar_t`\\-sized characters; please **note** that C’s `char` is different from Rust’s. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type [`char`](../primitive.char.html \"primitive char\") represents a ‘[Unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value)’, which is similar to, but not the same as, a ‘[Unicode code point](https://www.unicode.org/glossary/#code_point)’.\n    \n-   **Nul terminators and implicit string lengths** - Often, C strings are nul-terminated, i.e., they have a `\\0` character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like `strlen()` for `char`\\-based strings, or `wcslen()` for `wchar_t`\\-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really `len+1` characters. Rust strings don’t have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string’s length is an _O_(1) operation (because the length is stored); in C it is an _O_(_n_) operation because the length needs to be computed by scanning the string for the nul terminator.\n    \n-   **Internal nul characters** - When C strings have a nul terminator character, this usually means that they cannot have nul characters in the middle — a nul character would essentially truncate the string. Rust strings _can_ have nul characters in the middle, because nul does not have to mark the end of the string in Rust.\n    \n\n## [§](#representations-of-non-rust-strings)Representations of non-Rust strings\n\n[`CString`](struct.CString.html \"struct std::ffi::CString\") and [`CStr`](struct.CStr.html \"struct std::ffi::CStr\") are useful when you need to transfer UTF-8 strings to and from languages with a C ABI, like Python.\n\n-   **From Rust to C:** [`CString`](struct.CString.html \"struct std::ffi::CString\") represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a [`CString`](struct.CString.html \"struct std::ffi::CString\") out of a normal string (provided that the string doesn’t have nul characters in the middle), and then use a variety of methods to obtain a raw `*mut [u8](../primitive.u8.html \"primitive u8\")` that can then be passed as an argument to functions which use the C conventions for strings.\n    \n-   **From C to Rust:** [`CStr`](struct.CStr.html \"struct std::ffi::CStr\") represents a borrowed C string; it is what you would use to wrap a raw `*const [u8](../primitive.u8.html \"primitive u8\")` that you got from a C function. A [`CStr`](struct.CStr.html \"struct std::ffi::CStr\") is guaranteed to be a nul-terminated array of bytes. Once you have a [`CStr`](struct.CStr.html \"struct std::ffi::CStr\"), you can convert it to a Rust `&[str](../primitive.str.html \"primitive str\")` if it’s valid UTF-8, or lossily convert it by adding replacement characters.\n    \n\n[`OsString`](struct.OsString.html \"struct std::ffi::OsString\") and [`OsStr`](struct.OsStr.html \"struct std::ffi::OsStr\") are useful when you need to transfer strings to and from the operating system itself, or when capturing the output of external commands. Conversions between [`OsString`](struct.OsString.html \"struct std::ffi::OsString\"), [`OsStr`](struct.OsStr.html \"struct std::ffi::OsStr\") and Rust strings work similarly to those for [`CString`](struct.CString.html \"struct std::ffi::CString\") and [`CStr`](struct.CStr.html \"struct std::ffi::CStr\").\n\n-   [`OsString`](struct.OsString.html \"struct std::ffi::OsString\") losslessly represents an owned platform string. However, this representation is not necessarily in a form native to the platform. In the Rust standard library, various APIs that transfer strings to/from the operating system use [`OsString`](struct.OsString.html \"struct std::ffi::OsString\") instead of plain strings. For example, [`env::var_os()`](../env/fn.var_os.html \"env::var_os\") is used to query environment variables; it returns an `[Option](../option/enum.Option.html \"enum std::option::Option\")<[OsString](struct.OsString.html \"struct std::ffi::OsString\")>`. If the environment variable exists you will get a `[Some](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\")(os_string)`, which you can _then_ try to convert to a Rust string. This yields a [`Result`](../result/enum.Result.html \"enum std::result::Result\"), so that your code can detect errors in case the environment variable did not in fact contain valid Unicode data.\n    \n-   [`OsStr`](struct.OsStr.html \"struct std::ffi::OsStr\") losslessly represents a borrowed reference to a platform string. However, this representation is not necessarily in a form native to the platform. It can be converted into a UTF-8 Rust string slice in a similar way to [`OsString`](struct.OsString.html \"struct std::ffi::OsString\").\n    \n\n## [§](#conversions)Conversions\n\n### [§](#on-unix)On Unix\n\nOn Unix, [`OsStr`](struct.OsStr.html \"struct std::ffi::OsStr\") implements the `std::os::unix::ffi::[OsStrExt](../os/unix/ffi/trait.OsStrExt.html \"os::unix::ffi::OsStrExt\")` trait, which augments it with two methods, [`from_bytes`](about:blank/os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes \"os::unix::ffi::OsStrExt::from_bytes\") and [`as_bytes`](about:blank/os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes \"os::unix::ffi::OsStrExt::as_bytes\"). These do inexpensive conversions from and to byte slices.\n\nAdditionally, on Unix [`OsString`](struct.OsString.html \"struct std::ffi::OsString\") implements the `std::os::unix::ffi::[OsStringExt](../os/unix/ffi/trait.OsStringExt.html \"os::unix::ffi::OsStringExt\")` trait, which provides [`from_vec`](about:blank/os/unix/ffi/trait.OsStringExt.html#tymethod.from_vec \"os::unix::ffi::OsStringExt::from_vec\") and [`into_vec`](about:blank/os/unix/ffi/trait.OsStringExt.html#tymethod.into_vec \"os::unix::ffi::OsStringExt::into_vec\") methods that consume their arguments, and take or produce vectors of [`u8`](../primitive.u8.html \"primitive u8\").\n\n### [§](#on-windows)On Windows\n\nAn [`OsStr`](struct.OsStr.html \"struct std::ffi::OsStr\") can be losslessly converted to a native Windows string. And a native Windows string can be losslessly converted to an [`OsString`](struct.OsString.html \"struct std::ffi::OsString\").\n\nOn Windows, [`OsStr`](struct.OsStr.html \"struct std::ffi::OsStr\") implements the `std::os::windows::ffi::[OsStrExt](../os/windows/ffi/trait.OsStrExt.html \"os::windows::ffi::OsStrExt\")` trait, which provides an [`encode_wide`](about:blank/os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide \"os::windows::ffi::OsStrExt::encode_wide\") method. This provides an iterator that can be [`collect`](about:blank/iter/trait.Iterator.html#method.collect \"iter::Iterator::collect\")ed into a vector of [`u16`](../primitive.u16.html \"primitive u16\"). After a nul characters is appended, this is the same as a native Windows string.\n\nAdditionally, on Windows [`OsString`](struct.OsString.html \"struct std::ffi::OsString\") implements the `std::os::windows:ffi::[OsStringExt](../os/windows/ffi/trait.OsStringExt.html \"os::windows::ffi::OsStringExt\")` trait, which provides a [`from_wide`](about:blank/os/windows/ffi/trait.OsStringExt.html#tymethod.from_wide \"os::windows::ffi::OsStringExt::from_wide\") method to convert a native Windows string (without the terminating nul character) to an [`OsString`](struct.OsString.html \"struct std::ffi::OsString\").\n\n### [§](#other-platforms)Other platforms\n\nMany other platforms provide their own extension traits in a `std::os::*::ffi` module.\n\n### [§](#on-all-platforms)On all platforms\n\nOn all platforms, [`OsStr`](struct.OsStr.html \"struct std::ffi::OsStr\") consists of a sequence of bytes that is encoded as a superset of UTF-8; see [`OsString`](struct.OsString.html \"struct std::ffi::OsString\") for more details on its encoding on different platforms.\n\nFor limited, inexpensive conversions from and to bytes, see [`OsStr::as_encoded_bytes`](about:blank/struct.OsStr.html#method.as_encoded_bytes \"method std::ffi::OsStr::as_encoded_bytes\") and [`OsStr::from_encoded_bytes_unchecked`](about:blank/struct.OsStr.html#method.from_encoded_bytes_unchecked \"associated function std::ffi::OsStr::from_encoded_bytes_unchecked\").\n\nFor basic string processing, see [`OsStr::slice_encoded_bytes`](about:blank/struct.OsStr.html#method.slice_encoded_bytes \"method std::ffi::OsStr::slice_encoded_bytes\").\n\n-   The [`OsStr`](struct.OsStr.html \"struct std::ffi::OsStr\") and [`OsString`](struct.OsString.html \"struct std::ffi::OsString\") types and associated utilities.\n    \n\n-   Representation of a borrowed C string.\n    \n-   A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.\n    \n-   Borrowed reference to an OS string (see [`OsString`](struct.OsString.html \"struct std::ffi::OsString\")).\n    \n-   A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.\n    \n-   A wrapper for a `va_list`\n    \n-   x86\\_64 ABI implementation of a `va_list`.\n    \n\n-   Equivalent to C’s `void` type when used as a [pointer](../primitive.pointer.html \"primitive pointer\").\n    \n\n-   Equivalent to C’s `char` type.\n    \n-   Equivalent to C’s `double` type.\n    \n-   Equivalent to C’s `float` type.\n    \n-   Equivalent to C’s `signed int` (`int`) type.\n    \n-   Equivalent to C’s `signed long` (`long`) type.\n    \n-   Equivalent to C’s `signed long long` (`long long`) type.\n    \n-   Equivalent to C’s `signed char` type.\n    \n-   Equivalent to C’s `signed short` (`short`) type.\n    \n-   Equivalent to C’s `unsigned char` type.\n    \n-   Equivalent to C’s `unsigned int` type.\n    \n-   Equivalent to C’s `unsigned long` type.\n    \n-   Equivalent to C’s `unsigned long long` type.\n    \n-   Equivalent to C’s `unsigned short` type.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Utilities related to FFI bindings.\"><title>std::ffi - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module ffi</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module ffi</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#reexports\">Re-exports</a></li><li><a href=\"#modules\">Modules</a></li><li><a href=\"#structs\">Structs</a></li><li><a href=\"#enums\">Enums</a></li><li><a href=\"#types\">Type Aliases</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">ffi</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/ffi/mod.rs.html#1-213\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Utilities related to FFI bindings.</p>\n<p>This module provides utilities to handle data across non-Rust\ninterfaces, like other programming languages and the underlying\noperating system. It is mainly of use for FFI (Foreign Function\nInterface) bindings and code that needs to exchange C-like strings\nwith other languages.</p>\n<h2 id=\"overview\"><a class=\"doc-anchor\" href=\"#overview\">§</a>Overview</h2>\n<p>Rust represents owned strings with the <a href=\"../string/struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> type, and\nborrowed slices of strings with the <a href=\"../primitive.str.html\" title=\"primitive str\"><code>str</code></a> primitive. Both are\nalways in UTF-8 encoding, and may contain nul bytes in the middle,\ni.e., if you look at the bytes that make up the string, there may\nbe a <code>\\0</code> among them. Both <code>String</code> and <code>str</code> store their length\nexplicitly; there are no nul terminators at the end of strings\nlike in C.</p>\n<p>C strings are different from Rust strings:</p>\n<ul>\n<li>\n<p><strong>Encodings</strong> - Rust strings are UTF-8, but C strings may use\nother encodings. If you are using a string from C, you should\ncheck its encoding explicitly, rather than just assuming that it\nis UTF-8 like you can do in Rust.</p>\n</li>\n<li>\n<p><strong>Character size</strong> - C strings may use <code>char</code> or <code>wchar_t</code>-sized\ncharacters; please <strong>note</strong> that C’s <code>char</code> is different from Rust’s.\nThe C standard leaves the actual sizes of those types open to\ninterpretation, but defines different APIs for strings made up of\neach character type. Rust strings are always UTF-8, so different\nUnicode characters will be encoded in a variable number of bytes\neach. The Rust type <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> represents a ‘<a href=\"https://www.unicode.org/glossary/#unicode_scalar_value\">Unicode scalar\nvalue</a>’, which is similar to, but not the same as, a ‘<a href=\"https://www.unicode.org/glossary/#code_point\">Unicode\ncode point</a>’.</p>\n</li>\n<li>\n<p><strong>Nul terminators and implicit string lengths</strong> - Often, C\nstrings are nul-terminated, i.e., they have a <code>\\0</code> character at the\nend. The length of a string buffer is not stored, but has to be\ncalculated; to compute the length of a string, C code must\nmanually call a function like <code>strlen()</code> for <code>char</code>-based strings,\nor <code>wcslen()</code> for <code>wchar_t</code>-based ones. Those functions return\nthe number of characters in the string excluding the nul\nterminator, so the buffer length is really <code>len+1</code> characters.\nRust strings don’t have a nul terminator; their length is always\nstored and does not need to be calculated. While in Rust\naccessing a string’s length is an <em>O</em>(1) operation (because the\nlength is stored); in C it is an <em>O</em>(<em>n</em>) operation because the\nlength needs to be computed by scanning the string for the nul\nterminator.</p>\n</li>\n<li>\n<p><strong>Internal nul characters</strong> - When C strings have a nul\nterminator character, this usually means that they cannot have nul\ncharacters in the middle — a nul character would essentially\ntruncate the string. Rust strings <em>can</em> have nul characters in\nthe middle, because nul does not have to mark the end of the\nstring in Rust.</p>\n</li>\n</ul>\n<h2 id=\"representations-of-non-rust-strings\"><a class=\"doc-anchor\" href=\"#representations-of-non-rust-strings\">§</a>Representations of non-Rust strings</h2>\n<p><a href=\"struct.CString.html\" title=\"struct std::ffi::CString\"><code>CString</code></a> and <a href=\"struct.CStr.html\" title=\"struct std::ffi::CStr\"><code>CStr</code></a> are useful when you need to transfer\nUTF-8 strings to and from languages with a C ABI, like Python.</p>\n<ul>\n<li>\n<p><strong>From Rust to C:</strong> <a href=\"struct.CString.html\" title=\"struct std::ffi::CString\"><code>CString</code></a> represents an owned, C-friendly\nstring: it is nul-terminated, and has no internal nul characters.\nRust code can create a <a href=\"struct.CString.html\" title=\"struct std::ffi::CString\"><code>CString</code></a> out of a normal string (provided\nthat the string doesn’t have nul characters in the middle), and\nthen use a variety of methods to obtain a raw <code>*mut <a href=\"../primitive.u8.html\" title=\"primitive u8\">u8</a></code> that can\nthen be passed as an argument to functions which use the C\nconventions for strings.</p>\n</li>\n<li>\n<p><strong>From C to Rust:</strong> <a href=\"struct.CStr.html\" title=\"struct std::ffi::CStr\"><code>CStr</code></a> represents a borrowed C string; it\nis what you would use to wrap a raw <code>*const <a href=\"../primitive.u8.html\" title=\"primitive u8\">u8</a></code> that you got from\na C function. A <a href=\"struct.CStr.html\" title=\"struct std::ffi::CStr\"><code>CStr</code></a> is guaranteed to be a nul-terminated array\nof bytes. Once you have a <a href=\"struct.CStr.html\" title=\"struct std::ffi::CStr\"><code>CStr</code></a>, you can convert it to a Rust\n<code>&amp;<a href=\"../primitive.str.html\" title=\"primitive str\">str</a></code> if it’s valid UTF-8, or lossily convert it by adding\nreplacement characters.</p>\n</li>\n</ul>\n<p><a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a> and <a href=\"struct.OsStr.html\" title=\"struct std::ffi::OsStr\"><code>OsStr</code></a> are useful when you need to transfer\nstrings to and from the operating system itself, or when capturing\nthe output of external commands. Conversions between <a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a>,\n<a href=\"struct.OsStr.html\" title=\"struct std::ffi::OsStr\"><code>OsStr</code></a> and Rust strings work similarly to those for <a href=\"struct.CString.html\" title=\"struct std::ffi::CString\"><code>CString</code></a>\nand <a href=\"struct.CStr.html\" title=\"struct std::ffi::CStr\"><code>CStr</code></a>.</p>\n<ul>\n<li>\n<p><a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a> losslessly represents an owned platform string. However, this\nrepresentation is not necessarily in a form native to the platform.\nIn the Rust standard library, various APIs that transfer strings to/from the operating\nsystem use <a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a> instead of plain strings. For example,\n<a href=\"../env/fn.var_os.html\" title=\"env::var_os\"><code>env::var_os()</code></a> is used to query environment variables; it\nreturns an <code><a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a>&gt;</code>. If the environment variable\nexists you will get a <code><a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\">Some</a>(os_string)</code>, which you can\n<em>then</em> try to convert to a Rust string. This yields a <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>, so that\nyour code can detect errors in case the environment variable did\nnot in fact contain valid Unicode data.</p>\n</li>\n<li>\n<p><a href=\"struct.OsStr.html\" title=\"struct std::ffi::OsStr\"><code>OsStr</code></a> losslessly represents a borrowed reference to a platform string.\nHowever, this representation is not necessarily in a form native to the platform.\nIt can be converted into a UTF-8 Rust string slice in a similar way to\n<a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a>.</p>\n</li>\n</ul>\n<h2 id=\"conversions\"><a class=\"doc-anchor\" href=\"#conversions\">§</a>Conversions</h2><h3 id=\"on-unix\"><a class=\"doc-anchor\" href=\"#on-unix\">§</a>On Unix</h3>\n<p>On Unix, <a href=\"struct.OsStr.html\" title=\"struct std::ffi::OsStr\"><code>OsStr</code></a> implements the\n<code>std::os::unix::ffi::<a href=\"../os/unix/ffi/trait.OsStrExt.html\" title=\"os::unix::ffi::OsStrExt\">OsStrExt</a></code> trait, which\naugments it with two methods, <a href=\"../os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes\" title=\"os::unix::ffi::OsStrExt::from_bytes\"><code>from_bytes</code></a> and <a href=\"../os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes\" title=\"os::unix::ffi::OsStrExt::as_bytes\"><code>as_bytes</code></a>.\nThese do inexpensive conversions from and to byte slices.</p>\n<p>Additionally, on Unix <a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a> implements the\n<code>std::os::unix::ffi::<a href=\"../os/unix/ffi/trait.OsStringExt.html\" title=\"os::unix::ffi::OsStringExt\">OsStringExt</a></code> trait,\nwhich provides <a href=\"../os/unix/ffi/trait.OsStringExt.html#tymethod.from_vec\" title=\"os::unix::ffi::OsStringExt::from_vec\"><code>from_vec</code></a> and <a href=\"../os/unix/ffi/trait.OsStringExt.html#tymethod.into_vec\" title=\"os::unix::ffi::OsStringExt::into_vec\"><code>into_vec</code></a> methods that consume\ntheir arguments, and take or produce vectors of <a href=\"../primitive.u8.html\" title=\"primitive u8\"><code>u8</code></a>.</p>\n<h3 id=\"on-windows\"><a class=\"doc-anchor\" href=\"#on-windows\">§</a>On Windows</h3>\n<p>An <a href=\"struct.OsStr.html\" title=\"struct std::ffi::OsStr\"><code>OsStr</code></a> can be losslessly converted to a native Windows string. And\na native Windows string can be losslessly converted to an <a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a>.</p>\n<p>On Windows, <a href=\"struct.OsStr.html\" title=\"struct std::ffi::OsStr\"><code>OsStr</code></a> implements the\n<code>std::os::windows::ffi::<a href=\"../os/windows/ffi/trait.OsStrExt.html\" title=\"os::windows::ffi::OsStrExt\">OsStrExt</a></code> trait,\nwhich provides an <a href=\"../os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide\" title=\"os::windows::ffi::OsStrExt::encode_wide\"><code>encode_wide</code></a> method. This provides an\niterator that can be <a href=\"../iter/trait.Iterator.html#method.collect\" title=\"iter::Iterator::collect\"><code>collect</code></a>ed into a vector of <a href=\"../primitive.u16.html\" title=\"primitive u16\"><code>u16</code></a>. After a nul\ncharacters is appended, this is the same as a native Windows string.</p>\n<p>Additionally, on Windows <a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a> implements the\n<code>std::os::windows:ffi::<a href=\"../os/windows/ffi/trait.OsStringExt.html\" title=\"os::windows::ffi::OsStringExt\">OsStringExt</a></code>\ntrait, which provides a <a href=\"../os/windows/ffi/trait.OsStringExt.html#tymethod.from_wide\" title=\"os::windows::ffi::OsStringExt::from_wide\"><code>from_wide</code></a> method to convert a native Windows\nstring (without the terminating nul character) to an <a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a>.</p>\n<h3 id=\"other-platforms\"><a class=\"doc-anchor\" href=\"#other-platforms\">§</a>Other platforms</h3>\n<p>Many other platforms provide their own extension traits in a\n<code>std::os::*::ffi</code> module.</p>\n<h3 id=\"on-all-platforms\"><a class=\"doc-anchor\" href=\"#on-all-platforms\">§</a>On all platforms</h3>\n<p>On all platforms, <a href=\"struct.OsStr.html\" title=\"struct std::ffi::OsStr\"><code>OsStr</code></a> consists of a sequence of bytes that is encoded as a superset of\nUTF-8; see <a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a> for more details on its encoding on different platforms.</p>\n<p>For limited, inexpensive conversions from and to bytes, see <a href=\"struct.OsStr.html#method.as_encoded_bytes\" title=\"method std::ffi::OsStr::as_encoded_bytes\"><code>OsStr::as_encoded_bytes</code></a> and\n<a href=\"struct.OsStr.html#method.from_encoded_bytes_unchecked\" title=\"associated function std::ffi::OsStr::from_encoded_bytes_unchecked\"><code>OsStr::from_encoded_bytes_unchecked</code></a>.</p>\n<p>For basic string processing, see <a href=\"struct.OsStr.html#method.slice_encoded_bytes\" title=\"method std::ffi::OsStr::slice_encoded_bytes\"><code>OsStr::slice_encoded_bytes</code></a>.</p>\n</div></details><h2 id=\"reexports\" class=\"section-header\">Re-exports<a href=\"#reexports\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\" id=\"reexport.FromBytesWithNulError\"><code>pub use self::c_str::<a class=\"struct\" href=\"c_str/struct.FromBytesWithNulError.html\" title=\"struct std::ffi::c_str::FromBytesWithNulError\">FromBytesWithNulError</a>;</code></div></li><li><div class=\"item-name\" id=\"reexport.FromBytesUntilNulError\"><code>pub use self::c_str::<a class=\"struct\" href=\"c_str/struct.FromBytesUntilNulError.html\" title=\"struct std::ffi::c_str::FromBytesUntilNulError\">FromBytesUntilNulError</a>;</code></div></li><li><div class=\"item-name\" id=\"reexport.NulError\"><code>pub use self::c_str::<a class=\"struct\" href=\"c_str/struct.NulError.html\" title=\"struct std::ffi::c_str::NulError\">NulError</a>;</code></div></li><li><div class=\"item-name\" id=\"reexport.FromVecWithNulError\"><code>pub use self::c_str::<a class=\"struct\" href=\"c_str/struct.FromVecWithNulError.html\" title=\"struct std::ffi::c_str::FromVecWithNulError\">FromVecWithNulError</a>;</code></div></li><li><div class=\"item-name\" id=\"reexport.IntoStringError\"><code>pub use self::c_str::<a class=\"struct\" href=\"c_str/struct.IntoStringError.html\" title=\"struct std::ffi::c_str::IntoStringError\">IntoStringError</a>;</code></div></li></ul><h2 id=\"modules\" class=\"section-header\">Modules<a href=\"#modules\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"mod\" href=\"c_str/index.html\" title=\"mod std::ffi::c_str\">c_str</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\"><a href=\"struct.CStr.html\" title=\"struct std::ffi::CStr\"><code>CStr</code></a>, <a href=\"struct.CString.html\" title=\"struct std::ffi::CString\"><code>CString</code></a>, and related types.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"os_str/index.html\" title=\"mod std::ffi::os_str\">os_str</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">The <a href=\"struct.OsStr.html\" title=\"struct std::ffi::OsStr\"><code>OsStr</code></a> and <a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a> types and associated utilities.</div></li></ul><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a></div><div class=\"desc docblock-short\">Representation of a borrowed C string.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.CString.html\" title=\"struct std::ffi::CString\">CString</a></div><div class=\"desc docblock-short\">A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the\nmiddle.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a></div><div class=\"desc docblock-short\">Borrowed reference to an OS string (see <a href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a>).</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a></div><div class=\"desc docblock-short\">A type that can represent owned, mutable platform-native strings, but is\ncheaply inter-convertible with Rust strings.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.VaList.html\" title=\"struct std::ffi::VaList\">VaList</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">A wrapper for a <code>va_list</code></div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.VaListImpl.html\" title=\"struct std::ffi::VaListImpl\">VaListImpl</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">x86_64 ABI implementation of a <code>va_list</code>.</div></li></ul><h2 id=\"enums\" class=\"section-header\">Enums<a href=\"#enums\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.c_void.html\" title=\"enum std::ffi::c_void\">c_void</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>void</code> type when used as a <a href=\"../primitive.pointer.html\" title=\"primitive pointer\">pointer</a>.</div></li></ul><h2 id=\"types\" class=\"section-header\">Type Aliases<a href=\"#types\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_char.html\" title=\"type std::ffi::c_char\">c_char</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>char</code> type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_double.html\" title=\"type std::ffi::c_double\">c_double</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>double</code> type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_float.html\" title=\"type std::ffi::c_float\">c_float</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>float</code> type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_int.html\" title=\"type std::ffi::c_int\">c_int</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>signed int</code> (<code>int</code>) type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_long.html\" title=\"type std::ffi::c_long\">c_long</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>signed long</code> (<code>long</code>) type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_longlong.html\" title=\"type std::ffi::c_longlong\">c_longlong</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>signed long long</code> (<code>long long</code>) type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_schar.html\" title=\"type std::ffi::c_schar\">c_schar</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>signed char</code> type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_short.html\" title=\"type std::ffi::c_short\">c_short</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>signed short</code> (<code>short</code>) type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_uchar.html\" title=\"type std::ffi::c_uchar\">c_uchar</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>unsigned char</code> type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_uint.html\" title=\"type std::ffi::c_uint\">c_uint</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>unsigned int</code> type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_ulong.html\" title=\"type std::ffi::c_ulong\">c_ulong</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>unsigned long</code> type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_ulonglong.html\" title=\"type std::ffi::c_ulonglong\">c_ulonglong</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>unsigned long long</code> type.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.c_ushort.html\" title=\"type std::ffi::c_ushort\">c_ushort</a></div><div class=\"desc docblock-short\">Equivalent to C’s <code>unsigned short</code> type.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:10:56.243Z"
}