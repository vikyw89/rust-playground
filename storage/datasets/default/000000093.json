{
	"title": "Advanced Traits - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch19-03-advanced-traits.html",
	"markdown": "# Advanced Traits - The Rust Programming Language\n\nWe first covered traits in the [“Traits: Defining Shared Behavior”](about:blank/ch10-02-traits.html#traits-defining-shared-behavior) section of Chapter 10, but we didn’t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.\n\n### [Specifying Placeholder Types in Trait Definitions with Associated Types](#specifying-placeholder-types-in-trait-definitions-with-associated-types)\n\n_Associated types_ connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures. The implementor of a trait will specify the concrete type to be used instead of the placeholder type for the particular implementation. That way, we can define a trait that uses some types without needing to know exactly what those types are until the trait is implemented.\n\nWe’ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they’re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.\n\nOne example of a trait with an associated type is the `Iterator` trait that the standard library provides. The associated type is named `Item` and stands in for the type of the values the type implementing the `Iterator` trait is iterating over. The definition of the `Iterator` trait is as shown in Listing 19-12.\n\n```rust\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n```\n\nListing 19-12: The definition of the `Iterator` trait that has an associated type `Item`\n\nThe type `Item` is a placeholder, and the `next` method’s definition shows that it will return values of type `Option<Self::Item>`. Implementors of the `Iterator` trait will specify the concrete type for `Item`, and the `next` method will return an `Option` containing a value of that concrete type.\n\nAssociated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. To examine the difference between the two concepts, we’ll look at an implementation of the `Iterator` trait on a type named `Counter` that specifies the `Item` type is `u32`:\n\nFilename: src/lib.rs\n\n```rust\nstruct Counter {\n    count: u32,\n}\n\nimpl Counter {\n    fn new() -> Counter {\n        Counter { count: 0 }\n    }\n}\n\nimpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // --snip--\n        if self.count < 5 {\n            self.count += 1;\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n```\n\nThis syntax seems comparable to that of generics. So why not just define the `Iterator` trait with generics, as shown in Listing 19-13?\n\n```rust\npub trait Iterator<T> {\n    fn next(&mut self) -> Option<T>;\n}\n```\n\nListing 19-13: A hypothetical definition of the `Iterator` trait using generics\n\nThe difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement `Iterator<String> for Counter` or any other type, we could have multiple implementations of `Iterator` for `Counter`. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the `next` method on `Counter`, we would have to provide type annotations to indicate which implementation of `Iterator` we want to use.\n\nWith associated types, we don’t need to annotate types because we can’t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of `Item` will be once, because there can only be one `impl Iterator for Counter`. We don’t have to specify that we want an iterator of `u32` values everywhere that we call `next` on `Counter`.\n\nAssociated types also become part of the trait’s contract: implementors of the trait must provide a type to stand in for the associated type placeholder. Associated types often have a name that describes how the type will be used, and documenting the associated type in the API documentation is good practice.\n\n### [Default Generic Type Parameters and Operator Overloading](#default-generic-type-parameters-and-operator-overloading)\n\nWhen we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. You specify a default type when declaring a generic type with the `<PlaceholderType=ConcreteType>` syntax.\n\nA great example of a situation where this technique is useful is with _operator overloading_, in which you customize the behavior of an operator (such as `+`) in particular situations.\n\nRust doesn’t allow you to create your own operators or overload arbitrary operators. But you can overload the operations and corresponding traits listed in `std::ops` by implementing the traits associated with the operator. For example, in Listing 19-14 we overload the `+` operator to add two `Point` instances together. We do this by implementing the `Add` trait on a `Point` struct:\n\nFilename: src/main.rs\n\n```rust\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n```\n\nListing 19-14: Implementing the `Add` trait to overload the `+` operator for `Point` instances\n\nThe `add` method adds the `x` values of two `Point` instances and the `y` values of two `Point` instances to create a new `Point`. The `Add` trait has an associated type named `Output` that determines the type returned from the `add` method.\n\nThe default generic type in this code is within the `Add` trait. Here is its definition:\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Add<Rhs=Self> {\n    type Output;\n\n    fn add(self, rhs: Rhs) -> Self::Output;\n}\n}\n```\n\nThis code should look generally familiar: a trait with one method and an associated type. The new part is `Rhs=Self`: this syntax is called _default type parameters_. The `Rhs` generic type parameter (short for “right hand side”) defines the type of the `rhs` parameter in the `add` method. If we don’t specify a concrete type for `Rhs` when we implement the `Add` trait, the type of `Rhs` will default to `Self`, which will be the type we’re implementing `Add` on.\n\nWhen we implemented `Add` for `Point`, we used the default for `Rhs` because we wanted to add two `Point` instances. Let’s look at an example of implementing the `Add` trait where we want to customize the `Rhs` type rather than using the default.\n\nWe have two structs, `Millimeters` and `Meters`, holding values in different units. This thin wrapping of an existing type in another struct is known as the _newtype pattern_, which we describe in more detail in the [“Using the Newtype Pattern to Implement External Traits on External Types”](about:blank/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types) section. We want to add values in millimeters to values in meters and have the implementation of `Add` do the conversion correctly. We can implement `Add` for `Millimeters` with `Meters` as the `Rhs`, as shown in Listing 19-15.\n\nFilename: src/lib.rs\n\n```rust\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add<Meters> for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -> Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n```\n\nListing 19-15: Implementing the `Add` trait on `Millimeters` to add `Millimeters` to `Meters`\n\nTo add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the value of the `Rhs` type parameter instead of using the default of `Self`.\n\nYou’ll use default type parameters in two main ways:\n\n-   To extend a type without breaking existing code\n-   To allow customization in specific cases most users won’t need\n\nThe standard library’s `Add` trait is an example of the second purpose: usually, you’ll add two like types, but the `Add` trait provides the ability to customize beyond that. Using a default type parameter in the `Add` trait definition means you don’t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn’t needed, making it easier to use the trait.\n\nThe first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.\n\n### [Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name](#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name)\n\nNothing in Rust prevents a trait from having a method with the same name as another trait’s method, nor does Rust prevent you from implementing both traits on one type. It’s also possible to implement a method directly on the type with the same name as methods from traits.\n\nWhen calling methods with the same name, you’ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we’ve defined two traits, `Pilot` and `Wizard`, that both have a method called `fly`. We then implement both traits on a type `Human` that already has a method named `fly` implemented on it. Each `fly` method does something different.\n\nFilename: src/main.rs\n\n```rust\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n\nfn main() {}\n```\n\nListing 19-16: Two traits are defined to have a `fly` method and are implemented on the `Human` type, and a `fly` method is implemented on `Human` directly\n\nWhen we call `fly` on an instance of `Human`, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.\n\nFilename: src/main.rs\n\n```rust\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n\nfn main() {\n    let person = Human;\n    person.fly();\n}\n```\n\nListing 19-17: Calling `fly` on an instance of `Human`\n\nRunning this code will print `*waving arms furiously*`, showing that Rust called the `fly` method implemented on `Human` directly.\n\nTo call the `fly` methods from either the `Pilot` trait or the `Wizard` trait, we need to use more explicit syntax to specify which `fly` method we mean. Listing 19-18 demonstrates this syntax.\n\nFilename: src/main.rs\n\n```rust\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n\nfn main() {\n    let person = Human;\n    Pilot::fly(&person);\n    Wizard::fly(&person);\n    person.fly();\n}\n```\n\nListing 19-18: Specifying which trait’s `fly` method we want to call\n\nSpecifying the trait name before the method name clarifies to Rust which implementation of `fly` we want to call. We could also write `Human::fly(&person)`, which is equivalent to the `person.fly()` that we used in Listing 19-18, but this is a bit longer to write if we don’t need to disambiguate.\n\nRunning this code prints the following:\n\n```console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s\n     Running `target/debug/traits-example`\nThis is your captain speaking.\nUp!\n*waving arms furiously*\n\n```\n\nBecause the `fly` method takes a `self` parameter, if we had two _types_ that both implement one _trait_, Rust could figure out which implementation of a trait to use based on the type of `self`.\n\nHowever, associated functions that are not methods don’t have a `self` parameter. When there are multiple types or traits that define non-method functions with the same function name, Rust doesn’t always know which type you mean unless you use _fully qualified syntax_. For example, in Listing 19-19 we create a trait for an animal shelter that wants to name all baby dogs _Spot_. We make an `Animal` trait with an associated non-method function `baby_name`. The `Animal` trait is implemented for the struct `Dog`, on which we also provide an associated non-method function `baby_name` directly.\n\nFilename: src/main.rs\n\n```rust\ntrait Animal {\n    fn baby_name() -> String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -> String {\n        String::from(\"Spot\")\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -> String {\n        String::from(\"puppy\")\n    }\n}\n\nfn main() {\n    println!(\"A baby dog is called a {}\", Dog::baby_name());\n}\n```\n\nListing 19-19: A trait with an associated function and a type with an associated function of the same name that also implements the trait\n\nWe implement the code for naming all puppies Spot in the `baby_name` associated function that is defined on `Dog`. The `Dog` type also implements the trait `Animal`, which describes characteristics that all animals have. Baby dogs are called puppies, and that is expressed in the implementation of the `Animal` trait on `Dog` in the `baby_name` function associated with the `Animal` trait.\n\nIn `main`, we call the `Dog::baby_name` function, which calls the associated function defined on `Dog` directly. This code prints the following:\n\n```console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n     Running `target/debug/traits-example`\nA baby dog is called a Spot\n\n```\n\nThis output isn’t what we wanted. We want to call the `baby_name` function that is part of the `Animal` trait that we implemented on `Dog` so the code prints `A baby dog is called a puppy`. The technique of specifying the trait name that we used in Listing 19-18 doesn’t help here; if we change `main` to the code in Listing 19-20, we’ll get a compilation error.\n\nFilename: src/main.rs\n\n```rust\ntrait Animal {\n    fn baby_name() -> String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -> String {\n        String::from(\"Spot\")\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -> String {\n        String::from(\"puppy\")\n    }\n}\n\nfn main() {\n    println!(\"A baby dog is called a {}\", Animal::baby_name());\n}\n```\n\nListing 19-20: Attempting to call the `baby_name` function from the `Animal` trait, but Rust doesn’t know which implementation to use\n\nBecause `Animal::baby_name` doesn’t have a `self` parameter, and there could be other types that implement the `Animal` trait, Rust can’t figure out which implementation of `Animal::baby_name` we want. We’ll get this compiler error:\n\n```console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type\n  --> src/main.rs:20:43\n   |\n2  |     fn baby_name() -> String;\n   |     ------------------------- `Animal::baby_name` defined here\n...\n20 |     println!(\"A baby dog is called a {}\", Animal::baby_name());\n   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait\n   |\nhelp: use the fully-qualified path to the only available implementation\n   |\n20 |     println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n   |                                           +++++++       +\n\nFor more information about this error, try `rustc --explain E0790`.\nerror: could not compile `traits-example` (bin \"traits-example\") due to 1 previous error\n\n```\n\nTo disambiguate and tell Rust that we want to use the implementation of `Animal` for `Dog` as opposed to the implementation of `Animal` for some other type, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.\n\nFilename: src/main.rs\n\n```rust\ntrait Animal {\n    fn baby_name() -> String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -> String {\n        String::from(\"Spot\")\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -> String {\n        String::from(\"puppy\")\n    }\n}\n\nfn main() {\n    println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n}\n```\n\nListing 19-21: Using fully qualified syntax to specify that we want to call the `baby_name` function from the `Animal` trait as implemented on `Dog`\n\nWe’re providing Rust with a type annotation within the angle brackets, which indicates we want to call the `baby_name` method from the `Animal` trait as implemented on `Dog` by saying that we want to treat the `Dog` type as an `Animal` for this function call. This code will now print what we want:\n\n```console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/traits-example`\nA baby dog is called a puppy\n\n```\n\nIn general, fully qualified syntax is defined as follows:\n\n```rust\n<Type as Trait>::function(receiver_if_method, next_arg, ...);\n```\n\nFor associated functions that aren’t methods, there would not be a `receiver`: there would only be the list of other arguments. You could use fully qualified syntax everywhere that you call functions or methods. However, you’re allowed to omit any part of this syntax that Rust can figure out from other information in the program. You only need to use this more verbose syntax in cases where there are multiple implementations that use the same name and Rust needs help to identify which implementation you want to call.\n\n### [Using Supertraits to Require One Trait’s Functionality Within Another Trait](#using-supertraits-to-require-one-traits-functionality-within-another-trait)\n\nSometimes, you might write a trait definition that depends on another trait: for a type to implement the first trait, you want to require that type to also implement the second trait. You would do this so that your trait definition can make use of the associated items of the second trait. The trait your trait definition is relying on is called a _supertrait_ of your trait.\n\nFor example, let’s say we want to make an `OutlinePrint` trait with an `outline_print` method that will print a given value formatted so that it’s framed in asterisks. That is, given a `Point` struct that implements the standard library trait `Display` to result in `(x, y)`, when we call `outline_print` on a `Point` instance that has `1` for `x` and `3` for `y`, it should print the following:\n\n```text\n**********\n*        *\n* (1, 3) *\n*        *\n**********\n\n```\n\nIn the implementation of the `outline_print` method, we want to use the `Display` trait’s functionality. Therefore, we need to specify that the `OutlinePrint` trait will work only for types that also implement `Display` and provide the functionality that `OutlinePrint` needs. We can do that in the trait definition by specifying `OutlinePrint: Display`. This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the `OutlinePrint` trait.\n\nFilename: src/main.rs\n\n```rust\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {output} *\");\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n\nfn main() {}\n```\n\nListing 19-22: Implementing the `OutlinePrint` trait that requires the functionality from `Display`\n\nBecause we’ve specified that `OutlinePrint` requires the `Display` trait, we can use the `to_string` function that is automatically implemented for any type that implements `Display`. If we tried to use `to_string` without adding a colon and specifying the `Display` trait after the trait name, we’d get an error saying that no method named `to_string` was found for the type `&Self` in the current scope.\n\nLet’s see what happens when we try to implement `OutlinePrint` on a type that doesn’t implement `Display`, such as the `Point` struct:\n\nFilename: src/main.rs\n\n```rust\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {output} *\");\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl OutlinePrint for Point {}\n\nfn main() {\n    let p = Point { x: 1, y: 3 };\n    p.outline_print();\n}\n```\n\nWe get an error saying that `Display` is required but not implemented:\n\n```console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0277]: `Point` doesn't implement `std::fmt::Display`\n  --> src/main.rs:20:23\n   |\n20 | impl OutlinePrint for Point {}\n   |                       ^^^^^ `Point` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Point`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\nnote: required by a bound in `OutlinePrint`\n  --> src/main.rs:3:21\n   |\n3  | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`\n\nerror[E0277]: `Point` doesn't implement `std::fmt::Display`\n  --> src/main.rs:24:7\n   |\n24 |     p.outline_print();\n   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Point`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\nnote: required by a bound in `OutlinePrint::outline_print`\n  --> src/main.rs:3:21\n   |\n3  | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`\n4  |     fn outline_print(&self) {\n   |        ------------- required by a bound in this associated function\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `traits-example` (bin \"traits-example\") due to 2 previous errors\n\n```\n\nTo fix this, we implement `Display` on `Point` and satisfy the constraint that `OutlinePrint` requires, like so:\n\nFilename: src/main.rs\n\n```rust\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {output} *\");\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl OutlinePrint for Point {}\n\nuse std::fmt;\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\n\nfn main() {\n    let p = Point { x: 1, y: 3 };\n    p.outline_print();\n}\n```\n\nThen implementing the `OutlinePrint` trait on `Point` will compile successfully, and we can call `outline_print` on a `Point` instance to display it within an outline of asterisks.\n\n### [Using the Newtype Pattern to Implement External Traits on External Types](#using-the-newtype-pattern-to-implement-external-traits-on-external-types)\n\nIn Chapter 10 in the [“Implementing a Trait on a Type”](about:blank/ch10-02-traits.html#implementing-a-trait-on-a-type) section, we mentioned the orphan rule that states we’re only allowed to implement a trait on a type if either the trait or the type are local to our crate. It’s possible to get around this restriction using the _newtype pattern_, which involves creating a new type in a tuple struct. (We covered tuple structs in the [“Using Tuple Structs without Named Fields to Create Different Types”](about:blank/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types) section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. _Newtype_ is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.\n\nAs an example, let’s say we want to implement `Display` on `Vec<T>`, which the orphan rule prevents us from doing directly because the `Display` trait and the `Vec<T>` type are defined outside our crate. We can make a `Wrapper` struct that holds an instance of `Vec<T>`; then we can implement `Display` on `Wrapper` and use the `Vec<T>` value, as shown in Listing 19-23.\n\nFilename: src/main.rs\n\n```rust\nuse std::fmt;\n\nstruct Wrapper(Vec<String>);\n\nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {w}\");\n}\n```\n\nListing 19-23: Creating a `Wrapper` type around `Vec<String>` to implement `Display`\n\nThe implementation of `Display` uses `self.0` to access the inner `Vec<T>`, because `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in the tuple. Then we can use the functionality of the `Display` trait on `Wrapper`.\n\nThe downside of using this technique is that `Wrapper` is a new type, so it doesn’t have the methods of the value it’s holding. We would have to implement all the methods of `Vec<T>` directly on `Wrapper` such that the methods delegate to `self.0`, which would allow us to treat `Wrapper` exactly like a `Vec<T>`. If we wanted the new type to have every method the inner type has, implementing the `Deref` trait (discussed in Chapter 15 in the [“Treating Smart Pointers Like Regular References with the `Deref` Trait”](about:blank/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait) section) on the `Wrapper` to return the inner type would be a solution. If we don’t want the `Wrapper` type to have all the methods of the inner type—for example, to restrict the `Wrapper` type’s behavior—we would have to implement just the methods we do want manually.\n\nThis newtype pattern is also useful even when traits are not involved. Let’s switch focus and look at some advanced ways to interact with Rust’s type system.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Advanced Traits - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"advanced-traits\"><a class=\"header\" href=\"#advanced-traits\">Advanced Traits</a></h2>\n<p>We first covered traits in the <a href=\"ch10-02-traits.html#traits-defining-shared-behavior\">“Traits: Defining Shared\nBehavior”</a><!-- ignore --> section of Chapter\n10, but we didn’t discuss the more advanced details. Now that you know more\nabout Rust, we can get into the nitty-gritty.</p>\n<h3 id=\"specifying-placeholder-types-in-trait-definitions-with-associated-types\"><a class=\"header\" href=\"#specifying-placeholder-types-in-trait-definitions-with-associated-types\">Specifying Placeholder Types in Trait Definitions with Associated Types</a></h3>\n<p><em>Associated types</em> connect a type placeholder with a trait such that the trait\nmethod definitions can use these placeholder types in their signatures. The\nimplementor of a trait will specify the concrete type to be used instead of the\nplaceholder type for the particular implementation. That way, we can define a\ntrait that uses some types without needing to know exactly what those types are\nuntil the trait is implemented.</p>\n<p>We’ve described most of the advanced features in this chapter as being rarely\nneeded. Associated types are somewhere in the middle: they’re used more rarely\nthan features explained in the rest of the book but more commonly than many of\nthe other features discussed in this chapter.</p>\n<p>One example of a trait with an associated type is the <code class=\"hljs\">Iterator</code> trait that the\nstandard library provides. The associated type is named <code class=\"hljs\">Item</code> and stands in\nfor the type of the values the type implementing the <code class=\"hljs\">Iterator</code> trait is\niterating over. The definition of the <code class=\"hljs\">Iterator</code> trait is as shown in Listing\n19-12.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Iterator</span></span> {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;Self::Item&gt;;\n}</code></pre>\n<p><span class=\"caption\">Listing 19-12: The definition of the <code class=\"hljs\">Iterator</code> trait\nthat has an associated type <code class=\"hljs\">Item</code></span></p>\n<p>The type <code class=\"hljs\">Item</code> is a placeholder, and the <code class=\"hljs\">next</code> method’s definition shows that\nit will return values of type <code class=\"hljs\">Option&lt;Self::Item&gt;</code>. Implementors of the\n<code class=\"hljs\">Iterator</code> trait will specify the concrete type for <code class=\"hljs\">Item</code>, and the <code class=\"hljs\">next</code>\nmethod will return an <code class=\"hljs\">Option</code> containing a value of that concrete type.</p>\n<p>Associated types might seem like a similar concept to generics, in that the\nlatter allow us to define a function without specifying what types it can\nhandle. To examine the difference between the two concepts, we’ll look at an\nimplementation of the <code class=\"hljs\">Iterator</code> trait on a type named <code class=\"hljs\">Counter</code> that specifies\nthe <code class=\"hljs\">Item</code> type is <code class=\"hljs\">u32</code>:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Counter</span></span> {\n</span><span class=\"boring\">    count: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Counter {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>() -&gt; Counter {\n</span><span class=\"boring\">        Counter { count: <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Iterator</span> <span class=\"hljs-keyword\">for</span> Counter {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span> = <span class=\"hljs-built_in\">u32</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;Self::Item&gt; {\n        <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.count &lt; <span class=\"hljs-number\">5</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">self</span>.count += <span class=\"hljs-number\">1</span>;\n</span><span class=\"boring\">            <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-keyword\">self</span>.count)\n</span><span class=\"boring\">        } <span class=\"hljs-keyword\">else</span> {\n</span><span class=\"boring\">            <span class=\"hljs-literal\">None</span>\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>This syntax seems comparable to that of generics. So why not just define the\n<code class=\"hljs\">Iterator</code> trait with generics, as shown in Listing 19-13?</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Iterator</span></span>&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt;;\n}</code></pre>\n<p><span class=\"caption\">Listing 19-13: A hypothetical definition of the\n<code class=\"hljs\">Iterator</code> trait using generics</span></p>\n<p>The difference is that when using generics, as in Listing 19-13, we must\nannotate the types in each implementation; because we can also implement\n<code class=\"hljs\">Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple\nimplementations of <code class=\"hljs\">Iterator</code> for <code class=\"hljs\">Counter</code>. In other words, when a trait has a\ngeneric parameter, it can be implemented for a type multiple times, changing\nthe concrete types of the generic type parameters each time. When we use the\n<code class=\"hljs\">next</code> method on <code class=\"hljs\">Counter</code>, we would have to provide type annotations to\nindicate which implementation of <code class=\"hljs\">Iterator</code> we want to use.</p>\n<p>With associated types, we don’t need to annotate types because we can’t\nimplement a trait on a type multiple times. In Listing 19-12 with the\ndefinition that uses associated types, we can only choose what the type of\n<code class=\"hljs\">Item</code> will be once, because there can only be one <code class=\"hljs\">impl Iterator for Counter</code>.\nWe don’t have to specify that we want an iterator of <code class=\"hljs\">u32</code> values everywhere\nthat we call <code class=\"hljs\">next</code> on <code class=\"hljs\">Counter</code>.</p>\n<p>Associated types also become part of the trait’s contract: implementors of the\ntrait must provide a type to stand in for the associated type placeholder.\nAssociated types often have a name that describes how the type will be used,\nand documenting the associated type in the API documentation is good practice.</p>\n<h3 id=\"default-generic-type-parameters-and-operator-overloading\"><a class=\"header\" href=\"#default-generic-type-parameters-and-operator-overloading\">Default Generic Type Parameters and Operator Overloading</a></h3>\n<p>When we use generic type parameters, we can specify a default concrete type for\nthe generic type. This eliminates the need for implementors of the trait to\nspecify a concrete type if the default type works. You specify a default type\nwhen declaring a generic type with the <code class=\"hljs\">&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</p>\n<p>A great example of a situation where this technique is useful is with <em>operator\noverloading</em>, in which you customize the behavior of an operator (such as <code class=\"hljs\">+</code>)\nin particular situations.</p>\n<p>Rust doesn’t allow you to create your own operators or overload arbitrary\noperators. But you can overload the operations and corresponding traits listed\nin <code class=\"hljs\">std::ops</code> by implementing the traits associated with the operator. For\nexample, in Listing 19-14 we overload the <code class=\"hljs\">+</code> operator to add two <code class=\"hljs\">Point</code>\ninstances together. We do this by implementing the <code class=\"hljs\">Add</code> trait on a <code class=\"hljs\">Point</code>\nstruct:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">use</span> std::ops::Add;\n\n<span class=\"hljs-meta\">#[derive(Debug, Copy, Clone, PartialEq)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n    x: <span class=\"hljs-built_in\">i32</span>,\n    y: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> Add <span class=\"hljs-keyword\">for</span> Point {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Output</span></span> = Point;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add</span></span>(<span class=\"hljs-keyword\">self</span>, other: Point) -&gt; Point {\n        Point {\n            x: <span class=\"hljs-keyword\">self</span>.x + other.x,\n            y: <span class=\"hljs-keyword\">self</span>.y + other.y,\n        }\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">assert_eq!</span>(\n        Point { x: <span class=\"hljs-number\">1</span>, y: <span class=\"hljs-number\">0</span> } + Point { x: <span class=\"hljs-number\">2</span>, y: <span class=\"hljs-number\">3</span> },\n        Point { x: <span class=\"hljs-number\">3</span>, y: <span class=\"hljs-number\">3</span> }\n    );\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-14: Implementing the <code class=\"hljs\">Add</code> trait to overload\nthe <code class=\"hljs\">+</code> operator for <code class=\"hljs\">Point</code> instances</span></p>\n<p>The <code class=\"hljs\">add</code> method adds the <code class=\"hljs\">x</code> values of two <code class=\"hljs\">Point</code> instances and the <code class=\"hljs\">y</code>\nvalues of two <code class=\"hljs\">Point</code> instances to create a new <code class=\"hljs\">Point</code>. The <code class=\"hljs\">Add</code> trait has an\nassociated type named <code class=\"hljs\">Output</code> that determines the type returned from the <code class=\"hljs\">add</code>\nmethod.</p>\n<p>The default generic type in this code is within the <code class=\"hljs\">Add</code> trait. Here is its\ndefinition:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Add</span></span>&lt;Rhs=<span class=\"hljs-keyword\">Self</span>&gt; {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Output</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add</span></span>(<span class=\"hljs-keyword\">self</span>, rhs: Rhs) -&gt; Self::Output;\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code should look generally familiar: a trait with one method and an\nassociated type. The new part is <code class=\"hljs\">Rhs=Self</code>: this syntax is called <em>default\ntype parameters</em>. The <code class=\"hljs\">Rhs</code> generic type parameter (short for “right hand\nside”) defines the type of the <code class=\"hljs\">rhs</code> parameter in the <code class=\"hljs\">add</code> method. If we don’t\nspecify a concrete type for <code class=\"hljs\">Rhs</code> when we implement the <code class=\"hljs\">Add</code> trait, the type\nof <code class=\"hljs\">Rhs</code> will default to <code class=\"hljs\">Self</code>, which will be the type we’re implementing\n<code class=\"hljs\">Add</code> on.</p>\n<p>When we implemented <code class=\"hljs\">Add</code> for <code class=\"hljs\">Point</code>, we used the default for <code class=\"hljs\">Rhs</code> because we\nwanted to add two <code class=\"hljs\">Point</code> instances. Let’s look at an example of implementing\nthe <code class=\"hljs\">Add</code> trait where we want to customize the <code class=\"hljs\">Rhs</code> type rather than using the\ndefault.</p>\n<p>We have two structs, <code class=\"hljs\">Millimeters</code> and <code class=\"hljs\">Meters</code>, holding values in different\nunits. This thin wrapping of an existing type in another struct is known as the\n<em>newtype pattern</em>, which we describe in more detail in the <a href=\"ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types\">“Using the Newtype\nPattern to Implement External Traits on External Types”</a><!-- ignore\n--> section. We want to add values in millimeters to values in meters and have\nthe implementation of <code class=\"hljs\">Add</code> do the conversion correctly. We can implement <code class=\"hljs\">Add</code>\nfor <code class=\"hljs\">Millimeters</code> with <code class=\"hljs\">Meters</code> as the <code class=\"hljs\">Rhs</code>, as shown in Listing 19-15.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">use</span> std::ops::Add;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Millimeters</span></span>(<span class=\"hljs-built_in\">u32</span>);\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Meters</span></span>(<span class=\"hljs-built_in\">u32</span>);\n\n<span class=\"hljs-keyword\">impl</span> Add&lt;Meters&gt; <span class=\"hljs-keyword\">for</span> Millimeters {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Output</span></span> = Millimeters;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add</span></span>(<span class=\"hljs-keyword\">self</span>, other: Meters) -&gt; Millimeters {\n        Millimeters(<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span> + (other.<span class=\"hljs-number\">0</span> * <span class=\"hljs-number\">1000</span>))\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 19-15: Implementing the <code class=\"hljs\">Add</code> trait on\n<code class=\"hljs\">Millimeters</code> to add <code class=\"hljs\">Millimeters</code> to <code class=\"hljs\">Meters</code></span></p>\n<p>To add <code class=\"hljs\">Millimeters</code> and <code class=\"hljs\">Meters</code>, we specify <code class=\"hljs\">impl Add&lt;Meters&gt;</code> to set the\nvalue of the <code class=\"hljs\">Rhs</code> type parameter instead of using the default of <code class=\"hljs\">Self</code>.</p>\n<p>You’ll use default type parameters in two main ways:</p>\n<ul>\n<li>To extend a type without breaking existing code</li>\n<li>To allow customization in specific cases most users won’t need</li>\n</ul>\n<p>The standard library’s <code class=\"hljs\">Add</code> trait is an example of the second purpose:\nusually, you’ll add two like types, but the <code class=\"hljs\">Add</code> trait provides the ability to\ncustomize beyond that. Using a default type parameter in the <code class=\"hljs\">Add</code> trait\ndefinition means you don’t have to specify the extra parameter most of the\ntime. In other words, a bit of implementation boilerplate isn’t needed, making\nit easier to use the trait.</p>\n<p>The first purpose is similar to the second but in reverse: if you want to add a\ntype parameter to an existing trait, you can give it a default to allow\nextension of the functionality of the trait without breaking the existing\nimplementation code.</p>\n<h3 id=\"fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\"><a class=\"header\" href=\"#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</a></h3>\n<p>Nothing in Rust prevents a trait from having a method with the same name as\nanother trait’s method, nor does Rust prevent you from implementing both traits\non one type. It’s also possible to implement a method directly on the type with\nthe same name as methods from traits.</p>\n<p>When calling methods with the same name, you’ll need to tell Rust which one you\nwant to use. Consider the code in Listing 19-16 where we’ve defined two traits,\n<code class=\"hljs\">Pilot</code> and <code class=\"hljs\">Wizard</code>, that both have a method called <code class=\"hljs\">fly</code>. We then implement\nboth traits on a type <code class=\"hljs\">Human</code> that already has a method named <code class=\"hljs\">fly</code> implemented\non it. Each <code class=\"hljs\">fly</code> method does something different.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Pilot</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Wizard</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Human</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> Pilot <span class=\"hljs-keyword\">for</span> Human {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"This is your captain speaking.\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> Wizard <span class=\"hljs-keyword\">for</span> Human {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Up!\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> Human {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"*waving arms furiously*\"</span>);\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 19-16: Two traits are defined to have a <code class=\"hljs\">fly</code>\nmethod and are implemented on the <code class=\"hljs\">Human</code> type, and a <code class=\"hljs\">fly</code> method is\nimplemented on <code class=\"hljs\">Human</code> directly</span></p>\n<p>When we call <code class=\"hljs\">fly</code> on an instance of <code class=\"hljs\">Human</code>, the compiler defaults to calling\nthe method that is directly implemented on the type, as shown in Listing 19-17.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Pilot</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Wizard</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Human</span></span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Pilot <span class=\"hljs-keyword\">for</span> Human {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"This is your captain speaking.\"</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Wizard <span class=\"hljs-keyword\">for</span> Human {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Up!\"</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Human {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"*waving arms furiously*\"</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> person = Human;\n    person.fly();\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-17: Calling <code class=\"hljs\">fly</code> on an instance of\n<code class=\"hljs\">Human</code></span></p>\n<p>Running this code will print <code class=\"hljs\">*waving arms furiously*</code>, showing that Rust\ncalled the <code class=\"hljs\">fly</code> method implemented on <code class=\"hljs\">Human</code> directly.</p>\n<p>To call the <code class=\"hljs\">fly</code> methods from either the <code class=\"hljs\">Pilot</code> trait or the <code class=\"hljs\">Wizard</code> trait,\nwe need to use more explicit syntax to specify which <code class=\"hljs\">fly</code> method we mean.\nListing 19-18 demonstrates this syntax.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Pilot</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Wizard</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Human</span></span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Pilot <span class=\"hljs-keyword\">for</span> Human {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"This is your captain speaking.\"</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Wizard <span class=\"hljs-keyword\">for</span> Human {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Up!\"</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Human {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fly</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"*waving arms furiously*\"</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> person = Human;\n    Pilot::fly(&amp;person);\n    Wizard::fly(&amp;person);\n    person.fly();\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-18: Specifying which trait’s <code class=\"hljs\">fly</code> method we\nwant to call</span></p>\n<p>Specifying the trait name before the method name clarifies to Rust which\nimplementation of <code class=\"hljs\">fly</code> we want to call. We could also write\n<code class=\"hljs\">Human::fly(&amp;person)</code>, which is equivalent to the <code class=\"hljs\">person.fly()</code> that we used\nin Listing 19-18, but this is a bit longer to write if we don’t need to\ndisambiguate.</p>\n<p>Running this code prints the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s\n     Running `target/debug/traits-example`\nThis is your captain speaking.\nUp!\n*waving arms furiously*\n</code></pre>\n<p>Because the <code class=\"hljs\">fly</code> method takes a <code class=\"hljs\">self</code> parameter, if we had two <em>types</em> that\nboth implement one <em>trait</em>, Rust could figure out which implementation of a\ntrait to use based on the type of <code class=\"hljs\">self</code>.</p>\n<p>However, associated functions that are not methods don’t have a <code class=\"hljs\">self</code>\nparameter. When there are multiple types or traits that define non-method\nfunctions with the same function name, Rust doesn’t always know which type you\nmean unless you use <em>fully qualified syntax</em>. For example, in Listing 19-19 we\ncreate a trait for an animal shelter that wants to name all baby dogs <em>Spot</em>.\nWe make an <code class=\"hljs\">Animal</code> trait with an associated non-method function <code class=\"hljs\">baby_name</code>.\nThe <code class=\"hljs\">Animal</code> trait is implemented for the struct <code class=\"hljs\">Dog</code>, on which we also\nprovide an associated non-method function <code class=\"hljs\">baby_name</code> directly.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Animal</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">baby_name</span></span>() -&gt; <span class=\"hljs-built_in\">String</span>;\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Dog</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> Dog {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">baby_name</span></span>() -&gt; <span class=\"hljs-built_in\">String</span> {\n        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Spot\"</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> Animal <span class=\"hljs-keyword\">for</span> Dog {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">baby_name</span></span>() -&gt; <span class=\"hljs-built_in\">String</span> {\n        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"puppy\"</span>)\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"A baby dog is called a {}\"</span>, Dog::baby_name());\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-19: A trait with an associated function and a\ntype with an associated function of the same name that also implements the\ntrait</span></p>\n<p>We implement the code for naming all puppies Spot in the <code class=\"hljs\">baby_name</code> associated\nfunction that is defined on <code class=\"hljs\">Dog</code>. The <code class=\"hljs\">Dog</code> type also implements the trait\n<code class=\"hljs\">Animal</code>, which describes characteristics that all animals have. Baby dogs are\ncalled puppies, and that is expressed in the implementation of the <code class=\"hljs\">Animal</code>\ntrait on <code class=\"hljs\">Dog</code> in the <code class=\"hljs\">baby_name</code> function associated with the <code class=\"hljs\">Animal</code> trait.</p>\n<p>In <code class=\"hljs\">main</code>, we call the <code class=\"hljs\">Dog::baby_name</code> function, which calls the associated\nfunction defined on <code class=\"hljs\">Dog</code> directly. This code prints the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n     Running `target/debug/traits-example`\nA baby dog is called a Spot\n</code></pre>\n<p>This output isn’t what we wanted. We want to call the <code class=\"hljs\">baby_name</code> function that\nis part of the <code class=\"hljs\">Animal</code> trait that we implemented on <code class=\"hljs\">Dog</code> so the code prints\n<code class=\"hljs\">A baby dog is called a puppy</code>. The technique of specifying the trait name that\nwe used in Listing 19-18 doesn’t help here; if we change <code class=\"hljs\">main</code> to the code in\nListing 19-20, we’ll get a compilation error.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-small\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Animal</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">baby_name</span></span>() -&gt; <span class=\"hljs-built_in\">String</span>;\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Dog</span></span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Dog {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">baby_name</span></span>() -&gt; <span class=\"hljs-built_in\">String</span> {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Spot\"</span>)\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Animal <span class=\"hljs-keyword\">for</span> Dog {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">baby_name</span></span>() -&gt; <span class=\"hljs-built_in\">String</span> {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"puppy\"</span>)\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"A baby dog is called a {}\"</span>, Animal::baby_name());\n}</code></pre>\n<p><span class=\"caption\">Listing 19-20: Attempting to call the <code class=\"hljs\">baby_name</code>\nfunction from the <code class=\"hljs\">Animal</code> trait, but Rust doesn’t know which implementation to\nuse</span></p>\n<p>Because <code class=\"hljs\">Animal::baby_name</code> doesn’t have a <code class=\"hljs\">self</code> parameter, and there could be\nother types that implement the <code class=\"hljs\">Animal</code> trait, Rust can’t figure out which\nimplementation of <code class=\"hljs\">Animal::baby_name</code> we want. We’ll get this compiler error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/main.rs:20:43</span>\n   |\n2  |     fn baby_name() -&gt; String;\n   |     ------------------------- `Animal::baby_name` defined here\n...\n20 |     println!(\"A baby dog is called a {}\", Animal::baby_name());\n   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait\n   |\nhelp: use the fully-qualified path to the only available implementation\n   |\n20 |     println!(\"A baby dog is called a {}\", &lt;Dog as Animal&gt;::baby_name());\n   |                                           +++++++       +\n\nFor more information about this error, try `rustc --explain E0790`.\nerror: could not compile `traits-example` (bin \"traits-example\") due to 1 previous error\n</code></pre>\n<p>To disambiguate and tell Rust that we want to use the implementation of\n<code class=\"hljs\">Animal</code> for <code class=\"hljs\">Dog</code> as opposed to the implementation of <code class=\"hljs\">Animal</code> for some other\ntype, we need to use fully qualified syntax. Listing 19-21 demonstrates how to\nuse fully qualified syntax.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Animal</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">baby_name</span></span>() -&gt; <span class=\"hljs-built_in\">String</span>;\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Dog</span></span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Dog {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">baby_name</span></span>() -&gt; <span class=\"hljs-built_in\">String</span> {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Spot\"</span>)\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Animal <span class=\"hljs-keyword\">for</span> Dog {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">baby_name</span></span>() -&gt; <span class=\"hljs-built_in\">String</span> {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"puppy\"</span>)\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"A baby dog is called a {}\"</span>, &lt;Dog <span class=\"hljs-keyword\">as</span> Animal&gt;::baby_name());\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-21: Using fully qualified syntax to specify\nthat we want to call the <code class=\"hljs\">baby_name</code> function from the <code class=\"hljs\">Animal</code> trait as\nimplemented on <code class=\"hljs\">Dog</code></span></p>\n<p>We’re providing Rust with a type annotation within the angle brackets, which\nindicates we want to call the <code class=\"hljs\">baby_name</code> method from the <code class=\"hljs\">Animal</code> trait as\nimplemented on <code class=\"hljs\">Dog</code> by saying that we want to treat the <code class=\"hljs\">Dog</code> type as an\n<code class=\"hljs\">Animal</code> for this function call. This code will now print what we want:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/traits-example`\nA baby dog is called a puppy\n</code></pre>\n<p>In general, fully qualified syntax is defined as follows:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">&lt;Type <span class=\"hljs-keyword\">as</span> Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>\n<p>For associated functions that aren’t methods, there would not be a <code class=\"hljs\">receiver</code>:\nthere would only be the list of other arguments. You could use fully qualified\nsyntax everywhere that you call functions or methods. However, you’re allowed\nto omit any part of this syntax that Rust can figure out from other information\nin the program. You only need to use this more verbose syntax in cases where\nthere are multiple implementations that use the same name and Rust needs help\nto identify which implementation you want to call.</p>\n<h3 id=\"using-supertraits-to-require-one-traits-functionality-within-another-trait\"><a class=\"header\" href=\"#using-supertraits-to-require-one-traits-functionality-within-another-trait\">Using Supertraits to Require One Trait’s Functionality Within Another Trait</a></h3>\n<p>Sometimes, you might write a trait definition that depends on another trait:\nfor a type to implement the first trait, you want to require that type to also\nimplement the second trait. You would do this so that your trait definition can\nmake use of the associated items of the second trait. The trait your trait\ndefinition is relying on is called a <em>supertrait</em> of your trait.</p>\n<p>For example, let’s say we want to make an <code class=\"hljs\">OutlinePrint</code> trait with an\n<code class=\"hljs\">outline_print</code> method that will print a given value formatted so that it’s\nframed in asterisks. That is, given a <code class=\"hljs\">Point</code> struct that implements the\nstandard library trait <code class=\"hljs\">Display</code> to result in <code class=\"hljs\">(x, y)</code>, when we call\n<code class=\"hljs\">outline_print</code> on a <code class=\"hljs\">Point</code> instance that has <code class=\"hljs\">1</code> for <code class=\"hljs\">x</code> and <code class=\"hljs\">3</code> for <code class=\"hljs\">y</code>, it\nshould print the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">**********\n*        *\n* (1, 3) *\n*        *\n**********\n</code></pre>\n<p>In the implementation of the <code class=\"hljs\">outline_print</code> method, we want to use the\n<code class=\"hljs\">Display</code> trait’s functionality. Therefore, we need to specify that the\n<code class=\"hljs\">OutlinePrint</code> trait will work only for types that also implement <code class=\"hljs\">Display</code> and\nprovide the functionality that <code class=\"hljs\">OutlinePrint</code> needs. We can do that in the\ntrait definition by specifying <code class=\"hljs\">OutlinePrint: Display</code>. This technique is\nsimilar to adding a trait bound to the trait. Listing 19-22 shows an\nimplementation of the <code class=\"hljs\">OutlinePrint</code> trait.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::fmt;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">OutlinePrint</span></span>: fmt::Display {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">outline_print</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">let</span> output = <span class=\"hljs-keyword\">self</span>.to_string();\n        <span class=\"hljs-keyword\">let</span> len = output.len();\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-string\">\"*\"</span>.repeat(len + <span class=\"hljs-number\">4</span>));\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"*{}*\"</span>, <span class=\"hljs-string\">\" \"</span>.repeat(len + <span class=\"hljs-number\">2</span>));\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"* {output} *\"</span>);\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"*{}*\"</span>, <span class=\"hljs-string\">\" \"</span>.repeat(len + <span class=\"hljs-number\">2</span>));\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-string\">\"*\"</span>.repeat(len + <span class=\"hljs-number\">4</span>));\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 19-22: Implementing the <code class=\"hljs\">OutlinePrint</code> trait that\nrequires the functionality from <code class=\"hljs\">Display</code></span></p>\n<p>Because we’ve specified that <code class=\"hljs\">OutlinePrint</code> requires the <code class=\"hljs\">Display</code> trait, we\ncan use the <code class=\"hljs\">to_string</code> function that is automatically implemented for any type\nthat implements <code class=\"hljs\">Display</code>. If we tried to use <code class=\"hljs\">to_string</code> without adding a\ncolon and specifying the <code class=\"hljs\">Display</code> trait after the trait name, we’d get an\nerror saying that no method named <code class=\"hljs\">to_string</code> was found for the type <code class=\"hljs\">&amp;Self</code> in\nthe current scope.</p>\n<p>Let’s see what happens when we try to implement <code class=\"hljs\">OutlinePrint</code> on a type that\ndoesn’t implement <code class=\"hljs\">Display</code>, such as the <code class=\"hljs\">Point</code> struct:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fmt;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">OutlinePrint</span></span>: fmt::Display {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">outline_print</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> output = <span class=\"hljs-keyword\">self</span>.to_string();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> len = output.len();\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-string\">\"*\"</span>.repeat(len + <span class=\"hljs-number\">4</span>));\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"*{}*\"</span>, <span class=\"hljs-string\">\" \"</span>.repeat(len + <span class=\"hljs-number\">2</span>));\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"* {output} *\"</span>);\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"*{}*\"</span>, <span class=\"hljs-string\">\" \"</span>.repeat(len + <span class=\"hljs-number\">2</span>));\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-string\">\"*\"</span>.repeat(len + <span class=\"hljs-number\">4</span>));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n    x: <span class=\"hljs-built_in\">i32</span>,\n    y: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> OutlinePrint <span class=\"hljs-keyword\">for</span> Point {}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> p = Point { x: <span class=\"hljs-number\">1</span>, y: <span class=\"hljs-number\">3</span> };\n</span><span class=\"boring\">    p.outline_print();\n</span><span class=\"boring\">}</span></code></pre>\n<p>We get an error saying that <code class=\"hljs\">Display</code> is required but not implemented:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0277]: `Point` doesn't implement `std::fmt::Display`\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/main.rs:20:23</span>\n   |\n20 | impl OutlinePrint for Point {}\n   |                       ^^^^^ `Point` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Point`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\nnote: required by a bound in `OutlinePrint`\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/main.rs:3:21</span>\n   |\n3  | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`\n\nerror[E0277]: `Point` doesn't implement `std::fmt::Display`\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/main.rs:24:7</span>\n   |\n24 |     p.outline_print();\n   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Point`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\nnote: required by a bound in `OutlinePrint::outline_print`\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/main.rs:3:21</span>\n   |\n3  | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`\n4  |     fn outline_print(&amp;self) {\n   |        ------------- required by a bound in this associated function\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `traits-example` (bin \"traits-example\") due to 2 previous errors\n</code></pre>\n<p>To fix this, we implement <code class=\"hljs\">Display</code> on <code class=\"hljs\">Point</code> and satisfy the constraint that\n<code class=\"hljs\">OutlinePrint</code> requires, like so:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">OutlinePrint</span></span>: fmt::Display {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">outline_print</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> output = <span class=\"hljs-keyword\">self</span>.to_string();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> len = output.len();\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-string\">\"*\"</span>.repeat(len + <span class=\"hljs-number\">4</span>));\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"*{}*\"</span>, <span class=\"hljs-string\">\" \"</span>.repeat(len + <span class=\"hljs-number\">2</span>));\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"* {output} *\"</span>);\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"*{}*\"</span>, <span class=\"hljs-string\">\" \"</span>.repeat(len + <span class=\"hljs-number\">2</span>));\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-string\">\"*\"</span>.repeat(len + <span class=\"hljs-number\">4</span>));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n</span><span class=\"boring\">    x: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">    y: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> OutlinePrint <span class=\"hljs-keyword\">for</span> Point {}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">use</span> std::fmt;\n\n<span class=\"hljs-keyword\">impl</span> fmt::Display <span class=\"hljs-keyword\">for</span> Point {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fmt</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, f: &amp;<span class=\"hljs-keyword\">mut</span> fmt::Formatter) -&gt; fmt::<span class=\"hljs-built_in\">Result</span> {\n        <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"({}, {})\"</span>, <span class=\"hljs-keyword\">self</span>.x, <span class=\"hljs-keyword\">self</span>.y)\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> p = Point { x: <span class=\"hljs-number\">1</span>, y: <span class=\"hljs-number\">3</span> };\n</span><span class=\"boring\">    p.outline_print();\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p>Then implementing the <code class=\"hljs\">OutlinePrint</code> trait on <code class=\"hljs\">Point</code> will compile\nsuccessfully, and we can call <code class=\"hljs\">outline_print</code> on a <code class=\"hljs\">Point</code> instance to display\nit within an outline of asterisks.</p>\n<h3 id=\"using-the-newtype-pattern-to-implement-external-traits-on-external-types\"><a class=\"header\" href=\"#using-the-newtype-pattern-to-implement-external-traits-on-external-types\">Using the Newtype Pattern to Implement External Traits on External Types</a></h3>\n<p>In Chapter 10 in the <a href=\"ch10-02-traits.html#implementing-a-trait-on-a-type\">“Implementing a Trait on a\nType”</a><!-- ignore --> section, we mentioned the\norphan rule that states we’re only allowed to implement a trait on a type if\neither the trait or the type are local to our crate. It’s possible to get\naround this restriction using the <em>newtype pattern</em>, which involves creating a\nnew type in a tuple struct. (We covered tuple structs in the <a href=\"ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types\">“Using Tuple\nStructs without Named Fields to Create Different Types”</a><!--\nignore --> section of Chapter 5.) The tuple struct will have one field and be a\nthin wrapper around the type we want to implement a trait for. Then the wrapper\ntype is local to our crate, and we can implement the trait on the wrapper.\n<em>Newtype</em> is a term that originates from the Haskell programming language.\nThere is no runtime performance penalty for using this pattern, and the wrapper\ntype is elided at compile time.</p>\n<p>As an example, let’s say we want to implement <code class=\"hljs\">Display</code> on <code class=\"hljs\">Vec&lt;T&gt;</code>, which the\norphan rule prevents us from doing directly because the <code class=\"hljs\">Display</code> trait and the\n<code class=\"hljs\">Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code class=\"hljs\">Wrapper</code> struct\nthat holds an instance of <code class=\"hljs\">Vec&lt;T&gt;</code>; then we can implement <code class=\"hljs\">Display</code> on\n<code class=\"hljs\">Wrapper</code> and use the <code class=\"hljs\">Vec&lt;T&gt;</code> value, as shown in Listing 19-23.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">use</span> std::fmt;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Wrapper</span></span>(<span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt;);\n\n<span class=\"hljs-keyword\">impl</span> fmt::Display <span class=\"hljs-keyword\">for</span> Wrapper {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">fmt</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, f: &amp;<span class=\"hljs-keyword\">mut</span> fmt::Formatter) -&gt; fmt::<span class=\"hljs-built_in\">Result</span> {\n        <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"[{}]\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>.join(<span class=\"hljs-string\">\", \"</span>))\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> w = Wrapper(<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>), <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"world\"</span>)]);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"w = {w}\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-23: Creating a <code class=\"hljs\">Wrapper</code> type around\n<code class=\"hljs\">Vec&lt;String&gt;</code> to implement <code class=\"hljs\">Display</code></span></p>\n<p>The implementation of <code class=\"hljs\">Display</code> uses <code class=\"hljs\">self.0</code> to access the inner <code class=\"hljs\">Vec&lt;T&gt;</code>,\nbecause <code class=\"hljs\">Wrapper</code> is a tuple struct and <code class=\"hljs\">Vec&lt;T&gt;</code> is the item at index 0 in the\ntuple. Then we can use the functionality of the <code class=\"hljs\">Display</code> trait on <code class=\"hljs\">Wrapper</code>.</p>\n<p>The downside of using this technique is that <code class=\"hljs\">Wrapper</code> is a new type, so it\ndoesn’t have the methods of the value it’s holding. We would have to implement\nall the methods of <code class=\"hljs\">Vec&lt;T&gt;</code> directly on <code class=\"hljs\">Wrapper</code> such that the methods\ndelegate to <code class=\"hljs\">self.0</code>, which would allow us to treat <code class=\"hljs\">Wrapper</code> exactly like a\n<code class=\"hljs\">Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has,\nimplementing the <code class=\"hljs\">Deref</code> trait (discussed in Chapter 15 in the <a href=\"ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait\">“Treating Smart\nPointers Like Regular References with the <code class=\"hljs\">Deref</code>\nTrait”</a><!-- ignore --> section) on the <code class=\"hljs\">Wrapper</code> to return\nthe inner type would be a solution. If we don’t want the <code class=\"hljs\">Wrapper</code> type to have\nall the methods of the inner type—for example, to restrict the <code class=\"hljs\">Wrapper</code> type’s\nbehavior—we would have to implement just the methods we do want manually.</p>\n<p>This newtype pattern is also useful even when traits are not involved. Let’s\nswitch focus and look at some advanced ways to interact with Rust’s type system.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch19-01-unsafe-rust.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch19-04-advanced-types.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch19-01-unsafe-rust.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch19-04-advanced-types.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:34.173Z"
}