{
	"title": "The match Control Flow Construct - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch06-02-match.html",
	"markdown": "# The match Control Flow Construct\n\nRust has an extremely powerful control flow construct called `match` that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things; [Chapter 18](ch18-00-patterns.html) covers all the different kinds of patterns and what they do. The power of `match` comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled.\n\nThink of a `match` expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a `match`, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution.\n\nSpeaking of coins, let’s use them as an example using `match`! We can write a function that takes an unknown US coin and, in a similar way as the counting machine, determines which coin it is and returns its value in cents, as shown in Listing 6-3.\n\n```rust\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n\nfn main() {}\n```\n\nListing 6-3: An enum and a `match` expression that has the variants of the enum as its patterns\n\nLet’s break down the `match` in the `value_in_cents` function. First we list the `match` keyword followed by an expression, which in this case is the value `coin`. This seems very similar to a conditional expression used with `if`, but there’s a big difference: with `if`, the condition needs to evaluate to a Boolean value, but here it can be any type. The type of `coin` in this example is the `Coin` enum that we defined on the first line.\n\nNext are the `match` arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value `Coin::Penny` and then the `=>` operator that separates the pattern and the code to run. The code in this case is just the value `1`. Each arm is separated from the next with a comma.\n\nWhen the `match` expression executes, it compares the resultant value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our `match` has four arms.\n\nThe code associated with each arm is an expression, and the resultant value of the expression in the matching arm is the value that gets returned for the entire `match` expression.\n\nWe don’t typically use curly brackets if the match arm code is short, as it is in Listing 6-3 where each arm just returns a value. If you want to run multiple lines of code in a match arm, you must use curly brackets, and the comma following the arm is then optional. For example, the following code prints “Lucky penny!” every time the method is called with a `Coin::Penny`, but still returns the last value of the block, `1`:\n\n```rust\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            1\n        }\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n\nfn main() {}\n```\n\n### [Patterns That Bind to Values](#patterns-that-bind-to-values)\n\nAnother useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.\n\nAs an example, let’s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our `enum` by changing the `Quarter` variant to include a `UsState` value stored inside it, which we’ve done in Listing 6-4.\n\n```rust\n#[derive(Debug)] // so we can inspect the state in a minute\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn main() {}\n```\n\nListing 6-4: A `Coin` enum in which the `Quarter` variant also holds a `UsState` value\n\nLet’s imagine that a friend is trying to collect all 50 state quarters. While we sort our loose change by coin type, we’ll also call out the name of the state associated with each quarter so that if it’s one our friend doesn’t have, they can add it to their collection.\n\nIn the match expression for this code, we add a variable called `state` to the pattern that matches values of the variant `Coin::Quarter`. When a `Coin::Quarter` matches, the `state` variable will bind to the value of that quarter’s state. Then we can use `state` in the code for that arm, like so:\n\n```rust\n#[derive(Debug)]\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {state:?}!\");\n            25\n        }\n    }\n}\n\nfn main() {\n    value_in_cents(Coin::Quarter(UsState::Alaska));\n}\n```\n\nIf we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each of the match arms, none of them match until we reach `Coin::Quarter(state)`. At that point, the binding for `state` will be the value `UsState::Alaska`. We can then use that binding in the `println!` expression, thus getting the inner state value out of the `Coin` enum variant for `Quarter`.\n\n### [Matching with `Option<T>`](#matching-with-optiont)\n\nIn the previous section, we wanted to get the inner `T` value out of the `Some` case when using `Option<T>`; we can also handle `Option<T>` using `match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll compare the variants of `Option<T>`, but the way the `match` expression works remains the same.\n\nLet’s say we want to write a function that takes an `Option<i32>` and, if there’s a value inside, adds 1 to that value. If there isn’t a value inside, the function should return the `None` value and not attempt to perform any operations.\n\nThis function is very easy to write, thanks to `match`, and will look like Listing 6-5.\n\n```rust\nfn main() {\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            None => None,\n            Some(i) => Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n}\n```\n\nListing 6-5: A function that uses a `match` expression on an `Option<i32>`\n\nLet’s examine the first execution of `plus_one` in more detail. When we call `plus_one(five)`, the variable `x` in the body of `plus_one` will have the value `Some(5)`. We then compare that against each match arm:\n\n```rust\nfn main() {\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            None => None,\n            Some(i) => Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n}\n```\n\nThe `Some(5)` value doesn’t match the pattern `None`, so we continue to the next arm:\n\n```rust\nfn main() {\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            None => None,\n            Some(i) => Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n}\n```\n\nDoes `Some(5)` match `Some(i)`? It does! We have the same variant. The `i` binds to the value contained in `Some`, so `i` takes the value `5`. The code in the match arm is then executed, so we add 1 to the value of `i` and create a new `Some` value with our total `6` inside.\n\nNow let’s consider the second call of `plus_one` in Listing 6-5, where `x` is `None`. We enter the `match` and compare to the first arm:\n\n```rust\nfn main() {\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            None => None,\n            Some(i) => Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n}\n```\n\nIt matches! There’s no value to add to, so the program stops and returns the `None` value on the right side of `=>`. Because the first arm matched, no other arms are compared.\n\nCombining `match` and enums is useful in many situations. You’ll see this pattern a lot in Rust code: `match` against an enum, bind a variable to the data inside, and then execute code based on it. It’s a bit tricky at first, but once you get used to it, you’ll wish you had it in all languages. It’s consistently a user favorite.\n\n### [Matches Are Exhaustive](#matches-are-exhaustive)\n\nThere’s one other aspect of `match` we need to discuss: the arms’ patterns must cover all possibilities. Consider this version of our `plus_one` function, which has a bug and won’t compile:\n\n```rust\nfn main() {\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            Some(i) => Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n}\n```\n\nWe didn’t handle the `None` case, so this code will cause a bug. Luckily, it’s a bug Rust knows how to catch. If we try to compile this code, we’ll get this error:\n\n```console\n$ cargo run\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0004]: non-exhaustive patterns: `None` not covered\n --> src/main.rs:3:15\n  |\n3 |         match x {\n  |               ^ pattern `None` not covered\n  |\nnote: `Option<i32>` defined here\n --> /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:572:1\n ::: /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:576:5\n  |\n  = note: not covered\n  = note: the matched value is of type `Option<i32>`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n  |\n4 ~             Some(i) => Some(i + 1),\n5 ~             None => todo!(),\n  |\n\nFor more information about this error, try `rustc --explain E0004`.\nerror: could not compile `enums` (bin \"enums\") due to 1 previous error\n\n```\n\nRust knows that we didn’t cover every possible case, and even knows which pattern we forgot! Matches in Rust are _exhaustive_: we must exhaust every last possibility in order for the code to be valid. Especially in the case of `Option<T>`, when Rust prevents us from forgetting to explicitly handle the `None` case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible.\n\n### [Catch-all Patterns and the `_` Placeholder](#catch-all-patterns-and-the-_-placeholder)\n\nUsing enums, we can also take special actions for a few particular values, but for all other values take one default action. Imagine we’re implementing a game where, if you roll a 3 on a dice roll, your player doesn’t move, but instead gets a new fancy hat. If you roll a 7, your player loses a fancy hat. For all other values, your player moves that number of spaces on the game board. Here’s a `match` that implements that logic, with the result of the dice roll hardcoded rather than a random value, and all other logic represented by functions without bodies because actually implementing them is out of scope for this example:\n\n```rust\nfn main() {\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        other => move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\n}\n```\n\nFor the first two arms, the patterns are the literal values `3` and `7`. For the last arm that covers every other possible value, the pattern is the variable we’ve chosen to name `other`. The code that runs for the `other` arm uses the variable by passing it to the `move_player` function.\n\nThis code compiles, even though we haven’t listed all the possible values a `u8` can have, because the last pattern will match all values not specifically listed. This catch-all pattern meets the requirement that `match` must be exhaustive. Note that we have to put the catch-all arm last because the patterns are evaluated in order. If we put the catch-all arm earlier, the other arms would never run, so Rust will warn us if we add arms after a catch-all!\n\nRust also has a pattern we can use when we want a catch-all but don’t want to _use_ the value in the catch-all pattern: `_` is a special pattern that matches any value and does not bind to that value. This tells Rust we aren’t going to use the value, so Rust won’t warn us about an unused variable.\n\nLet’s change the rules of the game: now, if you roll anything other than a 3 or a 7, you must roll again. We no longer need to use the catch-all value, so we can change our code to use `_` instead of the variable named `other`:\n\n```rust\nfn main() {\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => reroll(),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn reroll() {}\n}\n```\n\nThis example also meets the exhaustiveness requirement because we’re explicitly ignoring all other values in the last arm; we haven’t forgotten anything.\n\nFinally, we’ll change the rules of the game one more time so that nothing else happens on your turn if you roll anything other than a 3 or a 7. We can express that by using the unit value (the empty tuple type we mentioned in [“The Tuple Type”](about:blank/ch03-02-data-types.html#the-tuple-type) section) as the code that goes with the `_` arm:\n\n```rust\nfn main() {\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => (),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n}\n```\n\nHere, we’re telling Rust explicitly that we aren’t going to use any other value that doesn’t match a pattern in an earlier arm, and we don’t want to run any code in this case.\n\nThere’s more about patterns and matching that we’ll cover in [Chapter 18](ch18-00-patterns.html). For now, we’re going to move on to the `if let` syntax, which can be useful in situations where the `match` expression is a bit wordy.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>The match Control Flow Construct - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <!-- Old heading. Do not remove or links may break. -->\n<p><a id=\"the-match-control-flow-operator\"></a></p>\n<h2 id=\"the-match-control-flow-construct\"><a class=\"header\" href=\"#the-match-control-flow-construct\">The <code>match</code> Control Flow Construct</a></h2>\n<p>Rust has an extremely powerful control flow construct called <code class=\"hljs\">match</code> that\nallows you to compare a value against a series of patterns and then execute\ncode based on which pattern matches. Patterns can be made up of literal values,\nvariable names, wildcards, and many other things; <a href=\"ch18-00-patterns.html\">Chapter\n18</a><!-- ignore --> covers all the different kinds of patterns\nand what they do. The power of <code class=\"hljs\">match</code> comes from the expressiveness of the\npatterns and the fact that the compiler confirms that all possible cases are\nhandled.</p>\n<p>Think of a <code class=\"hljs\">match</code> expression as being like a coin-sorting machine: coins slide\ndown a track with variously sized holes along it, and each coin falls through\nthe first hole it encounters that it fits into. In the same way, values go\nthrough each pattern in a <code class=\"hljs\">match</code>, and at the first pattern the value “fits,”\nthe value falls into the associated code block to be used during execution.</p>\n<p>Speaking of coins, let’s use them as an example using <code class=\"hljs\">match</code>! We can write a\nfunction that takes an unknown US coin and, in a similar way as the counting\nmachine, determines which coin it is and returns its value in cents, as shown\nin Listing 6-3.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Coin</span></span> {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">value_in_cents</span></span>(coin: Coin) -&gt; <span class=\"hljs-built_in\">u8</span> {\n    <span class=\"hljs-keyword\">match</span> coin {\n        Coin::Penny =&gt; <span class=\"hljs-number\">1</span>,\n        Coin::Nickel =&gt; <span class=\"hljs-number\">5</span>,\n        Coin::Dime =&gt; <span class=\"hljs-number\">10</span>,\n        Coin::Quarter =&gt; <span class=\"hljs-number\">25</span>,\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 6-3: An enum and a <code class=\"hljs\">match</code> expression that has\nthe variants of the enum as its patterns</span></p>\n<p>Let’s break down the <code class=\"hljs\">match</code> in the <code class=\"hljs\">value_in_cents</code> function. First we list\nthe <code class=\"hljs\">match</code> keyword followed by an expression, which in this case is the value\n<code class=\"hljs\">coin</code>. This seems very similar to a conditional expression used with <code class=\"hljs\">if</code>, but\nthere’s a big difference: with <code class=\"hljs\">if</code>, the condition needs to evaluate to a\nBoolean value, but here it can be any type. The type of <code class=\"hljs\">coin</code> in this example\nis the <code class=\"hljs\">Coin</code> enum that we defined on the first line.</p>\n<p>Next are the <code class=\"hljs\">match</code> arms. An arm has two parts: a pattern and some code. The\nfirst arm here has a pattern that is the value <code class=\"hljs\">Coin::Penny</code> and then the <code class=\"hljs\">=&gt;</code>\noperator that separates the pattern and the code to run. The code in this case\nis just the value <code class=\"hljs\">1</code>. Each arm is separated from the next with a comma.</p>\n<p>When the <code class=\"hljs\">match</code> expression executes, it compares the resultant value against\nthe pattern of each arm, in order. If a pattern matches the value, the code\nassociated with that pattern is executed. If that pattern doesn’t match the\nvalue, execution continues to the next arm, much as in a coin-sorting machine.\nWe can have as many arms as we need: in Listing 6-3, our <code class=\"hljs\">match</code> has four arms.</p>\n<p>The code associated with each arm is an expression, and the resultant value of\nthe expression in the matching arm is the value that gets returned for the\nentire <code class=\"hljs\">match</code> expression.</p>\n<p>We don’t typically use curly brackets if the match arm code is short, as it is\nin Listing 6-3 where each arm just returns a value. If you want to run multiple\nlines of code in a match arm, you must use curly brackets, and the comma\nfollowing the arm is then optional. For example, the following code prints\n“Lucky penny!” every time the method is called with a <code class=\"hljs\">Coin::Penny</code>, but still\nreturns the last value of the block, <code class=\"hljs\">1</code>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Coin</span></span> {\n</span><span class=\"boring\">    Penny,\n</span><span class=\"boring\">    Nickel,\n</span><span class=\"boring\">    Dime,\n</span><span class=\"boring\">    Quarter,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">value_in_cents</span></span>(coin: Coin) -&gt; <span class=\"hljs-built_in\">u8</span> {\n    <span class=\"hljs-keyword\">match</span> coin {\n        Coin::Penny =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Lucky penny!\"</span>);\n            <span class=\"hljs-number\">1</span>\n        }\n        Coin::Nickel =&gt; <span class=\"hljs-number\">5</span>,\n        Coin::Dime =&gt; <span class=\"hljs-number\">10</span>,\n        Coin::Quarter =&gt; <span class=\"hljs-number\">25</span>,\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<h3 id=\"patterns-that-bind-to-values\"><a class=\"header\" href=\"#patterns-that-bind-to-values\">Patterns That Bind to Values</a></h3>\n<p>Another useful feature of match arms is that they can bind to the parts of the\nvalues that match the pattern. This is how we can extract values out of enum\nvariants.</p>\n<p>As an example, let’s change one of our enum variants to hold data inside it.\nFrom 1999 through 2008, the United States minted quarters with different\ndesigns for each of the 50 states on one side. No other coins got state\ndesigns, so only quarters have this extra value. We can add this information to\nour <code class=\"hljs\">enum</code> by changing the <code class=\"hljs\">Quarter</code> variant to include a <code class=\"hljs\">UsState</code> value\nstored inside it, which we’ve done in Listing 6-4.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span> <span class=\"hljs-comment\">// so we can inspect the state in a minute</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">UsState</span></span> {\n    Alabama,\n    Alaska,\n    <span class=\"hljs-comment\">// --snip--</span>\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Coin</span></span> {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 6-4: A <code class=\"hljs\">Coin</code> enum in which the <code class=\"hljs\">Quarter</code> variant\nalso holds a <code class=\"hljs\">UsState</code> value</span></p>\n<p>Let’s imagine that a friend is trying to collect all 50 state quarters. While\nwe sort our loose change by coin type, we’ll also call out the name of the\nstate associated with each quarter so that if it’s one our friend doesn’t have,\nthey can add it to their collection.</p>\n<p>In the match expression for this code, we add a variable called <code class=\"hljs\">state</code> to the\npattern that matches values of the variant <code class=\"hljs\">Coin::Quarter</code>. When a\n<code class=\"hljs\">Coin::Quarter</code> matches, the <code class=\"hljs\">state</code> variable will bind to the value of that\nquarter’s state. Then we can use <code class=\"hljs\">state</code> in the code for that arm, like so:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">UsState</span></span> {\n</span><span class=\"boring\">    Alabama,\n</span><span class=\"boring\">    Alaska,\n</span><span class=\"boring\">    <span class=\"hljs-comment\">// --snip--</span>\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Coin</span></span> {\n</span><span class=\"boring\">    Penny,\n</span><span class=\"boring\">    Nickel,\n</span><span class=\"boring\">    Dime,\n</span><span class=\"boring\">    Quarter(UsState),\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">value_in_cents</span></span>(coin: Coin) -&gt; <span class=\"hljs-built_in\">u8</span> {\n    <span class=\"hljs-keyword\">match</span> coin {\n        Coin::Penny =&gt; <span class=\"hljs-number\">1</span>,\n        Coin::Nickel =&gt; <span class=\"hljs-number\">5</span>,\n        Coin::Dime =&gt; <span class=\"hljs-number\">10</span>,\n        Coin::Quarter(state) =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"State quarter from {state:?}!\"</span>);\n            <span class=\"hljs-number\">25</span>\n        }\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    value_in_cents(Coin::Quarter(UsState::Alaska));\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p>If we were to call <code class=\"hljs\">value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code class=\"hljs\">coin</code>\nwould be <code class=\"hljs\">Coin::Quarter(UsState::Alaska)</code>. When we compare that value with each\nof the match arms, none of them match until we reach <code class=\"hljs\">Coin::Quarter(state)</code>. At\nthat point, the binding for <code class=\"hljs\">state</code> will be the value <code class=\"hljs\">UsState::Alaska</code>. We can\nthen use that binding in the <code class=\"hljs\">println!</code> expression, thus getting the inner\nstate value out of the <code class=\"hljs\">Coin</code> enum variant for <code class=\"hljs\">Quarter</code>.</p>\n<h3 id=\"matching-with-optiont\"><a class=\"header\" href=\"#matching-with-optiont\">Matching with <code>Option&lt;T&gt;</code></a></h3>\n<p>In the previous section, we wanted to get the inner <code class=\"hljs\">T</code> value out of the <code class=\"hljs\">Some</code>\ncase when using <code class=\"hljs\">Option&lt;T&gt;</code>; we can also handle <code class=\"hljs\">Option&lt;T&gt;</code> using <code class=\"hljs\">match</code>, as\nwe did with the <code class=\"hljs\">Coin</code> enum! Instead of comparing coins, we’ll compare the\nvariants of <code class=\"hljs\">Option&lt;T&gt;</code>, but the way the <code class=\"hljs\">match</code> expression works remains the\nsame.</p>\n<p>Let’s say we want to write a function that takes an <code class=\"hljs\">Option&lt;i32&gt;</code> and, if\nthere’s a value inside, adds 1 to that value. If there isn’t a value inside,\nthe function should return the <code class=\"hljs\">None</code> value and not attempt to perform any\noperations.</p>\n<p>This function is very easy to write, thanks to <code class=\"hljs\">match</code>, and will look like\nListing 6-5.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">plus_one</span></span>(x: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt;) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; {\n        <span class=\"hljs-keyword\">match</span> x {\n            <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-literal\">None</span>,\n            <span class=\"hljs-literal\">Some</span>(i) =&gt; <span class=\"hljs-literal\">Some</span>(i + <span class=\"hljs-number\">1</span>),\n        }\n    }\n\n    <span class=\"hljs-keyword\">let</span> five = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">let</span> six = plus_one(five);\n    <span class=\"hljs-keyword\">let</span> none = plus_one(<span class=\"hljs-literal\">None</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 6-5: A function that uses a <code class=\"hljs\">match</code> expression on\nan <code class=\"hljs\">Option&lt;i32&gt;</code></span></p>\n<p>Let’s examine the first execution of <code class=\"hljs\">plus_one</code> in more detail. When we call\n<code class=\"hljs\">plus_one(five)</code>, the variable <code class=\"hljs\">x</code> in the body of <code class=\"hljs\">plus_one</code> will have the\nvalue <code class=\"hljs\">Some(5)</code>. We then compare that against each match arm:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">plus_one</span></span>(x: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt;) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">match</span> x {\n</span>            <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-literal\">None</span>,\n<span class=\"boring\">            <span class=\"hljs-literal\">Some</span>(i) =&gt; <span class=\"hljs-literal\">Some</span>(i + <span class=\"hljs-number\">1</span>),\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> five = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> six = plus_one(five);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> none = plus_one(<span class=\"hljs-literal\">None</span>);\n</span><span class=\"boring\">}</span></code></pre>\n<p>The <code class=\"hljs\">Some(5)</code> value doesn’t match the pattern <code class=\"hljs\">None</code>, so we continue to the\nnext arm:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">plus_one</span></span>(x: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt;) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">match</span> x {\n</span><span class=\"boring\">            <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-literal\">None</span>,\n</span>            <span class=\"hljs-literal\">Some</span>(i) =&gt; <span class=\"hljs-literal\">Some</span>(i + <span class=\"hljs-number\">1</span>),\n<span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> five = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> six = plus_one(five);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> none = plus_one(<span class=\"hljs-literal\">None</span>);\n</span><span class=\"boring\">}</span></code></pre>\n<p>Does <code class=\"hljs\">Some(5)</code> match <code class=\"hljs\">Some(i)</code>? It does! We have the same variant. The <code class=\"hljs\">i</code>\nbinds to the value contained in <code class=\"hljs\">Some</code>, so <code class=\"hljs\">i</code> takes the value <code class=\"hljs\">5</code>. The code in\nthe match arm is then executed, so we add 1 to the value of <code class=\"hljs\">i</code> and create a\nnew <code class=\"hljs\">Some</code> value with our total <code class=\"hljs\">6</code> inside.</p>\n<p>Now let’s consider the second call of <code class=\"hljs\">plus_one</code> in Listing 6-5, where <code class=\"hljs\">x</code> is\n<code class=\"hljs\">None</code>. We enter the <code class=\"hljs\">match</code> and compare to the first arm:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">plus_one</span></span>(x: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt;) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">match</span> x {\n</span>            <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-literal\">None</span>,\n<span class=\"boring\">            <span class=\"hljs-literal\">Some</span>(i) =&gt; <span class=\"hljs-literal\">Some</span>(i + <span class=\"hljs-number\">1</span>),\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> five = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> six = plus_one(five);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> none = plus_one(<span class=\"hljs-literal\">None</span>);\n</span><span class=\"boring\">}</span></code></pre>\n<p>It matches! There’s no value to add to, so the program stops and returns the\n<code class=\"hljs\">None</code> value on the right side of <code class=\"hljs\">=&gt;</code>. Because the first arm matched, no other\narms are compared.</p>\n<p>Combining <code class=\"hljs\">match</code> and enums is useful in many situations. You’ll see this\npattern a lot in Rust code: <code class=\"hljs\">match</code> against an enum, bind a variable to the\ndata inside, and then execute code based on it. It’s a bit tricky at first, but\nonce you get used to it, you’ll wish you had it in all languages. It’s\nconsistently a user favorite.</p>\n<h3 id=\"matches-are-exhaustive\"><a class=\"header\" href=\"#matches-are-exhaustive\">Matches Are Exhaustive</a></h3>\n<p>There’s one other aspect of <code class=\"hljs\">match</code> we need to discuss: the arms’ patterns must\ncover all possibilities. Consider this version of our <code class=\"hljs\">plus_one</code> function,\nwhich has a bug and won’t compile:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">plus_one</span></span>(x: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt;) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; {\n        <span class=\"hljs-keyword\">match</span> x {\n            <span class=\"hljs-literal\">Some</span>(i) =&gt; <span class=\"hljs-literal\">Some</span>(i + <span class=\"hljs-number\">1</span>),\n        }\n    }\n<span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> five = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> six = plus_one(five);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> none = plus_one(<span class=\"hljs-literal\">None</span>);\n</span><span class=\"boring\">}</span></code></pre>\n<p>We didn’t handle the <code class=\"hljs\">None</code> case, so this code will cause a bug. Luckily, it’s\na bug Rust knows how to catch. If we try to compile this code, we’ll get this\nerror:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0004]: non-exhaustive patterns: `None` not covered\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:3:15</span>\n  |\n3 |         match x {\n  |               ^ pattern `None` not covered\n  |\nnote: `Option&lt;i32&gt;` defined here\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:572:1</span>\n ::: /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:576:5\n  |\n  = note: not covered\n  = note: the matched value is of type `Option&lt;i32&gt;`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n  |\n4 ~             Some(i) =&gt; Some(i + 1),\n5 ~             None =&gt; todo!(),\n  |\n\nFor more information about this error, try `rustc --explain E0004`.\nerror: could not compile `enums` (bin \"enums\") due to 1 previous error\n</code></pre>\n<p>Rust knows that we didn’t cover every possible case, and even knows which\npattern we forgot! Matches in Rust are <em>exhaustive</em>: we must exhaust every last\npossibility in order for the code to be valid. Especially in the case of\n<code class=\"hljs\">Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the\n<code class=\"hljs\">None</code> case, it protects us from assuming that we have a value when we might\nhave null, thus making the billion-dollar mistake discussed earlier impossible.</p>\n<h3 id=\"catch-all-patterns-and-the-_-placeholder\"><a class=\"header\" href=\"#catch-all-patterns-and-the-_-placeholder\">Catch-all Patterns and the <code>_</code> Placeholder</a></h3>\n<p>Using enums, we can also take special actions for a few particular values, but\nfor all other values take one default action. Imagine we’re implementing a game\nwhere, if you roll a 3 on a dice roll, your player doesn’t move, but instead\ngets a new fancy hat. If you roll a 7, your player loses a fancy hat. For all\nother values, your player moves that number of spaces on the game board. Here’s\na <code class=\"hljs\">match</code> that implements that logic, with the result of the dice roll\nhardcoded rather than a random value, and all other logic represented by\nfunctions without bodies because actually implementing them is out of scope for\nthis example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> dice_roll = <span class=\"hljs-number\">9</span>;\n    <span class=\"hljs-keyword\">match</span> dice_roll {\n        <span class=\"hljs-number\">3</span> =&gt; add_fancy_hat(),\n        <span class=\"hljs-number\">7</span> =&gt; remove_fancy_hat(),\n        other =&gt; move_player(other),\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add_fancy_hat</span></span>() {}\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">remove_fancy_hat</span></span>() {}\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">move_player</span></span>(num_spaces: <span class=\"hljs-built_in\">u8</span>) {}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>For the first two arms, the patterns are the literal values <code class=\"hljs\">3</code> and <code class=\"hljs\">7</code>. For\nthe last arm that covers every other possible value, the pattern is the\nvariable we’ve chosen to name <code class=\"hljs\">other</code>. The code that runs for the <code class=\"hljs\">other</code> arm\nuses the variable by passing it to the <code class=\"hljs\">move_player</code> function.</p>\n<p>This code compiles, even though we haven’t listed all the possible values a\n<code class=\"hljs\">u8</code> can have, because the last pattern will match all values not specifically\nlisted. This catch-all pattern meets the requirement that <code class=\"hljs\">match</code> must be\nexhaustive. Note that we have to put the catch-all arm last because the\npatterns are evaluated in order. If we put the catch-all arm earlier, the other\narms would never run, so Rust will warn us if we add arms after a catch-all!</p>\n<p>Rust also has a pattern we can use when we want a catch-all but don’t want to\n<em>use</em> the value in the catch-all pattern: <code class=\"hljs\">_</code> is a special pattern that matches\nany value and does not bind to that value. This tells Rust we aren’t going to\nuse the value, so Rust won’t warn us about an unused variable.</p>\n<p>Let’s change the rules of the game: now, if you roll anything other than a 3 or\na 7, you must roll again. We no longer need to use the catch-all value, so we\ncan change our code to use <code class=\"hljs\">_</code> instead of the variable named <code class=\"hljs\">other</code>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> dice_roll = <span class=\"hljs-number\">9</span>;\n    <span class=\"hljs-keyword\">match</span> dice_roll {\n        <span class=\"hljs-number\">3</span> =&gt; add_fancy_hat(),\n        <span class=\"hljs-number\">7</span> =&gt; remove_fancy_hat(),\n        _ =&gt; reroll(),\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add_fancy_hat</span></span>() {}\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">remove_fancy_hat</span></span>() {}\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">reroll</span></span>() {}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This example also meets the exhaustiveness requirement because we’re explicitly\nignoring all other values in the last arm; we haven’t forgotten anything.</p>\n<p>Finally, we’ll change the rules of the game one more time so that nothing else\nhappens on your turn if you roll anything other than a 3 or a 7. We can express\nthat by using the unit value (the empty tuple type we mentioned in <a href=\"ch03-02-data-types.html#the-tuple-type\">“The Tuple\nType”</a><!-- ignore --> section) as the code that goes with the <code class=\"hljs\">_</code> arm:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> dice_roll = <span class=\"hljs-number\">9</span>;\n    <span class=\"hljs-keyword\">match</span> dice_roll {\n        <span class=\"hljs-number\">3</span> =&gt; add_fancy_hat(),\n        <span class=\"hljs-number\">7</span> =&gt; remove_fancy_hat(),\n        _ =&gt; (),\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add_fancy_hat</span></span>() {}\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">remove_fancy_hat</span></span>() {}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Here, we’re telling Rust explicitly that we aren’t going to use any other value\nthat doesn’t match a pattern in an earlier arm, and we don’t want to run any\ncode in this case.</p>\n<p>There’s more about patterns and matching that we’ll cover in <a href=\"ch18-00-patterns.html\">Chapter\n18</a><!-- ignore -->. For now, we’re going to move on to the\n<code class=\"hljs\">if let</code> syntax, which can be useful in situations where the <code class=\"hljs\">match</code> expression\nis a bit wordy.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch06-01-defining-an-enum.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch06-03-if-let.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch06-01-defining-an-enum.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch06-03-if-let.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:18.303Z"
}