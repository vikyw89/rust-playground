{
	"title": "std::iter - Rust",
	"url": "https://doc.rust-lang.org/stable/std/iter/index.html",
	"markdown": "# std::iter - Rust\n\n## Module [std](../index.html)::[iter](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/lib.rs.html#398) ·\n\nExpand description\n\nComposable external iteration.\n\nIf you’ve found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you’ll quickly run into ‘iterators’. Iterators are heavily used in idiomatic Rust code, so it’s worth becoming familiar with them.\n\nBefore explaining more, let’s talk about how this module is structured:\n\n## [§](#organization)Organization\n\nThis module is largely organized by type:\n\n-   [Traits](#traits) are the core portion: these traits define what kind of iterators exist and what you can do with them. The methods of these traits are worth putting some extra study time into.\n-   [Functions](#functions) provide some helpful ways to create some basic iterators.\n-   [Structs](#structs) are often the return types of the various methods on this module’s traits. You’ll usually want to look at the method that creates the `struct`, rather than the `struct` itself. For more detail about why, see ‘[Implementing Iterator](#implementing-iterator)’.\n\nThat’s it! Let’s dig into iterators.\n\n## [§](#iterator)Iterator\n\nThe heart and soul of this module is the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") trait. The core of [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") looks like this:\n\n```\ntrait Iterator {\n    type Item;\n    fn next(&mut self) -> Option<Self::Item>;\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++trait+Iterator+%7B%0A++++++++type+Item;%0A++++++++fn+next(%26mut+self)+-%3E+Option%3CSelf::Item%3E;%0A++++%7D%0A%7D&edition=2021)\n\nAn iterator has a method, [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\"), which when called, returns an `[Option](../option/enum.Option.html \"enum std::option::Option\")<Item>`. Calling [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") will return [`Some(Item)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") as long as there are elements, and once they’ve all been exhausted, will return `None` to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") again may or may not eventually start returning [`Some(Item)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") again at some point (for example, see [`TryIter`](../../std/sync/mpsc/struct.TryIter.html)).\n\n[`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\")’s full definition includes a number of other methods as well, but they are default methods, built on top of [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\"), and so you get them for free.\n\nIterators are also composable, and it’s common to chain them together to do more complex forms of processing. See the [Adapters](#adapters) section below for more details.\n\n## [§](#the-three-forms-of-iteration)The three forms of iteration\n\nThere are three common methods which can create iterators from a collection:\n\n-   `iter()`, which iterates over `&T`.\n-   `iter_mut()`, which iterates over `&mut T`.\n-   `into_iter()`, which iterates over `T`.\n\nVarious things in the standard library may implement one or more of the three, where appropriate.\n\n## [§](#implementing-iterator)Implementing Iterator\n\nCreating an iterator of your own involves two steps: creating a `struct` to hold the iterator’s state, and then implementing [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") for that `struct`. This is why there are so many `struct`s in this module: there is one for each iterator and iterator adapter.\n\nLet’s make an iterator named `Counter` which counts from `1` to `5`:\n\n```\n// First, the struct:\n\n/// An iterator which counts from one to five\nstruct Counter {\n    count: usize,\n}\n\n// we want our count to start at one, so let's add a new() method to help.\n// This isn't strictly necessary, but is convenient. Note that we start\n// `count` at zero, we'll see why in `next()`'s implementation below.\nimpl Counter {\n    fn new() -> Counter {\n        Counter { count: 0 }\n    }\n}\n\n// Then, we implement `Iterator` for our `Counter`:\n\nimpl Iterator for Counter {\n    // we will be counting with usize\n    type Item = usize;\n\n    // next() is the only required method\n    fn next(&mut self) -> Option<Self::Item> {\n        // Increment our count. This is why we started at zero.\n        self.count += 1;\n\n        // Check to see if we've finished counting or not.\n        if self.count < 6 {\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n\n// And now we can use it!\n\nlet mut counter = Counter::new();\n\nassert_eq!(counter.next(), Some(1));\nassert_eq!(counter.next(), Some(2));\nassert_eq!(counter.next(), Some(3));\nassert_eq!(counter.next(), Some(4));\nassert_eq!(counter.next(), Some(5));\nassert_eq!(counter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+First,+the+struct:%0A%0Afn+main()+%7B%0A++++///+An+iterator+which+counts+from+one+to+five%0A++++struct+Counter+%7B%0A++++++++count:+usize,%0A++++%7D%0A++++%0A++++//+we+want+our+count+to+start+at+one,+so+let%27s+add+a+new()+method+to+help.%0A++++//+This+isn%27t+strictly+necessary,+but+is+convenient.+Note+that+we+start%0A++++//+%60count%60+at+zero,+we%27ll+see+why+in+%60next()%60%27s+implementation+below.%0A++++impl+Counter+%7B%0A++++++++fn+new()+-%3E+Counter+%7B%0A++++++++++++Counter+%7B+count:+0+%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+Then,+we+implement+%60Iterator%60+for+our+%60Counter%60:%0A++++%0A++++impl+Iterator+for+Counter+%7B%0A++++++++//+we+will+be+counting+with+usize%0A++++++++type+Item+=+usize;%0A++++%0A++++++++//+next()+is+the+only+required+method%0A++++++++fn+next(%26mut+self)+-%3E+Option%3CSelf::Item%3E+%7B%0A++++++++++++//+Increment+our+count.+This+is+why+we+started+at+zero.%0A++++++++++++self.count+%2B=+1;%0A++++%0A++++++++++++//+Check+to+see+if+we%27ve+finished+counting+or+not.%0A++++++++++++if+self.count+%3C+6+%7B%0A++++++++++++++++Some(self.count)%0A++++++++++++%7D+else+%7B%0A++++++++++++++++None%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+And+now+we+can+use+it!%0A++++%0A++++let+mut+counter+=+Counter::new();%0A++++%0A++++assert_eq!(counter.next(),+Some(1));%0A++++assert_eq!(counter.next(),+Some(2));%0A++++assert_eq!(counter.next(),+Some(3));%0A++++assert_eq!(counter.next(),+Some(4));%0A++++assert_eq!(counter.next(),+Some(5));%0A++++assert_eq!(counter.next(),+None);%0A%7D&edition=2021)\n\nCalling [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") this way gets repetitive. Rust has a construct which can call [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") on your iterator, until it reaches `None`. Let’s go over that next.\n\nAlso note that `Iterator` provides a default implementation of methods such as `nth` and `fold` which call `next` internally. However, it is also possible to write a custom implementation of methods like `nth` and `fold` if an iterator can compute them more efficiently without calling `next`.\n\n## [§](#for-loops-and-intoiterator)`for` loops and `IntoIterator`\n\nRust’s `for` loop syntax is actually sugar for iterators. Here’s a basic example of `for`:\n\n```\nlet values = vec![1, 2, 3, 4, 5];\n\nfor x in values {\n    println!(\"{x}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+values+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++for+x+in+values+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\nThis will print the numbers one through five, each on their own line. But you’ll notice something here: we never called anything on our vector to produce an iterator. What gives?\n\nThere’s a trait in the standard library for converting something into an iterator: [`IntoIterator`](trait.IntoIterator.html \"trait std::iter::IntoIterator\"). This trait has one method, [`into_iter`](about:blank/trait.IntoIterator.html#tymethod.into_iter \"method std::iter::IntoIterator::into_iter\"), which converts the thing implementing [`IntoIterator`](trait.IntoIterator.html \"trait std::iter::IntoIterator\") into an iterator. Let’s take a look at that `for` loop again, and what the compiler converts it into:\n\n```\nlet values = vec![1, 2, 3, 4, 5];\n\nfor x in values {\n    println!(\"{x}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+values+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++for+x+in+values+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\nRust de-sugars this into:\n\n```\nlet values = vec![1, 2, 3, 4, 5];\n{\n    let result = match IntoIterator::into_iter(values) {\n        mut iter => loop {\n            let next;\n            match iter.next() {\n                Some(val) => next = val,\n                None => break,\n            };\n            let x = next;\n            let () = { println!(\"{x}\"); };\n        },\n    };\n    result\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+values+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++%7B%0A++++++++let+result+=+match+IntoIterator::into_iter(values)+%7B%0A++++++++++++mut+iter+=%3E+loop+%7B%0A++++++++++++++++let+next;%0A++++++++++++++++match+iter.next()+%7B%0A++++++++++++++++++++Some(val)+=%3E+next+=+val,%0A++++++++++++++++++++None+=%3E+break,%0A++++++++++++++++%7D;%0A++++++++++++++++let+x+=+next;%0A++++++++++++++++let+()+=+%7B+println!(%22%7Bx%7D%22);+%7D;%0A++++++++++++%7D,%0A++++++++%7D;%0A++++++++result%0A++++%7D%0A%7D&edition=2021)\n\nFirst, we call `into_iter()` on the value. Then, we match on the iterator that returns, calling [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") over and over until we see a `None`. At that point, we `break` out of the loop, and we’re done iterating.\n\nThere’s one more subtle bit here: the standard library contains an interesting implementation of [`IntoIterator`](trait.IntoIterator.html \"trait std::iter::IntoIterator\"):\n\n[ⓘ](# \"This example is not tested\")\n\n```\nimpl<I: Iterator> IntoIterator for I\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++impl%3CI:+Iterator%3E+IntoIterator+for+I%0A%7D&edition=2021)\n\nIn other words, all [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\")s implement [`IntoIterator`](trait.IntoIterator.html \"trait std::iter::IntoIterator\"), by just returning themselves. This means two things:\n\n1.  If you’re writing an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\"), you can use it with a `for` loop.\n2.  If you’re creating a collection, implementing [`IntoIterator`](trait.IntoIterator.html \"trait std::iter::IntoIterator\") for it will allow your collection to be used with the `for` loop.\n\n## [§](#iterating-by-reference)Iterating by reference\n\nSince [`into_iter()`](about:blank/trait.IntoIterator.html#tymethod.into_iter \"method std::iter::IntoIterator::into_iter\") takes `self` by value, using a `for` loop to iterate over a collection consumes that collection. Often, you may want to iterate over a collection without consuming it. Many collections offer methods that provide iterators over references, conventionally called `iter()` and `iter_mut()` respectively:\n\n```\nlet mut values = vec![41];\nfor x in values.iter_mut() {\n    *x += 1;\n}\nfor x in values.iter() {\n    assert_eq!(*x, 42);\n}\nassert_eq!(values.len(), 1); // `values` is still owned by this function.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+values+=+vec!%5B41%5D;%0A++++for+x+in+values.iter_mut()+%7B%0A++++++++*x+%2B=+1;%0A++++%7D%0A++++for+x+in+values.iter()+%7B%0A++++++++assert_eq!(*x,+42);%0A++++%7D%0A++++assert_eq!(values.len(),+1);+//+%60values%60+is+still+owned+by+this+function.%0A%7D&edition=2021)\n\nIf a collection type `C` provides `iter()`, it usually also implements `IntoIterator` for `&C`, with an implementation that just calls `iter()`. Likewise, a collection `C` that provides `iter_mut()` generally implements `IntoIterator` for `&mut C` by delegating to `iter_mut()`. This enables a convenient shorthand:\n\n```\nlet mut values = vec![41];\nfor x in &mut values { // same as `values.iter_mut()`\n    *x += 1;\n}\nfor x in &values { // same as `values.iter()`\n    assert_eq!(*x, 42);\n}\nassert_eq!(values.len(), 1);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+values+=+vec!%5B41%5D;%0A++++for+x+in+%26mut+values+%7B+//+same+as+%60values.iter_mut()%60%0A++++++++*x+%2B=+1;%0A++++%7D%0A++++for+x+in+%26values+%7B+//+same+as+%60values.iter()%60%0A++++++++assert_eq!(*x,+42);%0A++++%7D%0A++++assert_eq!(values.len(),+1);%0A%7D&edition=2021)\n\nWhile many collections offer `iter()`, not all offer `iter_mut()`. For example, mutating the keys of a [`HashSet<T>`](../../std/collections/struct.HashSet.html) could put the collection into an inconsistent state if the key hashes change, so this collection only offers `iter()`.\n\n## [§](#adapters)Adapters\n\nFunctions which take an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") and return another [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") are often called ‘iterator adapters’, as they’re a form of the ‘adapter pattern’.\n\nCommon iterator adapters include [`map`](about:blank/trait.Iterator.html#method.map \"method std::iter::Iterator::map\"), [`take`](about:blank/trait.Iterator.html#method.take \"method std::iter::Iterator::take\"), and [`filter`](about:blank/trait.Iterator.html#method.filter \"method std::iter::Iterator::filter\"). For more, see their documentation.\n\nIf an iterator adapter panics, the iterator will be in an unspecified (but memory safe) state. This state is also not guaranteed to stay the same across versions of Rust, so you should avoid relying on the exact values returned by an iterator which panicked.\n\n## [§](#laziness)Laziness\n\nIterators (and iterator [adapters](#adapters)) are _lazy_. This means that just creating an iterator doesn’t _do_ a whole lot. Nothing really happens until you call [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\"). This is sometimes a source of confusion when creating an iterator solely for its side effects. For example, the [`map`](about:blank/trait.Iterator.html#method.map \"method std::iter::Iterator::map\") method calls a closure on each element it iterates over:\n\n```\nlet v = vec![1, 2, 3, 4, 5];\nv.iter().map(|x| println!(\"{x}\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0A%23!%5Ballow(map_unit_fn)%5D%0Afn+main()+%7B%0A++++let+v+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++v.iter().map(%7Cx%7C+println!(%22%7Bx%7D%22));%0A%7D&edition=2021)\n\nThis will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:\n\n```text\nwarning: unused result that must be used: iterators are lazy and\ndo nothing unless consumed\n\n```\n\nThe idiomatic way to write a [`map`](about:blank/trait.Iterator.html#method.map \"method std::iter::Iterator::map\") for its side effects is to use a `for` loop or call the [`for_each`](about:blank/trait.Iterator.html#method.for_each \"method std::iter::Iterator::for_each\") method:\n\n```\nlet v = vec![1, 2, 3, 4, 5];\n\nv.iter().for_each(|x| println!(\"{x}\"));\n// or\nfor x in &v {\n    println!(\"{x}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++v.iter().for_each(%7Cx%7C+println!(%22%7Bx%7D%22));%0A++++//+or%0A++++for+x+in+%26v+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\nAnother common way to evaluate an iterator is to use the [`collect`](about:blank/trait.Iterator.html#method.collect \"method std::iter::Iterator::collect\") method to produce a new collection.\n\n## [§](#infinity)Infinity\n\nIterators do not have to be finite. As an example, an open-ended range is an infinite iterator:\n\nIt is common to use the [`take`](about:blank/trait.Iterator.html#method.take \"method std::iter::Iterator::take\") iterator adapter to turn an infinite iterator into a finite one:\n\n```\nlet numbers = 0..;\nlet five_numbers = numbers.take(5);\n\nfor number in five_numbers {\n    println!(\"{number}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+numbers+=+0..;%0A++++let+five_numbers+=+numbers.take(5);%0A++++%0A++++for+number+in+five_numbers+%7B%0A++++++++println!(%22%7Bnumber%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\nThis will print the numbers `0` through `4`, each on their own line.\n\nBear in mind that methods on infinite iterators, even those for which a result can be determined mathematically in finite time, might not terminate. Specifically, methods such as [`min`](about:blank/trait.Iterator.html#method.min \"method std::iter::Iterator::min\"), which in the general case require traversing every element in the iterator, are likely not to return successfully for any infinite iterators.\n\n```\nlet ones = std::iter::repeat(1);\nlet least = ones.min().unwrap(); // Oh no! An infinite loop!\n// `ones.min()` causes an infinite loop, so we won't reach this point!\nprintln!(\"The smallest number one is {least}.\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ones+=+std::iter::repeat(1);%0A++++let+least+=+ones.min().unwrap();+//+Oh+no!+An+infinite+loop!%0A++++//+%60ones.min()%60+causes+an+infinite+loop,+so+we+won%27t+reach+this+point!%0A++++println!(%22The+smallest+number+one+is+%7Bleast%7D.%22);%0A%7D&edition=2021)\n\n-   An iterator that links two iterators together, in a chain.\n    \n-   An iterator that clones the elements of an underlying iterator.\n    \n-   An iterator that copies the elements of an underlying iterator.\n    \n-   An iterator that repeats endlessly.\n    \n-   An iterator that yields nothing.\n    \n-   An iterator that yields the current count and the element during iteration.\n    \n-   An iterator that filters the elements of `iter` with `predicate`.\n    \n-   An iterator that uses `f` to both filter and map elements from `iter`.\n    \n-   An iterator that maps each element to an iterator, and yields the elements of the produced iterators.\n    \n-   An iterator that flattens one level of nesting in an iterator of things that can be turned into iterators.\n    \n-   An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.\n    \n-   An iterator that yields `None` forever after the underlying iterator yields `None` once.\n    \n-   An iterator that calls a function with a reference to each element before yielding it.\n    \n-   An iterator that maps the values of `iter` with `f`.\n    \n-   An iterator that only accepts elements while `predicate` returns `Some(_)`.\n    \n-   An iterator that yields an element exactly once.\n    \n-   An iterator that yields a single element of type `A` by applying the provided closure `F: FnOnce() -> A`.\n    \n-   An iterator with a `peek()` that returns an optional reference to the next element.\n    \n-   An iterator that repeats an element endlessly.\n    \n-   An iterator that repeats elements of type `A` endlessly by applying the provided closure `F: FnMut() -> A`.\n    \n-   A double-ended iterator with the direction inverted.\n    \n-   An iterator to maintain state while iterating another iterator.\n    \n-   An iterator that skips over `n` elements of `iter`.\n    \n-   An iterator that rejects elements while `predicate` returns `true`.\n    \n-   An iterator for stepping iterators by a custom amount.\n    \n-   A new iterator where each successive item is computed based on the preceding one.\n    \n-   An iterator that only iterates over the first `n` iterations of `iter`.\n    \n-   An iterator that only accepts elements while `predicate` returns `true`.\n    \n-   An iterator that iterates two other iterators simultaneously.\n    \n-   An iterator over `N` elements of the iterator at a time.\n    \n-   Like `Iterator::by_ref`, but requiring `Sized` so it can forward generics.\n    \n-   An iterator adapter that places a separator between all elements.\n    \n-   An iterator adapter that places a separator between all elements.\n    \n-   An iterator over the mapped windows of another iterator.\n    \n-   An iterator that repeats an element an exact number of times.\n    \n\n-   An iterator able to yield elements from both ends.\n    \n-   An iterator that knows its exact length.\n    \n-   Extend a collection with the contents of an iterator.\n    \n\n-   An iterator that always continues to yield `None` when exhausted.\n    \n\n-   A trait for dealing with iterators.\n    \n-   Trait to represent types that can be created by multiplying elements of an iterator.\n    \n-   Trait to represent types that can be created by summing up an iterator.\n    \n-   Objects that have a notion of _successor_ and _predecessor_ operations.\n    \n-   An iterator that reports an accurate length using size\\_hint.\n    \n-   A type that upholds all invariants of [`Step`](trait.Step.html \"trait std::iter::Step\").\n    \n\n-   Creates an iterator that yields nothing.\n    \n-   Creates a new iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.\n    \n-   Creates an iterator that yields an element exactly once.\n    \n-   Creates an iterator that lazily generates a value exactly once by invoking the provided closure.\n    \n-   Creates a new iterator that endlessly repeats a single element.\n    \n-   Creates a new iterator that repeats elements of type `A` endlessly by applying the provided closure, the repeater, `F: FnMut() -> A`.\n    \n-   Creates a new iterator where each successive item is computed based on the preceding one.\n    \n-   Converts the arguments to iterators and zips them.\n    \n-   Converts the arguments to iterators and links them together, in a chain.\n    \n-   Creates a new iterator where each iteration calls the provided coroutine.\n    \n-   Creates a new iterator that repeats a single element a given number of times.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Composable external iteration.\"><title>std::iter - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module iter</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module iter</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li><li><a href=\"#traits\">Traits</a></li><li><a href=\"#functions\">Functions</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">iter</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/lib.rs.html#398\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Composable external iteration.</p>\n<p>If you’ve found yourself with a collection of some kind, and needed to\nperform an operation on the elements of said collection, you’ll quickly run\ninto ‘iterators’. Iterators are heavily used in idiomatic Rust code, so\nit’s worth becoming familiar with them.</p>\n<p>Before explaining more, let’s talk about how this module is structured:</p>\n<h2 id=\"organization\"><a class=\"doc-anchor\" href=\"#organization\">§</a>Organization</h2>\n<p>This module is largely organized by type:</p>\n<ul>\n<li><a href=\"#traits\">Traits</a> are the core portion: these traits define what kind of iterators\nexist and what you can do with them. The methods of these traits are worth\nputting some extra study time into.</li>\n<li><a href=\"#functions\">Functions</a> provide some helpful ways to create some basic iterators.</li>\n<li><a href=\"#structs\">Structs</a> are often the return types of the various methods on this\nmodule’s traits. You’ll usually want to look at the method that creates\nthe <code>struct</code>, rather than the <code>struct</code> itself. For more detail about why,\nsee ‘<a href=\"#implementing-iterator\">Implementing Iterator</a>’.</li>\n</ul>\n<p>That’s it! Let’s dig into iterators.</p>\n<h2 id=\"iterator\"><a class=\"doc-anchor\" href=\"#iterator\">§</a>Iterator</h2>\n<p>The heart and soul of this module is the <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> trait. The core of\n<a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> looks like this:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">trait </span>Iterator {\n    <span class=\"kw\">type </span>Item;\n    <span class=\"kw\">fn </span>next(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) -&gt; <span class=\"prelude-ty\">Option</span>&lt;<span class=\"self\">Self</span>::Item&gt;;\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++trait+Iterator+%7B%0A++++++++type+Item;%0A++++++++fn+next(%26mut+self)+-%3E+Option%3CSelf::Item%3E;%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>An iterator has a method, <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a>, which when called, returns an\n<code><a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Item&gt;</code>. Calling <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> will return <a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(Item)</code></a> as long as there\nare elements, and once they’ve all been exhausted, will return <code>None</code> to\nindicate that iteration is finished. Individual iterators may choose to\nresume iteration, and so calling <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> again may or may not eventually\nstart returning <a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(Item)</code></a> again at some point (for example, see <a href=\"../../std/sync/mpsc/struct.TryIter.html\"><code>TryIter</code></a>).</p>\n<p><a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a>’s full definition includes a number of other methods as well,\nbut they are default methods, built on top of <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a>, and so you get\nthem for free.</p>\n<p>Iterators are also composable, and it’s common to chain them together to do\nmore complex forms of processing. See the <a href=\"#adapters\">Adapters</a> section\nbelow for more details.</p>\n<h2 id=\"the-three-forms-of-iteration\"><a class=\"doc-anchor\" href=\"#the-three-forms-of-iteration\">§</a>The three forms of iteration</h2>\n<p>There are three common methods which can create iterators from a collection:</p>\n<ul>\n<li><code>iter()</code>, which iterates over <code>&amp;T</code>.</li>\n<li><code>iter_mut()</code>, which iterates over <code>&amp;mut T</code>.</li>\n<li><code>into_iter()</code>, which iterates over <code>T</code>.</li>\n</ul>\n<p>Various things in the standard library may implement one or more of the\nthree, where appropriate.</p>\n<h2 id=\"implementing-iterator\"><a class=\"doc-anchor\" href=\"#implementing-iterator\">§</a>Implementing Iterator</h2>\n<p>Creating an iterator of your own involves two steps: creating a <code>struct</code> to\nhold the iterator’s state, and then implementing <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> for that <code>struct</code>.\nThis is why there are so many <code>struct</code>s in this module: there is one for\neach iterator and iterator adapter.</p>\n<p>Let’s make an iterator named <code>Counter</code> which counts from <code>1</code> to <code>5</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// First, the struct:\n\n</span><span class=\"doccomment\">/// An iterator which counts from one to five\n</span><span class=\"kw\">struct </span>Counter {\n    count: usize,\n}\n\n<span class=\"comment\">// we want our count to start at one, so let's add a new() method to help.\n// This isn't strictly necessary, but is convenient. Note that we start\n// `count` at zero, we'll see why in `next()`'s implementation below.\n</span><span class=\"kw\">impl </span>Counter {\n    <span class=\"kw\">fn </span>new() -&gt; Counter {\n        Counter { count: <span class=\"number\">0 </span>}\n    }\n}\n\n<span class=\"comment\">// Then, we implement `Iterator` for our `Counter`:\n\n</span><span class=\"kw\">impl </span>Iterator <span class=\"kw\">for </span>Counter {\n    <span class=\"comment\">// we will be counting with usize\n    </span><span class=\"kw\">type </span>Item = usize;\n\n    <span class=\"comment\">// next() is the only required method\n    </span><span class=\"kw\">fn </span>next(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) -&gt; <span class=\"prelude-ty\">Option</span>&lt;<span class=\"self\">Self</span>::Item&gt; {\n        <span class=\"comment\">// Increment our count. This is why we started at zero.\n        </span><span class=\"self\">self</span>.count += <span class=\"number\">1</span>;\n\n        <span class=\"comment\">// Check to see if we've finished counting or not.\n        </span><span class=\"kw\">if </span><span class=\"self\">self</span>.count &lt; <span class=\"number\">6 </span>{\n            <span class=\"prelude-val\">Some</span>(<span class=\"self\">self</span>.count)\n        } <span class=\"kw\">else </span>{\n            <span class=\"prelude-val\">None\n        </span>}\n    }\n}\n\n<span class=\"comment\">// And now we can use it!\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>counter = Counter::new();\n\n<span class=\"macro\">assert_eq!</span>(counter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(counter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(counter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(counter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(counter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">5</span>));\n<span class=\"macro\">assert_eq!</span>(counter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+First,+the+struct:%0A%0Afn+main()+%7B%0A++++///+An+iterator+which+counts+from+one+to+five%0A++++struct+Counter+%7B%0A++++++++count:+usize,%0A++++%7D%0A++++%0A++++//+we+want+our+count+to+start+at+one,+so+let's+add+a+new()+method+to+help.%0A++++//+This+isn't+strictly+necessary,+but+is+convenient.+Note+that+we+start%0A++++//+%60count%60+at+zero,+we'll+see+why+in+%60next()%60's+implementation+below.%0A++++impl+Counter+%7B%0A++++++++fn+new()+-%3E+Counter+%7B%0A++++++++++++Counter+%7B+count:+0+%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+Then,+we+implement+%60Iterator%60+for+our+%60Counter%60:%0A++++%0A++++impl+Iterator+for+Counter+%7B%0A++++++++//+we+will+be+counting+with+usize%0A++++++++type+Item+=+usize;%0A++++%0A++++++++//+next()+is+the+only+required+method%0A++++++++fn+next(%26mut+self)+-%3E+Option%3CSelf::Item%3E+%7B%0A++++++++++++//+Increment+our+count.+This+is+why+we+started+at+zero.%0A++++++++++++self.count+%2B=+1;%0A++++%0A++++++++++++//+Check+to+see+if+we've+finished+counting+or+not.%0A++++++++++++if+self.count+%3C+6+%7B%0A++++++++++++++++Some(self.count)%0A++++++++++++%7D+else+%7B%0A++++++++++++++++None%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+And+now+we+can+use+it!%0A++++%0A++++let+mut+counter+=+Counter::new();%0A++++%0A++++assert_eq!(counter.next(),+Some(1));%0A++++assert_eq!(counter.next(),+Some(2));%0A++++assert_eq!(counter.next(),+Some(3));%0A++++assert_eq!(counter.next(),+Some(4));%0A++++assert_eq!(counter.next(),+Some(5));%0A++++assert_eq!(counter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Calling <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> this way gets repetitive. Rust has a construct which can\ncall <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> on your iterator, until it reaches <code>None</code>. Let’s go over that\nnext.</p>\n<p>Also note that <code>Iterator</code> provides a default implementation of methods such as <code>nth</code> and <code>fold</code>\nwhich call <code>next</code> internally. However, it is also possible to write a custom implementation of\nmethods like <code>nth</code> and <code>fold</code> if an iterator can compute them more efficiently without calling\n<code>next</code>.</p>\n<h2 id=\"for-loops-and-intoiterator\"><a class=\"doc-anchor\" href=\"#for-loops-and-intoiterator\">§</a><code>for</code> loops and <code>IntoIterator</code></h2>\n<p>Rust’s <code>for</code> loop syntax is actually sugar for iterators. Here’s a basic\nexample of <code>for</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>values = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span>values {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+values+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++for+x+in+values+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will print the numbers one through five, each on their own line. But\nyou’ll notice something here: we never called anything on our vector to\nproduce an iterator. What gives?</p>\n<p>There’s a trait in the standard library for converting something into an\niterator: <a href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a>. This trait has one method, <a href=\"trait.IntoIterator.html#tymethod.into_iter\" title=\"method std::iter::IntoIterator::into_iter\"><code>into_iter</code></a>,\nwhich converts the thing implementing <a href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a> into an iterator.\nLet’s take a look at that <code>for</code> loop again, and what the compiler converts\nit into:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>values = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span>values {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+values+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++for+x+in+values+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Rust de-sugars this into:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>values = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n{\n    <span class=\"kw\">let </span>result = <span class=\"kw\">match </span>IntoIterator::into_iter(values) {\n        <span class=\"kw-2\">mut </span>iter =&gt; <span class=\"kw\">loop </span>{\n            <span class=\"kw\">let </span>next;\n            <span class=\"kw\">match </span>iter.next() {\n                <span class=\"prelude-val\">Some</span>(val) =&gt; next = val,\n                <span class=\"prelude-val\">None </span>=&gt; <span class=\"kw\">break</span>,\n            };\n            <span class=\"kw\">let </span>x = next;\n            <span class=\"kw\">let </span>() = { <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>); };\n        },\n    };\n    result\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+values+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++%7B%0A++++++++let+result+=+match+IntoIterator::into_iter(values)+%7B%0A++++++++++++mut+iter+=%3E+loop+%7B%0A++++++++++++++++let+next;%0A++++++++++++++++match+iter.next()+%7B%0A++++++++++++++++++++Some(val)+=%3E+next+=+val,%0A++++++++++++++++++++None+=%3E+break,%0A++++++++++++++++%7D;%0A++++++++++++++++let+x+=+next;%0A++++++++++++++++let+()+=+%7B+println!(%22%7Bx%7D%22);+%7D;%0A++++++++++++%7D,%0A++++++++%7D;%0A++++++++result%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>First, we call <code>into_iter()</code> on the value. Then, we match on the iterator\nthat returns, calling <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> over and over until we see a <code>None</code>. At\nthat point, we <code>break</code> out of the loop, and we’re done iterating.</p>\n<p>There’s one more subtle bit here: the standard library contains an\ninteresting implementation of <a href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a>:</p>\n\n<div class=\"example-wrap ignore\"><a href=\"#\" class=\"tooltip\" title=\"This example is not tested\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">impl</span>&lt;I: Iterator&gt; IntoIterator <span class=\"kw\">for </span>I</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++impl%3CI:+Iterator%3E+IntoIterator+for+I%0A%7D&amp;edition=2021\">Run</a></div>\n<p>In other words, all <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a>s implement <a href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a>, by just\nreturning themselves. This means two things:</p>\n<ol>\n<li>If you’re writing an <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a>, you can use it with a <code>for</code> loop.</li>\n<li>If you’re creating a collection, implementing <a href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a> for it\nwill allow your collection to be used with the <code>for</code> loop.</li>\n</ol>\n<h2 id=\"iterating-by-reference\"><a class=\"doc-anchor\" href=\"#iterating-by-reference\">§</a>Iterating by reference</h2>\n<p>Since <a href=\"trait.IntoIterator.html#tymethod.into_iter\" title=\"method std::iter::IntoIterator::into_iter\"><code>into_iter()</code></a> takes <code>self</code> by value, using a <code>for</code> loop to iterate\nover a collection consumes that collection. Often, you may want to iterate\nover a collection without consuming it. Many collections offer methods that\nprovide iterators over references, conventionally called <code>iter()</code> and\n<code>iter_mut()</code> respectively:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>values = <span class=\"macro\">vec!</span>[<span class=\"number\">41</span>];\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span>values.iter_mut() {\n    <span class=\"kw-2\">*</span>x += <span class=\"number\">1</span>;\n}\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span>values.iter() {\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">42</span>);\n}\n<span class=\"macro\">assert_eq!</span>(values.len(), <span class=\"number\">1</span>); <span class=\"comment\">// `values` is still owned by this function.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+values+=+vec!%5B41%5D;%0A++++for+x+in+values.iter_mut()+%7B%0A++++++++*x+%2B=+1;%0A++++%7D%0A++++for+x+in+values.iter()+%7B%0A++++++++assert_eq!(*x,+42);%0A++++%7D%0A++++assert_eq!(values.len(),+1);+//+%60values%60+is+still+owned+by+this+function.%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If a collection type <code>C</code> provides <code>iter()</code>, it usually also implements\n<code>IntoIterator</code> for <code>&amp;C</code>, with an implementation that just calls <code>iter()</code>.\nLikewise, a collection <code>C</code> that provides <code>iter_mut()</code> generally implements\n<code>IntoIterator</code> for <code>&amp;mut C</code> by delegating to <code>iter_mut()</code>. This enables a\nconvenient shorthand:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>values = <span class=\"macro\">vec!</span>[<span class=\"number\">41</span>];\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span><span class=\"kw-2\">&amp;mut </span>values { <span class=\"comment\">// same as `values.iter_mut()`\n    </span><span class=\"kw-2\">*</span>x += <span class=\"number\">1</span>;\n}\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span><span class=\"kw-2\">&amp;</span>values { <span class=\"comment\">// same as `values.iter()`\n    </span><span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">42</span>);\n}\n<span class=\"macro\">assert_eq!</span>(values.len(), <span class=\"number\">1</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+values+=+vec!%5B41%5D;%0A++++for+x+in+%26mut+values+%7B+//+same+as+%60values.iter_mut()%60%0A++++++++*x+%2B=+1;%0A++++%7D%0A++++for+x+in+%26values+%7B+//+same+as+%60values.iter()%60%0A++++++++assert_eq!(*x,+42);%0A++++%7D%0A++++assert_eq!(values.len(),+1);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>While many collections offer <code>iter()</code>, not all offer <code>iter_mut()</code>. For\nexample, mutating the keys of a <a href=\"../../std/collections/struct.HashSet.html\"><code>HashSet&lt;T&gt;</code></a> could put the collection\ninto an inconsistent state if the key hashes change, so this collection\nonly offers <code>iter()</code>.</p>\n<h2 id=\"adapters\"><a class=\"doc-anchor\" href=\"#adapters\">§</a>Adapters</h2>\n<p>Functions which take an <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> and return another <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> are\noften called ‘iterator adapters’, as they’re a form of the ‘adapter\npattern’.</p>\n<p>Common iterator adapters include <a href=\"trait.Iterator.html#method.map\" title=\"method std::iter::Iterator::map\"><code>map</code></a>, <a href=\"trait.Iterator.html#method.take\" title=\"method std::iter::Iterator::take\"><code>take</code></a>, and <a href=\"trait.Iterator.html#method.filter\" title=\"method std::iter::Iterator::filter\"><code>filter</code></a>.\nFor more, see their documentation.</p>\n<p>If an iterator adapter panics, the iterator will be in an unspecified (but\nmemory safe) state.  This state is also not guaranteed to stay the same\nacross versions of Rust, so you should avoid relying on the exact values\nreturned by an iterator which panicked.</p>\n<h2 id=\"laziness\"><a class=\"doc-anchor\" href=\"#laziness\">§</a>Laziness</h2>\n<p>Iterators (and iterator <a href=\"#adapters\">adapters</a>) are <em>lazy</em>. This means that\njust creating an iterator doesn’t <em>do</em> a whole lot. Nothing really happens\nuntil you call <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a>. This is sometimes a source of confusion when\ncreating an iterator solely for its side effects. For example, the <a href=\"trait.Iterator.html#method.map\" title=\"method std::iter::Iterator::map\"><code>map</code></a>\nmethod calls a closure on each element it iterates over:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\nv.iter().map(|x| <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0A%23!%5Ballow(map_unit_fn)%5D%0Afn+main()+%7B%0A++++let+v+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++v.iter().map(%7Cx%7C+println!(%22%7Bx%7D%22));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will not print any values, as we only created an iterator, rather than\nusing it. The compiler will warn us about this kind of behavior:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>warning: unused result that must be used: iterators are lazy and\ndo nothing unless consumed\n</code></pre></div>\n<p>The idiomatic way to write a <a href=\"trait.Iterator.html#method.map\" title=\"method std::iter::Iterator::map\"><code>map</code></a> for its side effects is to use a\n<code>for</code> loop or call the <a href=\"trait.Iterator.html#method.for_each\" title=\"method std::iter::Iterator::for_each\"><code>for_each</code></a> method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\nv.iter().for_each(|x| <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>));\n<span class=\"comment\">// or\n</span><span class=\"kw\">for </span>x <span class=\"kw\">in </span><span class=\"kw-2\">&amp;</span>v {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+vec!%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++v.iter().for_each(%7Cx%7C+println!(%22%7Bx%7D%22));%0A++++//+or%0A++++for+x+in+%26v+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Another common way to evaluate an iterator is to use the <a href=\"trait.Iterator.html#method.collect\" title=\"method std::iter::Iterator::collect\"><code>collect</code></a>\nmethod to produce a new collection.</p>\n<h2 id=\"infinity\"><a class=\"doc-anchor\" href=\"#infinity\">§</a>Infinity</h2>\n<p>Iterators do not have to be finite. As an example, an open-ended range is\nan infinite iterator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>numbers = <span class=\"number\">0</span>..;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+numbers+=+0..;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>It is common to use the <a href=\"trait.Iterator.html#method.take\" title=\"method std::iter::Iterator::take\"><code>take</code></a> iterator adapter to turn an infinite\niterator into a finite one:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>numbers = <span class=\"number\">0</span>..;\n<span class=\"kw\">let </span>five_numbers = numbers.take(<span class=\"number\">5</span>);\n\n<span class=\"kw\">for </span>number <span class=\"kw\">in </span>five_numbers {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{number}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+numbers+=+0..;%0A++++let+five_numbers+=+numbers.take(5);%0A++++%0A++++for+number+in+five_numbers+%7B%0A++++++++println!(%22%7Bnumber%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will print the numbers <code>0</code> through <code>4</code>, each on their own line.</p>\n<p>Bear in mind that methods on infinite iterators, even those for which a\nresult can be determined mathematically in finite time, might not terminate.\nSpecifically, methods such as <a href=\"trait.Iterator.html#method.min\" title=\"method std::iter::Iterator::min\"><code>min</code></a>, which in the general case require\ntraversing every element in the iterator, are likely not to return\nsuccessfully for any infinite iterators.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>ones = std::iter::repeat(<span class=\"number\">1</span>);\n<span class=\"kw\">let </span>least = ones.min().unwrap(); <span class=\"comment\">// Oh no! An infinite loop!\n// `ones.min()` causes an infinite loop, so we won't reach this point!\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"The smallest number one is {least}.\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ones+=+std::iter::repeat(1);%0A++++let+least+=+ones.min().unwrap();+//+Oh+no!+An+infinite+loop!%0A++++//+%60ones.min()%60+causes+an+infinite+loop,+so+we+won't+reach+this+point!%0A++++println!(%22The+smallest+number+one+is+%7Bleast%7D.%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Chain.html\" title=\"struct std::iter::Chain\">Chain</a></div><div class=\"desc docblock-short\">An iterator that links two iterators together, in a chain.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Cloned.html\" title=\"struct std::iter::Cloned\">Cloned</a></div><div class=\"desc docblock-short\">An iterator that clones the elements of an underlying iterator.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Copied.html\" title=\"struct std::iter::Copied\">Copied</a></div><div class=\"desc docblock-short\">An iterator that copies the elements of an underlying iterator.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Cycle.html\" title=\"struct std::iter::Cycle\">Cycle</a></div><div class=\"desc docblock-short\">An iterator that repeats endlessly.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Empty.html\" title=\"struct std::iter::Empty\">Empty</a></div><div class=\"desc docblock-short\">An iterator that yields nothing.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Enumerate.html\" title=\"struct std::iter::Enumerate\">Enumerate</a></div><div class=\"desc docblock-short\">An iterator that yields the current count and the element during iteration.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Filter.html\" title=\"struct std::iter::Filter\">Filter</a></div><div class=\"desc docblock-short\">An iterator that filters the elements of <code>iter</code> with <code>predicate</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.FilterMap.html\" title=\"struct std::iter::FilterMap\">FilterMap</a></div><div class=\"desc docblock-short\">An iterator that uses <code>f</code> to both filter and map elements from <code>iter</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.FlatMap.html\" title=\"struct std::iter::FlatMap\">FlatMap</a></div><div class=\"desc docblock-short\">An iterator that maps each element to an iterator, and yields the elements\nof the produced iterators.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Flatten.html\" title=\"struct std::iter::Flatten\">Flatten</a></div><div class=\"desc docblock-short\">An iterator that flattens one level of nesting in an iterator of things\nthat can be turned into iterators.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.FromFn.html\" title=\"struct std::iter::FromFn\">FromFn</a></div><div class=\"desc docblock-short\">An iterator where each iteration calls the provided closure <code>F: FnMut() -&gt; Option&lt;T&gt;</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Fuse.html\" title=\"struct std::iter::Fuse\">Fuse</a></div><div class=\"desc docblock-short\">An iterator that yields <code>None</code> forever after the underlying iterator\nyields <code>None</code> once.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Inspect.html\" title=\"struct std::iter::Inspect\">Inspect</a></div><div class=\"desc docblock-short\">An iterator that calls a function with a reference to each element before\nyielding it.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Map.html\" title=\"struct std::iter::Map\">Map</a></div><div class=\"desc docblock-short\">An iterator that maps the values of <code>iter</code> with <code>f</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.MapWhile.html\" title=\"struct std::iter::MapWhile\">MapWhile</a></div><div class=\"desc docblock-short\">An iterator that only accepts elements while <code>predicate</code> returns <code>Some(_)</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Once.html\" title=\"struct std::iter::Once\">Once</a></div><div class=\"desc docblock-short\">An iterator that yields an element exactly once.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.OnceWith.html\" title=\"struct std::iter::OnceWith\">OnceWith</a></div><div class=\"desc docblock-short\">An iterator that yields a single element of type <code>A</code> by\napplying the provided closure <code>F: FnOnce() -&gt; A</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Peekable.html\" title=\"struct std::iter::Peekable\">Peekable</a></div><div class=\"desc docblock-short\">An iterator with a <code>peek()</code> that returns an optional reference to the next\nelement.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Repeat.html\" title=\"struct std::iter::Repeat\">Repeat</a></div><div class=\"desc docblock-short\">An iterator that repeats an element endlessly.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.RepeatWith.html\" title=\"struct std::iter::RepeatWith\">RepeatWith</a></div><div class=\"desc docblock-short\">An iterator that repeats elements of type <code>A</code> endlessly by\napplying the provided closure <code>F: FnMut() -&gt; A</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Rev.html\" title=\"struct std::iter::Rev\">Rev</a></div><div class=\"desc docblock-short\">A double-ended iterator with the direction inverted.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Scan.html\" title=\"struct std::iter::Scan\">Scan</a></div><div class=\"desc docblock-short\">An iterator to maintain state while iterating another iterator.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Skip.html\" title=\"struct std::iter::Skip\">Skip</a></div><div class=\"desc docblock-short\">An iterator that skips over <code>n</code> elements of <code>iter</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.SkipWhile.html\" title=\"struct std::iter::SkipWhile\">SkipWhile</a></div><div class=\"desc docblock-short\">An iterator that rejects elements while <code>predicate</code> returns <code>true</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.StepBy.html\" title=\"struct std::iter::StepBy\">StepBy</a></div><div class=\"desc docblock-short\">An iterator for stepping iterators by a custom amount.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Successors.html\" title=\"struct std::iter::Successors\">Successors</a></div><div class=\"desc docblock-short\">A new iterator where each successive item is computed based on the preceding one.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Take.html\" title=\"struct std::iter::Take\">Take</a></div><div class=\"desc docblock-short\">An iterator that only iterates over the first <code>n</code> iterations of <code>iter</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.TakeWhile.html\" title=\"struct std::iter::TakeWhile\">TakeWhile</a></div><div class=\"desc docblock-short\">An iterator that only accepts elements while <code>predicate</code> returns <code>true</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Zip.html\" title=\"struct std::iter::Zip\">Zip</a></div><div class=\"desc docblock-short\">An iterator that iterates two other iterators simultaneously.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ArrayChunks.html\" title=\"struct std::iter::ArrayChunks\">ArrayChunks</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">An iterator over <code>N</code> elements of the iterator at a time.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ByRefSized.html\" title=\"struct std::iter::ByRefSized\">ByRefSized</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">Like <code>Iterator::by_ref</code>, but requiring <code>Sized</code> so it can forward generics.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Intersperse.html\" title=\"struct std::iter::Intersperse\">Intersperse</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">An iterator adapter that places a separator between all elements.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.IntersperseWith.html\" title=\"struct std::iter::IntersperseWith\">IntersperseWith</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">An iterator adapter that places a separator between all elements.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.MapWindows.html\" title=\"struct std::iter::MapWindows\">MapWindows</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">An iterator over the mapped windows of another iterator.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.RepeatN.html\" title=\"struct std::iter::RepeatN\">RepeatN</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">An iterator that repeats an element an exact number of times.</div></li></ul><h2 id=\"traits\" class=\"section-header\">Traits<a href=\"#traits\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\">DoubleEndedIterator</a></div><div class=\"desc docblock-short\">An iterator able to yield elements from both ends.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.ExactSizeIterator.html\" title=\"trait std::iter::ExactSizeIterator\">ExactSizeIterator</a></div><div class=\"desc docblock-short\">An iterator that knows its exact length.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a></div><div class=\"desc docblock-short\">Extend a collection with the contents of an iterator.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a></div><div class=\"desc docblock-short\">Conversion from an <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a>.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.FusedIterator.html\" title=\"trait std::iter::FusedIterator\">FusedIterator</a></div><div class=\"desc docblock-short\">An iterator that always continues to yield <code>None</code> when exhausted.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a></div><div class=\"desc docblock-short\">Conversion into an <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a>.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a></div><div class=\"desc docblock-short\">A trait for dealing with iterators.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Product.html\" title=\"trait std::iter::Product\">Product</a></div><div class=\"desc docblock-short\">Trait to represent types that can be created by multiplying elements of an\niterator.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Sum.html\" title=\"trait std::iter::Sum\">Sum</a></div><div class=\"desc docblock-short\">Trait to represent types that can be created by summing up an iterator.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Step.html\" title=\"trait std::iter::Step\">Step</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">Objects that have a notion of <em>successor</em> and <em>predecessor</em> operations.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.TrustedLen.html\" title=\"trait std::iter::TrustedLen\">TrustedLen</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">An iterator that reports an accurate length using size_hint.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.TrustedStep.html\" title=\"trait std::iter::TrustedStep\">TrustedStep</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">A type that upholds all invariants of <a href=\"trait.Step.html\" title=\"trait std::iter::Step\"><code>Step</code></a>.</div></li></ul><h2 id=\"functions\" class=\"section-header\">Functions<a href=\"#functions\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.empty.html\" title=\"fn std::iter::empty\">empty</a></div><div class=\"desc docblock-short\">Creates an iterator that yields nothing.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.from_fn.html\" title=\"fn std::iter::from_fn\">from_fn</a></div><div class=\"desc docblock-short\">Creates a new iterator where each iteration calls the provided closure\n<code>F: FnMut() -&gt; Option&lt;T&gt;</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.once.html\" title=\"fn std::iter::once\">once</a></div><div class=\"desc docblock-short\">Creates an iterator that yields an element exactly once.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.once_with.html\" title=\"fn std::iter::once_with\">once_with</a></div><div class=\"desc docblock-short\">Creates an iterator that lazily generates a value exactly once by invoking\nthe provided closure.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.repeat.html\" title=\"fn std::iter::repeat\">repeat</a></div><div class=\"desc docblock-short\">Creates a new iterator that endlessly repeats a single element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.repeat_with.html\" title=\"fn std::iter::repeat_with\">repeat_with</a></div><div class=\"desc docblock-short\">Creates a new iterator that repeats elements of type <code>A</code> endlessly by\napplying the provided closure, the repeater, <code>F: FnMut() -&gt; A</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.successors.html\" title=\"fn std::iter::successors\">successors</a></div><div class=\"desc docblock-short\">Creates a new iterator where each successive item is computed based on the preceding one.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.zip.html\" title=\"fn std::iter::zip\">zip</a></div><div class=\"desc docblock-short\">Converts the arguments to iterators and zips them.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.chain.html\" title=\"fn std::iter::chain\">chain</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">Converts the arguments to iterators and links them together, in a chain.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.from_coroutine.html\" title=\"fn std::iter::from_coroutine\">from_coroutine</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">Creates a new iterator where each iteration calls the provided coroutine.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.repeat_n.html\" title=\"fn std::iter::repeat_n\">repeat_n</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">Creates a new iterator that repeats a single element a given number of times.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:02.270Z"
}