{
	"title": "Atomics - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/atomics.html",
	"markdown": "# Atomics - The Rustonomicon\n\nRust pretty blatantly just inherits the memory model for atomics from C++20. This is not due to this model being particularly excellent or easy to understand. Indeed, this model is quite complex and known to have [several flaws](http://plv.mpi-sws.org/c11comp/popl15.pdf). Rather, it is a pragmatic concession to the fact that _everyone_ is pretty bad at modeling atomics. At very least, we can benefit from existing tooling and research around the C/C++ memory model. (You'll often see this model referred to as \"C/C++11\" or just \"C11\". C just copies the C++ memory model; and C++11 was the first version of the model but it has received some bugfixes since then.)\n\nTrying to fully explain the model in this book is fairly hopeless. It's defined in terms of madness-inducing causality graphs that require a full book to properly understand in a practical way. If you want all the nitty-gritty details, you should check out the [C++ specification](https://en.cppreference.com/w/cpp/atomic/memory_order). Still, we'll try to cover the basics and some of the problems Rust developers face.\n\nThe C++ memory model is fundamentally about trying to bridge the gap between the semantics we want, the optimizations compilers want, and the inconsistent chaos our hardware wants. _We_ would like to just write programs and have them do exactly what we said but, you know, fast. Wouldn't that be great?\n\n## [Compiler Reordering](#compiler-reordering)\n\nCompilers fundamentally want to be able to do all sorts of complicated transformations to reduce data dependencies and eliminate dead code. In particular, they may radically change the actual order of events, or make events never occur! If we write something like:\n\n```rust\nx = 1;\ny = 3;\nx = 2;\n```\n\nThe compiler may conclude that it would be best if your program did:\n\n```rust\nx = 2;\ny = 3;\n```\n\nThis has inverted the order of events and completely eliminated one event. From a single-threaded perspective this is completely unobservable: after all the statements have executed we are in exactly the same state. But if our program is multi-threaded, we may have been relying on `x` to actually be assigned to 1 before `y` was assigned. We would like the compiler to be able to make these kinds of optimizations, because they can seriously improve performance. On the other hand, we'd also like to be able to depend on our program _doing the thing we said_.\n\n## [Hardware Reordering](#hardware-reordering)\n\nOn the other hand, even if the compiler totally understood what we wanted and respected our wishes, our hardware might instead get us in trouble. Trouble comes from CPUs in the form of memory hierarchies. There is indeed a global shared memory space somewhere in your hardware, but from the perspective of each CPU core it is _so very far away_ and _so very slow_. Each CPU would rather work with its local cache of the data and only go through all the anguish of talking to shared memory only when it doesn't actually have that memory in cache.\n\nAfter all, that's the whole point of the cache, right? If every read from the cache had to run back to shared memory to double check that it hadn't changed, what would the point be? The end result is that the hardware doesn't guarantee that events that occur in some order on _one_ thread, occur in the same order on _another_ thread. To guarantee this, we must issue special instructions to the CPU telling it to be a bit less smart.\n\nFor instance, say we convince the compiler to emit this logic:\n\n```text\ninitial state: x = 0, y = 1\n\nTHREAD 1        THREAD 2\ny = 3;          if x == 1 {\nx = 1;              y *= 2;\n                }\n\n```\n\nIdeally this program has 2 possible final states:\n\n-   `y = 3`: (thread 2 did the check before thread 1 completed)\n-   `y = 6`: (thread 2 did the check after thread 1 completed)\n\nHowever there's a third potential state that the hardware enables:\n\n-   `y = 2`: (thread 2 saw `x = 1`, but not `y = 3`, and then overwrote `y = 3`)\n\nIt's worth noting that different kinds of CPU provide different guarantees. It is common to separate hardware into two categories: strongly-ordered and weakly-ordered. Most notably x86/64 provides strong ordering guarantees, while ARM provides weak ordering guarantees. This has two consequences for concurrent programming:\n\n-   Asking for stronger guarantees on strongly-ordered hardware may be cheap or even free because they already provide strong guarantees unconditionally. Weaker guarantees may only yield performance wins on weakly-ordered hardware.\n    \n-   Asking for guarantees that are too weak on strongly-ordered hardware is more likely to _happen_ to work, even though your program is strictly incorrect. If possible, concurrent algorithms should be tested on weakly-ordered hardware.\n    \n\n## [Data Accesses](#data-accesses)\n\nThe C++ memory model attempts to bridge the gap by allowing us to talk about the _causality_ of our program. Generally, this is by establishing a _happens before_ relationship between parts of the program and the threads that are running them. This gives the hardware and compiler room to optimize the program more aggressively where a strict happens-before relationship isn't established, but forces them to be more careful where one is established. The way we communicate these relationships are through _data accesses_ and _atomic accesses_.\n\nData accesses are the bread-and-butter of the programming world. They are fundamentally unsynchronized and compilers are free to aggressively optimize them. In particular, data accesses are free to be reordered by the compiler on the assumption that the program is single-threaded. The hardware is also free to propagate the changes made in data accesses to other threads as lazily and inconsistently as it wants. Most critically, data accesses are how data races happen. Data accesses are very friendly to the hardware and compiler, but as we've seen they offer _awful_ semantics to try to write synchronized code with. Actually, that's too weak.\n\n**It is literally impossible to write correct synchronized code using only data accesses.**\n\nAtomic accesses are how we tell the hardware and compiler that our program is multi-threaded. Each atomic access can be marked with an _ordering_ that specifies what kind of relationship it establishes with other accesses. In practice, this boils down to telling the compiler and hardware certain things they _can't_ do. For the compiler, this largely revolves around re-ordering of instructions. For the hardware, this largely revolves around how writes are propagated to other threads. The set of orderings Rust exposes are:\n\n-   Sequentially Consistent (SeqCst)\n-   Release\n-   Acquire\n-   Relaxed\n\n(Note: We explicitly do not expose the C++ _consume_ ordering)\n\nTODO: negative reasoning vs positive reasoning? TODO: \"can't forget to synchronize\"\n\n## [Sequentially Consistent](#sequentially-consistent)\n\nSequentially Consistent is the most powerful of all, implying the restrictions of all other orderings. Intuitively, a sequentially consistent operation cannot be reordered: all accesses on one thread that happen before and after a SeqCst access stay before and after it. A data-race-free program that uses only sequentially consistent atomics and data accesses has the very nice property that there is a single global execution of the program's instructions that all threads agree on. This execution is also particularly nice to reason about: it's just an interleaving of each thread's individual executions. This does not hold if you start using the weaker atomic orderings.\n\nThe relative developer-friendliness of sequential consistency doesn't come for free. Even on strongly-ordered platforms sequential consistency involves emitting memory fences.\n\nIn practice, sequential consistency is rarely necessary for program correctness. However sequential consistency is definitely the right choice if you're not confident about the other memory orders. Having your program run a bit slower than it needs to is certainly better than it running incorrectly! It's also mechanically trivial to downgrade atomic operations to have a weaker consistency later on. Just change `SeqCst` to `Relaxed` and you're done! Of course, proving that this transformation is _correct_ is a whole other matter.\n\n## [Acquire-Release](#acquire-release)\n\nAcquire and Release are largely intended to be paired. Their names hint at their use case: they're perfectly suited for acquiring and releasing locks, and ensuring that critical sections don't overlap.\n\nIntuitively, an acquire access ensures that every access after it stays after it. However operations that occur before an acquire are free to be reordered to occur after it. Similarly, a release access ensures that every access before it stays before it. However operations that occur after a release are free to be reordered to occur before it.\n\nWhen thread A releases a location in memory and then thread B subsequently acquires _the same_ location in memory, causality is established. Every write (including non-atomic and relaxed atomic writes) that happened before A's release will be observed by B after its acquisition. However no causality is established with any other threads. Similarly, no causality is established if A and B access _different_ locations in memory.\n\nBasic use of release-acquire is therefore simple: you acquire a location of memory to begin the critical section, and then release that location to end it. For instance, a simple spinlock might look like:\n\n```rust\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::thread;\n\nfn main() {\n    let lock = Arc::new(AtomicBool::new(false)); // value answers \"am I locked?\"\n\n    // ... distribute lock to threads somehow ...\n\n    // Try to acquire the lock by setting it to true\n    while lock.compare_and_swap(false, true, Ordering::Acquire) { }\n    // broke out of the loop, so we successfully acquired the lock!\n\n    // ... scary data accesses ...\n\n    // ok we're done, release the lock\n    lock.store(false, Ordering::Release);\n}\n```\n\nOn strongly-ordered platforms most accesses have release or acquire semantics, making release and acquire often totally free. This is not the case on weakly-ordered platforms.\n\n## [Relaxed](#relaxed)\n\nRelaxed accesses are the absolute weakest. They can be freely re-ordered and provide no happens-before relationship. Still, relaxed operations are still atomic. That is, they don't count as data accesses and any read-modify-write operations done to them occur atomically. Relaxed operations are appropriate for things that you definitely want to happen, but don't particularly otherwise care about. For instance, incrementing a counter can be safely done by multiple threads using a relaxed `fetch_add` if you're not using the counter to synchronize any other accesses.\n\nThere's rarely a benefit in making an operation relaxed on strongly-ordered platforms, since they usually provide release-acquire semantics anyway. However relaxed operations can be cheaper on weakly-ordered platforms.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Atomics - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"atomics\"><a class=\"header\" href=\"#atomics\">Atomics</a></h1>\n<p>Rust pretty blatantly just inherits the memory model for atomics from C++20. This is not\ndue to this model being particularly excellent or easy to understand. Indeed,\nthis model is quite complex and known to have <a href=\"http://plv.mpi-sws.org/c11comp/popl15.pdf\">several flaws</a>.\nRather, it is a pragmatic concession to the fact that <em>everyone</em> is pretty bad\nat modeling atomics. At very least, we can benefit from existing tooling and\nresearch around the C/C++ memory model.\n(You'll often see this model referred to as \"C/C++11\" or just \"C11\". C just copies\nthe C++ memory model; and C++11 was the first version of the model but it has\nreceived some bugfixes since then.)</p>\n<p>Trying to fully explain the model in this book is fairly hopeless. It's defined\nin terms of madness-inducing causality graphs that require a full book to\nproperly understand in a practical way. If you want all the nitty-gritty\ndetails, you should check out the <a href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\">C++ specification</a>.\nStill, we'll try to cover the basics and some of the problems Rust developers\nface.</p>\n<p>The C++ memory model is fundamentally about trying to bridge the gap between the\nsemantics we want, the optimizations compilers want, and the inconsistent chaos\nour hardware wants. <em>We</em> would like to just write programs and have them do\nexactly what we said but, you know, fast. Wouldn't that be great?</p>\n<h2 id=\"compiler-reordering\"><a class=\"header\" href=\"#compiler-reordering\">Compiler Reordering</a></h2>\n<p>Compilers fundamentally want to be able to do all sorts of complicated\ntransformations to reduce data dependencies and eliminate dead code. In\nparticular, they may radically change the actual order of events, or make events\nnever occur! If we write something like:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">x = <span class=\"hljs-number\">1</span>;\ny = <span class=\"hljs-number\">3</span>;\nx = <span class=\"hljs-number\">2</span>;</code></pre>\n<p>The compiler may conclude that it would be best if your program did:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">x = <span class=\"hljs-number\">2</span>;\ny = <span class=\"hljs-number\">3</span>;</code></pre>\n<p>This has inverted the order of events and completely eliminated one event.\nFrom a single-threaded perspective this is completely unobservable: after all\nthe statements have executed we are in exactly the same state. But if our\nprogram is multi-threaded, we may have been relying on <code class=\"hljs\">x</code> to actually be\nassigned to 1 before <code class=\"hljs\">y</code> was assigned. We would like the compiler to be\nable to make these kinds of optimizations, because they can seriously improve\nperformance. On the other hand, we'd also like to be able to depend on our\nprogram <em>doing the thing we said</em>.</p>\n<h2 id=\"hardware-reordering\"><a class=\"header\" href=\"#hardware-reordering\">Hardware Reordering</a></h2>\n<p>On the other hand, even if the compiler totally understood what we wanted and\nrespected our wishes, our hardware might instead get us in trouble. Trouble\ncomes from CPUs in the form of memory hierarchies. There is indeed a global\nshared memory space somewhere in your hardware, but from the perspective of each\nCPU core it is <em>so very far away</em> and <em>so very slow</em>. Each CPU would rather work\nwith its local cache of the data and only go through all the anguish of\ntalking to shared memory only when it doesn't actually have that memory in\ncache.</p>\n<p>After all, that's the whole point of the cache, right? If every read from the\ncache had to run back to shared memory to double check that it hadn't changed,\nwhat would the point be? The end result is that the hardware doesn't guarantee\nthat events that occur in some order on <em>one</em> thread, occur in the same\norder on <em>another</em> thread. To guarantee this, we must issue special instructions\nto the CPU telling it to be a bit less smart.</p>\n<p>For instance, say we convince the compiler to emit this logic:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">initial state: x = 0, y = 1\n\nTHREAD 1        THREAD 2\ny = 3;          if x == 1 {\nx = 1;              y *= 2;\n                }\n</code></pre>\n<p>Ideally this program has 2 possible final states:</p>\n<ul>\n<li><code class=\"hljs\">y = 3</code>: (thread 2 did the check before thread 1 completed)</li>\n<li><code class=\"hljs\">y = 6</code>: (thread 2 did the check after thread 1 completed)</li>\n</ul>\n<p>However there's a third potential state that the hardware enables:</p>\n<ul>\n<li><code class=\"hljs\">y = 2</code>: (thread 2 saw <code class=\"hljs\">x = 1</code>, but not <code class=\"hljs\">y = 3</code>, and then overwrote <code class=\"hljs\">y = 3</code>)</li>\n</ul>\n<p>It's worth noting that different kinds of CPU provide different guarantees. It\nis common to separate hardware into two categories: strongly-ordered and weakly-ordered.\nMost notably x86/64 provides strong ordering guarantees, while ARM\nprovides weak ordering guarantees. This has two consequences for concurrent\nprogramming:</p>\n<ul>\n<li>\n<p>Asking for stronger guarantees on strongly-ordered hardware may be cheap or\neven free because they already provide strong guarantees unconditionally.\nWeaker guarantees may only yield performance wins on weakly-ordered hardware.</p>\n</li>\n<li>\n<p>Asking for guarantees that are too weak on strongly-ordered hardware is\nmore likely to <em>happen</em> to work, even though your program is strictly\nincorrect. If possible, concurrent algorithms should be tested on\nweakly-ordered hardware.</p>\n</li>\n</ul>\n<h2 id=\"data-accesses\"><a class=\"header\" href=\"#data-accesses\">Data Accesses</a></h2>\n<p>The C++ memory model attempts to bridge the gap by allowing us to talk about the\n<em>causality</em> of our program. Generally, this is by establishing a <em>happens\nbefore</em> relationship between parts of the program and the threads that are\nrunning them. This gives the hardware and compiler room to optimize the program\nmore aggressively where a strict happens-before relationship isn't established,\nbut forces them to be more careful where one is established. The way we\ncommunicate these relationships are through <em>data accesses</em> and <em>atomic\naccesses</em>.</p>\n<p>Data accesses are the bread-and-butter of the programming world. They are\nfundamentally unsynchronized and compilers are free to aggressively optimize\nthem. In particular, data accesses are free to be reordered by the compiler on\nthe assumption that the program is single-threaded. The hardware is also free to\npropagate the changes made in data accesses to other threads as lazily and\ninconsistently as it wants. Most critically, data accesses are how data races\nhappen. Data accesses are very friendly to the hardware and compiler, but as\nwe've seen they offer <em>awful</em> semantics to try to write synchronized code with.\nActually, that's too weak.</p>\n<p><strong>It is literally impossible to write correct synchronized code using only data\naccesses.</strong></p>\n<p>Atomic accesses are how we tell the hardware and compiler that our program is\nmulti-threaded. Each atomic access can be marked with an <em>ordering</em> that\nspecifies what kind of relationship it establishes with other accesses. In\npractice, this boils down to telling the compiler and hardware certain things\nthey <em>can't</em> do. For the compiler, this largely revolves around re-ordering of\ninstructions. For the hardware, this largely revolves around how writes are\npropagated to other threads. The set of orderings Rust exposes are:</p>\n<ul>\n<li>Sequentially Consistent (SeqCst)</li>\n<li>Release</li>\n<li>Acquire</li>\n<li>Relaxed</li>\n</ul>\n<p>(Note: We explicitly do not expose the C++ <em>consume</em> ordering)</p>\n<p>TODO: negative reasoning vs positive reasoning? TODO: \"can't forget to\nsynchronize\"</p>\n<h2 id=\"sequentially-consistent\"><a class=\"header\" href=\"#sequentially-consistent\">Sequentially Consistent</a></h2>\n<p>Sequentially Consistent is the most powerful of all, implying the restrictions\nof all other orderings. Intuitively, a sequentially consistent operation\ncannot be reordered: all accesses on one thread that happen before and after a\nSeqCst access stay before and after it. A data-race-free program that uses\nonly sequentially consistent atomics and data accesses has the very nice\nproperty that there is a single global execution of the program's instructions\nthat all threads agree on. This execution is also particularly nice to reason\nabout: it's just an interleaving of each thread's individual executions. This\ndoes not hold if you start using the weaker atomic orderings.</p>\n<p>The relative developer-friendliness of sequential consistency doesn't come for\nfree. Even on strongly-ordered platforms sequential consistency involves\nemitting memory fences.</p>\n<p>In practice, sequential consistency is rarely necessary for program correctness.\nHowever sequential consistency is definitely the right choice if you're not\nconfident about the other memory orders. Having your program run a bit slower\nthan it needs to is certainly better than it running incorrectly! It's also\nmechanically trivial to downgrade atomic operations to have a weaker\nconsistency later on. Just change <code class=\"hljs\">SeqCst</code> to <code class=\"hljs\">Relaxed</code> and you're done! Of\ncourse, proving that this transformation is <em>correct</em> is a whole other matter.</p>\n<h2 id=\"acquire-release\"><a class=\"header\" href=\"#acquire-release\">Acquire-Release</a></h2>\n<p>Acquire and Release are largely intended to be paired. Their names hint at their\nuse case: they're perfectly suited for acquiring and releasing locks, and\nensuring that critical sections don't overlap.</p>\n<p>Intuitively, an acquire access ensures that every access after it stays after\nit. However operations that occur before an acquire are free to be reordered to\noccur after it. Similarly, a release access ensures that every access before it\nstays before it. However operations that occur after a release are free to be\nreordered to occur before it.</p>\n<p>When thread A releases a location in memory and then thread B subsequently\nacquires <em>the same</em> location in memory, causality is established. Every write\n(including non-atomic and relaxed atomic writes) that happened before A's\nrelease will be observed by B after its acquisition. However no causality is\nestablished with any other threads. Similarly, no causality is established\nif A and B access <em>different</em> locations in memory.</p>\n<p>Basic use of release-acquire is therefore simple: you acquire a location of\nmemory to begin the critical section, and then release that location to end it.\nFor instance, a simple spinlock might look like:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-keyword\">use</span> std::sync::Arc;\n<span class=\"hljs-keyword\">use</span> std::sync::atomic::{AtomicBool, Ordering};\n<span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> lock = Arc::new(AtomicBool::new(<span class=\"hljs-literal\">false</span>)); <span class=\"hljs-comment\">// value answers \"am I locked?\"</span>\n\n    <span class=\"hljs-comment\">// ... distribute lock to threads somehow ...</span>\n\n    <span class=\"hljs-comment\">// Try to acquire the lock by setting it to true</span>\n    <span class=\"hljs-keyword\">while</span> lock.compare_and_swap(<span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">true</span>, Ordering::Acquire) { }\n    <span class=\"hljs-comment\">// broke out of the loop, so we successfully acquired the lock!</span>\n\n    <span class=\"hljs-comment\">// ... scary data accesses ...</span>\n\n    <span class=\"hljs-comment\">// ok we're done, release the lock</span>\n    lock.store(<span class=\"hljs-literal\">false</span>, Ordering::Release);\n}</code></pre></pre>\n<p>On strongly-ordered platforms most accesses have release or acquire semantics,\nmaking release and acquire often totally free. This is not the case on\nweakly-ordered platforms.</p>\n<h2 id=\"relaxed\"><a class=\"header\" href=\"#relaxed\">Relaxed</a></h2>\n<p>Relaxed accesses are the absolute weakest. They can be freely re-ordered and\nprovide no happens-before relationship. Still, relaxed operations are still\natomic. That is, they don't count as data accesses and any read-modify-write\noperations done to them occur atomically. Relaxed operations are appropriate for\nthings that you definitely want to happen, but don't particularly otherwise care\nabout. For instance, incrementing a counter can be safely done by multiple\nthreads using a relaxed <code class=\"hljs\">fetch_add</code> if you're not using the counter to\nsynchronize any other accesses.</p>\n<p>There's rarely a benefit in making an operation relaxed on strongly-ordered\nplatforms, since they usually provide release-acquire semantics anyway. However\nrelaxed operations can be cheaper on weakly-ordered platforms.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"send-and-sync.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"vec/vec.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"send-and-sync.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"vec/vec.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:09.326Z"
}