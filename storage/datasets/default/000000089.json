{
	"title": "Unsafe Rust - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html",
	"markdown": "# Unsafe Rust - The Rust Programming Language\n\nAll the code we’ve discussed so far has had Rust’s memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn’t enforce these memory safety guarantees: it’s called _unsafe Rust_ and works just like regular Rust, but gives us extra superpowers.\n\nUnsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it’s better for it to reject some valid programs than to accept some invalid programs. Although the code _might_ be okay, if the Rust compiler doesn’t have enough information to be confident, it will reject the code. In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what I’m doing.” Be warned, however, that you use unsafe Rust at your own risk: if you use unsafe code incorrectly, problems can occur due to memory unsafety, such as null pointer dereferencing.\n\nAnother reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you couldn’t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let’s explore what we can do with unsafe Rust and how to do it.\n\n### [Unsafe Superpowers](#unsafe-superpowers)\n\nTo switch to unsafe Rust, use the `unsafe` keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust that you can’t in safe Rust, which we call _unsafe superpowers_. Those superpowers include the ability to:\n\n-   Dereference a raw pointer\n-   Call an unsafe function or method\n-   Access or modify a mutable static variable\n-   Implement an unsafe trait\n-   Access fields of a `union`\n\nIt’s important to understand that `unsafe` doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked. The `unsafe` keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You’ll still get some degree of safety inside of an unsafe block.\n\nIn addition, `unsafe` does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you’ll ensure the code inside an `unsafe` block will access memory in a valid way.\n\nPeople are fallible, and mistakes will happen, but by requiring these five unsafe operations to be inside blocks annotated with `unsafe` you’ll know that any errors related to memory safety must be within an `unsafe` block. Keep `unsafe` blocks small; you’ll be thankful later when you investigate memory bugs.\n\nTo isolate unsafe code as much as possible, it’s best to enclose unsafe code within a safe abstraction and provide a safe API, which we’ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe` from leaking out into all the places that you or your users might want to use the functionality implemented with `unsafe` code, because using a safe abstraction is safe.\n\nLet’s look at each of the five unsafe superpowers in turn. We’ll also look at some abstractions that provide a safe interface to unsafe code.\n\n### [Dereferencing a Raw Pointer](#dereferencing-a-raw-pointer)\n\nIn Chapter 4, in the [“Dangling References”](about:blank/ch04-02-references-and-borrowing.html#dangling-references) section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called _raw pointers_ that are similar to references. As with references, raw pointers can be immutable or mutable and are written as `*const T` and `*mut T`, respectively. The asterisk isn’t the dereference operator; it’s part of the type name. In the context of raw pointers, _immutable_ means that the pointer can’t be directly assigned to after being dereferenced.\n\nDifferent from references and smart pointers, raw pointers:\n\n-   Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location\n-   Aren’t guaranteed to point to valid memory\n-   Are allowed to be null\n-   Don’t implement any automatic cleanup\n\nBy opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust’s guarantees don’t apply.\n\nListing 19-1 shows how to create an immutable and a mutable raw pointer from references.\n\n```rust\nfn main() {\n    let mut num = 5;\n\n    let r1 = &num as *const i32;\n    let r2 = &mut num as *mut i32;\n}\n```\n\nListing 19-1: Creating raw pointers from references\n\nNotice that we don’t include the `unsafe` keyword in this code. We can create raw pointers in safe code; we just can’t dereference raw pointers outside an unsafe block, as you’ll see in a bit.\n\nWe’ve created raw pointers by using `as` to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can’t make that assumption about just any raw pointer.\n\nTo demonstrate this, next we’ll create a raw pointer whose validity we can’t be so certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. Usually, there is no good reason to write code like this, but it is possible.\n\n```rust\nfn main() {\n    let address = 0x012345usize;\n    let r = address as *const i32;\n}\n```\n\nListing 19-2: Creating a raw pointer to an arbitrary memory address\n\nRecall that we can create raw pointers in safe code, but we can’t _dereference_ raw pointers and read the data being pointed to. In Listing 19-3, we use the dereference operator `*` on a raw pointer that requires an `unsafe` block.\n\n```rust\nfn main() {\n    let mut num = 5;\n\n    let r1 = &num as *const i32;\n    let r2 = &mut num as *mut i32;\n\n    unsafe {\n        println!(\"r1 is: {}\", *r1);\n        println!(\"r2 is: {}\", *r2);\n    }\n}\n```\n\nListing 19-3: Dereferencing raw pointers within an `unsafe` block\n\nCreating a pointer does no harm; it’s only when we try to access the value that it points at that we might end up dealing with an invalid value.\n\nNote also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut i32` raw pointers that both pointed to the same memory location, where `num` is stored. If we instead tried to create an immutable and a mutable reference to `num`, the code would not have compiled because Rust’s ownership rules don’t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!\n\nWith all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you’ll see in the next section, [“Calling an Unsafe Function or Method.”](#calling-an-unsafe-function-or-method) Another case is when building up safe abstractions that the borrow checker doesn’t understand. We’ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.\n\n### [Calling an Unsafe Function or Method](#calling-an-unsafe-function-or-method)\n\nThe second type of operation you can perform in an unsafe block is calling unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra `unsafe` before the rest of the definition. The `unsafe` keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can’t guarantee we’ve met these requirements. By calling an unsafe function within an `unsafe` block, we’re saying that we’ve read this function’s documentation and take responsibility for upholding the function’s contracts.\n\nHere is an unsafe function named `dangerous` that doesn’t do anything in its body:\n\n```rust\nfn main() {\n    unsafe fn dangerous() {}\n\n    unsafe {\n        dangerous();\n    }\n}\n```\n\nWe must call the `dangerous` function within a separate `unsafe` block. If we try to call `dangerous` without the `unsafe` block, we’ll get an error:\n\n```console\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe function or block\n --> src/main.rs:4:5\n  |\n4 |     dangerous();\n  |     ^^^^^^^^^^^ call to unsafe function\n  |\n  = note: consult the function's documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try `rustc --explain E0133`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n\n```\n\nWith the `unsafe` block, we’re asserting to Rust that we’ve read the function’s documentation, we understand how to use it properly, and we’ve verified that we’re fulfilling the contract of the function.\n\nBodies of unsafe functions are effectively `unsafe` blocks, so to perform other unsafe operations within an unsafe function, we don’t need to add another `unsafe` block.\n\n#### [Creating a Safe Abstraction over Unsafe Code](#creating-a-safe-abstraction-over-unsafe-code)\n\nJust because a function contains unsafe code doesn’t mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction. As an example, let’s study the `split_at_mut` function from the standard library, which requires some unsafe code. We’ll explore how we might implement it. This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 19-4 shows how to use `split_at_mut`.\n\n```rust\nfn main() {\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &mut v[..];\n\n    let (a, b) = r.split_at_mut(3);\n\n    assert_eq!(a, &mut [1, 2, 3]);\n    assert_eq!(b, &mut [4, 5, 6]);\n}\n```\n\nListing 19-4: Using the safe `split_at_mut` function\n\nWe can’t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won’t compile. For simplicity, we’ll implement `split_at_mut` as a function rather than a method and only for slices of `i32` values rather than for a generic type `T`.\n\n```rust\nfn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = values.len();\n\n    assert!(mid <= len);\n\n    (&mut values[..mid], &mut values[mid..])\n}\n\nfn main() {\n    let mut vector = vec![1, 2, 3, 4, 5, 6];\n    let (left, right) = split_at_mut(&mut vector, 3);\n}\n```\n\nListing 19-5: An attempted implementation of `split_at_mut` using only safe Rust\n\nThis function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it’s less than or equal to the length. The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.\n\nThen we return two mutable slices in a tuple: one from the start of the original slice to the `mid` index and another from `mid` to the end of the slice.\n\nWhen we try to compile the code in Listing 19-5, we’ll get an error.\n\n```console\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0499]: cannot borrow `*values` as mutable more than once at a time\n --> src/main.rs:6:31\n  |\n1 | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n  |                         - let's call the lifetime of this reference `'1`\n...\n6 |     (&mut values[..mid], &mut values[mid..])\n  |     --------------------------^^^^^^--------\n  |     |     |                   |\n  |     |     |                   second mutable borrow occurs here\n  |     |     first mutable borrow occurs here\n  |     returning this value requires that `*values` is borrowed for `'1`\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n\n```\n\nRust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. Borrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart enough to know this. When we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.\n\nListing 19-6 shows how to use an `unsafe` block, a raw pointer, and some calls to unsafe functions to make the implementation of `split_at_mut` work.\n\n```rust\nuse std::slice;\n\nfn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = values.len();\n    let ptr = values.as_mut_ptr();\n\n    assert!(mid <= len);\n\n    unsafe {\n        (\n            slice::from_raw_parts_mut(ptr, mid),\n            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\n\nfn main() {\n    let mut vector = vec![1, 2, 3, 4, 5, 6];\n    let (left, right) = split_at_mut(&mut vector, 3);\n}\n```\n\nListing 19-6: Using unsafe code in the implementation of the `split_at_mut` function\n\nRecall from [“The Slice Type”](about:blank/ch04-03-slices.html#the-slice-type) section in Chapter 4 that slices are a pointer to some data and the length of the slice. We use the `len` method to get the length of a slice and the `as_mut_ptr` method to access the raw pointer of a slice. In this case, because we have a mutable slice to `i32` values, `as_mut_ptr` returns a raw pointer with the type `*mut i32`, which we’ve stored in the variable `ptr`.\n\nWe keep the assertion that the `mid` index is within the slice. Then we get to the unsafe code: the `slice::from_raw_parts_mut` function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from `ptr` and is `mid` items long. Then we call the `add` method on `ptr` with `mid` as an argument to get a raw pointer that starts at `mid`, and we create a slice using that pointer and the remaining number of items after `mid` as the length.\n\nThe function `slice::from_raw_parts_mut` is unsafe because it takes a raw pointer and must trust that this pointer is valid. The `add` method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an `unsafe` block around our calls to `slice::from_raw_parts_mut` and `add` so we could call them. By looking at the code and by adding the assertion that `mid` must be less than or equal to `len`, we can tell that all the raw pointers used within the `unsafe` block will be valid pointers to data within the slice. This is an acceptable and appropriate use of `unsafe`.\n\nNote that we don’t need to mark the resulting `split_at_mut` function as `unsafe`, and we can call this function from safe Rust. We’ve created a safe abstraction to the unsafe code with an implementation of the function that uses `unsafe` code in a safe way, because it creates only valid pointers from the data this function has access to.\n\nIn contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.\n\n```rust\nfn main() {\n    use std::slice;\n\n    let address = 0x01234usize;\n    let r = address as *mut i32;\n\n    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };\n}\n```\n\nListing 19-7: Creating a slice from an arbitrary memory location\n\nWe don’t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid `i32` values. Attempting to use `values` as though it’s a valid slice results in undefined behavior.\n\n#### [Using `extern` Functions to Call External Code](#using-extern-functions-to-call-external-code)\n\nSometimes, your Rust code might need to interact with code written in another language. For this, Rust has the keyword `extern` that facilitates the creation and use of a _Foreign Function Interface (FFI)_. An FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.\n\nListing 19-8 demonstrates how to set up an integration with the `abs` function from the C standard library. Functions declared within `extern` blocks are always unsafe to call from Rust code. The reason is that other languages don’t enforce Rust’s rules and guarantees, and Rust can’t check them, so responsibility falls on the programmer to ensure safety.\n\nFilename: src/main.rs\n\n```rust\nextern \"C\" {\n    fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n```\n\nListing 19-8: Declaring and calling an `extern` function defined in another language\n\nWithin the `extern \"C\"` block, we list the names and signatures of external functions from another language we want to call. The `\"C\"` part defines which _application binary interface (ABI)_ the external function uses: the ABI defines how to call the function at the assembly level. The `\"C\"` ABI is the most common and follows the C programming language’s ABI.\n\n#### [Calling Rust Functions from Other Languages](#calling-rust-functions-from-other-languages)\n\nWe can also use `extern` to create an interface that allows other languages to call Rust functions. Instead of creating a whole `extern` block, we add the `extern` keyword and specify the ABI to use just before the `fn` keyword for the relevant function. We also need to add a `#[no_mangle]` annotation to tell the Rust compiler not to mangle the name of this function. _Mangling_ is when a compiler changes the name we’ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler’s name mangling.\n\nIn the following example, we make the `call_from_c` function accessible from C code, after it’s compiled to a shared library and linked from C:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[no_mangle]\npub extern \"C\" fn call_from_c() {\n    println!(\"Just called a Rust function from C!\");\n}\n}\n```\n\nThis usage of `extern` does not require `unsafe`.\n\n### [Accessing or Modifying a Mutable Static Variable](#accessing-or-modifying-a-mutable-static-variable)\n\nIn this book, we’ve not yet talked about _global variables_, which Rust does support but can be problematic with Rust’s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.\n\nIn Rust, global variables are called _static_ variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.\n\nFilename: src/main.rs\n\n```rust\nstatic HELLO_WORLD: &str = \"Hello, world!\";\n\nfn main() {\n    println!(\"name is: {HELLO_WORLD}\");\n}\n```\n\nListing 19-9: Defining and using an immutable static variable\n\nStatic variables are similar to constants, which we discussed in the [“Differences Between Variables and Constants”](about:blank/ch03-01-variables-and-mutability.html#constants) section in Chapter 3. The names of static variables are in `SCREAMING_SNAKE_CASE` by convention. Static variables can only store references with the `'static` lifetime, which means the Rust compiler can figure out the lifetime and we aren’t required to annotate it explicitly. Accessing an immutable static variable is safe.\n\nA subtle difference between constants and immutable static variables is that values in a static variable have a fixed address in memory. Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they’re used. Another difference is that static variables can be mutable. Accessing and modifying mutable static variables is _unsafe_. Listing 19-10 shows how to declare, access, and modify a mutable static variable named `COUNTER`.\n\nFilename: src/main.rs\n\n```rust\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    unsafe {\n        println!(\"COUNTER: {COUNTER}\");\n    }\n}\n```\n\nListing 19-10: Reading from or writing to a mutable static variable is unsafe\n\nAs with regular variables, we specify mutability using the `mut` keyword. Any code that reads or writes from `COUNTER` must be within an `unsafe` block. This code compiles and prints `COUNTER: 3` as we would expect because it’s single threaded. Having multiple threads access `COUNTER` would likely result in data races.\n\nWith mutable data that is globally accessible, it’s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it’s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.\n\n### [Implementing an Unsafe Trait](#implementing-an-unsafe-trait)\n\nWe can use `unsafe` to implement an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify. We declare that a trait is `unsafe` by adding the `unsafe` keyword before `trait` and marking the implementation of the trait as `unsafe` too, as shown in Listing 19-11.\n\n```rust\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n\nfn main() {}\n```\n\nListing 19-11: Defining and implementing an unsafe trait\n\nBy using `unsafe impl`, we’re promising that we’ll uphold the invariants that the compiler can’t verify.\n\nAs an example, recall the `Sync` and `Send` marker traits we discussed in the [“Extensible Concurrency with the `Sync` and `Send` Traits”](about:blank/ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits) section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of `Send` and `Sync` types. If we implement a type that contains a type that is not `Send` or `Sync`, such as raw pointers, and we want to mark that type as `Send` or `Sync`, we must use `unsafe`. Rust can’t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with `unsafe`.\n\n### [Accessing Fields of a Union](#accessing-fields-of-a-union)\n\nThe final action that works only with `unsafe` is accessing fields of a _union_. A `union` is similar to a `struct`, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can’t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in [the Rust Reference](../reference/items/unions.html).\n\n### [When to Use Unsafe Code](#when-to-use-unsafe-code)\n\nUsing `unsafe` to take one of the five actions (superpowers) just discussed isn’t wrong or even frowned upon. But it is trickier to get `unsafe` code correct because the compiler can’t help uphold memory safety. When you have a reason to use `unsafe` code, you can do so, and having the explicit `unsafe` annotation makes it easier to track down the source of problems when they occur.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Unsafe Rust - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"unsafe-rust\"><a class=\"header\" href=\"#unsafe-rust\">Unsafe Rust</a></h2>\n<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees\nenforced at compile time. However, Rust has a second language hidden inside it\nthat doesn’t enforce these memory safety guarantees: it’s called <em>unsafe Rust</em>\nand works just like regular Rust, but gives us extra superpowers.</p>\n<p>Unsafe Rust exists because, by nature, static analysis is conservative. When\nthe compiler tries to determine whether or not code upholds the guarantees,\nit’s better for it to reject some valid programs than to accept some invalid\nprograms. Although the code <em>might</em> be okay, if the Rust compiler doesn’t have\nenough information to be confident, it will reject the code. In these cases,\nyou can use unsafe code to tell the compiler, “Trust me, I know what I’m\ndoing.” Be warned, however, that you use unsafe Rust at your own risk: if you\nuse unsafe code incorrectly, problems can occur due to memory unsafety, such as\nnull pointer dereferencing.</p>\n<p>Another reason Rust has an unsafe alter ego is that the underlying computer\nhardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you\ncouldn’t do certain tasks. Rust needs to allow you to do low-level systems\nprogramming, such as directly interacting with the operating system or even\nwriting your own operating system. Working with low-level systems programming\nis one of the goals of the language. Let’s explore what we can do with unsafe\nRust and how to do it.</p>\n<h3 id=\"unsafe-superpowers\"><a class=\"header\" href=\"#unsafe-superpowers\">Unsafe Superpowers</a></h3>\n<p>To switch to unsafe Rust, use the <code class=\"hljs\">unsafe</code> keyword and then start a new block\nthat holds the unsafe code. You can take five actions in unsafe Rust that you\ncan’t in safe Rust, which we call <em>unsafe superpowers</em>. Those superpowers\ninclude the ability to:</p>\n<ul>\n<li>Dereference a raw pointer</li>\n<li>Call an unsafe function or method</li>\n<li>Access or modify a mutable static variable</li>\n<li>Implement an unsafe trait</li>\n<li>Access fields of a <code class=\"hljs\">union</code></li>\n</ul>\n<p>It’s important to understand that <code class=\"hljs\">unsafe</code> doesn’t turn off the borrow checker\nor disable any other of Rust’s safety checks: if you use a reference in unsafe\ncode, it will still be checked. The <code class=\"hljs\">unsafe</code> keyword only gives you access to\nthese five features that are then not checked by the compiler for memory\nsafety. You’ll still get some degree of safety inside of an unsafe block.</p>\n<p>In addition, <code class=\"hljs\">unsafe</code> does not mean the code inside the block is necessarily\ndangerous or that it will definitely have memory safety problems: the intent is\nthat as the programmer, you’ll ensure the code inside an <code class=\"hljs\">unsafe</code> block will\naccess memory in a valid way.</p>\n<p>People are fallible, and mistakes will happen, but by requiring these five\nunsafe operations to be inside blocks annotated with <code class=\"hljs\">unsafe</code> you’ll know that\nany errors related to memory safety must be within an <code class=\"hljs\">unsafe</code> block. Keep\n<code class=\"hljs\">unsafe</code> blocks small; you’ll be thankful later when you investigate memory\nbugs.</p>\n<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code\nwithin a safe abstraction and provide a safe API, which we’ll discuss later in\nthe chapter when we examine unsafe functions and methods. Parts of the standard\nlibrary are implemented as safe abstractions over unsafe code that has been\naudited. Wrapping unsafe code in a safe abstraction prevents uses of <code class=\"hljs\">unsafe</code>\nfrom leaking out into all the places that you or your users might want to use\nthe functionality implemented with <code class=\"hljs\">unsafe</code> code, because using a safe\nabstraction is safe.</p>\n<p>Let’s look at each of the five unsafe superpowers in turn. We’ll also look at\nsome abstractions that provide a safe interface to unsafe code.</p>\n<h3 id=\"dereferencing-a-raw-pointer\"><a class=\"header\" href=\"#dereferencing-a-raw-pointer\">Dereferencing a Raw Pointer</a></h3>\n<p>In Chapter 4, in the <a href=\"ch04-02-references-and-borrowing.html#dangling-references\">“Dangling References”</a><!-- ignore\n--> section, we mentioned that the compiler ensures references are always\nvalid. Unsafe Rust has two new types called <em>raw pointers</em> that are similar to\nreferences. As with references, raw pointers can be immutable or mutable and\nare written as <code class=\"hljs\">*const T</code> and <code class=\"hljs\">*mut T</code>, respectively. The asterisk isn’t the\ndereference operator; it’s part of the type name. In the context of raw\npointers, <em>immutable</em> means that the pointer can’t be directly assigned to\nafter being dereferenced.</p>\n<p>Different from references and smart pointers, raw pointers:</p>\n<ul>\n<li>Are allowed to ignore the borrowing rules by having both immutable and\nmutable pointers or multiple mutable pointers to the same location</li>\n<li>Aren’t guaranteed to point to valid memory</li>\n<li>Are allowed to be null</li>\n<li>Don’t implement any automatic cleanup</li>\n</ul>\n<p>By opting out of having Rust enforce these guarantees, you can give up\nguaranteed safety in exchange for greater performance or the ability to\ninterface with another language or hardware where Rust’s guarantees don’t apply.</p>\n<p>Listing 19-1 shows how to create an immutable and a mutable raw pointer from\nreferences.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> num = <span class=\"hljs-number\">5</span>;\n\n    <span class=\"hljs-keyword\">let</span> r1 = &amp;num <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">i32</span>;\n    <span class=\"hljs-keyword\">let</span> r2 = &amp;<span class=\"hljs-keyword\">mut</span> num <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>;\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 19-1: Creating raw pointers from references</span></p>\n<p>Notice that we don’t include the <code class=\"hljs\">unsafe</code> keyword in this code. We can create\nraw pointers in safe code; we just can’t dereference raw pointers outside an\nunsafe block, as you’ll see in a bit.</p>\n<p>We’ve created raw pointers by using <code class=\"hljs\">as</code> to cast an immutable and a mutable\nreference into their corresponding raw pointer types. Because we created them\ndirectly from references guaranteed to be valid, we know these particular raw\npointers are valid, but we can’t make that assumption about just any raw\npointer.</p>\n<p>To demonstrate this, next we’ll create a raw pointer whose validity we can’t be\nso certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary\nlocation in memory. Trying to use arbitrary memory is undefined: there might be\ndata at that address or there might not, the compiler might optimize the code\nso there is no memory access, or the program might error with a segmentation\nfault. Usually, there is no good reason to write code like this, but it is\npossible.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> address = <span class=\"hljs-number\">0x012345usize</span>;\n    <span class=\"hljs-keyword\">let</span> r = address <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">i32</span>;\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 19-2: Creating a raw pointer to an arbitrary\nmemory address</span></p>\n<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em>\nraw pointers and read the data being pointed to. In Listing 19-3, we use the\ndereference operator <code class=\"hljs\">*</code> on a raw pointer that requires an <code class=\"hljs\">unsafe</code> block.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> num = <span class=\"hljs-number\">5</span>;\n\n    <span class=\"hljs-keyword\">let</span> r1 = &amp;num <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">i32</span>;\n    <span class=\"hljs-keyword\">let</span> r2 = &amp;<span class=\"hljs-keyword\">mut</span> num <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>;\n\n    <span class=\"hljs-keyword\">unsafe</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"r1 is: {}\"</span>, *r1);\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"r2 is: {}\"</span>, *r2);\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 19-3: Dereferencing raw pointers within an\n<code class=\"hljs\">unsafe</code> block</span></p>\n<p>Creating a pointer does no harm; it’s only when we try to access the value that\nit points at that we might end up dealing with an invalid value.</p>\n<p>Note also that in Listing 19-1 and 19-3, we created <code class=\"hljs\">*const i32</code> and <code class=\"hljs\">*mut i32</code>\nraw pointers that both pointed to the same memory location, where <code class=\"hljs\">num</code> is\nstored. If we instead tried to create an immutable and a mutable reference to\n<code class=\"hljs\">num</code>, the code would not have compiled because Rust’s ownership rules don’t\nallow a mutable reference at the same time as any immutable references. With\nraw pointers, we can create a mutable pointer and an immutable pointer to the\nsame location and change data through the mutable pointer, potentially creating\na data race. Be careful!</p>\n<p>With all of these dangers, why would you ever use raw pointers? One major use\ncase is when interfacing with C code, as you’ll see in the next section,\n<a href=\"#calling-an-unsafe-function-or-method\">“Calling an Unsafe Function or\nMethod.”</a><!-- ignore --> Another case is\nwhen building up safe abstractions that the borrow checker doesn’t understand.\nWe’ll introduce unsafe functions and then look at an example of a safe\nabstraction that uses unsafe code.</p>\n<h3 id=\"calling-an-unsafe-function-or-method\"><a class=\"header\" href=\"#calling-an-unsafe-function-or-method\">Calling an Unsafe Function or Method</a></h3>\n<p>The second type of operation you can perform in an unsafe block is calling\nunsafe functions. Unsafe functions and methods look exactly like regular\nfunctions and methods, but they have an extra <code class=\"hljs\">unsafe</code> before the rest of the\ndefinition. The <code class=\"hljs\">unsafe</code> keyword in this context indicates the function has\nrequirements we need to uphold when we call this function, because Rust can’t\nguarantee we’ve met these requirements. By calling an unsafe function within an\n<code class=\"hljs\">unsafe</code> block, we’re saying that we’ve read this function’s documentation and\ntake responsibility for upholding the function’s contracts.</p>\n<p>Here is an unsafe function named <code class=\"hljs\">dangerous</code> that doesn’t do anything in its\nbody:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">dangerous</span></span>() {}\n\n    <span class=\"hljs-keyword\">unsafe</span> {\n        dangerous();\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p>We must call the <code class=\"hljs\">dangerous</code> function within a separate <code class=\"hljs\">unsafe</code> block. If we\ntry to call <code class=\"hljs\">dangerous</code> without the <code class=\"hljs\">unsafe</code> block, we’ll get an error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe function or block\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:4:5</span>\n  |\n4 |     dangerous();\n  |     ^^^^^^^^^^^ call to unsafe function\n  |\n  = note: consult the function's documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try `rustc --explain E0133`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n</code></pre>\n<p>With the <code class=\"hljs\">unsafe</code> block, we’re asserting to Rust that we’ve read the function’s\ndocumentation, we understand how to use it properly, and we’ve verified that\nwe’re fulfilling the contract of the function.</p>\n<p>Bodies of unsafe functions are effectively <code class=\"hljs\">unsafe</code> blocks, so to perform other\nunsafe operations within an unsafe function, we don’t need to add another\n<code class=\"hljs\">unsafe</code> block.</p>\n<h4 id=\"creating-a-safe-abstraction-over-unsafe-code\"><a class=\"header\" href=\"#creating-a-safe-abstraction-over-unsafe-code\">Creating a Safe Abstraction over Unsafe Code</a></h4>\n<p>Just because a function contains unsafe code doesn’t mean we need to mark the\nentire function as unsafe. In fact, wrapping unsafe code in a safe function is\na common abstraction. As an example, let’s study the <code class=\"hljs\">split_at_mut</code> function\nfrom the standard library, which requires some unsafe code. We’ll explore how\nwe might implement it. This safe method is defined on mutable slices: it takes\none slice and makes it two by splitting the slice at the index given as an\nargument. Listing 19-4 shows how to use <code class=\"hljs\">split_at_mut</code>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> v = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];\n\n    <span class=\"hljs-keyword\">let</span> r = &amp;<span class=\"hljs-keyword\">mut</span> v[..];\n\n    <span class=\"hljs-keyword\">let</span> (a, b) = r.split_at_mut(<span class=\"hljs-number\">3</span>);\n\n    <span class=\"hljs-built_in\">assert_eq!</span>(a, &amp;<span class=\"hljs-keyword\">mut</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);\n    <span class=\"hljs-built_in\">assert_eq!</span>(b, &amp;<span class=\"hljs-keyword\">mut</span> [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>]);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 19-4: Using the safe <code class=\"hljs\">split_at_mut</code>\nfunction</span></p>\n<p>We can’t implement this function using only safe Rust. An attempt might look\nsomething like Listing 19-5, which won’t compile. For simplicity, we’ll\nimplement <code class=\"hljs\">split_at_mut</code> as a function rather than a method and only for slices\nof <code class=\"hljs\">i32</code> values rather than for a generic type <code class=\"hljs\">T</code>.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">split_at_mut</span></span>(values: &amp;<span class=\"hljs-keyword\">mut</span> [<span class=\"hljs-built_in\">i32</span>], mid: <span class=\"hljs-built_in\">usize</span>) -&gt; (&amp;<span class=\"hljs-keyword\">mut</span> [<span class=\"hljs-built_in\">i32</span>], &amp;<span class=\"hljs-keyword\">mut</span> [<span class=\"hljs-built_in\">i32</span>]) {\n    <span class=\"hljs-keyword\">let</span> len = values.len();\n\n    <span class=\"hljs-built_in\">assert!</span>(mid &lt;= len);\n\n    (&amp;<span class=\"hljs-keyword\">mut</span> values[..mid], &amp;<span class=\"hljs-keyword\">mut</span> values[mid..])\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> vector = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> (left, right) = split_at_mut(&amp;<span class=\"hljs-keyword\">mut</span> vector, <span class=\"hljs-number\">3</span>);\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 19-5: An attempted implementation of\n<code class=\"hljs\">split_at_mut</code> using only safe Rust</span></p>\n<p>This function first gets the total length of the slice. Then it asserts that\nthe index given as a parameter is within the slice by checking whether it’s\nless than or equal to the length. The assertion means that if we pass an index\nthat is greater than the length to split the slice at, the function will panic\nbefore it attempts to use that index.</p>\n<p>Then we return two mutable slices in a tuple: one from the start of the\noriginal slice to the <code class=\"hljs\">mid</code> index and another from <code class=\"hljs\">mid</code> to the end of the\nslice.</p>\n<p>When we try to compile the code in Listing 19-5, we’ll get an error.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0499]: cannot borrow `*values` as mutable more than once at a time\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:6:31</span>\n  |\n1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {\n  |                         - let's call the lifetime of this reference `'1`\n...\n6 |     (&amp;mut values[..mid], &amp;mut values[mid..])\n  |     --------------------------^^^^^^--------\n  |     |     |                   |\n  |     |     |                   second mutable borrow occurs here\n  |     |     first mutable borrow occurs here\n  |     returning this value requires that `*values` is borrowed for `'1`\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n</code></pre>\n<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of\nthe slice; it only knows that we’re borrowing from the same slice twice.\nBorrowing different parts of a slice is fundamentally okay because the two\nslices aren’t overlapping, but Rust isn’t smart enough to know this. When we\nknow code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>\n<p>Listing 19-6 shows how to use an <code class=\"hljs\">unsafe</code> block, a raw pointer, and some calls\nto unsafe functions to make the implementation of <code class=\"hljs\">split_at_mut</code> work.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::slice;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">split_at_mut</span></span>(values: &amp;<span class=\"hljs-keyword\">mut</span> [<span class=\"hljs-built_in\">i32</span>], mid: <span class=\"hljs-built_in\">usize</span>) -&gt; (&amp;<span class=\"hljs-keyword\">mut</span> [<span class=\"hljs-built_in\">i32</span>], &amp;<span class=\"hljs-keyword\">mut</span> [<span class=\"hljs-built_in\">i32</span>]) {\n    <span class=\"hljs-keyword\">let</span> len = values.len();\n    <span class=\"hljs-keyword\">let</span> ptr = values.as_mut_ptr();\n\n    <span class=\"hljs-built_in\">assert!</span>(mid &lt;= len);\n\n    <span class=\"hljs-keyword\">unsafe</span> {\n        (\n            slice::from_raw_parts_mut(ptr, mid),\n            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> vector = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> (left, right) = split_at_mut(&amp;<span class=\"hljs-keyword\">mut</span> vector, <span class=\"hljs-number\">3</span>);\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 19-6: Using unsafe code in the implementation of\nthe <code class=\"hljs\">split_at_mut</code> function</span></p>\n<p>Recall from <a href=\"ch04-03-slices.html#the-slice-type\">“The Slice Type”</a><!-- ignore --> section in\nChapter 4 that slices are a pointer to some data and the length of the slice.\nWe use the <code class=\"hljs\">len</code> method to get the length of a slice and the <code class=\"hljs\">as_mut_ptr</code>\nmethod to access the raw pointer of a slice. In this case, because we have a\nmutable slice to <code class=\"hljs\">i32</code> values, <code class=\"hljs\">as_mut_ptr</code> returns a raw pointer with the type\n<code class=\"hljs\">*mut i32</code>, which we’ve stored in the variable <code class=\"hljs\">ptr</code>.</p>\n<p>We keep the assertion that the <code class=\"hljs\">mid</code> index is within the slice. Then we get to\nthe unsafe code: the <code class=\"hljs\">slice::from_raw_parts_mut</code> function takes a raw pointer\nand a length, and it creates a slice. We use this function to create a slice\nthat starts from <code class=\"hljs\">ptr</code> and is <code class=\"hljs\">mid</code> items long. Then we call the <code class=\"hljs\">add</code>\nmethod on <code class=\"hljs\">ptr</code> with <code class=\"hljs\">mid</code> as an argument to get a raw pointer that starts at\n<code class=\"hljs\">mid</code>, and we create a slice using that pointer and the remaining number of\nitems after <code class=\"hljs\">mid</code> as the length.</p>\n<p>The function <code class=\"hljs\">slice::from_raw_parts_mut</code> is unsafe because it takes a raw\npointer and must trust that this pointer is valid. The <code class=\"hljs\">add</code> method on raw\npointers is also unsafe, because it must trust that the offset location is also\na valid pointer. Therefore, we had to put an <code class=\"hljs\">unsafe</code> block around our calls to\n<code class=\"hljs\">slice::from_raw_parts_mut</code> and <code class=\"hljs\">add</code> so we could call them. By looking at\nthe code and by adding the assertion that <code class=\"hljs\">mid</code> must be less than or equal to\n<code class=\"hljs\">len</code>, we can tell that all the raw pointers used within the <code class=\"hljs\">unsafe</code> block\nwill be valid pointers to data within the slice. This is an acceptable and\nappropriate use of <code class=\"hljs\">unsafe</code>.</p>\n<p>Note that we don’t need to mark the resulting <code class=\"hljs\">split_at_mut</code> function as\n<code class=\"hljs\">unsafe</code>, and we can call this function from safe Rust. We’ve created a safe\nabstraction to the unsafe code with an implementation of the function that uses\n<code class=\"hljs\">unsafe</code> code in a safe way, because it creates only valid pointers from the\ndata this function has access to.</p>\n<p>In contrast, the use of <code class=\"hljs\">slice::from_raw_parts_mut</code> in Listing 19-7 would\nlikely crash when the slice is used. This code takes an arbitrary memory\nlocation and creates a slice 10,000 items long.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">use</span> std::slice;\n\n    <span class=\"hljs-keyword\">let</span> address = <span class=\"hljs-number\">0x01234usize</span>;\n    <span class=\"hljs-keyword\">let</span> r = address <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>;\n\n    <span class=\"hljs-keyword\">let</span> values: &amp;[<span class=\"hljs-built_in\">i32</span>] = <span class=\"hljs-keyword\">unsafe</span> { slice::from_raw_parts_mut(r, <span class=\"hljs-number\">10000</span>) };\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 19-7: Creating a slice from an arbitrary memory\nlocation</span></p>\n<p>We don’t own the memory at this arbitrary location, and there is no guarantee\nthat the slice this code creates contains valid <code class=\"hljs\">i32</code> values. Attempting to use\n<code class=\"hljs\">values</code> as though it’s a valid slice results in undefined behavior.</p>\n<h4 id=\"using-extern-functions-to-call-external-code\"><a class=\"header\" href=\"#using-extern-functions-to-call-external-code\">Using <code>extern</code> Functions to Call External Code</a></h4>\n<p>Sometimes, your Rust code might need to interact with code written in another\nlanguage. For this, Rust has the keyword <code class=\"hljs\">extern</code> that facilitates the creation\nand use of a <em>Foreign Function Interface (FFI)</em>. An FFI is a way for a\nprogramming language to define functions and enable a different (foreign)\nprogramming language to call those functions.</p>\n<p>Listing 19-8 demonstrates how to set up an integration with the <code class=\"hljs\">abs</code> function\nfrom the C standard library. Functions declared within <code class=\"hljs\">extern</code> blocks are\nalways unsafe to call from Rust code. The reason is that other languages don’t\nenforce Rust’s rules and guarantees, and Rust can’t check them, so\nresponsibility falls on the programmer to ensure safety.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">abs</span></span>(input: <span class=\"hljs-built_in\">i32</span>) -&gt; <span class=\"hljs-built_in\">i32</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">unsafe</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Absolute value of -3 according to C: {}\"</span>, abs(-<span class=\"hljs-number\">3</span>));\n    }\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-8: Declaring and calling an <code class=\"hljs\">extern</code> function\ndefined in another language</span></p>\n<p>Within the <code class=\"hljs\">extern \"C\"</code> block, we list the names and signatures of external\nfunctions from another language we want to call. The <code class=\"hljs\">\"C\"</code> part defines which\n<em>application binary interface (ABI)</em> the external function uses: the ABI\ndefines how to call the function at the assembly level. The <code class=\"hljs\">\"C\"</code> ABI is the\nmost common and follows the C programming language’s ABI.</p>\n<section class=\"note\" aria-role=\"note\">\n<h4 id=\"calling-rust-functions-from-other-languages\"><a class=\"header\" href=\"#calling-rust-functions-from-other-languages\">Calling Rust Functions from Other Languages</a></h4>\n<p>We can also use <code class=\"hljs\">extern</code> to create an interface that allows other languages\nto call Rust functions. Instead of creating a whole <code class=\"hljs\">extern</code> block, we add\nthe <code class=\"hljs\">extern</code> keyword and specify the ABI to use just before the <code class=\"hljs\">fn</code> keyword\nfor the relevant function. We also need to add a <code class=\"hljs\">#[no_mangle]</code> annotation to\ntell the Rust compiler not to mangle the name of this function. <em>Mangling</em> is\nwhen a compiler changes the name we’ve given a function to a different name\nthat contains more information for other parts of the compilation process to\nconsume but is less human readable. Every programming language compiler\nmangles names slightly differently, so for a Rust function to be nameable by\nother languages, we must disable the Rust compiler’s name mangling.</p>\n<p>In the following example, we make the <code class=\"hljs\">call_from_c</code> function accessible from\nC code, after it’s compiled to a shared library and linked from C:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[no_mangle]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">call_from_c</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Just called a Rust function from C!\"</span>);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This usage of <code class=\"hljs\">extern</code> does not require <code class=\"hljs\">unsafe</code>.</p>\n</section>\n<h3 id=\"accessing-or-modifying-a-mutable-static-variable\"><a class=\"header\" href=\"#accessing-or-modifying-a-mutable-static-variable\">Accessing or Modifying a Mutable Static Variable</a></h3>\n<p>In this book, we’ve not yet talked about <em>global variables</em>, which Rust does\nsupport but can be problematic with Rust’s ownership rules. If two threads are\naccessing the same mutable global variable, it can cause a data race.</p>\n<p>In Rust, global variables are called <em>static</em> variables. Listing 19-9 shows an\nexample declaration and use of a static variable with a string slice as a\nvalue.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">static</span> HELLO_WORLD: &amp;<span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"Hello, world!\"</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"name is: {HELLO_WORLD}\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-9: Defining and using an immutable static\nvariable</span></p>\n<p>Static variables are similar to constants, which we discussed in the\n<a href=\"ch03-01-variables-and-mutability.html#constants\">“Differences Between Variables and\nConstants”</a><!-- ignore --> section\nin Chapter 3. The names of static variables are in <code class=\"hljs\">SCREAMING_SNAKE_CASE</code> by\nconvention. Static variables can only store references with the <code class=\"hljs\">'static</code>\nlifetime, which means the Rust compiler can figure out the lifetime and we\naren’t required to annotate it explicitly. Accessing an immutable static\nvariable is safe.</p>\n<p>A subtle difference between constants and immutable static variables is that\nvalues in a static variable have a fixed address in memory. Using the value\nwill always access the same data. Constants, on the other hand, are allowed to\nduplicate their data whenever they’re used. Another difference is that static\nvariables can be mutable. Accessing and modifying mutable static variables is\n<em>unsafe</em>. Listing 19-10 shows how to declare, access, and modify a mutable\nstatic variable named <code class=\"hljs\">COUNTER</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">mut</span> COUNTER: <span class=\"hljs-built_in\">u32</span> = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add_to_count</span></span>(inc: <span class=\"hljs-built_in\">u32</span>) {\n    <span class=\"hljs-keyword\">unsafe</span> {\n        COUNTER += inc;\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    add_to_count(<span class=\"hljs-number\">3</span>);\n\n    <span class=\"hljs-keyword\">unsafe</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"COUNTER: {COUNTER}\"</span>);\n    }\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-10: Reading from or writing to a mutable\nstatic variable is unsafe</span></p>\n<p>As with regular variables, we specify mutability using the <code class=\"hljs\">mut</code> keyword. Any\ncode that reads or writes from <code class=\"hljs\">COUNTER</code> must be within an <code class=\"hljs\">unsafe</code> block. This\ncode compiles and prints <code class=\"hljs\">COUNTER: 3</code> as we would expect because it’s single\nthreaded. Having multiple threads access <code class=\"hljs\">COUNTER</code> would likely result in data\nraces.</p>\n<p>With mutable data that is globally accessible, it’s difficult to ensure there\nare no data races, which is why Rust considers mutable static variables to be\nunsafe. Where possible, it’s preferable to use the concurrency techniques and\nthread-safe smart pointers we discussed in Chapter 16 so the compiler checks\nthat data accessed from different threads is done safely.</p>\n<h3 id=\"implementing-an-unsafe-trait\"><a class=\"header\" href=\"#implementing-an-unsafe-trait\">Implementing an Unsafe Trait</a></h3>\n<p>We can use <code class=\"hljs\">unsafe</code> to implement an unsafe trait. A trait is unsafe when at\nleast one of its methods has some invariant that the compiler can’t verify. We\ndeclare that a trait is <code class=\"hljs\">unsafe</code> by adding the <code class=\"hljs\">unsafe</code> keyword before <code class=\"hljs\">trait</code>\nand marking the implementation of the trait as <code class=\"hljs\">unsafe</code> too, as shown in\nListing 19-11.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-comment\">// methods go here</span>\n}\n\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span> Foo <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">i32</span> {\n    <span class=\"hljs-comment\">// method implementations go here</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</code></pre></pre>\n<p><span class=\"caption\">Listing 19-11: Defining and implementing an unsafe\ntrait</span></p>\n<p>By using <code class=\"hljs\">unsafe impl</code>, we’re promising that we’ll uphold the invariants that\nthe compiler can’t verify.</p>\n<p>As an example, recall the <code class=\"hljs\">Sync</code> and <code class=\"hljs\">Send</code> marker traits we discussed in the\n<a href=\"ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits\">“Extensible Concurrency with the <code class=\"hljs\">Sync</code> and <code class=\"hljs\">Send</code>\nTraits”</a><!-- ignore -->\nsection in Chapter 16: the compiler implements these traits automatically if\nour types are composed entirely of <code class=\"hljs\">Send</code> and <code class=\"hljs\">Sync</code> types. If we implement a\ntype that contains a type that is not <code class=\"hljs\">Send</code> or <code class=\"hljs\">Sync</code>, such as raw pointers,\nand we want to mark that type as <code class=\"hljs\">Send</code> or <code class=\"hljs\">Sync</code>, we must use <code class=\"hljs\">unsafe</code>. Rust\ncan’t verify that our type upholds the guarantees that it can be safely sent\nacross threads or accessed from multiple threads; therefore, we need to do\nthose checks manually and indicate as such with <code class=\"hljs\">unsafe</code>.</p>\n<h3 id=\"accessing-fields-of-a-union\"><a class=\"header\" href=\"#accessing-fields-of-a-union\">Accessing Fields of a Union</a></h3>\n<p>The final action that works only with <code class=\"hljs\">unsafe</code> is accessing fields of a\n<em>union</em>. A <code class=\"hljs\">union</code> is similar to a <code class=\"hljs\">struct</code>, but only one declared field is\nused in a particular instance at one time. Unions are primarily used to\ninterface with unions in C code. Accessing union fields is unsafe because Rust\ncan’t guarantee the type of the data currently being stored in the union\ninstance. You can learn more about unions in <a href=\"../reference/items/unions.html\">the Rust Reference</a>.</p>\n<h3 id=\"when-to-use-unsafe-code\"><a class=\"header\" href=\"#when-to-use-unsafe-code\">When to Use Unsafe Code</a></h3>\n<p>Using <code class=\"hljs\">unsafe</code> to take one of the five actions (superpowers) just discussed\nisn’t wrong or even frowned upon. But it is trickier to get <code class=\"hljs\">unsafe</code> code\ncorrect because the compiler can’t help uphold memory safety. When you have a\nreason to use <code class=\"hljs\">unsafe</code> code, you can do so, and having the explicit <code class=\"hljs\">unsafe</code>\nannotation makes it easier to track down the source of problems when they occur.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch19-00-advanced-features.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch19-03-advanced-traits.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch19-00-advanced-features.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch19-03-advanced-traits.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:33.219Z"
}