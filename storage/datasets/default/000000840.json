{
	"title": "BinaryHeap in std::collections - Rust",
	"url": "https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html",
	"markdown": "# BinaryHeap in std::collections - Rust\n\n```\npub struct BinaryHeap<T, A = Global>where\n    A: Allocator,{ /* private fields */ }\n```\n\nExpand description\n\nA priority queue implemented with a binary heap.\n\nThis will be a max-heap.\n\nIt is a logic error for an item to be modified in such a way that the itemâ€™s ordering relative to any other item, as determined by the [`Ord`](../cmp/trait.Ord.html \"trait std::cmp::Ord\") trait, changes while it is in the heap. This is normally only possible through interior mutability, global state, I/O, or unsafe code. The behavior resulting from such a logic error is not specified, but will be encapsulated to the `BinaryHeap` that observed the logic error and not result in undefined behavior. This could include panics, incorrect results, aborts, memory leaks, and non-termination.\n\nAs long as no elements change their relative order while being in the heap as described above, the API of `BinaryHeap` guarantees that the heap invariant remains intact i.e. its methods all behave as documented. For example if a method is documented as iterating in sorted order, thatâ€™s guaranteed to work as long as elements in the heap have not changed order, even in the presence of closures getting unwinded out of, iterators getting leaked, and similar foolishness.\n\n## [Â§](#examples)Examples\n\n```\nuse std::collections::BinaryHeap;\n\n// Type inference lets us omit an explicit type signature (which\n// would be `BinaryHeap<i32>` in this example).\nlet mut heap = BinaryHeap::new();\n\n// We can use peek to look at the next item in the heap. In this case,\n// there's no items in there yet so we get None.\nassert_eq!(heap.peek(), None);\n\n// Let's add some scores...\nheap.push(1);\nheap.push(5);\nheap.push(2);\n\n// Now peek shows the most important item in the heap.\nassert_eq!(heap.peek(), Some(&5));\n\n// We can check the length of a heap.\nassert_eq!(heap.len(), 3);\n\n// We can iterate over the items in the heap, although they are returned in\n// a random order.\nfor x in &heap {\n    println!(\"{x}\");\n}\n\n// If we instead pop these scores, they should come back in order.\nassert_eq!(heap.pop(), Some(5));\nassert_eq!(heap.pop(), Some(2));\nassert_eq!(heap.pop(), Some(1));\nassert_eq!(heap.pop(), None);\n\n// We can clear the heap of any remaining items.\nheap.clear();\n\n// The heap should now be empty.\nassert!(heap.is_empty())\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++//+Type+inference+lets+us+omit+an+explicit+type+signature+(which%0A++++//+would+be+%60BinaryHeap%3Ci32%3E%60+in+this+example).%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++//+We+can+use+peek+to+look+at+the+next+item+in+the+heap.+In+this+case,%0A++++//+there%27s+no+items+in+there+yet+so+we+get+None.%0A++++assert_eq!(heap.peek(),+None);%0A++++%0A++++//+Let%27s+add+some+scores...%0A++++heap.push(1);%0A++++heap.push(5);%0A++++heap.push(2);%0A++++%0A++++//+Now+peek+shows+the+most+important+item+in+the+heap.%0A++++assert_eq!(heap.peek(),+Some(%265));%0A++++%0A++++//+We+can+check+the+length+of+a+heap.%0A++++assert_eq!(heap.len(),+3);%0A++++%0A++++//+We+can+iterate+over+the+items+in+the+heap,+although+they+are+returned+in%0A++++//+a+random+order.%0A++++for+x+in+%26heap+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A++++%0A++++//+If+we+instead+pop+these+scores,+they+should+come+back+in+order.%0A++++assert_eq!(heap.pop(),+Some(5));%0A++++assert_eq!(heap.pop(),+Some(2));%0A++++assert_eq!(heap.pop(),+Some(1));%0A++++assert_eq!(heap.pop(),+None);%0A++++%0A++++//+We+can+clear+the+heap+of+any+remaining+items.%0A++++heap.clear();%0A++++%0A++++//+The+heap+should+now+be+empty.%0A++++assert!(heap.is_empty())%0A%7D&edition=2021)\n\nA `BinaryHeap` with a known list of items can be initialized from an array:\n\n```\nuse std::collections::BinaryHeap;\n\nlet heap = BinaryHeap::from([1, 5, 2]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+heap+=+BinaryHeap::from(%5B1,+5,+2%5D);%0A%7D&edition=2021)\n\n### [Â§](#min-heap)Min-heap\n\nEither [`core::cmp::Reverse`](../cmp/struct.Reverse.html \"struct std::cmp::Reverse\") or a custom [`Ord`](../cmp/trait.Ord.html \"trait std::cmp::Ord\") implementation can be used to make `BinaryHeap` a min-heap. This makes `heap.pop()` return the smallest value instead of the greatest one.\n\n```\nuse std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\nlet mut heap = BinaryHeap::new();\n\n// Wrap values in `Reverse`\nheap.push(Reverse(1));\nheap.push(Reverse(5));\nheap.push(Reverse(2));\n\n// If we pop these scores now, they should come back in the reverse order.\nassert_eq!(heap.pop(), Some(Reverse(1)));\nassert_eq!(heap.pop(), Some(Reverse(2)));\nassert_eq!(heap.pop(), Some(Reverse(5)));\nassert_eq!(heap.pop(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::cmp::Reverse;%0A++++%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++//+Wrap+values+in+%60Reverse%60%0A++++heap.push(Reverse(1));%0A++++heap.push(Reverse(5));%0A++++heap.push(Reverse(2));%0A++++%0A++++//+If+we+pop+these+scores+now,+they+should+come+back+in+the+reverse+order.%0A++++assert_eq!(heap.pop(),+Some(Reverse(1)));%0A++++assert_eq!(heap.pop(),+Some(Reverse(2)));%0A++++assert_eq!(heap.pop(),+Some(Reverse(5)));%0A++++assert_eq!(heap.pop(),+None);%0A%7D&edition=2021)\n\n## [Â§](#time-complexity)Time complexity\n\nThe value for `push` is an expected cost; the method documentation gives a more detailed analysis.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#430)[Â§](#impl-BinaryHeap%3CT%3E)\n\n1.0.0 (const: 1.80.0) Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#445)\n\nCreates an empty `BinaryHeap` as a max-heap.\n\n##### [Â§](#examples-1)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nheap.push(4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.push(4);%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#466)\n\nCreates an empty `BinaryHeap` with at least the specified capacity.\n\nThe binary heap will be able to hold at least `capacity` elements without reallocating. This method is allowed to allocate for more elements than `capacity`. If `capacity` is 0, the binary heap will not allocate.\n\n##### [Â§](#examples-2)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::with_capacity(10);\nheap.push(4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::with_capacity(10);%0A++++heap.push(4);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#471)[Â§](#impl-BinaryHeap%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#489)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nCreates an empty `BinaryHeap` as a max-heap, using `A` as allocator.\n\n##### [Â§](#examples-3)Examples\n\nBasic usage:\n\n```\n#![feature(allocator_api)]\n\nuse std::alloc::System;\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new_in(System);\nheap.push(4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::alloc::System;%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new_in(System);%0A++++heap.push(4);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#513)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nCreates an empty `BinaryHeap` with at least the specified capacity, using `A` as allocator.\n\nThe binary heap will be able to hold at least `capacity` elements without reallocating. This method is allowed to allocate for more elements than `capacity`. If `capacity` is 0, the binary heap will not allocate.\n\n##### [Â§](#examples-4)Examples\n\nBasic usage:\n\n```\n#![feature(allocator_api)]\n\nuse std::alloc::System;\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::with_capacity_in(10, System);\nheap.push(4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::alloc::System;%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::with_capacity_in(10,+System);%0A++++heap.push(4);%0A%7D&version=nightly&edition=2021)\n\n1.12.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#548)\n\nReturns a mutable reference to the greatest item in the binary heap, or `None` if it is empty.\n\nNote: If the `PeekMut` value is leaked, some heap elements might get leaked along with it, but the remaining elements will remain a valid heap.\n\n##### [Â§](#examples-5)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nassert!(heap.peek_mut().is_none());\n\nheap.push(1);\nheap.push(5);\nheap.push(2);\n{\n    let mut val = heap.peek_mut().unwrap();\n    *val = 0;\n}\nassert_eq!(heap.peek(), Some(&2));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++assert!(heap.peek_mut().is_none());%0A++++%0A++++heap.push(1);%0A++++heap.push(5);%0A++++heap.push(2);%0A++++%7B%0A++++++++let+mut+val+=+heap.peek_mut().unwrap();%0A++++++++*val+=+0;%0A++++%7D%0A++++assert_eq!(heap.peek(),+Some(%262));%0A%7D&edition=2021)\n\n##### [Â§](#time-complexity-1)Time complexity\n\nIf the item is modified then the worst case time complexity is _O_(log(_n_)), otherwise itâ€™s _O_(1).\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#572)\n\nRemoves the greatest item from the binary heap and returns it, or `None` if it is empty.\n\n##### [Â§](#examples-6)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::from([1, 3]);\n\nassert_eq!(heap.pop(), Some(3));\nassert_eq!(heap.pop(), Some(1));\nassert_eq!(heap.pop(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert_eq!(heap.pop(),+Some(3));%0A++++assert_eq!(heap.pop(),+Some(1));%0A++++assert_eq!(heap.pop(),+None);%0A%7D&edition=2021)\n\n##### [Â§](#time-complexity-2)Time complexity\n\nThe worst case cost of `pop` on a heap containing _n_ elements is _O_(log(_n_)).\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#617)\n\nPushes an item onto the binary heap.\n\n##### [Â§](#examples-7)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nheap.push(3);\nheap.push(5);\nheap.push(1);\n\nassert_eq!(heap.len(), 3);\nassert_eq!(heap.peek(), Some(&5));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.push(3);%0A++++heap.push(5);%0A++++heap.push(1);%0A++++%0A++++assert_eq!(heap.len(),+3);%0A++++assert_eq!(heap.peek(),+Some(%265));%0A%7D&edition=2021)\n\n##### [Â§](#time-complexity-3)Time complexity\n\nThe expected cost of `push`, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is _O_(1). This is the most meaningful cost metric when pushing elements that are _not_ already in any sorted pattern.\n\nThe time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is _O_(log(_n_)) against a heap containing _n_ elements.\n\nThe worst case cost of a _single_ call to `push` is _O_(_n_). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.\n\n1.5.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#644)\n\nConsumes the `BinaryHeap` and returns a vector in sorted (ascending) order.\n\n##### [Â§](#examples-8)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\n\nlet mut heap = BinaryHeap::from([1, 2, 4, 5, 7]);\nheap.push(6);\nheap.push(3);\n\nlet vec = heap.into_sorted_vec();\nassert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+2,+4,+5,+7%5D);%0A++++heap.push(6);%0A++++heap.push(3);%0A++++%0A++++let+vec+=+heap.into_sorted_vec();%0A++++assert_eq!(vec,+%5B1,+2,+3,+4,+5,+6,+7%5D);%0A%7D&edition=2021)\n\n1.11.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#863)\n\nMoves all the elements of `other` into `self`, leaving `other` empty.\n\n##### [Â§](#examples-9)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\n\nlet mut a = BinaryHeap::from([-10, 1, 2, 3, 3]);\nlet mut b = BinaryHeap::from([-20, 5, 43]);\n\na.append(&mut b);\n\nassert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\nassert!(b.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+a+=+BinaryHeap::from(%5B-10,+1,+2,+3,+3%5D);%0A++++let+mut+b+=+BinaryHeap::from(%5B-20,+5,+43%5D);%0A++++%0A++++a.append(%26mut+b);%0A++++%0A++++assert_eq!(a.into_sorted_vec(),+%5B-20,+-10,+1,+2,+3,+3,+5,+43%5D);%0A++++assert!(b.is_empty());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#902)\n\nðŸ”¬This is a nightly-only experimental API. (`binary_heap_drain_sorted`Â [#59278](https://github.com/rust-lang/rust/issues/59278))\n\nClears the binary heap, returning an iterator over the removed elements in heap order. If the iterator is dropped before being fully consumed, it drops the remaining elements in heap order.\n\nThe returned iterator keeps a mutable borrow on the heap to optimize its implementation.\n\nNote:\n\n-   `.drain_sorted()` is _O_(_n_ \\* log(_n_)); much slower than `.drain()`. You should use the latter for most cases.\n\n##### [Â§](#examples-10)Examples\n\nBasic usage:\n\n```\n#![feature(binary_heap_drain_sorted)]\nuse std::collections::BinaryHeap;\n\nlet mut heap = BinaryHeap::from([1, 2, 3, 4, 5]);\nassert_eq!(heap.len(), 5);\n\ndrop(heap.drain_sorted()); // removes all elements in heap order\nassert_eq!(heap.len(), 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(binary_heap_drain_sorted)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5%5D);%0A++++assert_eq!(heap.len(),+5);%0A++++%0A++++drop(heap.drain_sorted());+//+removes+all+elements+in+heap+order%0A++++assert_eq!(heap.len(),+0);%0A%7D&version=nightly&edition=2021)\n\n1.70.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#925-927)\n\nRetains only the elements specified by the predicate.\n\nIn other words, remove all elements `e` for which `f(&e)` returns `false`. The elements are visited in unsorted (and unspecified) order.\n\n##### [Â§](#examples-11)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\n\nlet mut heap = BinaryHeap::from([-10, -5, 1, 2, 4, 13]);\n\nheap.retain(|x| x % 2 == 0); // only keep even numbers\n\nassert_eq!(heap.into_sorted_vec(), [-10, 2, 4])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+heap+=+BinaryHeap::from(%5B-10,+-5,+1,+2,+4,+13%5D);%0A++++%0A++++heap.retain(%7Cx%7C+x+%25+2+==+0);+//+only+keep+even+numbers%0A++++%0A++++assert_eq!(heap.into_sorted_vec(),+%5B-10,+2,+4%5D)%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#945)[Â§](#impl-BinaryHeap%3CT,+A%3E-1)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#963)\n\nReturns an iterator visiting all values in the underlying vector, in arbitrary order.\n\n##### [Â§](#examples-12)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet heap = BinaryHeap::from([1, 2, 3, 4]);\n\n// Print 1, 2, 3, 4 in arbitrary order\nfor x in heap.iter() {\n    println!(\"{x}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4%5D);%0A++++%0A++++//+Print+1,+2,+3,+4+in+arbitrary+order%0A++++for+x+in+heap.iter()+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#982)\n\nðŸ”¬This is a nightly-only experimental API. (`binary_heap_into_iter_sorted`Â [#59278](https://github.com/rust-lang/rust/issues/59278))\n\nReturns an iterator which retrieves elements in heap order. This method consumes the original heap.\n\n##### [Â§](#examples-13)Examples\n\nBasic usage:\n\n```\n#![feature(binary_heap_into_iter_sorted)]\nuse std::collections::BinaryHeap;\nlet heap = BinaryHeap::from([1, 2, 3, 4, 5]);\n\nassert_eq!(heap.into_iter_sorted().take(2).collect::<Vec<_>>(), [5, 4]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(binary_heap_into_iter_sorted)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5%5D);%0A++++%0A++++assert_eq!(heap.into_iter_sorted().take(2).collect::%3CVec%3C_%3E%3E(),+%5B5,+4%5D);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1009)\n\nReturns the greatest item in the binary heap, or `None` if it is empty.\n\n##### [Â§](#examples-14)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nassert_eq!(heap.peek(), None);\n\nheap.push(1);\nheap.push(5);\nheap.push(2);\nassert_eq!(heap.peek(), Some(&5));\n\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++assert_eq!(heap.peek(),+None);%0A++++%0A++++heap.push(1);%0A++++heap.push(5);%0A++++heap.push(2);%0A++++assert_eq!(heap.peek(),+Some(%265));%0A%7D&edition=2021)\n\n##### [Â§](#time-complexity-4)Time complexity\n\nCost is _O_(1) in the worst case.\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1027)\n\nReturns the number of elements the binary heap can hold without reallocating.\n\n##### [Â§](#examples-15)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::with_capacity(100);\nassert!(heap.capacity() >= 100);\nheap.push(4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::with_capacity(100);%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.push(4);%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1058)\n\nReserves the minimum capacity for at least `additional` elements more than the current length. Unlike [`reserve`](about:blank/struct.BinaryHeap.html#method.reserve \"method std::collections::BinaryHeap::reserve\"), this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling `reserve_exact`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if the capacity is already sufficient.\n\n##### [Â§](#panics)Panics\n\nPanics if the new capacity overflows [`usize`](../primitive.usize.html \"primitive usize\").\n\n##### [Â§](#examples-16)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nheap.reserve_exact(100);\nassert!(heap.capacity() >= 100);\nheap.push(4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.reserve_exact(100);%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.push(4);%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1084)\n\nReserves capacity for at least `additional` elements more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling `reserve`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if capacity is already sufficient.\n\n##### [Â§](#panics-1)Panics\n\nPanics if the new capacity overflows [`usize`](../primitive.usize.html \"primitive usize\").\n\n##### [Â§](#examples-17)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nheap.reserve(100);\nassert!(heap.capacity() >= 100);\nheap.push(4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.reserve(100);%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.push(4);%0A%7D&edition=2021)\n\n1.63.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1126)\n\nTries to reserve the minimum capacity for at least `additional` elements more than the current length. Unlike [`try_reserve`](about:blank/struct.BinaryHeap.html#method.try_reserve \"method std::collections::BinaryHeap::try_reserve\"), this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling `try_reserve_exact`, capacity will be greater than or equal to `self.len() + additional` if it returns `Ok(())`. Does nothing if the capacity is already sufficient.\n\nNote that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer [`try_reserve`](about:blank/struct.BinaryHeap.html#method.try_reserve \"method std::collections::BinaryHeap::try_reserve\") if future insertions are expected.\n\n##### [Â§](#errors)Errors\n\nIf the capacity overflows, or the allocator reports a failure, then an error is returned.\n\n##### [Â§](#examples-18)Examples\n\n```\nuse std::collections::BinaryHeap;\nuse std::collections::TryReserveError;\n\nfn find_max_slow(data: &[u32]) -> Result<Option<u32>, TryReserveError> {\n    let mut heap = BinaryHeap::new();\n\n    // Pre-reserve the memory, exiting if we can't\n    heap.try_reserve_exact(data.len())?;\n\n    // Now we know this can't OOM in the middle of our complex work\n    heap.extend(data.iter());\n\n    Ok(heap.pop())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+find_max_slow(data:+%26%5Bu32%5D)+-%3E+Result%3COption%3Cu32%3E,+TryReserveError%3E+%7B%0A++++++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can%27t%0A++++++++heap.try_reserve_exact(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can%27t+OOM+in+the+middle+of+our+complex+work%0A++++++++heap.extend(data.iter());%0A++++%0A++++++++Ok(heap.pop())%0A++++%7D%0A++++find_max_slow(%26%5B1,+2,+3%5D).expect(%22why+is+the+test+harness+OOMing+on+12+bytes?%22);%0A%7D&edition=2021)\n\n1.63.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1162)\n\nTries to reserve capacity for at least `additional` elements more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling `try_reserve`, capacity will be greater than or equal to `self.len() + additional` if it returns `Ok(())`. Does nothing if capacity is already sufficient. This method preserves the contents even if an error occurs.\n\n##### [Â§](#errors-1)Errors\n\nIf the capacity overflows, or the allocator reports a failure, then an error is returned.\n\n##### [Â§](#examples-19)Examples\n\n```\nuse std::collections::BinaryHeap;\nuse std::collections::TryReserveError;\n\nfn find_max_slow(data: &[u32]) -> Result<Option<u32>, TryReserveError> {\n    let mut heap = BinaryHeap::new();\n\n    // Pre-reserve the memory, exiting if we can't\n    heap.try_reserve(data.len())?;\n\n    // Now we know this can't OOM in the middle of our complex work\n    heap.extend(data.iter());\n\n    Ok(heap.pop())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+find_max_slow(data:+%26%5Bu32%5D)+-%3E+Result%3COption%3Cu32%3E,+TryReserveError%3E+%7B%0A++++++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can%27t%0A++++++++heap.try_reserve(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can%27t+OOM+in+the+middle+of+our+complex+work%0A++++++++heap.extend(data.iter());%0A++++%0A++++++++Ok(heap.pop())%0A++++%7D%0A++++find_max_slow(%26%5B1,+2,+3%5D).expect(%22why+is+the+test+harness+OOMing+on+12+bytes?%22);%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1181)\n\nDiscards as much additional capacity as possible.\n\n##### [Â§](#examples-20)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n\nassert!(heap.capacity() >= 100);\nheap.shrink_to_fit();\nassert!(heap.capacity() == 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap:+BinaryHeap%3Ci32%3E+=+BinaryHeap::with_capacity(100);%0A++++%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.shrink_to_fit();%0A++++assert!(heap.capacity()+==+0);%0A%7D&edition=2021)\n\n1.56.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1204)\n\nDiscards capacity with a lower bound.\n\nThe capacity will remain at least as large as both the length and the supplied value.\n\nIf the current capacity is less than the lower limit, this is a no-op.\n\n##### [Â§](#examples-21)Examples\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n\nassert!(heap.capacity() >= 100);\nheap.shrink_to(10);\nassert!(heap.capacity() >= 10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap:+BinaryHeap%3Ci32%3E+=+BinaryHeap::with_capacity(100);%0A++++%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.shrink_to(10);%0A++++assert!(heap.capacity()+%3E=+10);%0A%7D&edition=2021)\n\n1.80.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1225)\n\nReturns a slice of all values in the underlying vector, in arbitrary order.\n\n##### [Â§](#examples-22)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nuse std::io::{self, Write};\n\nlet heap = BinaryHeap::from([1, 2, 3, 4, 5, 6, 7]);\n\nio::sink().write(heap.as_slice()).unwrap();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::io::%7Bself,+Write%7D;%0A++++%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5,+6,+7%5D);%0A++++%0A++++io::sink().write(heap.as_slice()).unwrap();%0A%7D&edition=2021)\n\n1.5.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1248)\n\nConsumes the `BinaryHeap` and returns the underlying vector in arbitrary order.\n\n##### [Â§](#examples-23)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet heap = BinaryHeap::from([1, 2, 3, 4, 5, 6, 7]);\nlet vec = heap.into_vec();\n\n// Will print in some order\nfor x in vec {\n    println!(\"{x}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5,+6,+7%5D);%0A++++let+vec+=+heap.into_vec();%0A++++%0A++++//+Will+print+in+some+order%0A++++for+x+in+vec+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1255)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nReturns a reference to the underlying allocator.\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1274)\n\nReturns the length of the binary heap.\n\n##### [Â§](#examples-24)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet heap = BinaryHeap::from([1, 3]);\n\nassert_eq!(heap.len(), 2);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert_eq!(heap.len(),+2);%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1298)\n\nChecks if the binary heap is empty.\n\n##### [Â§](#examples-25)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\n\nassert!(heap.is_empty());\n\nheap.push(3);\nheap.push(5);\nheap.push(1);\n\nassert!(!heap.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++assert!(heap.is_empty());%0A++++%0A++++heap.push(3);%0A++++heap.push(5);%0A++++heap.push(1);%0A++++%0A++++assert!(!heap.is_empty());%0A%7D&edition=2021)\n\n1.6.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1327)\n\nClears the binary heap, returning an iterator over the removed elements in arbitrary order. If the iterator is dropped before being fully consumed, it drops the remaining elements in arbitrary order.\n\nThe returned iterator keeps a mutable borrow on the heap to optimize its implementation.\n\n##### [Â§](#examples-26)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::from([1, 3]);\n\nassert!(!heap.is_empty());\n\nfor x in heap.drain() {\n    println!(\"{x}\");\n}\n\nassert!(heap.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert!(!heap.is_empty());%0A++++%0A++++for+x+in+heap.drain()+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A++++%0A++++assert!(heap.is_empty());%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1348)\n\nDrops all items from the binary heap.\n\n##### [Â§](#examples-27)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::from([1, 3]);\n\nassert!(!heap.is_empty());\n\nheap.clear();\n\nassert!(heap.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert!(!heap.is_empty());%0A++++%0A++++heap.clear();%0A++++%0A++++assert!(heap.is_empty());%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#383)[Â§](#impl-Clone-for-BinaryHeap%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#394)[Â§](#method.clone_from)\n\nOverwrites the contents of `self` with a clone of the contents of `source`.\n\nThis method is preferred over simply assigning `source.clone()` to `self`, as it avoids reallocation if possible.\n\nSee [`Vec::clone_from()`](about:blank/vec/struct.Vec.html#method.clone_from \"method std::vec::Vec::clone_from\") for more details.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#384)[Â§](#method.clone)\n\nReturns a copy of the value. [Read more](about:blank/clone/trait.Clone.html#tymethod.clone)\n\n1.4.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#409)[Â§](#impl-Debug-for-BinaryHeap%3CT,+A%3E)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#400)[Â§](#impl-Default-for-BinaryHeap%3CT%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#403)[Â§](#method.default)\n\nCreates an empty `BinaryHeap<T>`.\n\n1.2.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1871)[Â§](#impl-Extend%3C%26T%3E-for-BinaryHeap%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1872)[Â§](#method.extend-1)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1877)[Â§](#method.extend_one-1)\n\nðŸ”¬This is a nightly-only experimental API. (`extend_one`Â [#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1882)[Â§](#method.extend_reserve-1)\n\nðŸ”¬This is a nightly-only experimental API. (`extend_one`Â [#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1852)[Â§](#impl-Extend%3CT%3E-for-BinaryHeap%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1854)[Â§](#method.extend)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1860)[Â§](#method.extend_one)\n\nðŸ”¬This is a nightly-only experimental API. (`extend_one`Â [#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1865)[Â§](#method.extend_reserve)\n\nðŸ”¬This is a nightly-only experimental API. (`extend_one`Â [#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.56.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1780)[Â§](#impl-From%3C%5BT;+N%5D%3E-for-BinaryHeap%3CT%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1790)[Â§](#method.from)\n\n```\nuse std::collections::BinaryHeap;\n\nlet mut h1 = BinaryHeap::from([1, 4, 2, 3]);\nlet mut h2: BinaryHeap<_> = [1, 4, 2, 3].into();\nwhile let Some((a, b)) = h1.pop().zip(h2.pop()) {\n    assert_eq!(a, b);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+h1+=+BinaryHeap::from(%5B1,+4,+2,+3%5D);%0A++++let+mut+h2:+BinaryHeap%3C_%3E+=+%5B1,+4,+2,+3%5D.into();%0A++++while+let+Some((a,+b))+=+h1.pop().zip(h2.pop())+%7B%0A++++++++assert_eq!(a,+b);%0A++++%7D%0A%7D&edition=2021)\n\n1.5.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1796)[Â§](#impl-From%3CBinaryHeap%3CT,+A%3E%3E-for-Vec%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1801)[Â§](#method.from-2)\n\nConverts a `BinaryHeap<T>` into a `Vec<T>`.\n\nThis conversion requires no data movement or allocation, and has constant time complexity.\n\n1.5.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1768)[Â§](#impl-From%3CVec%3CT,+A%3E%3E-for-BinaryHeap%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1772)[Â§](#method.from-1)\n\nConverts a `Vec<T>` into a `BinaryHeap<T>`.\n\nThis conversion happens in-place, and has _O_(_n_) time complexity.\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1807)[Â§](#impl-FromIterator%3CT%3E-for-BinaryHeap%3CT%3E)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1842)[Â§](#impl-IntoIterator-for-%26BinaryHeap%3CT,+A%3E)\n\n[Â§](#associatedtype.Item)\n\nThe type of the elements being iterated over.\n\n[Â§](#associatedtype.IntoIter)\n\nWhich kind of iterator are we turning this into?\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1846)[Â§](#method.into_iter)\n\nCreates an iterator from a value. [Read more](about:blank/iter/trait.IntoIterator.html#tymethod.into_iter)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1814)[Â§](#impl-IntoIterator-for-BinaryHeap%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1836)[Â§](#method.into_iter-1)\n\nCreates a consuming iterator, that is, one that moves each value out of the binary heap in arbitrary order. The binary heap cannot be used after calling this.\n\n##### [Â§](#examples-28)Examples\n\nBasic usage:\n\n```\nuse std::collections::BinaryHeap;\nlet heap = BinaryHeap::from([1, 2, 3, 4]);\n\n// Print 1, 2, 3, 4 in arbitrary order\nfor x in heap.into_iter() {\n    // x has type i32, not &i32\n    println!(\"{x}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4%5D);%0A++++%0A++++//+Print+1,+2,+3,+4+in+arbitrary+order%0A++++for+x+in+heap.into_iter()+%7B%0A++++++++//+x+has+type+i32,+not+%26i32%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\n[Â§](#associatedtype.Item-1)\n\nThe type of the elements being iterated over.\n\n[Â§](#associatedtype.IntoIter-1)\n\nWhich kind of iterator are we turning this into?\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140)[Â§](#impl-Any-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208)[Â§](#impl-Borrow%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216)[Â§](#impl-BorrowMut%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765)[Â§](#impl-From%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768)[Â§](#method.from-3)\n\nReturns the argument unchanged.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750)[Â§](#impl-Into%3CU%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758)[Â§](#method.into)\n\nCalls `U::from(self)`.\n\nThat is, this conversion is whatever the implementation of `[From](../convert/trait.From.html \"trait std::convert::From\")<T> for U` chooses to do.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85)[Â§](#impl-ToOwned-for-T)\n\n[Â§](#associatedtype.Owned)\n\nThe resulting type after obtaining ownership.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88)[Â§](#method.to_owned)\n\nCreates owned data from borrowed data, usually by cloning. [Read more](about:blank/borrow/trait.ToOwned.html#tymethod.to_owned)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92)[Â§](#method.clone_into)\n\nUses borrowed data to replace owned data, usually by cloning. [Read more](about:blank/borrow/trait.ToOwned.html#method.clone_into)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807)[Â§](#impl-TryFrom%3CU%3E-for-T)\n\n[Â§](#associatedtype.Error-1)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812)[Â§](#method.try_from)\n\nPerforms the conversion.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792)[Â§](#impl-TryInto%3CU%3E-for-T)\n\n[Â§](#associatedtype.Error)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797)[Â§](#method.try_into)\n\nPerforms the conversion.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A priority queue implemented with a binary heap.\"><title>BinaryHeap in std::collections - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc struct\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">BinaryHeap</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">BinaryHeap</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.allocator\">allocator</a></li><li><a href=\"#method.append\">append</a></li><li><a href=\"#method.as_slice\">as_slice</a></li><li><a href=\"#method.capacity\">capacity</a></li><li><a href=\"#method.clear\">clear</a></li><li><a href=\"#method.drain\">drain</a></li><li><a href=\"#method.drain_sorted\">drain_sorted</a></li><li><a href=\"#method.into_iter_sorted\">into_iter_sorted</a></li><li><a href=\"#method.into_sorted_vec\">into_sorted_vec</a></li><li><a href=\"#method.into_vec\">into_vec</a></li><li><a href=\"#method.is_empty\">is_empty</a></li><li><a href=\"#method.iter\">iter</a></li><li><a href=\"#method.len\">len</a></li><li><a href=\"#method.new\">new</a></li><li><a href=\"#method.new_in\">new_in</a></li><li><a href=\"#method.peek\">peek</a></li><li><a href=\"#method.peek_mut\">peek_mut</a></li><li><a href=\"#method.pop\">pop</a></li><li><a href=\"#method.push\">push</a></li><li><a href=\"#method.reserve\">reserve</a></li><li><a href=\"#method.reserve_exact\">reserve_exact</a></li><li><a href=\"#method.retain\">retain</a></li><li><a href=\"#method.shrink_to\">shrink_to</a></li><li><a href=\"#method.shrink_to_fit\">shrink_to_fit</a></li><li><a href=\"#method.try_reserve\">try_reserve</a></li><li><a href=\"#method.try_reserve_exact\">try_reserve_exact</a></li><li><a href=\"#method.with_capacity\">with_capacity</a></li><li><a href=\"#method.with_capacity_in\">with_capacity_in</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-Clone-for-BinaryHeap%3CT,+A%3E\">Clone</a></li><li><a href=\"#impl-Debug-for-BinaryHeap%3CT,+A%3E\">Debug</a></li><li><a href=\"#impl-Default-for-BinaryHeap%3CT%3E\">Default</a></li><li><a href=\"#impl-Extend%3C%26T%3E-for-BinaryHeap%3CT,+A%3E\">Extend&lt;&amp;'a T&gt;</a></li><li><a href=\"#impl-Extend%3CT%3E-for-BinaryHeap%3CT,+A%3E\">Extend&lt;T&gt;</a></li><li><a href=\"#impl-From%3CBinaryHeap%3CT,+A%3E%3E-for-Vec%3CT,+A%3E\">From&lt;BinaryHeap&lt;T, A&gt;&gt;</a></li><li><a href=\"#impl-From%3CVec%3CT,+A%3E%3E-for-BinaryHeap%3CT,+A%3E\">From&lt;Vec&lt;T, A&gt;&gt;</a></li><li><a href=\"#impl-From%3C%5BT;+N%5D%3E-for-BinaryHeap%3CT%3E\">From&lt;[T; N]&gt;</a></li><li><a href=\"#impl-FromIterator%3CT%3E-for-BinaryHeap%3CT%3E\">FromIterator&lt;T&gt;</a></li><li><a href=\"#impl-IntoIterator-for-%26BinaryHeap%3CT,+A%3E\">IntoIterator</a></li><li><a href=\"#impl-IntoIterator-for-BinaryHeap%3CT,+A%3E\">IntoIterator</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-BinaryHeap%3CT,+A%3E\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-BinaryHeap%3CT,+A%3E\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-BinaryHeap%3CT,+A%3E\">Send</a></li><li><a href=\"#impl-Sync-for-BinaryHeap%3CT,+A%3E\">Sync</a></li><li><a href=\"#impl-Unpin-for-BinaryHeap%3CT,+A%3E\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-BinaryHeap%3CT,+A%3E\">UnwindSafe</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-ToOwned-for-T\">ToOwned</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::collections</a></h2><h3><a href=\"index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"binary_heap/index.html\">binary_heap</a></li><li><a href=\"btree_map/index.html\">btree_map</a></li><li><a href=\"btree_set/index.html\">btree_set</a></li><li><a href=\"hash_map/index.html\">hash_map</a></li><li><a href=\"hash_set/index.html\">hash_set</a></li><li><a href=\"linked_list/index.html\">linked_list</a></li><li><a href=\"vec_deque/index.html\">vec_deque</a></li></ul><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.BTreeMap.html\">BTreeMap</a></li><li><a href=\"struct.BTreeSet.html\">BTreeSet</a></li><li><a href=\"struct.BinaryHeap.html\">BinaryHeap</a></li><li><a href=\"struct.HashMap.html\">HashMap</a></li><li><a href=\"struct.HashSet.html\">HashSet</a></li><li><a href=\"struct.LinkedList.html\">LinkedList</a></li><li><a href=\"struct.TryReserveError.html\">TryReserveError</a></li><li><a href=\"struct.VecDeque.html\">VecDeque</a></li></ul><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.TryReserveErrorKind.html\">TryReserveErrorKind</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type â€˜Sâ€™ or â€˜/â€™ to search, â€˜?â€™ for more optionsâ€¦\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Struct <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">collections</a>::<wbr><a class=\"struct\" href=\"#\">BinaryHeap</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#276-279\">source</a> Â· <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>âˆ’</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub struct BinaryHeap&lt;T, A = <a class=\"struct\" href=\"../alloc/struct.Global.html\" title=\"struct std::alloc::Global\">Global</a>&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div>{ <span class=\"comment\">/* private fields */</span> }</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A priority queue implemented with a binary heap.</p>\n<p>This will be a max-heap.</p>\n<p>It is a logic error for an item to be modified in such a way that the\nitemâ€™s ordering relative to any other item, as determined by the <a href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\"><code>Ord</code></a>\ntrait, changes while it is in the heap. This is normally only possible\nthrough interior mutability, global state, I/O, or unsafe code. The\nbehavior resulting from such a logic error is not specified, but will\nbe encapsulated to the <code>BinaryHeap</code> that observed the logic error and not\nresult in undefined behavior. This could include panics, incorrect results,\naborts, memory leaks, and non-termination.</p>\n<p>As long as no elements change their relative order while being in the heap\nas described above, the API of <code>BinaryHeap</code> guarantees that the heap\ninvariant remains intact i.e. its methods all behave as documented. For\nexample if a method is documented as iterating in sorted order, thatâ€™s\nguaranteed to work as long as elements in the heap have not changed order,\neven in the presence of closures getting unwinded out of, iterators getting\nleaked, and similar foolishness.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n\n<span class=\"comment\">// Type inference lets us omit an explicit type signature (which\n// would be `BinaryHeap&lt;i32&gt;` in this example).\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\n\n<span class=\"comment\">// We can use peek to look at the next item in the heap. In this case,\n// there's no items in there yet so we get None.\n</span><span class=\"macro\">assert_eq!</span>(heap.peek(), <span class=\"prelude-val\">None</span>);\n\n<span class=\"comment\">// Let's add some scores...\n</span>heap.push(<span class=\"number\">1</span>);\nheap.push(<span class=\"number\">5</span>);\nheap.push(<span class=\"number\">2</span>);\n\n<span class=\"comment\">// Now peek shows the most important item in the heap.\n</span><span class=\"macro\">assert_eq!</span>(heap.peek(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>));\n\n<span class=\"comment\">// We can check the length of a heap.\n</span><span class=\"macro\">assert_eq!</span>(heap.len(), <span class=\"number\">3</span>);\n\n<span class=\"comment\">// We can iterate over the items in the heap, although they are returned in\n// a random order.\n</span><span class=\"kw\">for </span>x <span class=\"kw\">in </span><span class=\"kw-2\">&amp;</span>heap {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>);\n}\n\n<span class=\"comment\">// If we instead pop these scores, they should come back in order.\n</span><span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">5</span>));\n<span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">None</span>);\n\n<span class=\"comment\">// We can clear the heap of any remaining items.\n</span>heap.clear();\n\n<span class=\"comment\">// The heap should now be empty.\n</span><span class=\"macro\">assert!</span>(heap.is_empty())</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++//+Type+inference+lets+us+omit+an+explicit+type+signature+(which%0A++++//+would+be+%60BinaryHeap%3Ci32%3E%60+in+this+example).%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++//+We+can+use+peek+to+look+at+the+next+item+in+the+heap.+In+this+case,%0A++++//+there's+no+items+in+there+yet+so+we+get+None.%0A++++assert_eq!(heap.peek(),+None);%0A++++%0A++++//+Let's+add+some+scores...%0A++++heap.push(1);%0A++++heap.push(5);%0A++++heap.push(2);%0A++++%0A++++//+Now+peek+shows+the+most+important+item+in+the+heap.%0A++++assert_eq!(heap.peek(),+Some(%265));%0A++++%0A++++//+We+can+check+the+length+of+a+heap.%0A++++assert_eq!(heap.len(),+3);%0A++++%0A++++//+We+can+iterate+over+the+items+in+the+heap,+although+they+are+returned+in%0A++++//+a+random+order.%0A++++for+x+in+%26heap+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A++++%0A++++//+If+we+instead+pop+these+scores,+they+should+come+back+in+order.%0A++++assert_eq!(heap.pop(),+Some(5));%0A++++assert_eq!(heap.pop(),+Some(2));%0A++++assert_eq!(heap.pop(),+Some(1));%0A++++assert_eq!(heap.pop(),+None);%0A++++%0A++++//+We+can+clear+the+heap+of+any+remaining+items.%0A++++heap.clear();%0A++++%0A++++//+The+heap+should+now+be+empty.%0A++++assert!(heap.is_empty())%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A <code>BinaryHeap</code> with a known list of items can be initialized from an array:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n\n<span class=\"kw\">let </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+heap+=+BinaryHeap::from(%5B1,+5,+2%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"min-heap\"><a class=\"doc-anchor\" href=\"#min-heap\">Â§</a>Min-heap</h3>\n<p>Either <a href=\"../cmp/struct.Reverse.html\" title=\"struct std::cmp::Reverse\"><code>core::cmp::Reverse</code></a> or a custom <a href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\"><code>Ord</code></a> implementation can be used to\nmake <code>BinaryHeap</code> a min-heap. This makes <code>heap.pop()</code> return the smallest\nvalue instead of the greatest one.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">use </span>std::cmp::Reverse;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\n\n<span class=\"comment\">// Wrap values in `Reverse`\n</span>heap.push(Reverse(<span class=\"number\">1</span>));\nheap.push(Reverse(<span class=\"number\">5</span>));\nheap.push(Reverse(<span class=\"number\">2</span>));\n\n<span class=\"comment\">// If we pop these scores now, they should come back in the reverse order.\n</span><span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">Some</span>(Reverse(<span class=\"number\">1</span>)));\n<span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">Some</span>(Reverse(<span class=\"number\">2</span>)));\n<span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">Some</span>(Reverse(<span class=\"number\">5</span>)));\n<span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::cmp::Reverse;%0A++++%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++//+Wrap+values+in+%60Reverse%60%0A++++heap.push(Reverse(1));%0A++++heap.push(Reverse(5));%0A++++heap.push(Reverse(2));%0A++++%0A++++//+If+we+pop+these+scores+now,+they+should+come+back+in+the+reverse+order.%0A++++assert_eq!(heap.pop(),+Some(Reverse(1)));%0A++++assert_eq!(heap.pop(),+Some(Reverse(2)));%0A++++assert_eq!(heap.pop(),+Some(Reverse(5)));%0A++++assert_eq!(heap.pop(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"time-complexity\"><a class=\"doc-anchor\" href=\"#time-complexity\">Â§</a>Time complexity</h2><div><table><thead><tr><th><a href=\"struct.BinaryHeap.html#method.push\" title=\"method std::collections::BinaryHeap::push\">push</a></th><th><a href=\"struct.BinaryHeap.html#method.pop\" title=\"method std::collections::BinaryHeap::pop\">pop</a></th><th><a href=\"struct.BinaryHeap.html#method.peek\" title=\"method std::collections::BinaryHeap::peek\">peek</a>/<a href=\"struct.BinaryHeap.html#method.peek_mut\" title=\"method std::collections::BinaryHeap::peek_mut\">peek_mut</a></th></tr></thead><tbody>\n<tr><td><em>O</em>(1)~</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(1)</td></tr>\n</tbody></table>\n</div>\n<p>The value for <code>push</code> is an expected cost; the method documentation gives a\nmore detailed analysis.</p>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">Â§</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BinaryHeap%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#430\">source</a><a href=\"#impl-BinaryHeap%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.80.0\">1.0.0 (const: 1.80.0)</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#445\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.new\" class=\"fn\">new</a>() -&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty <code>BinaryHeap</code> as a max-heap.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\nheap.push(<span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.push(4);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.with_capacity\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#466\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.with_capacity\" class=\"fn\">with_capacity</a>(capacity: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty <code>BinaryHeap</code> with at least the specified capacity.</p>\n<p>The binary heap will be able to hold at least <code>capacity</code> elements without\nreallocating. This method is allowed to allocate for more elements than\n<code>capacity</code>. If <code>capacity</code> is 0, the binary heap will not allocate.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::with_capacity(<span class=\"number\">10</span>);\nheap.push(<span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::with_capacity(10);%0A++++heap.push(4);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BinaryHeap%3CT,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#471\">source</a><a href=\"#impl-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#489\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.new_in\" class=\"fn\">new_in</a>(alloc: A) -&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Creates an empty <code>BinaryHeap</code> as a max-heap, using <code>A</code> as allocator.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n<span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new_in(System);\nheap.push(<span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::alloc::System;%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new_in(System);%0A++++heap.push(4);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.with_capacity_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#513\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.with_capacity_in\" class=\"fn\">with_capacity_in</a>(capacity: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, alloc: A) -&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Creates an empty <code>BinaryHeap</code> with at least the specified capacity, using <code>A</code> as allocator.</p>\n<p>The binary heap will be able to hold at least <code>capacity</code> elements without\nreallocating. This method is allowed to allocate for more elements than\n<code>capacity</code>. If <code>capacity</code> is 0, the binary heap will not allocate.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n<span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::with_capacity_in(<span class=\"number\">10</span>, System);\nheap.push(<span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::alloc::System;%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::with_capacity_in(10,+System);%0A++++heap.push(4);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.peek_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0\">1.12.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#548\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.peek_mut\" class=\"fn\">peek_mut</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"binary_heap/struct.PeekMut.html\" title=\"struct std::collections::binary_heap::PeekMut\">PeekMut</a>&lt;'_, T, A&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to the greatest item in the binary heap, or\n<code>None</code> if it is empty.</p>\n<p>Note: If the <code>PeekMut</code> value is leaked, some heap elements might get\nleaked along with it, but the remaining elements will remain a valid\nheap.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\n<span class=\"macro\">assert!</span>(heap.peek_mut().is_none());\n\nheap.push(<span class=\"number\">1</span>);\nheap.push(<span class=\"number\">5</span>);\nheap.push(<span class=\"number\">2</span>);\n{\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>val = heap.peek_mut().unwrap();\n    <span class=\"kw-2\">*</span>val = <span class=\"number\">0</span>;\n}\n<span class=\"macro\">assert_eq!</span>(heap.peek(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++assert!(heap.peek_mut().is_none());%0A++++%0A++++heap.push(1);%0A++++heap.push(5);%0A++++heap.push(2);%0A++++%7B%0A++++++++let+mut+val+=+heap.peek_mut().unwrap();%0A++++++++*val+=+0;%0A++++%7D%0A++++assert_eq!(heap.peek(),+Some(%262));%0A%7D&amp;edition=2021\">Run</a></div>\n<h5 id=\"time-complexity-1\"><a class=\"doc-anchor\" href=\"#time-complexity-1\">Â§</a>Time complexity</h5>\n<p>If the item is modified then the worst case time complexity is <em>O</em>(log(<em>n</em>)),\notherwise itâ€™s <em>O</em>(1).</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.pop\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#572\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.pop\" class=\"fn\">pop</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Removes the greatest item from the binary heap and returns it, or <code>None</code> if it\nis empty.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">3</span>]);\n\n<span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(heap.pop(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert_eq!(heap.pop(),+Some(3));%0A++++assert_eq!(heap.pop(),+Some(1));%0A++++assert_eq!(heap.pop(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<h5 id=\"time-complexity-2\"><a class=\"doc-anchor\" href=\"#time-complexity-2\">Â§</a>Time complexity</h5>\n<p>The worst case cost of <code>pop</code> on a heap containing <em>n</em> elements is <em>O</em>(log(<em>n</em>)).</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.push\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#617\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.push\" class=\"fn\">push</a>(&amp;mut self, item: T)</h4></section></summary><div class=\"docblock\"><p>Pushes an item onto the binary heap.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\nheap.push(<span class=\"number\">3</span>);\nheap.push(<span class=\"number\">5</span>);\nheap.push(<span class=\"number\">1</span>);\n\n<span class=\"macro\">assert_eq!</span>(heap.len(), <span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(heap.peek(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.push(3);%0A++++heap.push(5);%0A++++heap.push(1);%0A++++%0A++++assert_eq!(heap.len(),+3);%0A++++assert_eq!(heap.peek(),+Some(%265));%0A%7D&amp;edition=2021\">Run</a></div>\n<h5 id=\"time-complexity-3\"><a class=\"doc-anchor\" href=\"#time-complexity-3\">Â§</a>Time complexity</h5>\n<p>The expected cost of <code>push</code>, averaged over every possible ordering of\nthe elements being pushed, and over a sufficiently large number of\npushes, is <em>O</em>(1). This is the most meaningful cost metric when pushing\nelements that are <em>not</em> already in any sorted pattern.</p>\n<p>The time complexity degrades if elements are pushed in predominantly\nascending order. In the worst case, elements are pushed in ascending\nsorted order and the amortized cost per push is <em>O</em>(log(<em>n</em>)) against a heap\ncontaining <em>n</em> elements.</p>\n<p>The worst case cost of a <em>single</em> call to <code>push</code> is <em>O</em>(<em>n</em>). The worst case\noccurs when capacity is exhausted and needs a resize. The resize cost\nhas been amortized in the previous figures.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_sorted_vec\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#644\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_sorted_vec\" class=\"fn\">into_sorted_vec</a>(self) -&gt; <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Consumes the <code>BinaryHeap</code> and returns a vector in sorted\n(ascending) order.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>]);\nheap.push(<span class=\"number\">6</span>);\nheap.push(<span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>vec = heap.into_sorted_vec();\n<span class=\"macro\">assert_eq!</span>(vec, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+2,+4,+5,+7%5D);%0A++++heap.push(6);%0A++++heap.push(3);%0A++++%0A++++let+vec+=+heap.into_sorted_vec();%0A++++assert_eq!(vec,+%5B1,+2,+3,+4,+5,+6,+7%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.append\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.11.0\">1.11.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#863\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.append\" class=\"fn\">append</a>(&amp;mut self, other: &amp;mut <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;)</h4></section></summary><div class=\"docblock\"><p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BinaryHeap::from([-<span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>]);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>b = BinaryHeap::from([-<span class=\"number\">20</span>, <span class=\"number\">5</span>, <span class=\"number\">43</span>]);\n\na.append(<span class=\"kw-2\">&amp;mut </span>b);\n\n<span class=\"macro\">assert_eq!</span>(a.into_sorted_vec(), [-<span class=\"number\">20</span>, -<span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">43</span>]);\n<span class=\"macro\">assert!</span>(b.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+a+=+BinaryHeap::from(%5B-10,+1,+2,+3,+3%5D);%0A++++let+mut+b+=+BinaryHeap::from(%5B-20,+5,+43%5D);%0A++++%0A++++a.append(%26mut+b);%0A++++%0A++++assert_eq!(a.into_sorted_vec(),+%5B-20,+-10,+1,+2,+3,+3,+5,+43%5D);%0A++++assert!(b.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.drain_sorted\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#902\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.drain_sorted\" class=\"fn\">drain_sorted</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"binary_heap/struct.DrainSorted.html\" title=\"struct std::collections::binary_heap::DrainSorted\">DrainSorted</a>&lt;'_, T, A&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"DrainSorted<'_, T, A>\">â“˜</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>binary_heap_drain_sorted</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/59278\">#59278</a>)</span></div></span></summary><div class=\"docblock\"><p>Clears the binary heap, returning an iterator over the removed elements\nin heap order. If the iterator is dropped before being fully consumed,\nit drops the remaining elements in heap order.</p>\n<p>The returned iterator keeps a mutable borrow on the heap to optimize\nits implementation.</p>\n<p>Note:</p>\n<ul>\n<li><code>.drain_sorted()</code> is <em>O</em>(<em>n</em> * log(<em>n</em>)); much slower than <code>.drain()</code>.\nYou should use the latter for most cases.</li>\n</ul>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(binary_heap_drain_sorted)]\n</span><span class=\"kw\">use </span>std::collections::BinaryHeap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);\n<span class=\"macro\">assert_eq!</span>(heap.len(), <span class=\"number\">5</span>);\n\ndrop(heap.drain_sorted()); <span class=\"comment\">// removes all elements in heap order\n</span><span class=\"macro\">assert_eq!</span>(heap.len(), <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(binary_heap_drain_sorted)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5%5D);%0A++++assert_eq!(heap.len(),+5);%0A++++%0A++++drop(heap.drain_sorted());+//+removes+all+elements+in+heap+order%0A++++assert_eq!(heap.len(),+0);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.retain\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.70.0\">1.70.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#925-927\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.retain\" class=\"fn\">retain</a>&lt;F&gt;(&amp;mut self, f: F)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Retains only the elements specified by the predicate.</p>\n<p>In other words, remove all elements <code>e</code> for which <code>f(&amp;e)</code> returns\n<code>false</code>. The elements are visited in unsorted (and unspecified) order.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::from([-<span class=\"number\">10</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">13</span>]);\n\nheap.retain(|x| x % <span class=\"number\">2 </span>== <span class=\"number\">0</span>); <span class=\"comment\">// only keep even numbers\n\n</span><span class=\"macro\">assert_eq!</span>(heap.into_sorted_vec(), [-<span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+heap+=+BinaryHeap::from(%5B-10,+-5,+1,+2,+4,+13%5D);%0A++++%0A++++heap.retain(%7Cx%7C+x+%25+2+==+0);+//+only+keep+even+numbers%0A++++%0A++++assert_eq!(heap.into_sorted_vec(),+%5B-10,+2,+4%5D)%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BinaryHeap%3CT,+A%3E-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#945\">source</a><a href=\"#impl-BinaryHeap%3CT,+A%3E-1\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.iter\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#963\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.iter\" class=\"fn\">iter</a>(&amp;self) -&gt; <a class=\"struct\" href=\"binary_heap/struct.Iter.html\" title=\"struct std::collections::binary_heap::Iter\">Iter</a>&lt;'_, T&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Iter<'_, T>\">â“˜</a></h4></section></summary><div class=\"docblock\"><p>Returns an iterator visiting all values in the underlying vector, in\narbitrary order.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);\n\n<span class=\"comment\">// Print 1, 2, 3, 4 in arbitrary order\n</span><span class=\"kw\">for </span>x <span class=\"kw\">in </span>heap.iter() {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4%5D);%0A++++%0A++++//+Print+1,+2,+3,+4+in+arbitrary+order%0A++++for+x+in+heap.iter()+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_iter_sorted\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#982\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.into_iter_sorted\" class=\"fn\">into_iter_sorted</a>(self) -&gt; <a class=\"struct\" href=\"binary_heap/struct.IntoIterSorted.html\" title=\"struct std::collections::binary_heap::IntoIterSorted\">IntoIterSorted</a>&lt;T, A&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IntoIterSorted<T, A>\">â“˜</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>binary_heap_into_iter_sorted</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/59278\">#59278</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns an iterator which retrieves elements in heap order.\nThis method consumes the original heap.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(binary_heap_into_iter_sorted)]\n</span><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);\n\n<span class=\"macro\">assert_eq!</span>(heap.into_iter_sorted().take(<span class=\"number\">2</span>).collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), [<span class=\"number\">5</span>, <span class=\"number\">4</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(binary_heap_into_iter_sorted)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5%5D);%0A++++%0A++++assert_eq!(heap.into_iter_sorted().take(2).collect::%3CVec%3C_%3E%3E(),+%5B5,+4%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.peek\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1009\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.peek\" class=\"fn\">peek</a>(&amp;self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the greatest item in the binary heap, or <code>None</code> if it is empty.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\n<span class=\"macro\">assert_eq!</span>(heap.peek(), <span class=\"prelude-val\">None</span>);\n\nheap.push(<span class=\"number\">1</span>);\nheap.push(<span class=\"number\">5</span>);\nheap.push(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(heap.peek(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>));\n</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++assert_eq!(heap.peek(),+None);%0A++++%0A++++heap.push(1);%0A++++heap.push(5);%0A++++heap.push(2);%0A++++assert_eq!(heap.peek(),+Some(%265));%0A%7D&amp;edition=2021\">Run</a></div>\n<h5 id=\"time-complexity-4\"><a class=\"doc-anchor\" href=\"#time-complexity-4\">Â§</a>Time complexity</h5>\n<p>Cost is <em>O</em>(1) in the worst case.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.capacity\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1027\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.capacity\" class=\"fn\">capacity</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of elements the binary heap can hold without reallocating.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::with_capacity(<span class=\"number\">100</span>);\n<span class=\"macro\">assert!</span>(heap.capacity() &gt;= <span class=\"number\">100</span>);\nheap.push(<span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::with_capacity(100);%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.push(4);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.reserve_exact\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1058\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.reserve_exact\" class=\"fn\">reserve_exact</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Reserves the minimum capacity for at least <code>additional</code> elements more than\nthe current length. Unlike <a href=\"struct.BinaryHeap.html#method.reserve\" title=\"method std::collections::BinaryHeap::reserve\"><code>reserve</code></a>, this will not\ndeliberately over-allocate to speculatively avoid frequent allocations.\nAfter calling <code>reserve_exact</code>, capacity will be greater than or equal to\n<code>self.len() + additional</code>. Does nothing if the capacity is already\nsufficient.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">Â§</a>Panics</h5>\n<p>Panics if the new capacity overflows <a href=\"../primitive.usize.html\" title=\"primitive usize\"><code>usize</code></a>.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\nheap.reserve_exact(<span class=\"number\">100</span>);\n<span class=\"macro\">assert!</span>(heap.capacity() &gt;= <span class=\"number\">100</span>);\nheap.push(<span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.reserve_exact(100);%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.push(4);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.reserve\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1084\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.reserve\" class=\"fn\">reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Reserves capacity for at least <code>additional</code> elements more than the\ncurrent length. The allocator may reserve more space to speculatively\navoid frequent allocations. After calling <code>reserve</code>,\ncapacity will be greater than or equal to <code>self.len() + additional</code>.\nDoes nothing if capacity is already sufficient.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">Â§</a>Panics</h5>\n<p>Panics if the new capacity overflows <a href=\"../primitive.usize.html\" title=\"primitive usize\"><code>usize</code></a>.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\nheap.reserve(<span class=\"number\">100</span>);\n<span class=\"macro\">assert!</span>(heap.capacity() &gt;= <span class=\"number\">100</span>);\nheap.push(<span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.reserve(100);%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.push(4);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_reserve_exact\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.63.0\">1.63.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1126\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.try_reserve_exact\" class=\"fn\">try_reserve_exact</a>(\n    &amp;mut self,\n    additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"struct.TryReserveError.html\" title=\"struct std::collections::TryReserveError\">TryReserveError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to reserve the minimum capacity for at least <code>additional</code> elements\nmore than the current length. Unlike <a href=\"struct.BinaryHeap.html#method.try_reserve\" title=\"method std::collections::BinaryHeap::try_reserve\"><code>try_reserve</code></a>, this will not\ndeliberately over-allocate to speculatively avoid frequent allocations.\nAfter calling <code>try_reserve_exact</code>, capacity will be greater than or\nequal to <code>self.len() + additional</code> if it returns <code>Ok(())</code>.\nDoes nothing if the capacity is already sufficient.</p>\n<p>Note that the allocator may give the collection more space than it\nrequests. Therefore, capacity can not be relied upon to be precisely\nminimal. Prefer <a href=\"struct.BinaryHeap.html#method.try_reserve\" title=\"method std::collections::BinaryHeap::try_reserve\"><code>try_reserve</code></a> if future insertions are expected.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">Â§</a>Errors</h5>\n<p>If the capacity overflows, or the allocator reports a failure, then an error\nis returned.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">use </span>std::collections::TryReserveError;\n\n<span class=\"kw\">fn </span>find_max_slow(data: <span class=\"kw-2\">&amp;</span>[u32]) -&gt; <span class=\"prelude-ty\">Result</span>&lt;<span class=\"prelude-ty\">Option</span>&lt;u32&gt;, TryReserveError&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\n\n    <span class=\"comment\">// Pre-reserve the memory, exiting if we can't\n    </span>heap.try_reserve_exact(data.len())<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// Now we know this can't OOM in the middle of our complex work\n    </span>heap.extend(data.iter());\n\n    <span class=\"prelude-val\">Ok</span>(heap.pop())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+find_max_slow(data:+%26%5Bu32%5D)+-%3E+Result%3COption%3Cu32%3E,+TryReserveError%3E+%7B%0A++++++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can't%0A++++++++heap.try_reserve_exact(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can't+OOM+in+the+middle+of+our+complex+work%0A++++++++heap.extend(data.iter());%0A++++%0A++++++++Ok(heap.pop())%0A++++%7D%0A++++find_max_slow(%26%5B1,+2,+3%5D).expect(%22why+is+the+test+harness+OOMing+on+12+bytes?%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_reserve\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.63.0\">1.63.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1162\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.try_reserve\" class=\"fn\">try_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"struct.TryReserveError.html\" title=\"struct std::collections::TryReserveError\">TryReserveError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to reserve capacity for at least <code>additional</code> elements more than the\ncurrent length. The allocator may reserve more space to speculatively\navoid frequent allocations. After calling <code>try_reserve</code>, capacity will be\ngreater than or equal to <code>self.len() + additional</code> if it returns\n<code>Ok(())</code>. Does nothing if capacity is already sufficient. This method\npreserves the contents even if an error occurs.</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">Â§</a>Errors</h5>\n<p>If the capacity overflows, or the allocator reports a failure, then an error\nis returned.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">use </span>std::collections::TryReserveError;\n\n<span class=\"kw\">fn </span>find_max_slow(data: <span class=\"kw-2\">&amp;</span>[u32]) -&gt; <span class=\"prelude-ty\">Result</span>&lt;<span class=\"prelude-ty\">Option</span>&lt;u32&gt;, TryReserveError&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\n\n    <span class=\"comment\">// Pre-reserve the memory, exiting if we can't\n    </span>heap.try_reserve(data.len())<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// Now we know this can't OOM in the middle of our complex work\n    </span>heap.extend(data.iter());\n\n    <span class=\"prelude-val\">Ok</span>(heap.pop())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+find_max_slow(data:+%26%5Bu32%5D)+-%3E+Result%3COption%3Cu32%3E,+TryReserveError%3E+%7B%0A++++++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can't%0A++++++++heap.try_reserve(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can't+OOM+in+the+middle+of+our+complex+work%0A++++++++heap.extend(data.iter());%0A++++%0A++++++++Ok(heap.pop())%0A++++%7D%0A++++find_max_slow(%26%5B1,+2,+3%5D).expect(%22why+is+the+test+harness+OOMing+on+12+bytes?%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.shrink_to_fit\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1181\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.shrink_to_fit\" class=\"fn\">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Discards as much additional capacity as possible.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(<span class=\"number\">100</span>);\n\n<span class=\"macro\">assert!</span>(heap.capacity() &gt;= <span class=\"number\">100</span>);\nheap.shrink_to_fit();\n<span class=\"macro\">assert!</span>(heap.capacity() == <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap:+BinaryHeap%3Ci32%3E+=+BinaryHeap::with_capacity(100);%0A++++%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.shrink_to_fit();%0A++++assert!(heap.capacity()+==+0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.shrink_to\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.56.0\">1.56.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1204\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.shrink_to\" class=\"fn\">shrink_to</a>(&amp;mut self, min_capacity: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Discards capacity with a lower bound.</p>\n<p>The capacity will remain at least as large as both the length\nand the supplied value.</p>\n<p>If the current capacity is less than the lower limit, this is a no-op.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(<span class=\"number\">100</span>);\n\n<span class=\"macro\">assert!</span>(heap.capacity() &gt;= <span class=\"number\">100</span>);\nheap.shrink_to(<span class=\"number\">10</span>);\n<span class=\"macro\">assert!</span>(heap.capacity() &gt;= <span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap:+BinaryHeap%3Ci32%3E+=+BinaryHeap::with_capacity(100);%0A++++%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.shrink_to(10);%0A++++assert!(heap.capacity()+%3E=+10);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_slice\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1225\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_slice\" class=\"fn\">as_slice</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></summary><div class=\"docblock\"><p>Returns a slice of all values in the underlying vector, in arbitrary\norder.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">use </span>std::io::{<span class=\"self\">self</span>, Write};\n\n<span class=\"kw\">let </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>]);\n\nio::sink().write(heap.as_slice()).unwrap();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::io::%7Bself,+Write%7D;%0A++++%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5,+6,+7%5D);%0A++++%0A++++io::sink().write(heap.as_slice()).unwrap();%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_vec\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1248\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_vec\" class=\"fn\">into_vec</a>(self) -&gt; <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Consumes the <code>BinaryHeap</code> and returns the underlying vector\nin arbitrary order.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>]);\n<span class=\"kw\">let </span>vec = heap.into_vec();\n\n<span class=\"comment\">// Will print in some order\n</span><span class=\"kw\">for </span>x <span class=\"kw\">in </span>vec {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5,+6,+7%5D);%0A++++let+vec+=+heap.into_vec();%0A++++%0A++++//+Will+print+in+some+order%0A++++for+x+in+vec+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.allocator\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1255\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.allocator\" class=\"fn\">allocator</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;A</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns a reference to the underlying allocator.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.len\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1274\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.len\" class=\"fn\">len</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the length of the binary heap.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">3</span>]);\n\n<span class=\"macro\">assert_eq!</span>(heap.len(), <span class=\"number\">2</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert_eq!(heap.len(),+2);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_empty\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1298\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_empty\" class=\"fn\">is_empty</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks if the binary heap is empty.</p>\n<h5 id=\"examples-25\"><a class=\"doc-anchor\" href=\"#examples-25\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::new();\n\n<span class=\"macro\">assert!</span>(heap.is_empty());\n\nheap.push(<span class=\"number\">3</span>);\nheap.push(<span class=\"number\">5</span>);\nheap.push(<span class=\"number\">1</span>);\n\n<span class=\"macro\">assert!</span>(!heap.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++assert!(heap.is_empty());%0A++++%0A++++heap.push(3);%0A++++heap.push(5);%0A++++heap.push(1);%0A++++%0A++++assert!(!heap.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.drain\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1327\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.drain\" class=\"fn\">drain</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"binary_heap/struct.Drain.html\" title=\"struct std::collections::binary_heap::Drain\">Drain</a>&lt;'_, T, A&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Drain<'_, T, A>\">â“˜</a></h4></section></summary><div class=\"docblock\"><p>Clears the binary heap, returning an iterator over the removed elements\nin arbitrary order. If the iterator is dropped before being fully\nconsumed, it drops the remaining elements in arbitrary order.</p>\n<p>The returned iterator keeps a mutable borrow on the heap to optimize\nits implementation.</p>\n<h5 id=\"examples-26\"><a class=\"doc-anchor\" href=\"#examples-26\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">3</span>]);\n\n<span class=\"macro\">assert!</span>(!heap.is_empty());\n\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span>heap.drain() {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>);\n}\n\n<span class=\"macro\">assert!</span>(heap.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert!(!heap.is_empty());%0A++++%0A++++for+x+in+heap.drain()+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A++++%0A++++assert!(heap.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clear\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1348\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.clear\" class=\"fn\">clear</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Drops all items from the binary heap.</p>\n<h5 id=\"examples-27\"><a class=\"doc-anchor\" href=\"#examples-27\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">3</span>]);\n\n<span class=\"macro\">assert!</span>(!heap.is_empty());\n\nheap.clear();\n\n<span class=\"macro\">assert!</span>(heap.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert!(!heap.is_empty());%0A++++%0A++++heap.clear();%0A++++%0A++++assert!(heap.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">Â§</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Clone-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#383\">source</a></span><a href=\"#impl-Clone-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#394\">source</a><a href=\"#method.clone_from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;<a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;)</h4></section></summary><div class=\"docblock\"><p>Overwrites the contents of <code>self</code> with a clone of the contents of <code>source</code>.</p>\n<p>This method is preferred over simply assigning <code>source.clone()</code> to <code>self</code>,\nas it avoids reallocation if possible.</p>\n<p>See <a href=\"../vec/struct.Vec.html#method.clone_from\" title=\"method std::vec::Vec::clone_from\"><code>Vec::clone_from()</code></a> for more details.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#384\">source</a><a href=\"#method.clone\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\">Returns a copy of the value. <a href=\"../clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#409\">source</a></span><a href=\"#impl-Debug-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#410\">source</a><a href=\"#method.fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-BinaryHeap%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#400\">source</a></span><a href=\"#impl-Default-for-BinaryHeap%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#403\">source</a><a href=\"#method.default\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty <code>BinaryHeap&lt;T&gt;</code>.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3C%26T%3E-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1871\">source</a></span><a href=\"#impl-Extend%3C%26T%3E-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'a, T, A&gt; <a class=\"trait\" href=\"../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a>&gt; for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    T: 'a + <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1872\">source</a><a href=\"#method.extend-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1877\">source</a><a href=\"#method.extend_one-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, _: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1882\">source</a><a href=\"#method.extend_reserve-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3CT%3E-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1852\">source</a></span><a href=\"#impl-Extend%3CT%3E-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1854\">source</a><a href=\"#method.extend\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1860\">source</a><a href=\"#method.extend_one\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, item: T)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1865\">source</a><a href=\"#method.extend_reserve\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%5BT;+N%5D%3E-for-BinaryHeap%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.56.0\">1.56.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1780\">source</a></span><a href=\"#impl-From%3C%5BT;+N%5D%3E-for-BinaryHeap%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>&gt; for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1790\">source</a><a href=\"#method.from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(arr: <a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>) -&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\">\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>h1 = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>h2: BinaryHeap&lt;<span class=\"kw\">_</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].into();\n<span class=\"kw\">while let </span><span class=\"prelude-val\">Some</span>((a, b)) = h1.pop().zip(h2.pop()) {\n    <span class=\"macro\">assert_eq!</span>(a, b);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+h1+=+BinaryHeap::from(%5B1,+4,+2,+3%5D);%0A++++let+mut+h2:+BinaryHeap%3C_%3E+=+%5B1,+4,+2,+3%5D.into();%0A++++while+let+Some((a,+b))+=+h1.pop().zip(h2.pop())+%7B%0A++++++++assert_eq!(a,+b);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CBinaryHeap%3CT,+A%3E%3E-for-Vec%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1796\">source</a></span><a href=\"#impl-From%3CBinaryHeap%3CT,+A%3E%3E-for-Vec%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;&gt; for <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1801\">source</a><a href=\"#method.from-2\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(heap: <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;) -&gt; <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <code>BinaryHeap&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.</p>\n<p>This conversion requires no data movement or allocation, and has\nconstant time complexity.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CVec%3CT,+A%3E%3E-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1768\">source</a></span><a href=\"#impl-From%3CVec%3CT,+A%3E%3E-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;&gt; for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1772\">source</a><a href=\"#method.from-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(vec: <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;) -&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <code>Vec&lt;T&gt;</code> into a <code>BinaryHeap&lt;T&gt;</code>.</p>\n<p>This conversion happens in-place, and has <em>O</em>(<em>n</em>) time complexity.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3CT%3E-for-BinaryHeap%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1807\">source</a></span><a href=\"#impl-FromIterator%3CT%3E-for-BinaryHeap%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1808\">source</a><a href=\"#method.from_iter\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-IntoIterator-for-%26BinaryHeap%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1842\">source</a></span><a href=\"#impl-IntoIterator-for-%26BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'a, T, A&gt; <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a> for &amp;'a <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Item\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../iter/trait.IntoIterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></summary><div class=\"docblock\">The type of the elements being iterated over.</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.IntoIter\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.IntoIter\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../iter/trait.IntoIterator.html#associatedtype.IntoIter\" class=\"associatedtype\">IntoIter</a> = <a class=\"struct\" href=\"binary_heap/struct.Iter.html\" title=\"struct std::collections::binary_heap::Iter\">Iter</a>&lt;'a, T&gt;</h4></section></summary><div class=\"docblock\">Which kind of iterator are we turning this into?</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_iter\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1846\">source</a><a href=\"#method.into_iter\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.IntoIterator.html#tymethod.into_iter\" class=\"fn\">into_iter</a>(self) -&gt; <a class=\"struct\" href=\"binary_heap/struct.Iter.html\" title=\"struct std::collections::binary_heap::Iter\">Iter</a>&lt;'a, T&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Iter<'a, T>\">â“˜</a></h4></section></summary><div class=\"docblock\">Creates an iterator from a value. <a href=\"../iter/trait.IntoIterator.html#tymethod.into_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-IntoIterator-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1814\">source</a></span><a href=\"#impl-IntoIterator-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_iter-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1836\">source</a><a href=\"#method.into_iter-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.IntoIterator.html#tymethod.into_iter\" class=\"fn\">into_iter</a>(self) -&gt; <a class=\"struct\" href=\"binary_heap/struct.IntoIter.html\" title=\"struct std::collections::binary_heap::IntoIter\">IntoIter</a>&lt;T, A&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IntoIter<T, A>\">â“˜</a></h4></section></summary><div class=\"docblock\"><p>Creates a consuming iterator, that is, one that moves each value out of\nthe binary heap in arbitrary order. The binary heap cannot be used\nafter calling this.</p>\n<h5 id=\"examples-28\"><a class=\"doc-anchor\" href=\"#examples-28\">Â§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BinaryHeap;\n<span class=\"kw\">let </span>heap = BinaryHeap::from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);\n\n<span class=\"comment\">// Print 1, 2, 3, 4 in arbitrary order\n</span><span class=\"kw\">for </span>x <span class=\"kw\">in </span>heap.into_iter() {\n    <span class=\"comment\">// x has type i32, not &amp;i32\n    </span><span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4%5D);%0A++++%0A++++//+Print+1,+2,+3,+4+in+arbitrary+order%0A++++for+x+in+heap.into_iter()+%7B%0A++++++++//+x+has+type+i32,+not+%26i32%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Item-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../iter/trait.IntoIterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></summary><div class=\"docblock\">The type of the elements being iterated over.</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.IntoIter-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.IntoIter-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../iter/trait.IntoIterator.html#associatedtype.IntoIter\" class=\"associatedtype\">IntoIter</a> = <a class=\"struct\" href=\"binary_heap/struct.IntoIter.html\" title=\"struct std::collections::binary_heap::IntoIter\">IntoIter</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\">Which kind of iterator are we turning this into?</div></details></div></details></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">Â§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Freeze-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a>,</div></h3></section><section id=\"impl-RefUnwindSafe-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a>,\n    T: <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a>,</div></h3></section><section id=\"impl-Send-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Send-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>,\n    T: <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>,</div></h3></section><section id=\"impl-Sync-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Sync-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a>,\n    T: <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a>,</div></h3></section><section id=\"impl-Unpin-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Unpin-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a>,\n    T: <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a>,</div></h3></section><section id=\"impl-UnwindSafe-for-BinaryHeap%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-UnwindSafe-for-BinaryHeap%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a>,\n    T: <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a>,</div></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">Â§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from-3\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToOwned-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85\">source</a><a href=\"#impl-ToOwned-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Owned\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88\">source</a><a href=\"#method.to_owned\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\">Creates owned data from borrowed data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92\">source</a><a href=\"#method.clone_into\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>)</h4></section></summary><div class=\"docblock\">Uses borrowed data to replace owned data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div><script type=\"text/json\" id=\"notable-traits-data\">{\"Drain<'_, T, A>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"binary_heap/struct.Drain.html\\\" title=\\\"struct std::collections::binary_heap::Drain\\\">Drain</a>&lt;'_, T, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;T, A&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"binary_heap/struct.Drain.html\\\" title=\\\"struct std::collections::binary_heap::Drain\\\">Drain</a>&lt;'_, T, A&gt;<div class=\\\"where\\\">where\\n    A: <a class=\\\"trait\\\" href=\\\"../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = T;</div>\",\"DrainSorted<'_, T, A>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"binary_heap/struct.DrainSorted.html\\\" title=\\\"struct std::collections::binary_heap::DrainSorted\\\">DrainSorted</a>&lt;'_, T, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;T, A&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"binary_heap/struct.DrainSorted.html\\\" title=\\\"struct std::collections::binary_heap::DrainSorted\\\">DrainSorted</a>&lt;'_, T, A&gt;<div class=\\\"where\\\">where\\n    T: <a class=\\\"trait\\\" href=\\\"../cmp/trait.Ord.html\\\" title=\\\"trait std::cmp::Ord\\\">Ord</a>,\\n    A: <a class=\\\"trait\\\" href=\\\"../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = T;</div>\",\"IntoIter<T, A>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"binary_heap/struct.IntoIter.html\\\" title=\\\"struct std::collections::binary_heap::IntoIter\\\">IntoIter</a>&lt;T, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;T, A&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"binary_heap/struct.IntoIter.html\\\" title=\\\"struct std::collections::binary_heap::IntoIter\\\">IntoIter</a>&lt;T, A&gt;<div class=\\\"where\\\">where\\n    A: <a class=\\\"trait\\\" href=\\\"../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = T;</div>\",\"IntoIterSorted<T, A>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"binary_heap/struct.IntoIterSorted.html\\\" title=\\\"struct std::collections::binary_heap::IntoIterSorted\\\">IntoIterSorted</a>&lt;T, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;T, A&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"binary_heap/struct.IntoIterSorted.html\\\" title=\\\"struct std::collections::binary_heap::IntoIterSorted\\\">IntoIterSorted</a>&lt;T, A&gt;<div class=\\\"where\\\">where\\n    T: <a class=\\\"trait\\\" href=\\\"../cmp/trait.Ord.html\\\" title=\\\"trait std::cmp::Ord\\\">Ord</a>,\\n    A: <a class=\\\"trait\\\" href=\\\"../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = T;</div>\",\"Iter<'_, T>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"binary_heap/struct.Iter.html\\\" title=\\\"struct std::collections::binary_heap::Iter\\\">Iter</a>&lt;'a, T&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, T&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"binary_heap/struct.Iter.html\\\" title=\\\"struct std::collections::binary_heap::Iter\\\">Iter</a>&lt;'a, T&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../primitive.reference.html\\\">&amp;'a T</a>;</div>\",\"Iter<'a, T>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"binary_heap/struct.Iter.html\\\" title=\\\"struct std::collections::binary_heap::Iter\\\">Iter</a>&lt;'a, T&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, T&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"binary_heap/struct.Iter.html\\\" title=\\\"struct std::collections::binary_heap::Iter\\\">Iter</a>&lt;'a, T&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../primitive.reference.html\\\">&amp;'a T</a>;</div>\"}</script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:13:57.384Z"
}