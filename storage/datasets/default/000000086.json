{
	"title": "Pattern Syntax - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch18-03-pattern-syntax.html",
	"markdown": "# Pattern Syntax - The Rust Programming Language\n\nIn this section, we gather all the syntax valid in patterns and discuss why and when you might want to use each one.\n\n### [Matching Literals](#matching-literals)\n\nAs you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:\n\n```rust\nfn main() {\n    let x = 1;\n\n    match x {\n        1 => println!(\"one\"),\n        2 => println!(\"two\"),\n        3 => println!(\"three\"),\n        _ => println!(\"anything\"),\n    }\n}\n```\n\nThis code prints `one` because the value in `x` is 1. This syntax is useful when you want your code to take an action if it gets a particular concrete value.\n\n### [Matching Named Variables](#matching-named-variables)\n\nNamed variables are irrefutable patterns that match any value, and we’ve used them many times in the book. However, there is a complication when you use named variables in `match` expressions. Because `match` starts a new scope, variables declared as part of a pattern inside the `match` expression will shadow those with the same name outside the `match` construct, as is the case with all variables. In Listing 18-11, we declare a variable named `x` with the value `Some(5)` and a variable `y` with the value `10`. We then create a `match` expression on the value `x`. Look at the patterns in the match arms and `println!` at the end, and try to figure out what the code will print before running this code or reading further.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(y) => println!(\"Matched, y = {y}\"),\n        _ => println!(\"Default case, x = {x:?}\"),\n    }\n\n    println!(\"at the end: x = {x:?}, y = {y}\");\n}\n```\n\nListing 18-11: A `match` expression with an arm that introduces a shadowed variable `y`\n\nLet’s walk through what happens when the `match` expression runs. The pattern in the first match arm doesn’t match the defined value of `x`, so the code continues.\n\nThe pattern in the second match arm introduces a new variable named `y` that will match any value inside a `Some` value. Because we’re in a new scope inside the `match` expression, this is a new `y` variable, not the `y` we declared at the beginning with the value 10. This new `y` binding will match any value inside a `Some`, which is what we have in `x`. Therefore, this new `y` binds to the inner value of the `Some` in `x`. That value is `5`, so the expression for that arm executes and prints `Matched, y = 5`.\n\nIf `x` had been a `None` value instead of `Some(5)`, the patterns in the first two arms wouldn’t have matched, so the value would have matched to the underscore. We didn’t introduce the `x` variable in the pattern of the underscore arm, so the `x` in the expression is still the outer `x` that hasn’t been shadowed. In this hypothetical case, the `match` would print `Default case, x = None`.\n\nWhen the `match` expression is done, its scope ends, and so does the scope of the inner `y`. The last `println!` produces `at the end: x = Some(5), y = 10`.\n\nTo create a `match` expression that compares the values of the outer `x` and `y`, rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We’ll talk about match guards later in the [“Extra Conditionals with Match Guards”](#extra-conditionals-with-match-guards) section.\n\n### [Multiple Patterns](#multiple-patterns)\n\nIn `match` expressions, you can match multiple patterns using the `|` syntax, which is the pattern _or_ operator. For example, in the following code we match the value of `x` against the match arms, the first of which has an _or_ option, meaning if the value of `x` matches either of the values in that arm, that arm’s code will run:\n\n```rust\nfn main() {\n    let x = 1;\n\n    match x {\n        1 | 2 => println!(\"one or two\"),\n        3 => println!(\"three\"),\n        _ => println!(\"anything\"),\n    }\n}\n```\n\nThis code prints `one or two`.\n\n### [Matching Ranges of Values with `..=`](#matching-ranges-of-values-with-)\n\nThe `..=` syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the given range, that arm will execute:\n\n```rust\nfn main() {\n    let x = 5;\n\n    match x {\n        1..=5 => println!(\"one through five\"),\n        _ => println!(\"something else\"),\n    }\n}\n```\n\nIf `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient for multiple match values than using the `|` operator to express the same idea; if we were to use `|` we would have to specify `1 | 2 | 3 | 4 | 5`. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!\n\nThe compiler checks that the range isn’t empty at compile time, and because the only types for which Rust can tell if a range is empty or not are `char` and numeric values, ranges are only allowed with numeric or `char` values.\n\nHere is an example using ranges of `char` values:\n\n```rust\nfn main() {\n    let x = 'c';\n\n    match x {\n        'a'..='j' => println!(\"early ASCII letter\"),\n        'k'..='z' => println!(\"late ASCII letter\"),\n        _ => println!(\"something else\"),\n    }\n}\n```\n\nRust can tell that `'c'` is within the first pattern’s range and prints `early ASCII letter`.\n\n### [Destructuring to Break Apart Values](#destructuring-to-break-apart-values)\n\nWe can also use patterns to destructure structs, enums, and tuples to use different parts of these values. Let’s walk through each value.\n\n#### [Destructuring Structs](#destructuring-structs)\n\nListing 18-12 shows a `Point` struct with two fields, `x` and `y`, that we can break apart using a pattern with a `let` statement.\n\nFilename: src/main.rs\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}\n```\n\nListing 18-12: Destructuring a struct’s fields into separate variables\n\nThis code creates the variables `a` and `b` that match the values of the `x` and `y` fields of the `p` struct. This example shows that the names of the variables in the pattern don’t have to match the field names of the struct. However, it’s common to match the variable names to the field names to make it easier to remember which variables came from which fields. Because of this common usage, and because writing `let Point { x: x, y: y } = p;` contains a lot of duplication, Rust has a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 18-13 behaves in the same way as the code in Listing 18-12, but the variables created in the `let` pattern are `x` and `y` instead of `a` and `b`.\n\nFilename: src/main.rs\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x, y } = p;\n    assert_eq!(0, x);\n    assert_eq!(7, y);\n}\n```\n\nListing 18-13: Destructuring struct fields using struct field shorthand\n\nThis code creates the variables `x` and `y` that match the `x` and `y` fields of the `p` variable. The outcome is that the variables `x` and `y` contain the values from the `p` struct.\n\nWe can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.\n\nIn Listing 18-14, we have a `match` expression that separates `Point` values into three cases: points that lie directly on the `x` axis (which is true when `y = 0`), on the `y` axis (`x = 0`), or neither.\n\nFilename: src/main.rs\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!(\"On the x axis at {x}\"),\n        Point { x: 0, y } => println!(\"On the y axis at {y}\"),\n        Point { x, y } => {\n            println!(\"On neither axis: ({x}, {y})\");\n        }\n    }\n}\n```\n\nListing 18-14: Destructuring and matching literal values in one pattern\n\nThe first arm will match any point that lies on the `x` axis by specifying that the `y` field matches if its value matches the literal `0`. The pattern still creates an `x` variable that we can use in the code for this arm.\n\nSimilarly, the second arm matches any point on the `y` axis by specifying that the `x` field matches if its value is `0` and creates a variable `y` for the value of the `y` field. The third arm doesn’t specify any literals, so it matches any other `Point` and creates variables for both the `x` and `y` fields.\n\nIn this example, the value `p` matches the second arm by virtue of `x` containing a 0, so this code will print `On the y axis at 7`.\n\nRemember that a `match` expression stops checking arms once it has found the first matching pattern, so even though `Point { x: 0, y: 0}` is on the `x` axis and the `y` axis, this code would only print `On the x axis at 0`.\n\n#### [Destructuring Enums](#destructuring-enums)\n\nWe’ve destructured enums in this book (for example, Listing 6-5 in Chapter 6), but haven’t yet explicitly discussed that the pattern to destructure an enum corresponds to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the `Message` enum from Listing 6-2 and write a `match` with patterns that will destructure each inner value.\n\nFilename: src/main.rs\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\");\n        }\n        Message::Move { x, y } => {\n            println!(\"Move in the x direction {x} and in the y direction {y}\");\n        }\n        Message::Write(text) => {\n            println!(\"Text message: {text}\");\n        }\n        Message::ChangeColor(r, g, b) => {\n            println!(\"Change the color to red {r}, green {g}, and blue {b}\")\n        }\n    }\n}\n```\n\nListing 18-15: Destructuring enum variants that hold different kinds of values\n\nThis code will print `Change the color to red 0, green 160, and blue 255`. Try changing the value of `msg` to see the code from the other arms run.\n\nFor enum variants without any data, like `Message::Quit`, we can’t destructure the value any further. We can only match on the literal `Message::Quit` value, and no variables are in that pattern.\n\nFor struct-like enum variants, such as `Message::Move`, we can use a pattern similar to the pattern we specify to match structs. After the variant name, we place curly brackets and then list the fields with variables so we break apart the pieces to use in the code for this arm. Here we use the shorthand form as we did in Listing 18-13.\n\nFor tuple-like enum variants, like `Message::Write` that holds a tuple with one element and `Message::ChangeColor` that holds a tuple with three elements, the pattern is similar to the pattern we specify to match tuples. The number of variables in the pattern must match the number of elements in the variant we’re matching.\n\n#### [Destructuring Nested Structs and Enums](#destructuring-nested-structs-and-enums)\n\nSo far, our examples have all been matching structs or enums one level deep, but matching can work on nested items too! For example, we can refactor the code in Listing 18-15 to support RGB and HSV colors in the `ChangeColor` message, as shown in Listing 18-16.\n\n```rust\nenum Color {\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => {\n            println!(\"Change color to red {r}, green {g}, and blue {b}\");\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) => {\n            println!(\"Change color to hue {h}, saturation {s}, value {v}\")\n        }\n        _ => (),\n    }\n}\n```\n\nListing 18-16: Matching on nested enums\n\nThe pattern of the first arm in the `match` expression matches a `Message::ChangeColor` enum variant that contains a `Color::Rgb` variant; then the pattern binds to the three inner `i32` values. The pattern of the second arm also matches a `Message::ChangeColor` enum variant, but the inner enum matches `Color::Hsv` instead. We can specify these complex conditions in one `match` expression, even though two enums are involved.\n\n#### [Destructuring Structs and Tuples](#destructuring-structs-and-tuples)\n\nWe can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:\n\n```rust\nfn main() {\n    struct Point {\n        x: i32,\n        y: i32,\n    }\n\n    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });\n}\n```\n\nThis code lets us break complex types into their component parts so we can use the values we’re interested in separately.\n\nDestructuring with patterns is a convenient way to use pieces of values, such as the value from each field in a struct, separately from each other.\n\n### [Ignoring Values in a Pattern](#ignoring-values-in-a-pattern)\n\nYou’ve seen that it’s sometimes useful to ignore values in a pattern, such as in the last arm of a `match`, to get a catchall that doesn’t actually do anything but does account for all remaining possible values. There are a few ways to ignore entire values or parts of values in a pattern: using the `_` pattern (which you’ve seen), using the `_` pattern within another pattern, using a name that starts with an underscore, or using `..` to ignore remaining parts of a value. Let’s explore how and why to use each of these patterns.\n\n#### [Ignoring an Entire Value with `_`](#ignoring-an-entire-value-with-_)\n\nWe’ve used the underscore as a wildcard pattern that will match any value but not bind to the value. This is especially useful as the last arm in a `match` expression, but we can also use it in any pattern, including function parameters, as shown in Listing 18-17.\n\nFilename: src/main.rs\n\n```rust\nfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {y}\");\n}\n\nfn main() {\n    foo(3, 4);\n}\n```\n\nListing 18-17: Using `_` in a function signature\n\nThis code will completely ignore the value `3` passed as the first argument, and will print `This code only uses the y parameter: 4`.\n\nIn most cases when you no longer need a particular function parameter, you would change the signature so it doesn’t include the unused parameter. Ignoring a function parameter can be especially useful in cases when, for example, you’re implementing a trait when you need a certain type signature but the function body in your implementation doesn’t need one of the parameters. You then avoid getting a compiler warning about unused function parameters, as you would if you used a name instead.\n\n#### [Ignoring Parts of a Value with a Nested `_`](#ignoring-parts-of-a-value-with-a-nested-_)\n\nWe can also use `_` inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting’s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.\n\n```rust\nfn main() {\n    let mut setting_value = Some(5);\n    let new_setting_value = Some(10);\n\n    match (setting_value, new_setting_value) {\n        (Some(_), Some(_)) => {\n            println!(\"Can't overwrite an existing customized value\");\n        }\n        _ => {\n            setting_value = new_setting_value;\n        }\n    }\n\n    println!(\"setting is {setting_value:?}\");\n}\n```\n\nListing 18-18: Using an underscore within patterns that match `Some` variants when we don’t need to use the value inside the `Some`\n\nThis code will print `Can't overwrite an existing customized value` and then `setting is Some(5)`. In the first match arm, we don’t need to match on or use the values inside either `Some` variant, but we do need to test for the case when `setting_value` and `new_setting_value` are the `Some` variant. In that case, we print the reason for not changing `setting_value`, and it doesn’t get changed.\n\nIn all other cases (if either `setting_value` or `new_setting_value` are `None`) expressed by the `_` pattern in the second arm, we want to allow `new_setting_value` to become `setting_value`.\n\nWe can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.\n\n```rust\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, _, third, _, fifth) => {\n            println!(\"Some numbers: {first}, {third}, {fifth}\")\n        }\n    }\n}\n```\n\nListing 18-19: Ignoring multiple parts of a tuple\n\nThis code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will be ignored.\n\n#### [Ignoring an Unused Variable by Starting Its Name with `_`](#ignoring-an-unused-variable-by-starting-its-name-with-_)\n\nIf you create a variable but don’t use it anywhere, Rust will usually issue a warning because an unused variable could be a bug. However, sometimes it’s useful to be able to create a variable you won’t use yet, such as when you’re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we compile this code, we should only get a warning about one of them.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let _x = 5;\n    let y = 10;\n}\n```\n\nListing 18-20: Starting a variable name with an underscore to avoid getting unused variable warnings\n\nHere we get a warning about not using the variable `y`, but we don’t get a warning about not using `_x`.\n\nNote that there is a subtle difference between using only `_` and using a name that starts with an underscore. The syntax `_x` still binds the value to the variable, whereas `_` doesn’t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.\n\n```rust\nfn main() {\n    let s = Some(String::from(\"Hello!\"));\n\n    if let Some(_s) = s {\n        println!(\"found a string\");\n    }\n\n    println!(\"{s:?}\");\n}\n```\n\nListing 18-21: An unused variable starting with an underscore still binds the value, which might take ownership of the value\n\nWe’ll receive an error because the `s` value will still be moved into `_s`, which prevents us from using `s` again. However, using the underscore by itself doesn’t ever bind to the value. Listing 18-22 will compile without any errors because `s` doesn’t get moved into `_`.\n\n```rust\nfn main() {\n    let s = Some(String::from(\"Hello!\"));\n\n    if let Some(_) = s {\n        println!(\"found a string\");\n    }\n\n    println!(\"{s:?}\");\n}\n```\n\nListing 18-22: Using an underscore does not bind the value\n\nThis code works just fine because we never bind `s` to anything; it isn’t moved.\n\n#### [Ignoring Remaining Parts of a Value with `..`](#ignoring-remaining-parts-of-a-value-with-)\n\nWith values that have many parts, we can use the `..` syntax to use specific parts and ignore the rest, avoiding the need to list underscores for each ignored value. The `..` pattern ignores any parts of a value that we haven’t explicitly matched in the rest of the pattern. In Listing 18-23, we have a `Point` struct that holds a coordinate in three-dimensional space. In the `match` expression, we want to operate only on the `x` coordinate and ignore the values in the `y` and `z` fields.\n\n```rust\nfn main() {\n    struct Point {\n        x: i32,\n        y: i32,\n        z: i32,\n    }\n\n    let origin = Point { x: 0, y: 0, z: 0 };\n\n    match origin {\n        Point { x, .. } => println!(\"x is {x}\"),\n    }\n}\n```\n\nListing 18-23: Ignoring all fields of a `Point` except for `x` by using `..`\n\nWe list the `x` value and then just include the `..` pattern. This is quicker than having to list `y: _` and `z: _`, particularly when we’re working with structs that have lots of fields in situations where only one or two fields are relevant.\n\nThe syntax `..` will expand to as many values as it needs to be. Listing 18-24 shows how to use `..` with a tuple.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!(\"Some numbers: {first}, {last}\");\n        }\n    }\n}\n```\n\nListing 18-24: Matching only the first and last values in a tuple and ignoring all other values\n\nIn this code, the first and last value are matched with `first` and `last`. The `..` will match and ignore everything in the middle.\n\nHowever, using `..` must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using `..` ambiguously, so it will not compile.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (.., second, ..) => {\n            println!(\"Some numbers: {second}\")\n        },\n    }\n}\n```\n\nListing 18-25: An attempt to use `..` in an ambiguous way\n\nWhen we compile this example, we get this error:\n\n```console\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror: `..` can only be used once per tuple pattern\n --> src/main.rs:5:22\n  |\n5 |         (.., second, ..) => {\n  |          --          ^^ can only be used once per tuple pattern\n  |          |\n  |          previously used here\n\nerror: could not compile `patterns` (bin \"patterns\") due to 1 previous error\n\n```\n\nIt’s impossible for Rust to determine how many values in the tuple to ignore before matching a value with `second` and then how many further values to ignore thereafter. This code could mean that we want to ignore `2`, bind `second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to ignore `2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and so forth. The variable name `second` doesn’t mean anything special to Rust, so we get a compiler error because using `..` in two places like this is ambiguous.\n\nA _match guard_ is an additional `if` condition, specified after the pattern in a `match` arm, that must also match for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.\n\nThe condition can use variables created in the pattern. Listing 18-26 shows a `match` where the first arm has the pattern `Some(x)` and also has a match guard of `if x % 2 == 0` (which will be true if the number is even).\n\n```rust\nfn main() {\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 => println!(\"The number {x} is even\"),\n        Some(x) => println!(\"The number {x} is odd\"),\n        None => (),\n    }\n}\n```\n\nListing 18-26: Adding a match guard to a pattern\n\nThis example will print `The number 4 is even`. When `num` is compared to the pattern in the first arm, it matches, because `Some(4)` matches `Some(x)`. Then the match guard checks whether the remainder of dividing `x` by 2 is equal to 0, and because it is, the first arm is selected.\n\nIf `num` had been `Some(5)` instead, the match guard in the first arm would have been false because the remainder of 5 divided by 2 is 1, which is not equal to 0. Rust would then go to the second arm, which would match because the second arm doesn’t have a match guard and therefore matches any `Some` variant.\n\nThere is no way to express the `if x % 2 == 0` condition within a pattern, so the match guard gives us the ability to express this logic. The downside of this additional expressiveness is that the compiler doesn’t try to check for exhaustiveness when match guard expressions are involved.\n\nIn Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that we created a new variable inside the pattern in the `match` expression instead of using the variable outside the `match`. That new variable meant we couldn’t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(n) if n == y => println!(\"Matched, n = {n}\"),\n        _ => println!(\"Default case, x = {x:?}\"),\n    }\n\n    println!(\"at the end: x = {x:?}, y = {y}\");\n}\n```\n\nListing 18-27: Using a match guard to test for equality with an outer variable\n\nThis code will now print `Default case, x = Some(5)`. The pattern in the second match arm doesn’t introduce a new variable `y` that would shadow the outer `y`, meaning we can use the outer `y` in the match guard. Instead of specifying the pattern as `Some(y)`, which would have shadowed the outer `y`, we specify `Some(n)`. This creates a new variable `n` that doesn’t shadow anything because there is no `n` variable outside the `match`.\n\nThe match guard `if n == y` is not a pattern and therefore doesn’t introduce new variables. This `y` _is_ the outer `y` rather than a new shadowed `y`, and we can look for a value that has the same value as the outer `y` by comparing `n` to `y`.\n\nYou can also use the _or_ operator `|` in a match guard to specify multiple patterns; the match guard condition will apply to all the patterns. Listing 18-28 shows the precedence when combining a pattern that uses `|` with a match guard. The important part of this example is that the `if y` match guard applies to `4`, `5`, _and_ `6`, even though it might look like `if y` only applies to `6`.\n\n```rust\nfn main() {\n    let x = 4;\n    let y = false;\n\n    match x {\n        4 | 5 | 6 if y => println!(\"yes\"),\n        _ => println!(\"no\"),\n    }\n}\n```\n\nListing 18-28: Combining multiple patterns with a match guard\n\nThe match condition states that the arm only matches if the value of `x` is equal to `4`, `5`, or `6` _and_ if `y` is `true`. When this code runs, the pattern of the first arm matches because `x` is `4`, but the match guard `if y` is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints `no`. The reason is that the `if` condition applies to the whole pattern `4 | 5 | 6`, not only to the last value `6`. In other words, the precedence of a match guard in relation to a pattern behaves like this:\n\n```text\n(4 | 5 | 6) if y => ...\n\n```\n\nrather than this:\n\n```text\n4 | 5 | (6 if y) => ...\n\n```\n\nAfter running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the `|` operator, the arm would have matched and the program would have printed `yes`.\n\n### [`@` Bindings](#-bindings)\n\nThe _at_ operator `@` lets us create a variable that holds a value at the same time as we’re testing that value for a pattern match. In Listing 18-29, we want to test that a `Message::Hello` `id` field is within the range `3..=7`. We also want to bind the value to the variable `id_variable` so we can use it in the code associated with the arm. We could name this variable `id`, the same as the field, but for this example we’ll use a different name.\n\n```rust\nfn main() {\n    enum Message {\n        Hello { id: i32 },\n    }\n\n    let msg = Message::Hello { id: 5 };\n\n    match msg {\n        Message::Hello {\n            id: id_variable @ 3..=7,\n        } => println!(\"Found an id in range: {id_variable}\"),\n        Message::Hello { id: 10..=12 } => {\n            println!(\"Found an id in another range\")\n        }\n        Message::Hello { id } => println!(\"Found some other id: {id}\"),\n    }\n}\n```\n\nListing 18-29: Using `@` to bind to a value in a pattern while also testing it\n\nThis example will print `Found an id in range: 5`. By specifying `id_variable @` before the range `3..=7`, we’re capturing whatever value matched the range while also testing that the value matched the range pattern.\n\nIn the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn’t have a variable that contains the actual value of the `id` field. The `id` field’s value could have been 10, 11, or 12, but the code that goes with that pattern doesn’t know which it is. The pattern code isn’t able to use the value from the `id` field, because we haven’t saved the `id` value in a variable.\n\nIn the last arm, where we’ve specified a variable without a range, we do have the value available to use in the arm’s code in a variable named `id`. The reason is that we’ve used the struct field shorthand syntax. But we haven’t applied any test to the value in the `id` field in this arm, as we did with the first two arms: any value would match this pattern.\n\nUsing `@` lets us test a value and save it in a variable within one pattern.\n\n## [Summary](#summary)\n\nRust’s patterns are very useful in distinguishing between different kinds of data. When used in `match` expressions, Rust ensures your patterns cover every possible value, or your program won’t compile. Patterns in `let` statements and function parameters make those constructs more useful, enabling the destructuring of values into smaller parts at the same time as assigning to variables. We can create simple or complex patterns to suit our needs.\n\nNext, for the penultimate chapter of the book, we’ll look at some advanced aspects of a variety of Rust’s features.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Pattern Syntax - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"pattern-syntax\"><a class=\"header\" href=\"#pattern-syntax\">Pattern Syntax</a></h2>\n<p>In this section, we gather all the syntax valid in patterns and discuss why and\nwhen you might want to use each one.</p>\n<h3 id=\"matching-literals\"><a class=\"header\" href=\"#matching-literals\">Matching Literals</a></h3>\n<p>As you saw in Chapter 6, you can match patterns against literals directly. The\nfollowing code gives some examples:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">1</span>;\n\n    <span class=\"hljs-keyword\">match</span> x {\n        <span class=\"hljs-number\">1</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"one\"</span>),\n        <span class=\"hljs-number\">2</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"two\"</span>),\n        <span class=\"hljs-number\">3</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"three\"</span>),\n        _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"anything\"</span>),\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code prints <code class=\"hljs\">one</code> because the value in <code class=\"hljs\">x</code> is 1. This syntax is useful\nwhen you want your code to take an action if it gets a particular concrete\nvalue.</p>\n<h3 id=\"matching-named-variables\"><a class=\"header\" href=\"#matching-named-variables\">Matching Named Variables</a></h3>\n<p>Named variables are irrefutable patterns that match any value, and we’ve used\nthem many times in the book. However, there is a complication when you use\nnamed variables in <code class=\"hljs\">match</code> expressions. Because <code class=\"hljs\">match</code> starts a new scope,\nvariables declared as part of a pattern inside the <code class=\"hljs\">match</code> expression will\nshadow those with the same name outside the <code class=\"hljs\">match</code> construct, as is the case\nwith all variables. In Listing 18-11, we declare a variable named <code class=\"hljs\">x</code> with the\nvalue <code class=\"hljs\">Some(5)</code> and a variable <code class=\"hljs\">y</code> with the value <code class=\"hljs\">10</code>. We then create a\n<code class=\"hljs\">match</code> expression on the value <code class=\"hljs\">x</code>. Look at the patterns in the match arms and\n<code class=\"hljs\">println!</code> at the end, and try to figure out what the code will print before\nrunning this code or reading further.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">10</span>;\n\n    <span class=\"hljs-keyword\">match</span> x {\n        <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">50</span>) =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got 50\"</span>),\n        <span class=\"hljs-literal\">Some</span>(y) =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Matched, y = {y}\"</span>),\n        _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Default case, x = {x:?}\"</span>),\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"at the end: x = {x:?}, y = {y}\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 18-11: A <code class=\"hljs\">match</code> expression with an arm that\nintroduces a shadowed variable <code class=\"hljs\">y</code></span></p>\n<p>Let’s walk through what happens when the <code class=\"hljs\">match</code> expression runs. The pattern\nin the first match arm doesn’t match the defined value of <code class=\"hljs\">x</code>, so the code\ncontinues.</p>\n<p>The pattern in the second match arm introduces a new variable named <code class=\"hljs\">y</code> that\nwill match any value inside a <code class=\"hljs\">Some</code> value. Because we’re in a new scope inside\nthe <code class=\"hljs\">match</code> expression, this is a new <code class=\"hljs\">y</code> variable, not the <code class=\"hljs\">y</code> we declared at\nthe beginning with the value 10. This new <code class=\"hljs\">y</code> binding will match any value\ninside a <code class=\"hljs\">Some</code>, which is what we have in <code class=\"hljs\">x</code>. Therefore, this new <code class=\"hljs\">y</code> binds to\nthe inner value of the <code class=\"hljs\">Some</code> in <code class=\"hljs\">x</code>. That value is <code class=\"hljs\">5</code>, so the expression for\nthat arm executes and prints <code class=\"hljs\">Matched, y = 5</code>.</p>\n<p>If <code class=\"hljs\">x</code> had been a <code class=\"hljs\">None</code> value instead of <code class=\"hljs\">Some(5)</code>, the patterns in the first\ntwo arms wouldn’t have matched, so the value would have matched to the\nunderscore. We didn’t introduce the <code class=\"hljs\">x</code> variable in the pattern of the\nunderscore arm, so the <code class=\"hljs\">x</code> in the expression is still the outer <code class=\"hljs\">x</code> that hasn’t\nbeen shadowed. In this hypothetical case, the <code class=\"hljs\">match</code> would print <code class=\"hljs\">Default case, x = None</code>.</p>\n<p>When the <code class=\"hljs\">match</code> expression is done, its scope ends, and so does the scope of\nthe inner <code class=\"hljs\">y</code>. The last <code class=\"hljs\">println!</code> produces <code class=\"hljs\">at the end: x = Some(5), y = 10</code>.</p>\n<p>To create a <code class=\"hljs\">match</code> expression that compares the values of the outer <code class=\"hljs\">x</code> and\n<code class=\"hljs\">y</code>, rather than introducing a shadowed variable, we would need to use a match\nguard conditional instead. We’ll talk about match guards later in the <a href=\"#extra-conditionals-with-match-guards\">“Extra\nConditionals with Match Guards”</a><!--\nignore --> section.</p>\n<h3 id=\"multiple-patterns\"><a class=\"header\" href=\"#multiple-patterns\">Multiple Patterns</a></h3>\n<p>In <code class=\"hljs\">match</code> expressions, you can match multiple patterns using the <code class=\"hljs\">|</code> syntax,\nwhich is the pattern <em>or</em> operator. For example, in the following code we match\nthe value of <code class=\"hljs\">x</code> against the match arms, the first of which has an <em>or</em> option,\nmeaning if the value of <code class=\"hljs\">x</code> matches either of the values in that arm, that\narm’s code will run:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">1</span>;\n\n    <span class=\"hljs-keyword\">match</span> x {\n        <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"one or two\"</span>),\n        <span class=\"hljs-number\">3</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"three\"</span>),\n        _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"anything\"</span>),\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code prints <code class=\"hljs\">one or two</code>.</p>\n<h3 id=\"matching-ranges-of-values-with-\"><a class=\"header\" href=\"#matching-ranges-of-values-with-\">Matching Ranges of Values with <code>..=</code></a></h3>\n<p>The <code class=\"hljs\">..=</code> syntax allows us to match to an inclusive range of values. In the\nfollowing code, when a pattern matches any of the values within the given\nrange, that arm will execute:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;\n\n    <span class=\"hljs-keyword\">match</span> x {\n        <span class=\"hljs-number\">1</span>..=<span class=\"hljs-number\">5</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"one through five\"</span>),\n        _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"something else\"</span>),\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p>If <code class=\"hljs\">x</code> is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more\nconvenient for multiple match values than using the <code class=\"hljs\">|</code> operator to express the\nsame idea; if we were to use <code class=\"hljs\">|</code> we would have to specify <code class=\"hljs\">1 | 2 | 3 | 4 | 5</code>.\nSpecifying a range is much shorter, especially if we want to match, say, any\nnumber between 1 and 1,000!</p>\n<p>The compiler checks that the range isn’t empty at compile time, and because the\nonly types for which Rust can tell if a range is empty or not are <code class=\"hljs\">char</code> and\nnumeric values, ranges are only allowed with numeric or <code class=\"hljs\">char</code> values.</p>\n<p>Here is an example using ranges of <code class=\"hljs\">char</code> values:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-string\">'c'</span>;\n\n    <span class=\"hljs-keyword\">match</span> x {\n        <span class=\"hljs-string\">'a'</span>..=<span class=\"hljs-string\">'j'</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"early ASCII letter\"</span>),\n        <span class=\"hljs-string\">'k'</span>..=<span class=\"hljs-string\">'z'</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"late ASCII letter\"</span>),\n        _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"something else\"</span>),\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Rust can tell that <code class=\"hljs\">'c'</code> is within the first pattern’s range and prints <code class=\"hljs\">early ASCII letter</code>.</p>\n<h3 id=\"destructuring-to-break-apart-values\"><a class=\"header\" href=\"#destructuring-to-break-apart-values\">Destructuring to Break Apart Values</a></h3>\n<p>We can also use patterns to destructure structs, enums, and tuples to use\ndifferent parts of these values. Let’s walk through each value.</p>\n<h4 id=\"destructuring-structs\"><a class=\"header\" href=\"#destructuring-structs\">Destructuring Structs</a></h4>\n<p>Listing 18-12 shows a <code class=\"hljs\">Point</code> struct with two fields, <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code>, that we can\nbreak apart using a pattern with a <code class=\"hljs\">let</code> statement.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n    x: <span class=\"hljs-built_in\">i32</span>,\n    y: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Point { x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">7</span> };\n\n    <span class=\"hljs-keyword\">let</span> Point { x: a, y: b } = p;\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">0</span>, a);\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">7</span>, b);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 18-12: Destructuring a struct’s fields into\nseparate variables</span></p>\n<p>This code creates the variables <code class=\"hljs\">a</code> and <code class=\"hljs\">b</code> that match the values of the <code class=\"hljs\">x</code>\nand <code class=\"hljs\">y</code> fields of the <code class=\"hljs\">p</code> struct. This example shows that the names of the\nvariables in the pattern don’t have to match the field names of the struct.\nHowever, it’s common to match the variable names to the field names to make it\neasier to remember which variables came from which fields. Because of this\ncommon usage, and because writing <code class=\"hljs\">let Point { x: x, y: y } = p;</code> contains a\nlot of duplication, Rust has a shorthand for patterns that match struct fields:\nyou only need to list the name of the struct field, and the variables created\nfrom the pattern will have the same names. Listing 18-13 behaves in the same\nway as the code in Listing 18-12, but the variables created in the <code class=\"hljs\">let</code>\npattern are <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> instead of <code class=\"hljs\">a</code> and <code class=\"hljs\">b</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n    x: <span class=\"hljs-built_in\">i32</span>,\n    y: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Point { x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">7</span> };\n\n    <span class=\"hljs-keyword\">let</span> Point { x, y } = p;\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">0</span>, x);\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">7</span>, y);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 18-13: Destructuring struct fields using struct\nfield shorthand</span></p>\n<p>This code creates the variables <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> that match the <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> fields\nof the <code class=\"hljs\">p</code> variable. The outcome is that the variables <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> contain the\nvalues from the <code class=\"hljs\">p</code> struct.</p>\n<p>We can also destructure with literal values as part of the struct pattern\nrather than creating variables for all the fields. Doing so allows us to test\nsome of the fields for particular values while creating variables to\ndestructure the other fields.</p>\n<p>In Listing 18-14, we have a <code class=\"hljs\">match</code> expression that separates <code class=\"hljs\">Point</code> values\ninto three cases: points that lie directly on the <code class=\"hljs\">x</code> axis (which is true when\n<code class=\"hljs\">y = 0</code>), on the <code class=\"hljs\">y</code> axis (<code class=\"hljs\">x = 0</code>), or neither.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n</span><span class=\"boring\">    x: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">    y: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Point { x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">7</span> };\n\n    <span class=\"hljs-keyword\">match</span> p {\n        Point { x, y: <span class=\"hljs-number\">0</span> } =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"On the x axis at {x}\"</span>),\n        Point { x: <span class=\"hljs-number\">0</span>, y } =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"On the y axis at {y}\"</span>),\n        Point { x, y } =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"On neither axis: ({x}, {y})\"</span>);\n        }\n    }\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 18-14: Destructuring and matching literal values\nin one pattern</span></p>\n<p>The first arm will match any point that lies on the <code class=\"hljs\">x</code> axis by specifying that\nthe <code class=\"hljs\">y</code> field matches if its value matches the literal <code class=\"hljs\">0</code>. The pattern still\ncreates an <code class=\"hljs\">x</code> variable that we can use in the code for this arm.</p>\n<p>Similarly, the second arm matches any point on the <code class=\"hljs\">y</code> axis by specifying that\nthe <code class=\"hljs\">x</code> field matches if its value is <code class=\"hljs\">0</code> and creates a variable <code class=\"hljs\">y</code> for the\nvalue of the <code class=\"hljs\">y</code> field. The third arm doesn’t specify any literals, so it\nmatches any other <code class=\"hljs\">Point</code> and creates variables for both the <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> fields.</p>\n<p>In this example, the value <code class=\"hljs\">p</code> matches the second arm by virtue of <code class=\"hljs\">x</code>\ncontaining a 0, so this code will print <code class=\"hljs\">On the y axis at 7</code>.</p>\n<p>Remember that a <code class=\"hljs\">match</code> expression stops checking arms once it has found the\nfirst matching pattern, so even though <code class=\"hljs\">Point { x: 0, y: 0}</code> is on the <code class=\"hljs\">x</code> axis\nand the <code class=\"hljs\">y</code> axis, this code would only print <code class=\"hljs\">On the x axis at 0</code>.</p>\n<h4 id=\"destructuring-enums\"><a class=\"header\" href=\"#destructuring-enums\">Destructuring Enums</a></h4>\n<p>We’ve destructured enums in this book (for example, Listing 6-5 in Chapter 6),\nbut haven’t yet explicitly discussed that the pattern to destructure an enum\ncorresponds to the way the data stored within the enum is defined. As an\nexample, in Listing 18-15 we use the <code class=\"hljs\">Message</code> enum from Listing 6-2 and write\na <code class=\"hljs\">match</code> with patterns that will destructure each inner value.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Message</span></span> {\n    Quit,\n    Move { x: <span class=\"hljs-built_in\">i32</span>, y: <span class=\"hljs-built_in\">i32</span> },\n    Write(<span class=\"hljs-built_in\">String</span>),\n    ChangeColor(<span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>),\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> msg = Message::ChangeColor(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">160</span>, <span class=\"hljs-number\">255</span>);\n\n    <span class=\"hljs-keyword\">match</span> msg {\n        Message::Quit =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The Quit variant has no data to destructure.\"</span>);\n        }\n        Message::Move { x, y } =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Move in the x direction {x} and in the y direction {y}\"</span>);\n        }\n        Message::Write(text) =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Text message: {text}\"</span>);\n        }\n        Message::ChangeColor(r, g, b) =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Change the color to red {r}, green {g}, and blue {b}\"</span>)\n        }\n    }\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 18-15: Destructuring enum variants that hold\ndifferent kinds of values</span></p>\n<p>This code will print <code class=\"hljs\">Change the color to red 0, green 160, and blue 255</code>. Try\nchanging the value of <code class=\"hljs\">msg</code> to see the code from the other arms run.</p>\n<p>For enum variants without any data, like <code class=\"hljs\">Message::Quit</code>, we can’t destructure\nthe value any further. We can only match on the literal <code class=\"hljs\">Message::Quit</code> value,\nand no variables are in that pattern.</p>\n<p>For struct-like enum variants, such as <code class=\"hljs\">Message::Move</code>, we can use a pattern\nsimilar to the pattern we specify to match structs. After the variant name, we\nplace curly brackets and then list the fields with variables so we break apart\nthe pieces to use in the code for this arm. Here we use the shorthand form as\nwe did in Listing 18-13.</p>\n<p>For tuple-like enum variants, like <code class=\"hljs\">Message::Write</code> that holds a tuple with one\nelement and <code class=\"hljs\">Message::ChangeColor</code> that holds a tuple with three elements, the\npattern is similar to the pattern we specify to match tuples. The number of\nvariables in the pattern must match the number of elements in the variant we’re\nmatching.</p>\n<h4 id=\"destructuring-nested-structs-and-enums\"><a class=\"header\" href=\"#destructuring-nested-structs-and-enums\">Destructuring Nested Structs and Enums</a></h4>\n<p>So far, our examples have all been matching structs or enums one level deep,\nbut matching can work on nested items too! For example, we can refactor the\ncode in Listing 18-15 to support RGB and HSV colors in the <code class=\"hljs\">ChangeColor</code>\nmessage, as shown in Listing 18-16.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Color</span></span> {\n    Rgb(<span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>),\n    Hsv(<span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>),\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Message</span></span> {\n    Quit,\n    Move { x: <span class=\"hljs-built_in\">i32</span>, y: <span class=\"hljs-built_in\">i32</span> },\n    Write(<span class=\"hljs-built_in\">String</span>),\n    ChangeColor(Color),\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> msg = Message::ChangeColor(Color::Hsv(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">160</span>, <span class=\"hljs-number\">255</span>));\n\n    <span class=\"hljs-keyword\">match</span> msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Change color to red {r}, green {g}, and blue {b}\"</span>);\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Change color to hue {h}, saturation {s}, value {v}\"</span>)\n        }\n        _ =&gt; (),\n    }\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 18-16: Matching on nested enums</span></p>\n<p>The pattern of the first arm in the <code class=\"hljs\">match</code> expression matches a\n<code class=\"hljs\">Message::ChangeColor</code> enum variant that contains a <code class=\"hljs\">Color::Rgb</code> variant; then\nthe pattern binds to the three inner <code class=\"hljs\">i32</code> values. The pattern of the second\narm also matches a <code class=\"hljs\">Message::ChangeColor</code> enum variant, but the inner enum\nmatches <code class=\"hljs\">Color::Hsv</code> instead. We can specify these complex conditions in one\n<code class=\"hljs\">match</code> expression, even though two enums are involved.</p>\n<h4 id=\"destructuring-structs-and-tuples\"><a class=\"header\" href=\"#destructuring-structs-and-tuples\">Destructuring Structs and Tuples</a></h4>\n<p>We can mix, match, and nest destructuring patterns in even more complex ways.\nThe following example shows a complicated destructure where we nest structs and\ntuples inside a tuple and destructure all the primitive values out:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n</span><span class=\"boring\">        x: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">        y: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span>    <span class=\"hljs-keyword\">let</span> ((feet, inches), Point { x, y }) = ((<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">10</span>), Point { x: <span class=\"hljs-number\">3</span>, y: -<span class=\"hljs-number\">10</span> });\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code lets us break complex types into their component parts so we can use\nthe values we’re interested in separately.</p>\n<p>Destructuring with patterns is a convenient way to use pieces of values, such\nas the value from each field in a struct, separately from each other.</p>\n<h3 id=\"ignoring-values-in-a-pattern\"><a class=\"header\" href=\"#ignoring-values-in-a-pattern\">Ignoring Values in a Pattern</a></h3>\n<p>You’ve seen that it’s sometimes useful to ignore values in a pattern, such as\nin the last arm of a <code class=\"hljs\">match</code>, to get a catchall that doesn’t actually do\nanything but does account for all remaining possible values. There are a few\nways to ignore entire values or parts of values in a pattern: using the <code class=\"hljs\">_</code>\npattern (which you’ve seen), using the <code class=\"hljs\">_</code> pattern within another pattern,\nusing a name that starts with an underscore, or using <code class=\"hljs\">..</code> to ignore remaining\nparts of a value. Let’s explore how and why to use each of these patterns.</p>\n<h4 id=\"ignoring-an-entire-value-with-_\"><a class=\"header\" href=\"#ignoring-an-entire-value-with-_\">Ignoring an Entire Value with <code>_</code></a></h4>\n<p>We’ve used the underscore as a wildcard pattern that will match any value but\nnot bind to the value. This is especially useful as the last arm in a <code class=\"hljs\">match</code>\nexpression, but we can also use it in any pattern, including function\nparameters, as shown in Listing 18-17.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(_: <span class=\"hljs-built_in\">i32</span>, y: <span class=\"hljs-built_in\">i32</span>) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"This code only uses the y parameter: {y}\"</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    foo(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 18-17: Using <code class=\"hljs\">_</code> in a function signature</span></p>\n<p>This code will completely ignore the value <code class=\"hljs\">3</code> passed as the first argument,\nand will print <code class=\"hljs\">This code only uses the y parameter: 4</code>.</p>\n<p>In most cases when you no longer need a particular function parameter, you\nwould change the signature so it doesn’t include the unused parameter. Ignoring\na function parameter can be especially useful in cases when, for example,\nyou’re implementing a trait when you need a certain type signature but the\nfunction body in your implementation doesn’t need one of the parameters. You\nthen avoid getting a compiler warning about unused function parameters, as you\nwould if you used a name instead.</p>\n<h4 id=\"ignoring-parts-of-a-value-with-a-nested-_\"><a class=\"header\" href=\"#ignoring-parts-of-a-value-with-a-nested-_\">Ignoring Parts of a Value with a Nested <code>_</code></a></h4>\n<p>We can also use <code class=\"hljs\">_</code> inside another pattern to ignore just part of a value, for\nexample, when we want to test for only part of a value but have no use for the\nother parts in the corresponding code we want to run. Listing 18-18 shows code\nresponsible for managing a setting’s value. The business requirements are that\nthe user should not be allowed to overwrite an existing customization of a\nsetting but can unset the setting and give it a value if it is currently unset.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> setting_value = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">let</span> new_setting_value = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">10</span>);\n\n    <span class=\"hljs-keyword\">match</span> (setting_value, new_setting_value) {\n        (<span class=\"hljs-literal\">Some</span>(_), <span class=\"hljs-literal\">Some</span>(_)) =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Can't overwrite an existing customized value\"</span>);\n        }\n        _ =&gt; {\n            setting_value = new_setting_value;\n        }\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"setting is {setting_value:?}\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 18-18: Using an underscore within patterns that\nmatch <code class=\"hljs\">Some</code> variants when we don’t need to use the value inside the\n<code class=\"hljs\">Some</code></span></p>\n<p>This code will print <code class=\"hljs\">Can't overwrite an existing customized value</code> and then\n<code class=\"hljs\">setting is Some(5)</code>. In the first match arm, we don’t need to match on or use\nthe values inside either <code class=\"hljs\">Some</code> variant, but we do need to test for the case\nwhen <code class=\"hljs\">setting_value</code> and <code class=\"hljs\">new_setting_value</code> are the <code class=\"hljs\">Some</code> variant. In that\ncase, we print the reason for not changing <code class=\"hljs\">setting_value</code>, and it doesn’t get\nchanged.</p>\n<p>In all other cases (if either <code class=\"hljs\">setting_value</code> or <code class=\"hljs\">new_setting_value</code> are\n<code class=\"hljs\">None</code>) expressed by the <code class=\"hljs\">_</code> pattern in the second arm, we want to allow\n<code class=\"hljs\">new_setting_value</code> to become <code class=\"hljs\">setting_value</code>.</p>\n<p>We can also use underscores in multiple places within one pattern to ignore\nparticular values. Listing 18-19 shows an example of ignoring the second and\nfourth values in a tuple of five items.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> numbers = (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">32</span>);\n\n    <span class=\"hljs-keyword\">match</span> numbers {\n        (first, _, third, _, fifth) =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Some numbers: {first}, {third}, {fifth}\"</span>)\n        }\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 18-19: Ignoring multiple parts of a tuple</span></p>\n<p>This code will print <code class=\"hljs\">Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be\nignored.</p>\n<h4 id=\"ignoring-an-unused-variable-by-starting-its-name-with-_\"><a class=\"header\" href=\"#ignoring-an-unused-variable-by-starting-its-name-with-_\">Ignoring an Unused Variable by Starting Its Name with <code>_</code></a></h4>\n<p>If you create a variable but don’t use it anywhere, Rust will usually issue a\nwarning because an unused variable could be a bug. However, sometimes it’s\nuseful to be able to create a variable you won’t use yet, such as when you’re\nprototyping or just starting a project. In this situation, you can tell Rust\nnot to warn you about the unused variable by starting the name of the variable\nwith an underscore. In Listing 18-20, we create two unused variables, but when\nwe compile this code, we should only get a warning about one of them.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> _x = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">10</span>;\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 18-20: Starting a variable name with an\nunderscore to avoid getting unused variable warnings</span></p>\n<p>Here we get a warning about not using the variable <code class=\"hljs\">y</code>, but we don’t get a\nwarning about not using <code class=\"hljs\">_x</code>.</p>\n<p>Note that there is a subtle difference between using only <code class=\"hljs\">_</code> and using a name\nthat starts with an underscore. The syntax <code class=\"hljs\">_x</code> still binds the value to the\nvariable, whereas <code class=\"hljs\">_</code> doesn’t bind at all. To show a case where this\ndistinction matters, Listing 18-21 will provide us with an error.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hello!\"</span>));\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(_s) = s {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"found a string\"</span>);\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{s:?}\"</span>);\n<span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 18-21: An unused variable starting with an\nunderscore still binds the value, which might take ownership of the value</span></p>\n<p>We’ll receive an error because the <code class=\"hljs\">s</code> value will still be moved into <code class=\"hljs\">_s</code>,\nwhich prevents us from using <code class=\"hljs\">s</code> again. However, using the underscore by itself\ndoesn’t ever bind to the value. Listing 18-22 will compile without any errors\nbecause <code class=\"hljs\">s</code> doesn’t get moved into <code class=\"hljs\">_</code>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hello!\"</span>));\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(_) = s {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"found a string\"</span>);\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{s:?}\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 18-22: Using an underscore does not bind the\nvalue</span></p>\n<p>This code works just fine because we never bind <code class=\"hljs\">s</code> to anything; it isn’t moved.</p>\n<h4 id=\"ignoring-remaining-parts-of-a-value-with-\"><a class=\"header\" href=\"#ignoring-remaining-parts-of-a-value-with-\">Ignoring Remaining Parts of a Value with <code>..</code></a></h4>\n<p>With values that have many parts, we can use the <code class=\"hljs\">..</code> syntax to use specific\nparts and ignore the rest, avoiding the need to list underscores for each\nignored value. The <code class=\"hljs\">..</code> pattern ignores any parts of a value that we haven’t\nexplicitly matched in the rest of the pattern. In Listing 18-23, we have a\n<code class=\"hljs\">Point</code> struct that holds a coordinate in three-dimensional space. In the\n<code class=\"hljs\">match</code> expression, we want to operate only on the <code class=\"hljs\">x</code> coordinate and ignore\nthe values in the <code class=\"hljs\">y</code> and <code class=\"hljs\">z</code> fields.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n        x: <span class=\"hljs-built_in\">i32</span>,\n        y: <span class=\"hljs-built_in\">i32</span>,\n        z: <span class=\"hljs-built_in\">i32</span>,\n    }\n\n    <span class=\"hljs-keyword\">let</span> origin = Point { x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">0</span>, z: <span class=\"hljs-number\">0</span> };\n\n    <span class=\"hljs-keyword\">match</span> origin {\n        Point { x, .. } =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"x is {x}\"</span>),\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 18-23: Ignoring all fields of a <code class=\"hljs\">Point</code> except\nfor <code class=\"hljs\">x</code> by using <code class=\"hljs\">..</code></span></p>\n<p>We list the <code class=\"hljs\">x</code> value and then just include the <code class=\"hljs\">..</code> pattern. This is quicker\nthan having to list <code class=\"hljs\">y: _</code> and <code class=\"hljs\">z: _</code>, particularly when we’re working with\nstructs that have lots of fields in situations where only one or two fields are\nrelevant.</p>\n<p>The syntax <code class=\"hljs\">..</code> will expand to as many values as it needs to be. Listing 18-24\nshows how to use <code class=\"hljs\">..</code> with a tuple.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> numbers = (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">32</span>);\n\n    <span class=\"hljs-keyword\">match</span> numbers {\n        (first, .., last) =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Some numbers: {first}, {last}\"</span>);\n        }\n    }\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 18-24: Matching only the first and last values in\na tuple and ignoring all other values</span></p>\n<p>In this code, the first and last value are matched with <code class=\"hljs\">first</code> and <code class=\"hljs\">last</code>. The\n<code class=\"hljs\">..</code> will match and ignore everything in the middle.</p>\n<p>However, using <code class=\"hljs\">..</code> must be unambiguous. If it is unclear which values are\nintended for matching and which should be ignored, Rust will give us an error.\nListing 18-25 shows an example of using <code class=\"hljs\">..</code> ambiguously, so it will not\ncompile.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> numbers = (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">32</span>);\n\n    <span class=\"hljs-keyword\">match</span> numbers {\n        (.., second, ..) =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Some numbers: {second}\"</span>)\n        },\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 18-25: An attempt to use <code class=\"hljs\">..</code> in an ambiguous\nway</span></p>\n<p>When we compile this example, we get this error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror: `..` can only be used once per tuple pattern\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:5:22</span>\n  |\n5 |         (.., second, ..) =&gt; {\n  |          --          ^^ can only be used once per tuple pattern\n  |          |\n  |          previously used here\n\nerror: could not compile `patterns` (bin \"patterns\") due to 1 previous error\n</code></pre>\n<p>It’s impossible for Rust to determine how many values in the tuple to ignore\nbefore matching a value with <code class=\"hljs\">second</code> and then how many further values to\nignore thereafter. This code could mean that we want to ignore <code class=\"hljs\">2</code>, bind\n<code class=\"hljs\">second</code> to <code class=\"hljs\">4</code>, and then ignore <code class=\"hljs\">8</code>, <code class=\"hljs\">16</code>, and <code class=\"hljs\">32</code>; or that we want to ignore\n<code class=\"hljs\">2</code> and <code class=\"hljs\">4</code>, bind <code class=\"hljs\">second</code> to <code class=\"hljs\">8</code>, and then ignore <code class=\"hljs\">16</code> and <code class=\"hljs\">32</code>; and so forth.\nThe variable name <code class=\"hljs\">second</code> doesn’t mean anything special to Rust, so we get a\ncompiler error because using <code class=\"hljs\">..</code> in two places like this is ambiguous.</p>\n<h3 id=\"extra-conditionals-with-match-guards\"><a class=\"header\" href=\"#extra-conditionals-with-match-guards\">Extra Conditionals with Match Guards</a></h3>\n<p>A <em>match guard</em> is an additional <code class=\"hljs\">if</code> condition, specified after the pattern in\na <code class=\"hljs\">match</code> arm, that must also match for that arm to be chosen. Match guards are\nuseful for expressing more complex ideas than a pattern alone allows.</p>\n<p>The condition can use variables created in the pattern. Listing 18-26 shows a\n<code class=\"hljs\">match</code> where the first arm has the pattern <code class=\"hljs\">Some(x)</code> and also has a match\nguard of <code class=\"hljs\">if x % 2 == 0</code> (which will be true if the number is even).</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">4</span>);\n\n    <span class=\"hljs-keyword\">match</span> num {\n        <span class=\"hljs-literal\">Some</span>(x) <span class=\"hljs-keyword\">if</span> x % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The number {x} is even\"</span>),\n        <span class=\"hljs-literal\">Some</span>(x) =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The number {x} is odd\"</span>),\n        <span class=\"hljs-literal\">None</span> =&gt; (),\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 18-26: Adding a match guard to a pattern</span></p>\n<p>This example will print <code class=\"hljs\">The number 4 is even</code>. When <code class=\"hljs\">num</code> is compared to the\npattern in the first arm, it matches, because <code class=\"hljs\">Some(4)</code> matches <code class=\"hljs\">Some(x)</code>. Then\nthe match guard checks whether the remainder of dividing <code class=\"hljs\">x</code> by 2 is equal to\n0, and because it is, the first arm is selected.</p>\n<p>If <code class=\"hljs\">num</code> had been <code class=\"hljs\">Some(5)</code> instead, the match guard in the first arm would\nhave been false because the remainder of 5 divided by 2 is 1, which is not\nequal to 0. Rust would then go to the second arm, which would match because the\nsecond arm doesn’t have a match guard and therefore matches any <code class=\"hljs\">Some</code> variant.</p>\n<p>There is no way to express the <code class=\"hljs\">if x % 2 == 0</code> condition within a pattern, so\nthe match guard gives us the ability to express this logic. The downside of\nthis additional expressiveness is that the compiler doesn’t try to check for\nexhaustiveness when match guard expressions are involved.</p>\n<p>In Listing 18-11, we mentioned that we could use match guards to solve our\npattern-shadowing problem. Recall that we created a new variable inside the\npattern in the <code class=\"hljs\">match</code> expression instead of using the variable outside the\n<code class=\"hljs\">match</code>. That new variable meant we couldn’t test against the value of the\nouter variable. Listing 18-27 shows how we can use a match guard to fix this\nproblem.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">10</span>;\n\n    <span class=\"hljs-keyword\">match</span> x {\n        <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">50</span>) =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got 50\"</span>),\n        <span class=\"hljs-literal\">Some</span>(n) <span class=\"hljs-keyword\">if</span> n == y =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Matched, n = {n}\"</span>),\n        _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Default case, x = {x:?}\"</span>),\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"at the end: x = {x:?}, y = {y}\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 18-27: Using a match guard to test for equality\nwith an outer variable</span></p>\n<p>This code will now print <code class=\"hljs\">Default case, x = Some(5)</code>. The pattern in the second\nmatch arm doesn’t introduce a new variable <code class=\"hljs\">y</code> that would shadow the outer <code class=\"hljs\">y</code>,\nmeaning we can use the outer <code class=\"hljs\">y</code> in the match guard. Instead of specifying the\npattern as <code class=\"hljs\">Some(y)</code>, which would have shadowed the outer <code class=\"hljs\">y</code>, we specify\n<code class=\"hljs\">Some(n)</code>. This creates a new variable <code class=\"hljs\">n</code> that doesn’t shadow anything because\nthere is no <code class=\"hljs\">n</code> variable outside the <code class=\"hljs\">match</code>.</p>\n<p>The match guard <code class=\"hljs\">if n == y</code> is not a pattern and therefore doesn’t introduce\nnew variables. This <code class=\"hljs\">y</code> <em>is</em> the outer <code class=\"hljs\">y</code> rather than a new shadowed <code class=\"hljs\">y</code>, and\nwe can look for a value that has the same value as the outer <code class=\"hljs\">y</code> by comparing\n<code class=\"hljs\">n</code> to <code class=\"hljs\">y</code>.</p>\n<p>You can also use the <em>or</em> operator <code class=\"hljs\">|</code> in a match guard to specify multiple\npatterns; the match guard condition will apply to all the patterns. Listing\n18-28 shows the precedence when combining a pattern that uses <code class=\"hljs\">|</code> with a match\nguard. The important part of this example is that the <code class=\"hljs\">if y</code> match guard\napplies to <code class=\"hljs\">4</code>, <code class=\"hljs\">5</code>, <em>and</em> <code class=\"hljs\">6</code>, even though it might look like <code class=\"hljs\">if y</code> only\napplies to <code class=\"hljs\">6</code>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">4</span>;\n    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-literal\">false</span>;\n\n    <span class=\"hljs-keyword\">match</span> x {\n        <span class=\"hljs-number\">4</span> | <span class=\"hljs-number\">5</span> | <span class=\"hljs-number\">6</span> <span class=\"hljs-keyword\">if</span> y =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"yes\"</span>),\n        _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"no\"</span>),\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 18-28: Combining multiple patterns with a match\nguard</span></p>\n<p>The match condition states that the arm only matches if the value of <code class=\"hljs\">x</code> is\nequal to <code class=\"hljs\">4</code>, <code class=\"hljs\">5</code>, or <code class=\"hljs\">6</code> <em>and</em> if <code class=\"hljs\">y</code> is <code class=\"hljs\">true</code>. When this code runs, the\npattern of the first arm matches because <code class=\"hljs\">x</code> is <code class=\"hljs\">4</code>, but the match guard <code class=\"hljs\">if y</code>\nis false, so the first arm is not chosen. The code moves on to the second arm,\nwhich does match, and this program prints <code class=\"hljs\">no</code>. The reason is that the <code class=\"hljs\">if</code>\ncondition applies to the whole pattern <code class=\"hljs\">4 | 5 | 6</code>, not only to the last value\n<code class=\"hljs\">6</code>. In other words, the precedence of a match guard in relation to a pattern\nbehaves like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">(4 | 5 | 6) if y =&gt; ...\n</code></pre>\n<p>rather than this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">4 | 5 | (6 if y) =&gt; ...\n</code></pre>\n<p>After running the code, the precedence behavior is evident: if the match guard\nwere applied only to the final value in the list of values specified using the\n<code class=\"hljs\">|</code> operator, the arm would have matched and the program would have printed\n<code class=\"hljs\">yes</code>.</p>\n<h3 id=\"-bindings\"><a class=\"header\" href=\"#-bindings\"><code>@</code> Bindings</a></h3>\n<p>The <em>at</em> operator <code class=\"hljs\">@</code> lets us create a variable that holds a value at the same\ntime as we’re testing that value for a pattern match. In Listing 18-29, we want\nto test that a <code class=\"hljs\">Message::Hello</code> <code class=\"hljs\">id</code> field is within the range <code class=\"hljs\">3..=7</code>. We also\nwant to bind the value to the variable <code class=\"hljs\">id_variable</code> so we can use it in the\ncode associated with the arm. We could name this variable <code class=\"hljs\">id</code>, the same as the\nfield, but for this example we’ll use a different name.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Message</span></span> {\n        Hello { id: <span class=\"hljs-built_in\">i32</span> },\n    }\n\n    <span class=\"hljs-keyword\">let</span> msg = Message::Hello { id: <span class=\"hljs-number\">5</span> };\n\n    <span class=\"hljs-keyword\">match</span> msg {\n        Message::Hello {\n            id: id_variable @ <span class=\"hljs-number\">3</span>..=<span class=\"hljs-number\">7</span>,\n        } =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Found an id in range: {id_variable}\"</span>),\n        Message::Hello { id: <span class=\"hljs-number\">10</span>..=<span class=\"hljs-number\">12</span> } =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Found an id in another range\"</span>)\n        }\n        Message::Hello { id } =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Found some other id: {id}\"</span>),\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 18-29: Using <code class=\"hljs\">@</code> to bind to a value in a pattern\nwhile also testing it</span></p>\n<p>This example will print <code class=\"hljs\">Found an id in range: 5</code>. By specifying <code class=\"hljs\">id_variable @</code> before the range <code class=\"hljs\">3..=7</code>, we’re capturing whatever value matched the range\nwhile also testing that the value matched the range pattern.</p>\n<p>In the second arm, where we only have a range specified in the pattern, the code\nassociated with the arm doesn’t have a variable that contains the actual value\nof the <code class=\"hljs\">id</code> field. The <code class=\"hljs\">id</code> field’s value could have been 10, 11, or 12, but\nthe code that goes with that pattern doesn’t know which it is. The pattern code\nisn’t able to use the value from the <code class=\"hljs\">id</code> field, because we haven’t saved the\n<code class=\"hljs\">id</code> value in a variable.</p>\n<p>In the last arm, where we’ve specified a variable without a range, we do have\nthe value available to use in the arm’s code in a variable named <code class=\"hljs\">id</code>. The\nreason is that we’ve used the struct field shorthand syntax. But we haven’t\napplied any test to the value in the <code class=\"hljs\">id</code> field in this arm, as we did with the\nfirst two arms: any value would match this pattern.</p>\n<p>Using <code class=\"hljs\">@</code> lets us test a value and save it in a variable within one pattern.</p>\n<h2 id=\"summary\"><a class=\"header\" href=\"#summary\">Summary</a></h2>\n<p>Rust’s patterns are very useful in distinguishing between different kinds of\ndata. When used in <code class=\"hljs\">match</code> expressions, Rust ensures your patterns cover every\npossible value, or your program won’t compile. Patterns in <code class=\"hljs\">let</code> statements and\nfunction parameters make those constructs more useful, enabling the\ndestructuring of values into smaller parts at the same time as assigning to\nvariables. We can create simple or complex patterns to suit our needs.</p>\n<p>Next, for the penultimate chapter of the book, we’ll look at some advanced\naspects of a variety of Rust’s features.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch18-02-refutability.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch19-00-advanced-features.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch18-02-refutability.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch19-00-advanced-features.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:32.669Z"
}