{
	"title": "FFI - The Rustonomicon",
	"url": "https://doc.rust-lang.org/nomicon/ffi.html",
	"markdown": "# FFI - The Rustonomicon\n\n## [Foreign Function Interface](#foreign-function-interface)\n\n## [Introduction](#introduction)\n\nThis guide will use the [snappy](https://github.com/google/snappy) compression/decompression library as an introduction to writing bindings for foreign code. Rust is currently unable to call directly into a C++ library, but snappy includes a C interface (documented in [`snappy-c.h`](https://github.com/google/snappy/blob/master/snappy-c.h)).\n\n## [A note about libc](#a-note-about-libc)\n\nMany of these examples use [the `libc` crate](https://crates.io/crates/libc), which provides various type definitions for C types, among other things. If you’re trying these examples yourself, you’ll need to add `libc` to your `Cargo.toml`:\n\n```toml\n[dependencies]\nlibc = \"0.2.0\"\n\n```\n\n## [Calling foreign functions](#calling-foreign-functions)\n\nThe following is a minimal example of calling a foreign function which will compile if snappy is installed:\n\n```rust\nuse libc::size_t;\n\n#[link(name = \"snappy\")]\nextern {\n    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n}\n\nfn main() {\n    let x = unsafe { snappy_max_compressed_length(100) };\n    println!(\"max compressed length of a 100 byte buffer: {}\", x);\n}\n```\n\nThe `extern` block is a list of function signatures in a foreign library, in this case with the platform's C ABI. The `#[link(...)]` attribute is used to instruct the linker to link against the snappy library so the symbols are resolved.\n\nForeign functions are assumed to be unsafe so calls to them need to be wrapped with `unsafe {}` as a promise to the compiler that everything contained within truly is safe. C libraries often expose interfaces that aren't thread-safe, and almost any function that takes a pointer argument isn't valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of Rust's safe memory model.\n\nWhen declaring the argument types to a foreign function, the Rust compiler cannot check if the declaration is correct, so specifying it correctly is part of keeping the binding correct at runtime.\n\nThe `extern` block can be extended to cover the entire snappy API:\n\n```rust\nuse libc::{c_int, size_t};\n\n#[link(name = \"snappy\")]\nextern {\n    fn snappy_compress(input: *const u8,\n                       input_length: size_t,\n                       compressed: *mut u8,\n                       compressed_length: *mut size_t) -> c_int;\n    fn snappy_uncompress(compressed: *const u8,\n                         compressed_length: size_t,\n                         uncompressed: *mut u8,\n                         uncompressed_length: *mut size_t) -> c_int;\n    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n    fn snappy_uncompressed_length(compressed: *const u8,\n                                  compressed_length: size_t,\n                                  result: *mut size_t) -> c_int;\n    fn snappy_validate_compressed_buffer(compressed: *const u8,\n                                         compressed_length: size_t) -> c_int;\n}\nfn main() {}\n```\n\n## [Creating a safe interface](#creating-a-safe-interface)\n\nThe raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe internal details.\n\nWrapping the functions which expect buffers involves using the `slice::raw` module to manipulate Rust vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The length is the number of elements currently contained, and the capacity is the total size in elements of the allocated memory. The length is less than or equal to the capacity.\n\n```rust\nuse libc::{c_int, size_t};\nunsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -> c_int { 0 }\nfn main() {}\npub fn validate_compressed_buffer(src: &[u8]) -> bool {\n    unsafe {\n        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n    }\n}\n```\n\nThe `validate_compressed_buffer` wrapper above makes use of an `unsafe` block, but it makes the guarantee that calling it is safe for all inputs by leaving off `unsafe` from the function signature.\n\nThe `snappy_compress` and `snappy_uncompress` functions are more complex, since a buffer has to be allocated to hold the output too.\n\nThe `snappy_max_compressed_length` function can be used to allocate a vector with the maximum required capacity to hold the compressed output. The vector can then be passed to the `snappy_compress` function as an output parameter. An output parameter is also passed to retrieve the true length after compression for setting the length.\n\n```rust\nuse libc::{size_t, c_int};\nunsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,\n                          d: *mut size_t) -> c_int { 0 }\nunsafe fn snappy_max_compressed_length(a: size_t) -> size_t { a }\nfn main() {}\npub fn compress(src: &[u8]) -> Vec<u8> {\n    unsafe {\n        let srclen = src.len() as size_t;\n        let psrc = src.as_ptr();\n\n        let mut dstlen = snappy_max_compressed_length(srclen);\n        let mut dst = Vec::with_capacity(dstlen as usize);\n        let pdst = dst.as_mut_ptr();\n\n        snappy_compress(psrc, srclen, pdst, &mut dstlen);\n        dst.set_len(dstlen as usize);\n        dst\n    }\n}\n```\n\nDecompression is similar, because snappy stores the uncompressed size as part of the compression format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n\n```rust\nuse libc::{size_t, c_int};\nunsafe fn snappy_uncompress(compressed: *const u8,\n                            compressed_length: size_t,\n                            uncompressed: *mut u8,\n                            uncompressed_length: *mut size_t) -> c_int { 0 }\nunsafe fn snappy_uncompressed_length(compressed: *const u8,\n                                     compressed_length: size_t,\n                                     result: *mut size_t) -> c_int { 0 }\nfn main() {}\npub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n    unsafe {\n        let srclen = src.len() as size_t;\n        let psrc = src.as_ptr();\n\n        let mut dstlen: size_t = 0;\n        snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n\n        let mut dst = Vec::with_capacity(dstlen as usize);\n        let pdst = dst.as_mut_ptr();\n\n        if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n            dst.set_len(dstlen as usize);\n            Some(dst)\n        } else {\n            None // SNAPPY_INVALID_INPUT\n        }\n    }\n}\n```\n\nThen, we can add some tests to show how to use them.\n\n```rust\nuse libc::{c_int, size_t};\nunsafe fn snappy_compress(input: *const u8,\n                          input_length: size_t,\n                          compressed: *mut u8,\n                          compressed_length: *mut size_t)\n                          -> c_int { 0 }\nunsafe fn snappy_uncompress(compressed: *const u8,\n                            compressed_length: size_t,\n                            uncompressed: *mut u8,\n                            uncompressed_length: *mut size_t)\n                            -> c_int { 0 }\nunsafe fn snappy_max_compressed_length(source_length: size_t) -> size_t { 0 }\nunsafe fn snappy_uncompressed_length(compressed: *const u8,\n                                     compressed_length: size_t,\n                                     result: *mut size_t)\n                                     -> c_int { 0 }\nunsafe fn snappy_validate_compressed_buffer(compressed: *const u8,\n                                            compressed_length: size_t)\n                                            -> c_int { 0 }\nfn main() { }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn valid() {\n        let d = vec![0xde, 0xad, 0xd0, 0x0d];\n        let c: &[u8] = &compress(&d);\n        assert!(validate_compressed_buffer(c));\n        assert!(uncompress(c) == Some(d));\n    }\n\n    #[test]\n    fn invalid() {\n        let d = vec![0, 0, 0, 0];\n        assert!(!validate_compressed_buffer(&d));\n        assert!(uncompress(&d).is_none());\n    }\n\n    #[test]\n    fn empty() {\n        let d = vec![];\n        assert!(!validate_compressed_buffer(&d));\n        assert!(uncompress(&d).is_none());\n        let c = compress(&d);\n        assert!(validate_compressed_buffer(&c));\n        assert!(uncompress(&c) == Some(d));\n    }\n}\n```\n\n## [Destructors](#destructors)\n\nForeign libraries often hand off ownership of resources to the calling code. When this occurs, we must use Rust's destructors to provide safety and guarantee the release of these resources (especially in the case of panic).\n\nFor more about destructors, see the [Drop trait](../std/ops/trait.Drop.html).\n\n## [Calling Rust code from C](#calling-rust-code-from-c)\n\nYou may wish to compile Rust code in a way so that it can be called from C. This is fairly easy, but requires a few things.\n\n### [Rust side](#rust-side)\n\nFirst, we assume you have a lib crate named as `rust_from_c`. `lib.rs` should have Rust code as following:\n\n```rust\n#[no_mangle]\npub extern \"C\" fn hello_from_rust() {\n    println!(\"Hello from Rust!\");\n}\nfn main() {}\n```\n\nThe `extern \"C\"` makes this function adhere to the C calling convention, as discussed below in \"[Foreign Calling Conventions](about:blank/ffi.html#foreign-calling-conventions)\". The `no_mangle` attribute turns off Rust's name mangling, so that it has a well defined symbol to link to.\n\nThen, to compile Rust code as a shared library that can be called from C, add the following to your `Cargo.toml`:\n\n```toml\n[lib]\ncrate-type = [\"cdylib\"]\n\n```\n\n(NOTE: We could also use the `staticlib` crate type but it needs to tweak some linking flags.)\n\nRun `cargo build` and you're ready to go on the Rust side.\n\n### [C side](#c-side)\n\nWe'll create a C file to call the `hello_from_rust` function and compile it by `gcc`.\n\nC file should look like:\n\n```c\nextern void hello_from_rust();\n\nint main(void) {\n    hello_from_rust();\n    return 0;\n}\n\n```\n\nWe name the file as `call_rust.c` and place it on the crate root. Run the following to compile:\n\n```sh\ngcc call_rust.c -o call_rust -lrust_from_c -L./target/debug\n\n```\n\n`-l` and `-L` tell gcc to find our Rust library.\n\nFinally, we can call Rust code from C with `LD_LIBRARY_PATH` specified:\n\n```sh\n$ LD_LIBRARY_PATH=./target/debug ./call_rust\nHello from Rust!\n\n```\n\nThat's it! For more realistic example, check the [`cbindgen`](https://github.com/eqrion/cbindgen).\n\n## [Callbacks from C code to Rust functions](#callbacks-from-c-code-to-rust-functions)\n\nSome external libraries require the usage of callbacks to report back their current state or intermediate data to the caller. It is possible to pass functions defined in Rust to an external library. The requirement for this is that the callback function is marked as `extern` with the correct calling convention to make it callable from C code.\n\nThe callback function can then be sent through a registration call to the C library and afterwards be invoked from there.\n\nA basic example is:\n\nRust code:\n\n```rust\nextern fn callback(a: i32) {\n    println!(\"I'm called from C with value {0}\", a);\n}\n\n#[link(name = \"extlib\")]\nextern {\n   fn register_callback(cb: extern fn(i32)) -> i32;\n   fn trigger_callback();\n}\n\nfn main() {\n    unsafe {\n        register_callback(callback);\n        trigger_callback(); // Triggers the callback.\n    }\n}\n```\n\nC code:\n\n```c\ntypedef void (*rust_callback)(int32_t);\nrust_callback cb;\n\nint32_t register_callback(rust_callback callback) {\n    cb = callback;\n    return 1;\n}\n\nvoid trigger_callback() {\n  cb(7); // Will call callback(7) in Rust.\n}\n\n```\n\nIn this example Rust's `main()` will call `trigger_callback()` in C, which would, in turn, call back to `callback()` in Rust.\n\n## [Targeting callbacks to Rust objects](#targeting-callbacks-to-rust-objects)\n\nThe former example showed how a global function can be called from C code. However it is often desired that the callback is targeted to a special Rust object. This could be the object that represents the wrapper for the respective C object.\n\nThis can be achieved by passing a raw pointer to the object down to the C library. The C library can then include the pointer to the Rust object in the notification. This will allow the callback to unsafely access the referenced Rust object.\n\nRust code:\n\n```rust\nstruct RustObject {\n    a: i32,\n    // Other members...\n}\n\nextern \"C\" fn callback(target: *mut RustObject, a: i32) {\n    println!(\"I'm called from C with value {0}\", a);\n    unsafe {\n        // Update the value in RustObject with the value received from the callback:\n        (*target).a = a;\n    }\n}\n\n#[link(name = \"extlib\")]\nextern {\n   fn register_callback(target: *mut RustObject,\n                        cb: extern fn(*mut RustObject, i32)) -> i32;\n   fn trigger_callback();\n}\n\nfn main() {\n    // Create the object that will be referenced in the callback:\n    let mut rust_object = Box::new(RustObject { a: 5 });\n\n    unsafe {\n        register_callback(&mut *rust_object, callback);\n        trigger_callback();\n    }\n}\n```\n\nC code:\n\n```c\ntypedef void (*rust_callback)(void*, int32_t);\nvoid* cb_target;\nrust_callback cb;\n\nint32_t register_callback(void* callback_target, rust_callback callback) {\n    cb_target = callback_target;\n    cb = callback;\n    return 1;\n}\n\nvoid trigger_callback() {\n  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust.\n}\n\n```\n\n## [Asynchronous callbacks](#asynchronous-callbacks)\n\nIn the previously given examples the callbacks are invoked as a direct reaction to a function call to the external C library. The control over the current thread is switched from Rust to C to Rust for the execution of the callback, but in the end the callback is executed on the same thread that called the function which triggered the callback.\n\nThings get more complicated when the external library spawns its own threads and invokes callbacks from there. In these cases access to Rust data structures inside the callbacks is especially unsafe and proper synchronization mechanisms must be used. Besides classical synchronization mechanisms like mutexes, one possibility in Rust is to use channels (in `std::sync::mpsc`) to forward data from the C thread that invoked the callback into a Rust thread.\n\nIf an asynchronous callback targets a special object in the Rust address space it is also absolutely necessary that no more callbacks are performed by the C library after the respective Rust object gets destroyed. This can be achieved by unregistering the callback in the object's destructor and designing the library in a way that guarantees that no callback will be performed after deregistration.\n\n## [Linking](#linking)\n\nThe `link` attribute on `extern` blocks provides the basic building block for instructing rustc how it will link to native libraries. There are two accepted forms of the link attribute today:\n\n-   `#[link(name = \"foo\")]`\n-   `#[link(name = \"foo\", kind = \"bar\")]`\n\nIn both of these cases, `foo` is the name of the native library that we're linking to, and in the second case `bar` is the type of native library that the compiler is linking to. There are currently three known types of native libraries:\n\n-   Dynamic - `#[link(name = \"readline\")]`\n-   Static - `#[link(name = \"my_build_dependency\", kind = \"static\")]`\n-   Frameworks - `#[link(name = \"CoreFoundation\", kind = \"framework\")]`\n\nNote that frameworks are only available on macOS targets.\n\nThe different `kind` values are meant to differentiate how the native library participates in linkage. From a linkage perspective, the Rust compiler creates two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary). Native dynamic library and framework dependencies are propagated to the final artifact boundary, while static library dependencies are not propagated at all, because the static libraries are integrated directly into the subsequent artifact.\n\nA few examples of how this model can be used are:\n\n-   A native build dependency. Sometimes some C/C++ glue is needed when writing some Rust code, but distribution of the C/C++ code in a library format is a burden. In this case, the code will be archived into `libfoo.a` and then the Rust crate would declare a dependency via `#[link(name = \"foo\", kind = \"static\")]`.\n    \n    Regardless of the flavor of output for the crate, the native static library will be included in the output, meaning that distribution of the native static library is not necessary.\n    \n-   A normal dynamic dependency. Common system libraries (like `readline`) are available on a large number of systems, and often a static copy of these libraries cannot be found. When this dependency is included in a Rust crate, partial targets (like rlibs) will not link to the library, but when the rlib is included in a final target (like a binary), the native library will be linked in.\n    \n\nOn macOS, frameworks behave with the same semantics as a dynamic library.\n\n## [Unsafe blocks](#unsafe-blocks)\n\nSome operations, like dereferencing raw pointers or calling functions that have been marked unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to the compiler that the unsafety does not leak out of the block.\n\nUnsafe functions, on the other hand, advertise it to the world. An unsafe function is written like this:\n\n```rust\n#![allow(unused)]\nfn main() {\nunsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n}\n```\n\nThis function can only be called from an `unsafe` block or another `unsafe` function.\n\n## [Accessing foreign globals](#accessing-foreign-globals)\n\nForeign APIs often export a global variable which could do something like track global state. In order to access these variables, you declare them in `extern` blocks with the `static` keyword:\n\n```rust\n#[link(name = \"readline\")]\nextern {\n    static rl_readline_version: libc::c_int;\n}\n\nfn main() {\n    println!(\"You have readline version {} installed.\",\n             unsafe { rl_readline_version as i32 });\n}\n```\n\nAlternatively, you may need to alter global state provided by a foreign interface. To do this, statics can be declared with `mut` so we can mutate them.\n\n```rust\nuse std::ffi::CString;\nuse std::ptr;\n\n#[link(name = \"readline\")]\nextern {\n    static mut rl_prompt: *const libc::c_char;\n}\n\nfn main() {\n    let prompt = CString::new(\"[my-awesome-shell] $\").unwrap();\n    unsafe {\n        rl_prompt = prompt.as_ptr();\n\n        println!(\"{:?}\", rl_prompt);\n\n        rl_prompt = ptr::null();\n    }\n}\n```\n\nNote that all interaction with a `static mut` is unsafe, both reading and writing. Dealing with global mutable state requires a great deal of care.\n\n## [Foreign calling conventions](#foreign-calling-conventions)\n\nMost foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when calling foreign functions. Some foreign functions, most notably the Windows API, use other calling conventions. Rust provides a way to tell the compiler which convention to use:\n\n```rust\n#[cfg(all(target_os = \"win32\", target_arch = \"x86\"))]\n#[link(name = \"kernel32\")]\n#[allow(non_snake_case)]\nextern \"stdcall\" {\n    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -> libc::c_int;\n}\nfn main() { }\n```\n\nThis applies to the entire `extern` block. The list of supported ABI constraints are:\n\n-   `stdcall`\n-   `aapcs`\n-   `cdecl`\n-   `fastcall`\n-   `thiscall`\n-   `vectorcall` This is currently hidden behind the `abi_vectorcall` gate and is subject to change.\n-   `Rust`\n-   `rust-intrinsic`\n-   `system`\n-   `C`\n-   `win64`\n-   `sysv64`\n\nMost of the abis in this list are self-explanatory, but the `system` abi may seem a little odd. This constraint selects whatever the appropriate ABI is for interoperating with the target's libraries. For example, on win32 with a x86 architecture, this means that the abi used would be `stdcall`. On x86\\_64, however, windows uses the `C` calling convention, so `C` would be used. This means that in our previous example, we could have used `extern \"system\" { ... }` to define a block for all windows systems, not only x86 ones.\n\n## [Interoperability with foreign code](#interoperability-with-foreign-code)\n\nRust guarantees that the layout of a `struct` is compatible with the platform's representation in C only if the `#[repr(C)]` attribute is applied to it. `#[repr(C, packed)]` can be used to lay out struct members without padding. `#[repr(C)]` can also be applied to an enum.\n\nRust's owned boxes (`Box<T>`) use non-nullable pointers as handles which point to the contained object. However, they should not be manually created because they are managed by internal allocators. References can safely be assumed to be non-nullable pointers directly to the type. However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer using raw pointers (`*`) if that's needed because the compiler can't make as many assumptions about them.\n\nVectors and strings share the same basic memory layout, and utilities are available in the `vec` and `str` modules for working with C APIs. However, strings are not terminated with `\\0`. If you need a NUL-terminated string for interoperability with C, you should use the `CString` type in the `std::ffi` module.\n\nThe [`libc` crate on crates.io](https://crates.io/crates/libc) includes type aliases and function definitions for the C standard library in the `libc` module, and Rust links against `libc` and `libm` by default.\n\n## [Variadic functions](#variadic-functions)\n\nIn C, functions can be 'variadic', meaning they accept a variable number of arguments. This can be achieved in Rust by specifying `...` within the argument list of a foreign function declaration:\n\n```no\nextern {\n    fn foo(x: i32, ...);\n}\n\nfn main() {\n    unsafe {\n        foo(10, 20, 30, 40, 50);\n    }\n}\n\n```\n\nNormal Rust functions can _not_ be variadic:\n\n```rust\n#![allow(unused)]\nfn main() {\n// This will not compile\n\nfn foo(x: i32, ...) {}\n}\n```\n\n## [The \"nullable pointer optimization\"](#the-nullable-pointer-optimization)\n\nCertain Rust types are defined to never be `null`. This includes references (`&T`, `&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`). When interfacing with C, pointers that might be `null` are often used, which would seem to require some messy `transmute`s and/or unsafe code to handle conversions to/from Rust types. However, trying to construct/work with these invalid values **is undefined behavior**, so you should use the following workaround instead.\n\nAs a special case, an `enum` is eligible for the \"nullable pointer optimization\" if it contains exactly two variants, one of which contains no data and the other contains a field of one of the non-nullable types listed above. This means no extra space is required for a discriminant; rather, the empty variant is represented by putting a `null` value into the non-nullable field. This is called an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible types.\n\nThe most common type that takes advantage of the nullable pointer optimization is `Option<T>`, where `None` corresponds to `null`. So `Option<extern \"C\" fn(c_int) -> c_int>` is a correct way to represent a nullable function pointer using the C ABI (corresponding to the C type `int (*)(int)`).\n\nHere is a contrived example. Let's say some C library has a facility for registering a callback, which gets called in certain situations. The callback is passed a function pointer and an integer and it is supposed to run the function with the integer as a parameter. So we have function pointers flying across the FFI boundary in both directions.\n\n```rust\nuse libc::c_int;\n\n#[cfg(hidden)]\nextern \"C\" {\n    /// Registers the callback.\n    fn register(cb: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>, c_int) -> c_int>);\n}\nunsafe fn register(_: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>,\n                                           c_int) -> c_int>)\n{}\n\n/// This fairly useless function receives a function pointer and an integer\n/// from C, and returns the result of calling the function with the integer.\n/// In case no function is provided, it squares the integer by default.\nextern \"C\" fn apply(process: Option<extern \"C\" fn(c_int) -> c_int>, int: c_int) -> c_int {\n    match process {\n        Some(f) => f(int),\n        None    => int * int\n    }\n}\n\nfn main() {\n    unsafe {\n        register(Some(apply));\n    }\n}\n```\n\nAnd the code on the C side looks like this:\n\n```c\nvoid register(int (*f)(int (*)(int), int)) {\n    ...\n}\n\n```\n\nNo `transmute` required!\n\n## [FFI and unwinding](#ffi-and-unwinding)\n\nIt’s important to be mindful of unwinding when working with FFI. Most ABI strings come in two variants, one with an `-unwind` suffix and one without. The `Rust` ABI always permits unwinding, so there is no `Rust-unwind` ABI.\n\nIf you expect Rust `panic`s or foreign (e.g. C++) exceptions to cross an FFI boundary, that boundary must use the appropriate `-unwind` ABI string. Conversely, if you do not expect unwinding to cross an ABI boundary, use one of the non-`unwind` ABI strings.\n\n> Note: Compiling with `panic=abort` will still cause `panic!` to immediately abort the process, regardless of which ABI is specified by the function that `panic`s.\n\nIf an unwinding operation does encounter an ABI boundary that is not permitted to unwind, the behavior depends on the source of the unwinding (Rust `panic` or a foreign exception):\n\n-   `panic` will cause the process to safely abort.\n-   A foreign exception entering Rust will cause undefined behavior.\n\nNote that the interaction of `catch_unwind` with foreign exceptions **is undefined**, as is the interaction of `panic` with foreign exception-catching mechanisms (notably C++'s `try`/`catch`).\n\n### [Rust `panic` with `\"C-unwind\"`](#rust-panic-with-c-unwind)\n\n```rust\n#[no_mangle]\nextern \"C-unwind\" fn example() {\n    panic!(\"Uh oh\");\n}\n```\n\nThis function (when compiled with `panic=unwind`) is permitted to unwind C++ stack frames.\n\n```text\n[Rust function with `catch_unwind`, which stops the unwinding]\n      |\n     ...\n      |\n[C++ frames]\n      |                           ^\n      | (calls)                   | (unwinding\n      v                           |  goes this\n[Rust function `example`]         |  way)\n      |                           |\n      +--- rust function panics --+\n\n```\n\nIf the C++ frames have objects, their destructors will be called.\n\n### [C++ `throw` with `\"C-unwind\"`](#c-throw-with-c-unwind)\n\n```rust\n#[link(...)]\nextern \"C-unwind\" {\n    // A C++ function that may throw an exception\n    fn may_throw();\n}\n\n#[no_mangle]\nextern \"C-unwind\" fn rust_passthrough() {\n    let b = Box::new(5);\n    unsafe { may_throw(); }\n    println!(\"{:?}\", &b);\n}\n```\n\nA C++ function with a `try` block may invoke `rust_passthrough` and `catch` an exception thrown by `may_throw`.\n\n```text\n[C++ function with `try` block that invokes `rust_passthrough`]\n      |\n     ...\n      |\n[Rust function `rust_passthrough`]\n      |                            ^\n      | (calls)                    | (unwinding\n      v                            |  goes this\n[C++ function `may_throw`]         |  way)\n      |                            |\n      +--- C++ function throws ----+\n\n```\n\nIf `may_throw` does throw an exception, `b` will be dropped. Otherwise, `5` will be printed.\n\n### [`panic` can be stopped at an ABI boundary](#panic-can-be-stopped-at-an-abi-boundary)\n\n```rust\n#![allow(unused)]\nfn main() {\n#[no_mangle]\nextern \"C\" fn assert_nonzero(input: u32) {\n    assert!(input != 0)\n}\n}\n```\n\nIf `assert_nonzero` is called with the argument `0`, the runtime is guaranteed to (safely) abort the process, whether or not compiled with `panic=abort`.\n\n### [Catching `panic` preemptively](#catching-panic-preemptively)\n\nIf you are writing Rust code that may panic, and you don't wish to abort the process if it panics, you must use [`catch_unwind`](../std/panic/fn.catch_unwind.html):\n\n```rust\nuse std::panic::catch_unwind;\n\n#[no_mangle]\npub extern \"C\" fn oh_no() -> i32 {\n    let result = catch_unwind(|| {\n        panic!(\"Oops!\");\n    });\n    match result {\n        Ok(_) => 0,\n        Err(_) => 1,\n    }\n}\n\nfn main() {}\n```\n\nPlease note that [`catch_unwind`](../std/panic/fn.catch_unwind.html) will only catch unwinding panics, not those that abort the process. See the documentation of [`catch_unwind`](../std/panic/fn.catch_unwind.html) for more information.\n\n## [Representing opaque structs](#representing-opaque-structs)\n\nSometimes, a C library wants to provide a pointer to something, but not let you know the internal details of the thing it wants. A stable and simple way is to use a `void *` argument:\n\n```c\nvoid foo(void *arg);\nvoid bar(void *arg);\n\n```\n\nWe can represent this in Rust with the `c_void` type:\n\n```rust\nextern \"C\" {\n    pub fn foo(arg: *mut libc::c_void);\n    pub fn bar(arg: *mut libc::c_void);\n}\nfn main() {}\n```\n\nThis is a perfectly valid way of handling the situation. However, we can do a bit better. To solve this, some C libraries will instead create a `struct`, where the details and memory layout of the struct are private. This gives some amount of type safety. These structures are called ‘opaque’. Here’s an example, in C:\n\n```c\nstruct Foo; /* Foo is a structure, but its contents are not part of the public interface */\nstruct Bar;\nvoid foo(struct Foo *arg);\nvoid bar(struct Bar *arg);\n\n```\n\nTo do this in Rust, let’s create our own opaque types:\n\n```rust\n#[repr(C)]\npub struct Foo {\n    _data: [u8; 0],\n    _marker:\n        core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n}\n#[repr(C)]\npub struct Bar {\n    _data: [u8; 0],\n    _marker:\n        core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n}\n\nextern \"C\" {\n    pub fn foo(arg: *mut Foo);\n    pub fn bar(arg: *mut Bar);\n}\nfn main() {}\n```\n\nBy including at least one private field and no constructor, we create an opaque type that we can't instantiate outside of this module. (A struct with no field could be instantiated by anyone.) We also want to use this type in FFI, so we have to add `#[repr(C)]`. The marker ensures the compiler does not mark the struct as `Send`, `Sync` and `Unpin` are not applied to the struct. (`*mut u8` is not `Send` or `Sync`, `PhantomPinned` is not `Unpin`)\n\nBut because our `Foo` and `Bar` types are different, we’ll get type safety between the two of them, so we cannot accidentally pass a pointer to `Foo` to `bar()`.\n\nNotice that it is a really bad idea to use an empty enum as FFI type. The compiler relies on empty enums being uninhabited, so handling values of type `&Empty` is a huge footgun and can lead to buggy program behavior (by triggering undefined behavior).\n\n> **NOTE:** The simplest way would use \"extern types\". But it's currently (as of June 2021) unstable and has some unresolved questions, see the [RFC page](https://rust-lang.github.io/rfcs/1861-extern-types.html) and the [tracking issue](https://github.com/rust-lang/rust/issues/43467) for more details.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>FFI - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"foreign-function-interface\"><a class=\"header\" href=\"#foreign-function-interface\">Foreign Function Interface</a></h1>\n<h2 id=\"introduction\"><a class=\"header\" href=\"#introduction\">Introduction</a></h2>\n<p>This guide will use the <a href=\"https://github.com/google/snappy\">snappy</a>\ncompression/decompression library as an introduction to writing bindings for\nforeign code. Rust is currently unable to call directly into a C++ library, but\nsnappy includes a C interface (documented in\n<a href=\"https://github.com/google/snappy/blob/master/snappy-c.h\"><code class=\"hljs\">snappy-c.h</code></a>).</p>\n<h2 id=\"a-note-about-libc\"><a class=\"header\" href=\"#a-note-about-libc\">A note about libc</a></h2>\n<p>Many of these examples use <a href=\"https://crates.io/crates/libc\">the <code class=\"hljs\">libc</code> crate</a>, which provides various\ntype definitions for C types, among other things. If you’re trying these\nexamples yourself, you’ll need to add <code class=\"hljs\">libc</code> to your <code class=\"hljs\">Cargo.toml</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">libc</span> = <span class=\"hljs-string\">\"0.2.0\"</span>\n</code></pre>\n<h2 id=\"calling-foreign-functions\"><a class=\"header\" href=\"#calling-foreign-functions\">Calling foreign functions</a></h2>\n<p>The following is a minimal example of calling a foreign function which will\ncompile if snappy is installed:</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> libc::size_t;\n\n<span class=\"hljs-meta\">#[link(name = <span class=\"hljs-meta-string\">\"snappy\"</span>)]</span>\n<span class=\"hljs-keyword\">extern</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_max_compressed_length</span></span>(source_length: size_t) -&gt; size_t;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-keyword\">unsafe</span> { snappy_max_compressed_length(<span class=\"hljs-number\">100</span>) };\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"max compressed length of a 100 byte buffer: {}\"</span>, x);\n}</code></pre>\n<p>The <code class=\"hljs\">extern</code> block is a list of function signatures in a foreign library, in\nthis case with the platform's C ABI. The <code class=\"hljs\">#[link(...)]</code> attribute is used to\ninstruct the linker to link against the snappy library so the symbols are\nresolved.</p>\n<p>Foreign functions are assumed to be unsafe so calls to them need to be wrapped\nwith <code class=\"hljs\">unsafe {}</code> as a promise to the compiler that everything contained within\ntruly is safe. C libraries often expose interfaces that aren't thread-safe, and\nalmost any function that takes a pointer argument isn't valid for all possible\ninputs since the pointer could be dangling, and raw pointers fall outside of\nRust's safe memory model.</p>\n<p>When declaring the argument types to a foreign function, the Rust compiler\ncannot check if the declaration is correct, so specifying it correctly is part\nof keeping the binding correct at runtime.</p>\n<p>The <code class=\"hljs\">extern</code> block can be extended to cover the entire snappy API:</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-keyword\">use</span> libc::{c_int, size_t};\n\n<span class=\"hljs-meta\">#[link(name = <span class=\"hljs-meta-string\">\"snappy\"</span>)]</span>\n<span class=\"hljs-keyword\">extern</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_compress</span></span>(input: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n                       input_length: size_t,\n                       compressed: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>,\n                       compressed_length: *<span class=\"hljs-keyword\">mut</span> size_t) -&gt; c_int;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_uncompress</span></span>(compressed: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n                         compressed_length: size_t,\n                         uncompressed: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>,\n                         uncompressed_length: *<span class=\"hljs-keyword\">mut</span> size_t) -&gt; c_int;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_max_compressed_length</span></span>(source_length: size_t) -&gt; size_t;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_uncompressed_length</span></span>(compressed: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n                                  compressed_length: size_t,\n                                  result: *<span class=\"hljs-keyword\">mut</span> size_t) -&gt; c_int;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_validate_compressed_buffer</span></span>(compressed: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n                                         compressed_length: size_t) -&gt; c_int;\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre>\n<h2 id=\"creating-a-safe-interface\"><a class=\"header\" href=\"#creating-a-safe-interface\">Creating a safe interface</a></h2>\n<p>The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts\nlike vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe\ninternal details.</p>\n<p>Wrapping the functions which expect buffers involves using the <code class=\"hljs\">slice::raw</code> module to manipulate Rust\nvectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The\nlength is the number of elements currently contained, and the capacity is the total size in elements of\nthe allocated memory. The length is less than or equal to the capacity.</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> libc::{c_int, size_t};\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_validate_compressed_buffer</span></span>(_: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>, _: size_t) -&gt; c_int { <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">validate_compressed_buffer</span></span>(src: &amp;[<span class=\"hljs-built_in\">u8</span>]) -&gt; <span class=\"hljs-built_in\">bool</span> {\n    <span class=\"hljs-keyword\">unsafe</span> {\n        snappy_validate_compressed_buffer(src.as_ptr(), src.len() <span class=\"hljs-keyword\">as</span> size_t) == <span class=\"hljs-number\">0</span>\n    }\n}</code></pre>\n<p>The <code class=\"hljs\">validate_compressed_buffer</code> wrapper above makes use of an <code class=\"hljs\">unsafe</code> block, but it makes the\nguarantee that calling it is safe for all inputs by leaving off <code class=\"hljs\">unsafe</code> from the function\nsignature.</p>\n<p>The <code class=\"hljs\">snappy_compress</code> and <code class=\"hljs\">snappy_uncompress</code> functions are more complex, since a buffer has to be\nallocated to hold the output too.</p>\n<p>The <code class=\"hljs\">snappy_max_compressed_length</code> function can be used to allocate a vector with the maximum\nrequired capacity to hold the compressed output. The vector can then be passed to the\n<code class=\"hljs\">snappy_compress</code> function as an output parameter. An output parameter is also passed to retrieve\nthe true length after compression for setting the length.</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> libc::{size_t, c_int};\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_compress</span></span>(a: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>, b: size_t, c: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                          d: *<span class=\"hljs-keyword\">mut</span> size_t) -&gt; c_int { <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_max_compressed_length</span></span>(a: size_t) -&gt; size_t { a }\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">compress</span></span>(src: &amp;[<span class=\"hljs-built_in\">u8</span>]) -&gt; <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt; {\n    <span class=\"hljs-keyword\">unsafe</span> {\n        <span class=\"hljs-keyword\">let</span> srclen = src.len() <span class=\"hljs-keyword\">as</span> size_t;\n        <span class=\"hljs-keyword\">let</span> psrc = src.as_ptr();\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> dstlen = snappy_max_compressed_length(srclen);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> dst = <span class=\"hljs-built_in\">Vec</span>::with_capacity(dstlen <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>);\n        <span class=\"hljs-keyword\">let</span> pdst = dst.as_mut_ptr();\n\n        snappy_compress(psrc, srclen, pdst, &amp;<span class=\"hljs-keyword\">mut</span> dstlen);\n        dst.set_len(dstlen <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>);\n        dst\n    }\n}</code></pre>\n<p>Decompression is similar, because snappy stores the uncompressed size as part of the compression\nformat and <code class=\"hljs\">snappy_uncompressed_length</code> will retrieve the exact buffer size required.</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> libc::{size_t, c_int};\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_uncompress</span></span>(compressed: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                            compressed_length: size_t,\n</span><span class=\"boring\">                            uncompressed: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                            uncompressed_length: *<span class=\"hljs-keyword\">mut</span> size_t) -&gt; c_int { <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_uncompressed_length</span></span>(compressed: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                                     compressed_length: size_t,\n</span><span class=\"boring\">                                     result: *<span class=\"hljs-keyword\">mut</span> size_t) -&gt; c_int { <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">uncompress</span></span>(src: &amp;[<span class=\"hljs-built_in\">u8</span>]) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt;&gt; {\n    <span class=\"hljs-keyword\">unsafe</span> {\n        <span class=\"hljs-keyword\">let</span> srclen = src.len() <span class=\"hljs-keyword\">as</span> size_t;\n        <span class=\"hljs-keyword\">let</span> psrc = src.as_ptr();\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> dstlen: size_t = <span class=\"hljs-number\">0</span>;\n        snappy_uncompressed_length(psrc, srclen, &amp;<span class=\"hljs-keyword\">mut</span> dstlen);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> dst = <span class=\"hljs-built_in\">Vec</span>::with_capacity(dstlen <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>);\n        <span class=\"hljs-keyword\">let</span> pdst = dst.as_mut_ptr();\n\n        <span class=\"hljs-keyword\">if</span> snappy_uncompress(psrc, srclen, pdst, &amp;<span class=\"hljs-keyword\">mut</span> dstlen) == <span class=\"hljs-number\">0</span> {\n            dst.set_len(dstlen <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>);\n            <span class=\"hljs-literal\">Some</span>(dst)\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-literal\">None</span> <span class=\"hljs-comment\">// SNAPPY_INVALID_INPUT</span>\n        }\n    }\n}</code></pre>\n<p>Then, we can add some tests to show how to use them.</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> libc::{c_int, size_t};\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_compress</span></span>(input: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                          input_length: size_t,\n</span><span class=\"boring\">                          compressed: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                          compressed_length: *<span class=\"hljs-keyword\">mut</span> size_t)\n</span><span class=\"boring\">                          -&gt; c_int { <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_uncompress</span></span>(compressed: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                            compressed_length: size_t,\n</span><span class=\"boring\">                            uncompressed: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                            uncompressed_length: *<span class=\"hljs-keyword\">mut</span> size_t)\n</span><span class=\"boring\">                            -&gt; c_int { <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_max_compressed_length</span></span>(source_length: size_t) -&gt; size_t { <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_uncompressed_length</span></span>(compressed: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                                     compressed_length: size_t,\n</span><span class=\"boring\">                                     result: *<span class=\"hljs-keyword\">mut</span> size_t)\n</span><span class=\"boring\">                                     -&gt; c_int { <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">snappy_validate_compressed_buffer</span></span>(compressed: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">                                            compressed_length: size_t)\n</span><span class=\"boring\">                                            -&gt; c_int { <span class=\"hljs-number\">0</span> }\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() { }\n</span><span class=\"boring\">\n</span><span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">valid</span></span>() {\n        <span class=\"hljs-keyword\">let</span> d = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0xde</span>, <span class=\"hljs-number\">0xad</span>, <span class=\"hljs-number\">0xd0</span>, <span class=\"hljs-number\">0x0d</span>];\n        <span class=\"hljs-keyword\">let</span> c: &amp;[<span class=\"hljs-built_in\">u8</span>] = &amp;compress(&amp;d);\n        <span class=\"hljs-built_in\">assert!</span>(validate_compressed_buffer(c));\n        <span class=\"hljs-built_in\">assert!</span>(uncompress(c) == <span class=\"hljs-literal\">Some</span>(d));\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">invalid</span></span>() {\n        <span class=\"hljs-keyword\">let</span> d = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>];\n        <span class=\"hljs-built_in\">assert!</span>(!validate_compressed_buffer(&amp;d));\n        <span class=\"hljs-built_in\">assert!</span>(uncompress(&amp;d).is_none());\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">empty</span></span>() {\n        <span class=\"hljs-keyword\">let</span> d = <span class=\"hljs-built_in\">vec!</span>[];\n        <span class=\"hljs-built_in\">assert!</span>(!validate_compressed_buffer(&amp;d));\n        <span class=\"hljs-built_in\">assert!</span>(uncompress(&amp;d).is_none());\n        <span class=\"hljs-keyword\">let</span> c = compress(&amp;d);\n        <span class=\"hljs-built_in\">assert!</span>(validate_compressed_buffer(&amp;c));\n        <span class=\"hljs-built_in\">assert!</span>(uncompress(&amp;c) == <span class=\"hljs-literal\">Some</span>(d));\n    }\n}</code></pre>\n<h2 id=\"destructors\"><a class=\"header\" href=\"#destructors\">Destructors</a></h2>\n<p>Foreign libraries often hand off ownership of resources to the calling code.\nWhen this occurs, we must use Rust's destructors to provide safety and guarantee\nthe release of these resources (especially in the case of panic).</p>\n<p>For more about destructors, see the <a href=\"../std/ops/trait.Drop.html\">Drop trait</a>.</p>\n<h2 id=\"calling-rust-code-from-c\"><a class=\"header\" href=\"#calling-rust-code-from-c\">Calling Rust code from C</a></h2>\n<p>You may wish to compile Rust code in a way so that it can be called from C.\nThis is fairly easy, but requires a few things.</p>\n<h3 id=\"rust-side\"><a class=\"header\" href=\"#rust-side\">Rust side</a></h3>\n<p>First, we assume you have a lib crate named as <code class=\"hljs\">rust_from_c</code>.\n<code class=\"hljs\">lib.rs</code> should have Rust code as following:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"hljs-meta\">#[no_mangle]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello_from_rust</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Hello from Rust!\"</span>);\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p>The <code class=\"hljs\">extern \"C\"</code> makes this function adhere to the C calling convention, as discussed below in \"<a href=\"ffi.html#foreign-calling-conventions\">Foreign Calling Conventions</a>\".\nThe <code class=\"hljs\">no_mangle</code> attribute turns off Rust's name mangling, so that it has a well defined symbol to link to.</p>\n<p>Then, to compile Rust code as a shared library that can be called from C, add the following to your <code class=\"hljs\">Cargo.toml</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[lib]</span>\n<span class=\"hljs-attr\">crate-type</span> = [<span class=\"hljs-string\">\"cdylib\"</span>]\n</code></pre>\n<p>(NOTE: We could also use the <code class=\"hljs\">staticlib</code> crate type but it needs to tweak some linking flags.)</p>\n<p>Run <code class=\"hljs\">cargo build</code> and you're ready to go on the Rust side.</p>\n<h3 id=\"c-side\"><a class=\"header\" href=\"#c-side\">C side</a></h3>\n<p>We'll create a C file to call the <code class=\"hljs\">hello_from_rust</code> function and compile it by <code class=\"hljs\">gcc</code>.</p>\n<p>C file should look like:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-c hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hello_from_rust</span><span class=\"hljs-params\">()</span></span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>)</span> </span>{\n    hello_from_rust();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<p>We name the file as <code class=\"hljs\">call_rust.c</code> and place it on the crate root.\nRun the following to compile:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">gcc call_rust.c -o call_rust -lrust_from_c -L./target/debug\n</code></pre>\n<p><code class=\"hljs\">-l</code> and <code class=\"hljs\">-L</code> tell gcc to find our Rust library.</p>\n<p>Finally, we can call Rust code from C with <code class=\"hljs\">LD_LIBRARY_PATH</code> specified:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">$ LD_LIBRARY_PATH=./target/debug ./call_rust\nHello from Rust!\n</code></pre>\n<p>That's it!\nFor more realistic example, check the <a href=\"https://github.com/eqrion/cbindgen\"><code class=\"hljs\">cbindgen</code></a>.</p>\n<h2 id=\"callbacks-from-c-code-to-rust-functions\"><a class=\"header\" href=\"#callbacks-from-c-code-to-rust-functions\">Callbacks from C code to Rust functions</a></h2>\n<p>Some external libraries require the usage of callbacks to report back their\ncurrent state or intermediate data to the caller.\nIt is possible to pass functions defined in Rust to an external library.\nThe requirement for this is that the callback function is marked as <code class=\"hljs\">extern</code>\nwith the correct calling convention to make it callable from C code.</p>\n<p>The callback function can then be sent through a registration call\nto the C library and afterwards be invoked from there.</p>\n<p>A basic example is:</p>\n<p>Rust code:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust no_run edition2021 hljs\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">callback</span></span>(a: <span class=\"hljs-built_in\">i32</span>) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"I'm called from C with value {0}\"</span>, a);\n}\n\n<span class=\"hljs-meta\">#[link(name = <span class=\"hljs-meta-string\">\"extlib\"</span>)]</span>\n<span class=\"hljs-keyword\">extern</span> {\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">register_callback</span></span>(cb: <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(<span class=\"hljs-built_in\">i32</span>)) -&gt; <span class=\"hljs-built_in\">i32</span>;\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">trigger_callback</span></span>();\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">unsafe</span> {\n        register_callback(callback);\n        trigger_callback(); <span class=\"hljs-comment\">// Triggers the callback.</span>\n    }\n}</code></pre></pre>\n<p>C code:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-c hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">void</span> <span class=\"hljs-params\">(*rust_callback)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int32_t</span>)</span></span>;\nrust_callback cb;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int32_t</span> <span class=\"hljs-title\">register_callback</span><span class=\"hljs-params\">(rust_callback callback)</span> </span>{\n    cb = callback;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">trigger_callback</span><span class=\"hljs-params\">()</span> </span>{\n  cb(<span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// Will call callback(7) in Rust.</span>\n}\n</code></pre>\n<p>In this example Rust's <code class=\"hljs\">main()</code> will call <code class=\"hljs\">trigger_callback()</code> in C,\nwhich would, in turn, call back to <code class=\"hljs\">callback()</code> in Rust.</p>\n<h2 id=\"targeting-callbacks-to-rust-objects\"><a class=\"header\" href=\"#targeting-callbacks-to-rust-objects\">Targeting callbacks to Rust objects</a></h2>\n<p>The former example showed how a global function can be called from C code.\nHowever it is often desired that the callback is targeted to a special\nRust object. This could be the object that represents the wrapper for the\nrespective C object.</p>\n<p>This can be achieved by passing a raw pointer to the object down to the\nC library. The C library can then include the pointer to the Rust object in\nthe notification. This will allow the callback to unsafely access the\nreferenced Rust object.</p>\n<p>Rust code:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust no_run edition2021 hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RustObject</span></span> {\n    a: <span class=\"hljs-built_in\">i32</span>,\n    <span class=\"hljs-comment\">// Other members...</span>\n}\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">callback</span></span>(target: *<span class=\"hljs-keyword\">mut</span> RustObject, a: <span class=\"hljs-built_in\">i32</span>) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"I'm called from C with value {0}\"</span>, a);\n    <span class=\"hljs-keyword\">unsafe</span> {\n        <span class=\"hljs-comment\">// Update the value in RustObject with the value received from the callback:</span>\n        (*target).a = a;\n    }\n}\n\n<span class=\"hljs-meta\">#[link(name = <span class=\"hljs-meta-string\">\"extlib\"</span>)]</span>\n<span class=\"hljs-keyword\">extern</span> {\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">register_callback</span></span>(target: *<span class=\"hljs-keyword\">mut</span> RustObject,\n                        cb: <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(*<span class=\"hljs-keyword\">mut</span> RustObject, <span class=\"hljs-built_in\">i32</span>)) -&gt; <span class=\"hljs-built_in\">i32</span>;\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">trigger_callback</span></span>();\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// Create the object that will be referenced in the callback:</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> rust_object = <span class=\"hljs-built_in\">Box</span>::new(RustObject { a: <span class=\"hljs-number\">5</span> });\n\n    <span class=\"hljs-keyword\">unsafe</span> {\n        register_callback(&amp;<span class=\"hljs-keyword\">mut</span> *rust_object, callback);\n        trigger_callback();\n    }\n}</code></pre></pre>\n<p>C code:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-c hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">void</span> <span class=\"hljs-params\">(*rust_callback)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>*, <span class=\"hljs-keyword\">int32_t</span>)</span></span>;\n<span class=\"hljs-keyword\">void</span>* cb_target;\nrust_callback cb;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int32_t</span> <span class=\"hljs-title\">register_callback</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>* callback_target, rust_callback callback)</span> </span>{\n    cb_target = callback_target;\n    cb = callback;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">trigger_callback</span><span class=\"hljs-params\">()</span> </span>{\n  cb(cb_target, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// Will call callback(&amp;rustObject, 7) in Rust.</span>\n}\n</code></pre>\n<h2 id=\"asynchronous-callbacks\"><a class=\"header\" href=\"#asynchronous-callbacks\">Asynchronous callbacks</a></h2>\n<p>In the previously given examples the callbacks are invoked as a direct reaction\nto a function call to the external C library.\nThe control over the current thread is switched from Rust to C to Rust for the\nexecution of the callback, but in the end the callback is executed on the\nsame thread that called the function which triggered the callback.</p>\n<p>Things get more complicated when the external library spawns its own threads\nand invokes callbacks from there.\nIn these cases access to Rust data structures inside the callbacks is\nespecially unsafe and proper synchronization mechanisms must be used.\nBesides classical synchronization mechanisms like mutexes, one possibility in\nRust is to use channels (in <code class=\"hljs\">std::sync::mpsc</code>) to forward data from the C\nthread that invoked the callback into a Rust thread.</p>\n<p>If an asynchronous callback targets a special object in the Rust address space\nit is also absolutely necessary that no more callbacks are performed by the\nC library after the respective Rust object gets destroyed.\nThis can be achieved by unregistering the callback in the object's\ndestructor and designing the library in a way that guarantees that no\ncallback will be performed after deregistration.</p>\n<h2 id=\"linking\"><a class=\"header\" href=\"#linking\">Linking</a></h2>\n<p>The <code class=\"hljs\">link</code> attribute on <code class=\"hljs\">extern</code> blocks provides the basic building block for\ninstructing rustc how it will link to native libraries. There are two accepted\nforms of the link attribute today:</p>\n<ul>\n<li><code class=\"hljs\">#[link(name = \"foo\")]</code></li>\n<li><code class=\"hljs\">#[link(name = \"foo\", kind = \"bar\")]</code></li>\n</ul>\n<p>In both of these cases, <code class=\"hljs\">foo</code> is the name of the native library that we're\nlinking to, and in the second case <code class=\"hljs\">bar</code> is the type of native library that the\ncompiler is linking to. There are currently three known types of native\nlibraries:</p>\n<ul>\n<li>Dynamic - <code class=\"hljs\">#[link(name = \"readline\")]</code></li>\n<li>Static - <code class=\"hljs\">#[link(name = \"my_build_dependency\", kind = \"static\")]</code></li>\n<li>Frameworks - <code class=\"hljs\">#[link(name = \"CoreFoundation\", kind = \"framework\")]</code></li>\n</ul>\n<p>Note that frameworks are only available on macOS targets.</p>\n<p>The different <code class=\"hljs\">kind</code> values are meant to differentiate how the native library\nparticipates in linkage. From a linkage perspective, the Rust compiler creates\ntwo flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).\nNative dynamic library and framework dependencies are propagated to the final\nartifact boundary, while static library dependencies are not propagated at\nall, because the static libraries are integrated directly into the subsequent\nartifact.</p>\n<p>A few examples of how this model can be used are:</p>\n<ul>\n<li>\n<p>A native build dependency. Sometimes some C/C++ glue is needed when writing\nsome Rust code, but distribution of the C/C++ code in a library format is\na burden. In this case, the code will be archived into <code class=\"hljs\">libfoo.a</code> and then the\nRust crate would declare a dependency via <code class=\"hljs\">#[link(name = \"foo\", kind = \"static\")]</code>.</p>\n<p>Regardless of the flavor of output for the crate, the native static library\nwill be included in the output, meaning that distribution of the native static\nlibrary is not necessary.</p>\n</li>\n<li>\n<p>A normal dynamic dependency. Common system libraries (like <code class=\"hljs\">readline</code>) are\navailable on a large number of systems, and often a static copy of these\nlibraries cannot be found. When this dependency is included in a Rust crate,\npartial targets (like rlibs) will not link to the library, but when the rlib\nis included in a final target (like a binary), the native library will be\nlinked in.</p>\n</li>\n</ul>\n<p>On macOS, frameworks behave with the same semantics as a dynamic library.</p>\n<h2 id=\"unsafe-blocks\"><a class=\"header\" href=\"#unsafe-blocks\">Unsafe blocks</a></h2>\n<p>Some operations, like dereferencing raw pointers or calling functions that have been marked\nunsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to\nthe compiler that the unsafety does not leak out of the block.</p>\n<p>Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like\nthis:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">kaboom</span></span>(ptr: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">i32</span>) -&gt; <span class=\"hljs-built_in\">i32</span> { *ptr }\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This function can only be called from an <code class=\"hljs\">unsafe</code> block or another <code class=\"hljs\">unsafe</code> function.</p>\n<h2 id=\"accessing-foreign-globals\"><a class=\"header\" href=\"#accessing-foreign-globals\">Accessing foreign globals</a></h2>\n<p>Foreign APIs often export a global variable which could do something like track\nglobal state. In order to access these variables, you declare them in <code class=\"hljs\">extern</code>\nblocks with the <code class=\"hljs\">static</code> keyword:</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[link(name = <span class=\"hljs-meta-string\">\"readline\"</span>)]</span>\n<span class=\"hljs-keyword\">extern</span> {\n    <span class=\"hljs-keyword\">static</span> rl_readline_version: libc::c_int;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"You have readline version {} installed.\"</span>,\n             <span class=\"hljs-keyword\">unsafe</span> { rl_readline_version <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">i32</span> });\n}</code></pre>\n<p>Alternatively, you may need to alter global state provided by a foreign\ninterface. To do this, statics can be declared with <code class=\"hljs\">mut</code> so we can mutate\nthem.</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> std::ffi::CString;\n<span class=\"hljs-keyword\">use</span> std::ptr;\n\n<span class=\"hljs-meta\">#[link(name = <span class=\"hljs-meta-string\">\"readline\"</span>)]</span>\n<span class=\"hljs-keyword\">extern</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">mut</span> rl_prompt: *<span class=\"hljs-keyword\">const</span> libc::c_char;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> prompt = CString::new(<span class=\"hljs-string\">\"[my-awesome-shell] $\"</span>).unwrap();\n    <span class=\"hljs-keyword\">unsafe</span> {\n        rl_prompt = prompt.as_ptr();\n\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{:?}\"</span>, rl_prompt);\n\n        rl_prompt = ptr::null();\n    }\n}</code></pre>\n<p>Note that all interaction with a <code class=\"hljs\">static mut</code> is unsafe, both reading and\nwriting. Dealing with global mutable state requires a great deal of care.</p>\n<h2 id=\"foreign-calling-conventions\"><a class=\"header\" href=\"#foreign-calling-conventions\">Foreign calling conventions</a></h2>\n<p>Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when\ncalling foreign functions. Some foreign functions, most notably the Windows API, use other calling\nconventions. Rust provides a way to tell the compiler which convention to use:</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-meta\">#[cfg(all(target_os = <span class=\"hljs-meta-string\">\"win32\"</span>, target_arch = <span class=\"hljs-meta-string\">\"x86\"</span>))]</span>\n<span class=\"hljs-meta\">#[link(name = <span class=\"hljs-meta-string\">\"kernel32\"</span>)]</span>\n<span class=\"hljs-meta\">#[allow(non_snake_case)]</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"stdcall\"</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">SetEnvironmentVariableA</span></span>(n: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>, v: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>) -&gt; libc::c_int;\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() { }</span></code></pre>\n<p>This applies to the entire <code class=\"hljs\">extern</code> block. The list of supported ABI constraints\nare:</p>\n<ul>\n<li><code class=\"hljs\">stdcall</code></li>\n<li><code class=\"hljs\">aapcs</code></li>\n<li><code class=\"hljs\">cdecl</code></li>\n<li><code class=\"hljs\">fastcall</code></li>\n<li><code class=\"hljs\">thiscall</code></li>\n<li><code class=\"hljs\">vectorcall</code>\nThis is currently hidden behind the <code class=\"hljs\">abi_vectorcall</code> gate and is subject to change.</li>\n<li><code class=\"hljs\">Rust</code></li>\n<li><code class=\"hljs\">rust-intrinsic</code></li>\n<li><code class=\"hljs\">system</code></li>\n<li><code class=\"hljs\">C</code></li>\n<li><code class=\"hljs\">win64</code></li>\n<li><code class=\"hljs\">sysv64</code></li>\n</ul>\n<p>Most of the abis in this list are self-explanatory, but the <code class=\"hljs\">system</code> abi may\nseem a little odd. This constraint selects whatever the appropriate ABI is for\ninteroperating with the target's libraries. For example, on win32 with a x86\narchitecture, this means that the abi used would be <code class=\"hljs\">stdcall</code>. On x86_64,\nhowever, windows uses the <code class=\"hljs\">C</code> calling convention, so <code class=\"hljs\">C</code> would be used. This\nmeans that in our previous example, we could have used <code class=\"hljs\">extern \"system\" { ... }</code>\nto define a block for all windows systems, not only x86 ones.</p>\n<h2 id=\"interoperability-with-foreign-code\"><a class=\"header\" href=\"#interoperability-with-foreign-code\">Interoperability with foreign code</a></h2>\n<p>Rust guarantees that the layout of a <code class=\"hljs\">struct</code> is compatible with the platform's\nrepresentation in C only if the <code class=\"hljs\">#[repr(C)]</code> attribute is applied to it.\n<code class=\"hljs\">#[repr(C, packed)]</code> can be used to lay out struct members without padding.\n<code class=\"hljs\">#[repr(C)]</code> can also be applied to an enum.</p>\n<p>Rust's owned boxes (<code class=\"hljs\">Box&lt;T&gt;</code>) use non-nullable pointers as handles which point\nto the contained object. However, they should not be manually created because\nthey are managed by internal allocators. References can safely be assumed to be\nnon-nullable pointers directly to the type.  However, breaking the borrow\nchecking or mutability rules is not guaranteed to be safe, so prefer using raw\npointers (<code class=\"hljs\">*</code>) if that's needed because the compiler can't make as many\nassumptions about them.</p>\n<p>Vectors and strings share the same basic memory layout, and utilities are\navailable in the <code class=\"hljs\">vec</code> and <code class=\"hljs\">str</code> modules for working with C APIs. However,\nstrings are not terminated with <code class=\"hljs\">\\0</code>. If you need a NUL-terminated string for\ninteroperability with C, you should use the <code class=\"hljs\">CString</code> type in the <code class=\"hljs\">std::ffi</code>\nmodule.</p>\n<p>The <a href=\"https://crates.io/crates/libc\"><code class=\"hljs\">libc</code> crate on crates.io</a> includes type aliases and function\ndefinitions for the C standard library in the <code class=\"hljs\">libc</code> module, and Rust links\nagainst <code class=\"hljs\">libc</code> and <code class=\"hljs\">libm</code> by default.</p>\n<h2 id=\"variadic-functions\"><a class=\"header\" href=\"#variadic-functions\">Variadic functions</a></h2>\n<p>In C, functions can be 'variadic', meaning they accept a variable number of arguments. This can\nbe achieved in Rust by specifying <code class=\"hljs\">...</code> within the argument list of a foreign function declaration:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-no_run hljs\">extern {\n    fn foo(x: i32, ...);\n}\n\nfn main() {\n    unsafe {\n        foo(10, 20, 30, 40, 50);\n    }\n}\n</code></pre>\n<p>Normal Rust functions can <em>not</em> be variadic:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// This will not compile</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(x: <span class=\"hljs-built_in\">i32</span>, ...) {}\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"the-nullable-pointer-optimization\"><a class=\"header\" href=\"#the-nullable-pointer-optimization\">The \"nullable pointer optimization\"</a></h2>\n<p>Certain Rust types are defined to never be <code class=\"hljs\">null</code>. This includes references (<code class=\"hljs\">&amp;T</code>,\n<code class=\"hljs\">&amp;mut T</code>), boxes (<code class=\"hljs\">Box&lt;T&gt;</code>), and function pointers (<code class=\"hljs\">extern \"abi\" fn()</code>). When\ninterfacing with C, pointers that might be <code class=\"hljs\">null</code> are often used, which would seem to\nrequire some messy <code class=\"hljs\">transmute</code>s and/or unsafe code to handle conversions to/from Rust types.\nHowever, trying to construct/work with these invalid values <strong>is undefined behavior</strong>,\nso you should use the following workaround instead.</p>\n<p>As a special case, an <code class=\"hljs\">enum</code> is eligible for the \"nullable pointer optimization\" if it contains\nexactly two variants, one of which contains no data and the other contains a field of one of the\nnon-nullable types listed above.  This means no extra space is required for a discriminant; rather,\nthe empty variant is represented by putting a <code class=\"hljs\">null</code> value into the non-nullable field. This is\ncalled an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible\ntypes.</p>\n<p>The most common type that takes advantage of the nullable pointer optimization is <code class=\"hljs\">Option&lt;T&gt;</code>,\nwhere <code class=\"hljs\">None</code> corresponds to <code class=\"hljs\">null</code>. So <code class=\"hljs\">Option&lt;extern \"C\" fn(c_int) -&gt; c_int&gt;</code> is a correct way\nto represent a nullable function pointer using the C ABI (corresponding to the C type\n<code class=\"hljs\">int (*)(int)</code>).</p>\n<p>Here is a contrived example. Let's say some C library has a facility for registering a\ncallback, which gets called in certain situations. The callback is passed a function pointer\nand an integer and it is supposed to run the function with the integer as a parameter. So\nwe have function pointers flying across the FFI boundary in both directions.</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-keyword\">use</span> libc::c_int;\n\n<span class=\"boring\"><span class=\"hljs-meta\">#[cfg(hidden)]</span>\n</span><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-comment\">/// Registers the callback.</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">register</span></span>(cb: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(<span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(c_int) -&gt; c_int&gt;, c_int) -&gt; c_int&gt;);\n}\n<span class=\"boring\"><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">register</span></span>(_: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(<span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(c_int) -&gt; c_int&gt;,\n</span><span class=\"boring\">                                           c_int) -&gt; c_int&gt;)\n</span><span class=\"boring\">{}\n</span>\n<span class=\"hljs-comment\">/// This fairly useless function receives a function pointer and an integer</span>\n<span class=\"hljs-comment\">/// from C, and returns the result of calling the function with the integer.</span>\n<span class=\"hljs-comment\">/// In case no function is provided, it squares the integer by default.</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">apply</span></span>(process: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(c_int) -&gt; c_int&gt;, int: c_int) -&gt; c_int {\n    <span class=\"hljs-keyword\">match</span> process {\n        <span class=\"hljs-literal\">Some</span>(f) =&gt; f(int),\n        <span class=\"hljs-literal\">None</span>    =&gt; int * int\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">unsafe</span> {\n        register(<span class=\"hljs-literal\">Some</span>(apply));\n    }\n}</code></pre>\n<p>And the code on the C side looks like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-c hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">register</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> (*f)(<span class=\"hljs-keyword\">int</span> (*)(<span class=\"hljs-keyword\">int</span>), <span class=\"hljs-keyword\">int</span>))</span> </span>{\n    ...\n}\n</code></pre>\n<p>No <code class=\"hljs\">transmute</code> required!</p>\n<h2 id=\"ffi-and-unwinding\"><a class=\"header\" href=\"#ffi-and-unwinding\">FFI and unwinding</a></h2>\n<p>It’s important to be mindful of unwinding when working with FFI. Most\nABI strings come in two variants, one with an <code class=\"hljs\">-unwind</code> suffix and one without.\nThe <code class=\"hljs\">Rust</code> ABI always permits unwinding, so there is no <code class=\"hljs\">Rust-unwind</code> ABI.</p>\n<p>If you expect Rust <code class=\"hljs\">panic</code>s or foreign (e.g. C++) exceptions to cross an FFI\nboundary, that boundary must use the appropriate <code class=\"hljs\">-unwind</code> ABI string.\nConversely, if you do not expect unwinding to cross an ABI boundary, use one of\nthe non-<code class=\"hljs\">unwind</code> ABI strings.</p>\n<blockquote>\n<p>Note: Compiling with <code class=\"hljs\">panic=abort</code> will still cause <code class=\"hljs\">panic!</code> to immediately\nabort the process, regardless of which ABI is specified by the function that\n<code class=\"hljs\">panic</code>s.</p>\n</blockquote>\n<p>If an unwinding operation does encounter an ABI boundary that is\nnot permitted to unwind, the behavior depends on the source of the unwinding\n(Rust <code class=\"hljs\">panic</code> or a foreign exception):</p>\n<ul>\n<li><code class=\"hljs\">panic</code> will cause the process to safely abort.</li>\n<li>A foreign exception entering Rust will cause undefined behavior.</li>\n</ul>\n<p>Note that the interaction of <code class=\"hljs\">catch_unwind</code> with foreign exceptions <strong>is\nundefined</strong>, as is the interaction of <code class=\"hljs\">panic</code> with foreign exception-catching\nmechanisms (notably C++'s <code class=\"hljs\">try</code>/<code class=\"hljs\">catch</code>).</p>\n<h3 id=\"rust-panic-with-c-unwind\"><a class=\"header\" href=\"#rust-panic-with-c-unwind\">Rust <code>panic</code> with <code>\"C-unwind\"</code></a></h3>\n<!-- ignore: using unstable feature -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[no_mangle]</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C-unwind\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">example</span></span>() {\n    <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"Uh oh\"</span>);\n}</code></pre>\n<p>This function (when compiled with <code class=\"hljs\">panic=unwind</code>) is permitted to unwind C++\nstack frames.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">[Rust function with `catch_unwind`, which stops the unwinding]\n      |\n     ...\n      |\n[C++ frames]\n      |                           ^\n      | (calls)                   | (unwinding\n      v                           |  goes this\n[Rust function `example`]         |  way)\n      |                           |\n      +--- rust function panics --+\n</code></pre>\n<p>If the C++ frames have objects, their destructors will be called.</p>\n<h3 id=\"c-throw-with-c-unwind\"><a class=\"header\" href=\"#c-throw-with-c-unwind\">C++ <code>throw</code> with <code>\"C-unwind\"</code></a></h3>\n<!-- ignore: using unstable feature -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[link(...)]</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C-unwind\"</span> {\n    <span class=\"hljs-comment\">// A C++ function that may throw an exception</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">may_throw</span></span>();\n}\n\n<span class=\"hljs-meta\">#[no_mangle]</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C-unwind\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">rust_passthrough</span></span>() {\n    <span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">unsafe</span> { may_throw(); }\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{:?}\"</span>, &amp;b);\n}</code></pre>\n<p>A C++ function with a <code class=\"hljs\">try</code> block may invoke <code class=\"hljs\">rust_passthrough</code> and <code class=\"hljs\">catch</code> an\nexception thrown by <code class=\"hljs\">may_throw</code>.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">[C++ function with `try` block that invokes `rust_passthrough`]\n      |\n     ...\n      |\n[Rust function `rust_passthrough`]\n      |                            ^\n      | (calls)                    | (unwinding\n      v                            |  goes this\n[C++ function `may_throw`]         |  way)\n      |                            |\n      +--- C++ function throws ----+\n</code></pre>\n<p>If <code class=\"hljs\">may_throw</code> does throw an exception, <code class=\"hljs\">b</code> will be dropped. Otherwise, <code class=\"hljs\">5</code>\nwill be printed.</p>\n<h3 id=\"panic-can-be-stopped-at-an-abi-boundary\"><a class=\"header\" href=\"#panic-can-be-stopped-at-an-abi-boundary\"><code>panic</code> can be stopped at an ABI boundary</a></h3>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[no_mangle]</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">assert_nonzero</span></span>(input: <span class=\"hljs-built_in\">u32</span>) {\n    <span class=\"hljs-built_in\">assert!</span>(input != <span class=\"hljs-number\">0</span>)\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>If <code class=\"hljs\">assert_nonzero</code> is called with the argument <code class=\"hljs\">0</code>, the runtime is guaranteed\nto (safely) abort the process, whether or not compiled with <code class=\"hljs\">panic=abort</code>.</p>\n<h3 id=\"catching-panic-preemptively\"><a class=\"header\" href=\"#catching-panic-preemptively\">Catching <code>panic</code> preemptively</a></h3>\n<p>If you are writing Rust code that may panic, and you don't wish to abort the\nprocess if it panics, you must use <a href=\"../std/panic/fn.catch_unwind.html\"><code class=\"hljs\">catch_unwind</code></a>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-keyword\">use</span> std::panic::catch_unwind;\n\n<span class=\"hljs-meta\">#[no_mangle]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">oh_no</span></span>() -&gt; <span class=\"hljs-built_in\">i32</span> {\n    <span class=\"hljs-keyword\">let</span> result = catch_unwind(|| {\n        <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"Oops!\"</span>);\n    });\n    <span class=\"hljs-keyword\">match</span> result {\n        <span class=\"hljs-literal\">Ok</span>(_) =&gt; <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-literal\">Err</span>(_) =&gt; <span class=\"hljs-number\">1</span>,\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</code></pre></pre>\n<p>Please note that <a href=\"../std/panic/fn.catch_unwind.html\"><code class=\"hljs\">catch_unwind</code></a> will only catch unwinding panics, not\nthose that abort the process. See the documentation of <a href=\"../std/panic/fn.catch_unwind.html\"><code class=\"hljs\">catch_unwind</code></a>\nfor more information.</p>\n<h2 id=\"representing-opaque-structs\"><a class=\"header\" href=\"#representing-opaque-structs\">Representing opaque structs</a></h2>\n<p>Sometimes, a C library wants to provide a pointer to something, but not let you know the internal details of the thing it wants.\nA stable and simple way is to use a <code class=\"hljs\">void *</code> argument:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-c hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *arg)</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *arg)</span></span>;\n</code></pre>\n<p>We can represent this in Rust with the <code class=\"hljs\">c_void</code> type:</p>\n<!-- ignore: requires libc crate -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(arg: *<span class=\"hljs-keyword\">mut</span> libc::c_void);\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bar</span></span>(arg: *<span class=\"hljs-keyword\">mut</span> libc::c_void);\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre>\n<p>This is a perfectly valid way of handling the situation. However, we can do a bit\nbetter. To solve this, some C libraries will instead create a <code class=\"hljs\">struct</code>, where\nthe details and memory layout of the struct are private. This gives some amount\nof type safety. These structures are called ‘opaque’. Here’s an example, in C:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-c hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span>;</span> <span class=\"hljs-comment\">/* Foo is a structure, but its contents are not part of the public interface */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span>;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(struct Foo *arg)</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">(struct Bar *arg)</span></span>;\n</code></pre>\n<p>To do this in Rust, let’s create our own opaque types:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    _data: [<span class=\"hljs-built_in\">u8</span>; <span class=\"hljs-number\">0</span>],\n    _marker:\n        core::marker::PhantomData&lt;(*<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>, core::marker::PhantomPinned)&gt;,\n}\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span></span> {\n    _data: [<span class=\"hljs-built_in\">u8</span>; <span class=\"hljs-number\">0</span>],\n    _marker:\n        core::marker::PhantomData&lt;(*<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>, core::marker::PhantomPinned)&gt;,\n}\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(arg: *<span class=\"hljs-keyword\">mut</span> Foo);\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bar</span></span>(arg: *<span class=\"hljs-keyword\">mut</span> Bar);\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p>By including at least one private field and no constructor,\nwe create an opaque type that we can't instantiate outside of this module.\n(A struct with no field could be instantiated by anyone.)\nWe also want to use this type in FFI, so we have to add <code class=\"hljs\">#[repr(C)]</code>.\nThe marker ensures the compiler does not mark the struct as <code class=\"hljs\">Send</code>, <code class=\"hljs\">Sync</code> and <code class=\"hljs\">Unpin</code> are\nnot applied to the struct. (<code class=\"hljs\">*mut u8</code> is not <code class=\"hljs\">Send</code> or <code class=\"hljs\">Sync</code>, <code class=\"hljs\">PhantomPinned</code> is not <code class=\"hljs\">Unpin</code>)</p>\n<p>But because our <code class=\"hljs\">Foo</code> and <code class=\"hljs\">Bar</code> types are\ndifferent, we’ll get type safety between the two of them, so we cannot\naccidentally pass a pointer to <code class=\"hljs\">Foo</code> to <code class=\"hljs\">bar()</code>.</p>\n<p>Notice that it is a really bad idea to use an empty enum as FFI type.\nThe compiler relies on empty enums being uninhabited, so handling values of type\n<code class=\"hljs\">&amp;Empty</code> is a huge footgun and can lead to buggy program behavior (by triggering\nundefined behavior).</p>\n<blockquote>\n<p><strong>NOTE:</strong> The simplest way would use \"extern types\".\nBut it's currently (as of June 2021) unstable and has some unresolved questions, see the <a href=\"https://rust-lang.github.io/rfcs/1861-extern-types.html\">RFC page</a> and the <a href=\"https://github.com/rust-lang/rust/issues/43467\">tracking issue</a> for more details.</p>\n</blockquote>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"arc-mutex/arc-final.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"beneath-std.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"arc-mutex/arc-final.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"beneath-std.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:20:41.580Z"
}