{
	"title": "Search - The rustdoc book",
	"url": "https://doc.rust-lang.org/1.80.0/rustdoc/read-documentation/search.html",
	"markdown": "# Search - The rustdoc book\n\nTyping in the search bar instantly searches the available documentation, matching either the name and path of an item, or a function's approximate type signature.\n\n## [Search By Name](#search-by-name)\n\nTo search by the name of an item (items include modules, types, traits, functions, and macros), write its name or path. As a special case, the parts of a path that normally get divided by `::` double colons can instead be separated by spaces. For example:\n\n-   [`vec new`](../../std/vec/struct.Vec.html?search=vec%20new&filter-crate=std) and [`vec::new`](../../std/vec/struct.Vec.html?search=vec::new&filter-crate=std) both show the function `std::vec::Vec::new` as a result.\n-   [`vec`](../../std/vec/struct.Vec.html?search=vec&filter-crate=std), [`vec vec`](../../std/vec/struct.Vec.html?search=vec%20vec&filter-crate=std), [`std::vec`](../../std/vec/struct.Vec.html?search=std::vec&filter-crate=std), and [`std::vec::Vec`](../../std/vec/struct.Vec.html?search=std::vec::Vec&filter-crate=std) all include the struct `std::vec::Vec` itself in the results (and all but the last one also include the module in the results).\n\nAs a quick way to trim down the list of results, there's a drop-down selector below the search input, labeled \"Results in \\[std\\]\". Clicking it can change which crate is being searched.\n\nRustdoc uses a fuzzy matching function that can tolerate typos for this, though it's based on the length of the name that's typed in, so a good example of how this works would be [`HahsMap`](../../std/collections/struct.HashMap.html?search=HahsMap&filter-crate=std). To avoid this, wrap the item in quotes, searching for `\"HahsMap\"` (in this example, no results will be returned).\n\n### [Tabs in the Search By Name interface](#tabs-in-the-search-by-name-interface)\n\nIn fact, using [`HahsMap`](../../std/collections/struct.HashMap.html?search=HahsMap&filter-crate=std) again as the example, it tells you that you're using \"In Names\" by default, but also lists two other tabs below the crate drop-down: \"In Parameters\" and \"In Return Types\".\n\nThese two tabs are lists of functions, defined on the closest matching type to the search (for `HahsMap`, it loudly auto-corrects to `hashmap`). This auto-correct only kicks in if nothing is found that matches the literal.\n\nThese tabs are not just methods. For example, searching the alloc crate for [`Layout`](../../alloc/index.html?search=Layout&filter-crate=alloc) also lists functions that accept layouts even though they're methods on the allocator or free functions.\n\n## [Searching By Type Signature for functions](#searching-by-type-signature-for-functions)\n\nIf you know more specifically what the function you want to look at does, Rustdoc can search by more than one type at once in the parameters and return value. Multiple parameters are separated by `,` commas, and the return value is written with after a `->` arrow.\n\nBefore describing the syntax in more detail, here's a few sample searches of the standard library and functions that are included in the results list:\n\n### [How type-based search works](#how-type-based-search-works)\n\nIn a complex type-based search, Rustdoc always treats every item's name as literal. If a name is used and nothing in the docs matches the individual item, such as a typo-ed [`uize -> vec`](../../std/vec/struct.Vec.html?search=uize%20-%3E%20vec&filter-crate=std) search, the item `uize` is treated as a generic type parameter (resulting in `vec::from` and other generic vec constructors).\n\nAfter deciding which items are type parameters and which are actual types, it then searches by matching up the function parameters (written before the `->`) and the return types (written after the `->`). Type matching is order-agnostic, and allows items to be left out of the query, but items that are present in the query must be present in the function for it to match. The `self` parameter is treated the same as any other parameter, and `Self` is resolved to the underlying type's name.\n\nFunction signature searches can query generics, wrapped in angle brackets, and traits will be normalized like types in the search engine if no type parameters match them. For example, a function with the signature `fn my_function<I: Iterator<Item=u32>>(input: I) -> usize` can be matched with the following queries:\n\n-   `Iterator<Item=u32> -> usize`\n-   `Iterator<u32> -> usize` (you can leave out the `Item=` part)\n-   `Iterator -> usize` (you can leave out iterator's generic entirely)\n-   `T -> usize` (you can match with a generic parameter)\n\nEach of the above queries is progressively looser, except the last one would not match `dyn Iterator`, since that's not a type parameter.\n\nIf a bound has multiple associated types, specifying the name allows you to pick which one gets matched. If no name is specified, then the query will match of any of them. For example,\n\n```rust\n#![allow(unused)]\nfn main() {\npub trait MyTrait {\n    type First;\n    type Second;\n}\n\n/// This function can be found using the following search queries:\n///\n///     MyTrait<First=u8, Second=u32> -> bool\n///     MyTrait<u32, First=u8> -> bool\n///     MyTrait<Second=u32> -> bool\n///     MyTrait<u32, u8> -> bool\n///\n/// The following queries, however, will *not* match it:\n///\n///     MyTrait<First=u32> -> bool\n///     MyTrait<u32, u32> -> bool\npub fn my_fn(x: impl MyTrait<First=u8, Second=u32>) -> bool { true }\n}\n```\n\nGenerics and function parameters are order-agnostic, but sensitive to nesting and number of matches. For example, a function with the signature `fn read_all(&mut self: impl Read) -> Result<Vec<u8>, Error>` will match these queries:\n\n-   `&mut Read -> Result<Vec<u8>, Error>`\n-   `Read -> Result<Vec<u8>, Error>`\n-   `Read -> Result<Error, Vec>`\n-   `Read -> Result<Vec<u8>>`\n-   `Read -> u8`\n\nBut it _does not_ match `Result<Vec, u8>` or `Result<u8<Vec>>`.\n\nTo search for a function that accepts a function as a parameter, like `Iterator::all`, wrap the nested signature in parenthesis, as in [`Iterator<T>, (T -> bool) -> bool`](../../std/vec/struct.Vec.html?search=Iterator%3CT%3E%2C+(T+-%3E+bool)+-%3E+bool&filter-crate=std). You can also search for a specific closure trait, such as `Iterator<T>, (FnMut(T) -> bool) -> bool`, but you need to know which one you want.\n\n### [Primitives with Special Syntax](#primitives-with-special-syntax)\n\n| Shorthand | Explicit names |\n| --- | --- |\n| `&` | `primitive:reference` |\n| `&T` | `primitive:reference<T>` |\n| `&mut` | `primitive:reference<keyword:mut>` |\n| `&mut T` | `primitive:reference<keyword:mut, T>` |\n| `[]` | `primitive:slice` and/or `primitive:array` |\n| `[T]` | `primitive:slice<T>` and/or `primitive:array<T>` |\n| `()` | `primitive:unit` and/or `primitive:tuple` |\n| `(T)` | `T` |\n| `(T,)` | `primitive:tuple<T>` |\n| `!` | `primitive:never` |\n| `(T, U -> V, W)` | `fn(T, U) -> (V, W)`, `Fn`, `FnMut`, and `FnOnce` |\n\nWhen searching for `[]`, Rustdoc will return search results with either slices or arrays. If you know which one you want, you can force it to return results for `primitive:slice` or `primitive:array` using the explicit name syntax. Empty square brackets, `[]`, will match any slice or array regardless of what it contains, or an item type can be provided, such as `[u8]` or `[T]`, to explicitly find functions that operate on byte slices or generic slices, respectively.\n\nA single type expression wrapped in parens is the same as that type expression, since parens act as the grouping operator. If they're empty, though, they will match both `unit` and `tuple`, and if there's more than one type (or a trailing or leading comma) it is the same as `primitive:tuple<...>`.\n\nHowever, since items can be left out of the query, `(T)` will still return results for types that match tuples, even though it also matches the type on its own. That is, `(u32)` matches `(u32,)` for the exact same reason that it also matches `Result<u32, Error>`.\n\nThe `->` operator has lower precedence than comma. If it's not wrapped in brackets, it delimits the return value for the function being searched for. To search for functions that take functions as parameters, use parenthesis.\n\n### [Limitations and quirks of type-based search](#limitations-and-quirks-of-type-based-search)\n\nType-based search is still a buggy, experimental, work-in-progress feature. Most of these limitations should be addressed in future version of Rustdoc.\n\n-   There's no way to write trait constraints on generic parameters. You can name traits directly, and if there's a type parameter with that bound, it'll match, but `option<T> -> T where T: Default` cannot be precisely searched for (use `option<Default> -> Default`).\n    \n-   Supertraits, type aliases, and Deref are all ignored. Search mostly operates on type signatures _as written_, and not as they are represented within the compiler.\n    \n-   Type parameters match type parameters, such that `Option<A>` matches `Option<T>`, but never match concrete types in function signatures. A trait named as if it were a type, such as `Option<Read>`, will match a type parameter constrained by that trait, such as `Option<T> where T: Read`, as well as matching `dyn Trait` and `impl Trait`.\n    \n-   `impl Trait` in argument position is treated exactly like a type parameter, but in return position it will not match type parameters.\n    \n-   Any type named in a complex type-based search will be assumed to be a type parameter if nothing matching the name exactly is found. If you want to force a type parameter, write `generic:T` and it will be used as a type parameter even if a matching name is found. If you know that you don't want a type parameter, you can force it to match something else by giving it a different prefix like `struct:T`.\n    \n-   It's impossible to search for references or pointers. The wrapped types can be searched for, so a function that takes `&File` can be found with `File`, but you'll get a parse error when typing an `&` into the search field.\n    \n-   Searching for lifetimes is not supported.\n    \n-   It's impossible to search based on the length of an array.\n    \n\n## [Item filtering](#item-filtering)\n\nNames in the search interface can be prefixed with an item type followed by a colon (such as `mod:`) to restrict the results to just that kind of item. Also, searching for `println!` will search for a macro named `println`, just like searching for `macro:println` does. The complete list of available filters is given under the ? Help area, and in the detailed syntax below.\n\nItem filters can be used in both name-based and type signature-based searches.\n\n## [Search query syntax](#search-query-syntax)\n\n```text\nident = *(ALPHA / DIGIT / \"_\")\npath = ident *(DOUBLE-COLON ident) [BANG]\nslice-like = OPEN-SQUARE-BRACKET [ nonempty-arg-list ] CLOSE-SQUARE-BRACKET\ntuple-like = OPEN-PAREN [ nonempty-arg-list ] CLOSE-PAREN\nborrow-ref = AMP *WS [MUT] *WS [arg]\narg = [type-filter *WS COLON *WS] (path [generics] / slice-like / tuple-like / borrow-ref)\ntype-sep = COMMA/WS *(COMMA/WS)\nnonempty-arg-list = *(type-sep) arg *(type-sep arg) *(type-sep) [ return-args ]\ngeneric-arg-list = *(type-sep) arg [ EQUAL arg ] *(type-sep arg [ EQUAL arg ]) *(type-sep)\nnormal-generics = OPEN-ANGLE-BRACKET [ generic-arg-list ] *(type-sep)\n            CLOSE-ANGLE-BRACKET\nfn-like-generics = OPEN-PAREN [ nonempty-arg-list ] CLOSE-PAREN [ RETURN-ARROW arg ]\ngenerics = normal-generics / fn-like-generics\nreturn-args = RETURN-ARROW *(type-sep) nonempty-arg-list\n\nexact-search = [type-filter *WS COLON] [ RETURN-ARROW ] *WS QUOTE ident QUOTE [ generics ]\ntype-search = [ nonempty-arg-list ]\n\nquery = *WS (exact-search / type-search) *WS\n\ntype-filter = (\n    \"mod\" /\n    \"externcrate\" /\n    \"import\" /\n    \"struct\" /\n    \"enum\" /\n    \"fn\" /\n    \"type\" /\n    \"static\" /\n    \"trait\" /\n    \"impl\" /\n    \"tymethod\" /\n    \"method\" /\n    \"structfield\" /\n    \"variant\" /\n    \"macro\" /\n    \"primitive\" /\n    \"associatedtype\" /\n    \"constant\" /\n    \"associatedconstant\" /\n    \"union\" /\n    \"foreigntype\" /\n    \"keyword\" /\n    \"existential\" /\n    \"attr\" /\n    \"derive\" /\n    \"traitalias\" /\n    \"generic\")\n\nOPEN-ANGLE-BRACKET = \"<\"\nCLOSE-ANGLE-BRACKET = \">\"\nOPEN-SQUARE-BRACKET = \"[\"\nCLOSE-SQUARE-BRACKET = \"]\"\nOPEN-PAREN = \"(\"\nCLOSE-PAREN = \")\"\nCOLON = \":\"\nDOUBLE-COLON = \"::\"\nQUOTE = %x22\nCOMMA = \",\"\nRETURN-ARROW = \"->\"\nEQUAL = \"=\"\nBANG = \"!\"\nAMP = \"&\"\nMUT = \"mut\"\n\nALPHA = %x41-5A / %x61-7A ; A-Z / a-z\nDIGIT = %x30-39\nWS = %x09 / \" \"\n\n```",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Search - The rustdoc book</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"../favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded \"><a href=\"../what-is-rustdoc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> What is rustdoc?</a></li><li class=\"chapter-item expanded \"><a href=\"../command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Command-line arguments</a></li><li class=\"chapter-item expanded \"><a href=\"../how-to-read-rustdoc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> How to read rustdoc output</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../read-documentation/in-doc-settings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> In-doc settings</a></li><li class=\"chapter-item expanded \"><a href=\"../read-documentation/search.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Search</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../how-to-write-documentation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> How to write documentation</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../write-documentation/what-to-include.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What to include (and exclude)</a></li><li class=\"chapter-item expanded \"><a href=\"../write-documentation/the-doc-attribute.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The #[doc] attribute</a></li><li class=\"chapter-item expanded \"><a href=\"../write-documentation/re-exports.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Re-exports</a></li><li class=\"chapter-item expanded \"><a href=\"../write-documentation/linking-to-items-by-name.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Linking to items by name</a></li><li class=\"chapter-item expanded \"><a href=\"../write-documentation/documentation-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.</strong> Documentation tests</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../lints.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Rustdoc-specific lints</a></li><li class=\"chapter-item expanded \"><a href=\"../scraped-examples.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Scraped examples</a></li><li class=\"chapter-item expanded \"><a href=\"../advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Advanced features</a></li><li class=\"chapter-item expanded \"><a href=\"../unstable-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Unstable features</a></li><li class=\"chapter-item expanded \"><a href=\"../deprecated-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Deprecated features</a></li><li class=\"chapter-item expanded \"><a href=\"../references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> References</a></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The rustdoc book</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/rust/tree/master/src/doc/rustdoc\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"rustdoc-search\"><a class=\"header\" href=\"#rustdoc-search\">Rustdoc search</a></h1>\n<p>Typing in the search bar instantly searches the available documentation,\nmatching either the name and path of an item, or a function's approximate\ntype signature.</p>\n<h2 id=\"search-by-name\"><a class=\"header\" href=\"#search-by-name\">Search By Name</a></h2>\n<p>To search by the name of an item (items include modules, types, traits,\nfunctions, and macros), write its name or path. As a special case, the parts\nof a path that normally get divided by <code class=\"hljs\">::</code> double colons can instead be\nseparated by spaces. For example:</p>\n<ul>\n<li><a href=\"../../std/vec/struct.Vec.html?search=vec%20new&amp;filter-crate=std\"><code class=\"hljs\">vec new</code></a> and <a href=\"../../std/vec/struct.Vec.html?search=vec::new&amp;filter-crate=std\"><code class=\"hljs\">vec::new</code></a> both show the function <code class=\"hljs\">std::vec::Vec::new</code>\nas a result.</li>\n<li><a href=\"../../std/vec/struct.Vec.html?search=vec&amp;filter-crate=std\"><code class=\"hljs\">vec</code></a>, <a href=\"../../std/vec/struct.Vec.html?search=vec%20vec&amp;filter-crate=std\"><code class=\"hljs\">vec vec</code></a>, <a href=\"../../std/vec/struct.Vec.html?search=std::vec&amp;filter-crate=std\"><code class=\"hljs\">std::vec</code></a>, and <a href=\"../../std/vec/struct.Vec.html?search=std::vec::Vec&amp;filter-crate=std\"><code class=\"hljs\">std::vec::Vec</code></a> all include the struct\n<code class=\"hljs\">std::vec::Vec</code> itself in the results (and all but the last one also\ninclude the module in the results).</li>\n</ul>\n<p>As a quick way to trim down the list of results, there's a drop-down selector\nbelow the search input, labeled \"Results in [std]\". Clicking it can change\nwhich crate is being searched.</p>\n<p>Rustdoc uses a fuzzy matching function that can tolerate typos for this,\nthough it's based on the length of the name that's typed in, so a good example\nof how this works would be <a href=\"../../std/collections/struct.HashMap.html?search=HahsMap&amp;filter-crate=std\"><code class=\"hljs\">HahsMap</code></a>. To avoid this, wrap the item in quotes,\nsearching for <code class=\"hljs\">\"HahsMap\"</code> (in this example, no results will be returned).</p>\n<h3 id=\"tabs-in-the-search-by-name-interface\"><a class=\"header\" href=\"#tabs-in-the-search-by-name-interface\">Tabs in the Search By Name interface</a></h3>\n<p>In fact, using <a href=\"../../std/collections/struct.HashMap.html?search=HahsMap&amp;filter-crate=std\"><code class=\"hljs\">HahsMap</code></a> again as the example, it tells you that you're\nusing \"In Names\" by default, but also lists two other tabs below the crate\ndrop-down: \"In Parameters\" and \"In Return Types\".</p>\n<p>These two tabs are lists of functions, defined on the closest matching type\nto the search (for <code class=\"hljs\">HahsMap</code>, it loudly auto-corrects to <code class=\"hljs\">hashmap</code>). This\nauto-correct only kicks in if nothing is found that matches the literal.</p>\n<p>These tabs are not just methods. For example, searching the alloc crate for\n<a href=\"../../alloc/index.html?search=Layout&amp;filter-crate=alloc\"><code class=\"hljs\">Layout</code></a> also lists functions that accept layouts even though they're\nmethods on the allocator or free functions.</p>\n<h2 id=\"searching-by-type-signature-for-functions\"><a class=\"header\" href=\"#searching-by-type-signature-for-functions\">Searching By Type Signature for functions</a></h2>\n<p>If you know more specifically what the function you want to look at does,\nRustdoc can search by more than one type at once in the parameters and return\nvalue. Multiple parameters are separated by <code class=\"hljs\">,</code> commas, and the return value\nis written with after a <code class=\"hljs\">-&gt;</code> arrow.</p>\n<p>Before describing the syntax in more detail, here's a few sample searches of\nthe standard library and functions that are included in the results list:</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Query</th><th>Results</th></tr></thead><tbody>\n<tr><td><a href=\"../../std/vec/struct.Vec.html?search=usize%20-%3E%20vec&amp;filter-crate=std\"><code class=\"hljs\">usize -&gt; vec</code></a></td><td><code class=\"hljs\">slice::repeat</code> and <code class=\"hljs\">Vec::with_capacity</code></td></tr>\n<tr><td><a href=\"../../std/vec/struct.Vec.html?search=vec,%20vec%20-%3E%20bool&amp;filter-crate=std\"><code class=\"hljs\">vec, vec -&gt; bool</code></a></td><td><code class=\"hljs\">Vec::eq</code></td></tr>\n<tr><td><a href=\"../../std/vec/struct.Vec.html?search=option%3CT%3E%2C%20fnonce%20-%3E%20option%3CU%3E&amp;filter-crate=std\"><code class=\"hljs\">option&lt;T&gt;, fnonce -&gt; option&lt;U&gt;</code></a></td><td><code class=\"hljs\">Option::map</code> and <code class=\"hljs\">Option::and_then</code></td></tr>\n<tr><td><a href=\"../../std/vec/struct.Vec.html?search=option%3CT%3E%2C+(fnonce+(T)+-%3E+bool)+-%3E+option%3CT%3E&amp;filter-crate=std\"><code class=\"hljs\">option&lt;T&gt;, (fnonce (T) -&gt; bool) -&gt; option&lt;T&gt;</code></a></td><td><code class=\"hljs\">Option::filter</code></td></tr>\n<tr><td><a href=\"../../std/vec/struct.Vec.html?search=option%3CT%3E%2C+(T+-%3E+bool)+-%3E+option%3CT%3E&amp;filter-crate=std\"><code class=\"hljs\">option&lt;T&gt;, (T -&gt; bool) -&gt; option&lt;T&gt;</code></a></td><td><code class=\"hljs\">Option::filter</code></td></tr>\n<tr><td><a href=\"../../std/vec/struct.Vec.html?search=option%20-%3E%20default&amp;filter-crate=std\"><code class=\"hljs\">option -&gt; default</code></a></td><td><code class=\"hljs\">Option::unwrap_or_default</code></td></tr>\n<tr><td><a href=\"../../std/vec/struct.Vec.html?search=stdout%2C%20%5Bu8%5D&amp;filter-crate=std\"><code class=\"hljs\">stdout, [u8]</code></a></td><td><code class=\"hljs\">Stdout::write</code></td></tr>\n<tr><td><a href=\"../../std/vec/struct.Vec.html?search=any%20-%3E%20!&amp;filter-crate=std\"><code class=\"hljs\">any -&gt; !</code></a></td><td><code class=\"hljs\">panic::panic_any</code></td></tr>\n<tr><td><a href=\"../../std/vec/struct.Vec.html?search=vec%3A%3Aintoiter%3CT%3E%20-%3E%20%5BT%5D&amp;filter-crate=std\"><code class=\"hljs\">vec::intoiter&lt;T&gt; -&gt; [T]</code></a></td><td><code class=\"hljs\">IntoIter::as_slice</code> and <code class=\"hljs\">IntoIter::next_chunk</code></td></tr>\n<tr><td><a href=\"../../std/index.html?search=iterator%3CT%3E%2C%20fnmut%20-%3E%20T&amp;filter-crate=std\"><code class=\"hljs\">iterator&lt;T&gt;, fnmut -&gt; T</code></a></td><td><code class=\"hljs\">Iterator::reduce</code> and <code class=\"hljs\">Iterator::find</code></td></tr>\n</tbody></table>\n</div>\n<h3 id=\"how-type-based-search-works\"><a class=\"header\" href=\"#how-type-based-search-works\">How type-based search works</a></h3>\n<p>In a complex type-based search, Rustdoc always treats every item's name as literal.\nIf a name is used and nothing in the docs matches the individual item, such as\na typo-ed <a href=\"../../std/vec/struct.Vec.html?search=uize%20-%3E%20vec&amp;filter-crate=std\"><code class=\"hljs\">uize -&gt; vec</code></a> search, the item <code class=\"hljs\">uize</code> is treated as a generic\ntype parameter (resulting in <code class=\"hljs\">vec::from</code> and other generic vec constructors).</p>\n<p>After deciding which items are type parameters and which are actual types, it\nthen searches by matching up the function parameters (written before the <code class=\"hljs\">-&gt;</code>)\nand the return types (written after the <code class=\"hljs\">-&gt;</code>). Type matching is order-agnostic,\nand allows items to be left out of the query, but items that are present in the\nquery must be present in the function for it to match. The <code class=\"hljs\">self</code> parameter is\ntreated the same as any other parameter, and <code class=\"hljs\">Self</code> is resolved to the\nunderlying type's name.</p>\n<p>Function signature searches can query generics, wrapped in angle brackets, and\ntraits will be normalized like types in the search engine if no type parameters\nmatch them. For example, a function with the signature\n<code class=\"hljs\">fn my_function&lt;I: Iterator&lt;Item=u32&gt;&gt;(input: I) -&gt; usize</code>\ncan be matched with the following queries:</p>\n<ul>\n<li><code class=\"hljs\">Iterator&lt;Item=u32&gt; -&gt; usize</code></li>\n<li><code class=\"hljs\">Iterator&lt;u32&gt; -&gt; usize</code> (you can leave out the <code class=\"hljs\">Item=</code> part)</li>\n<li><code class=\"hljs\">Iterator -&gt; usize</code> (you can leave out iterator's generic entirely)</li>\n<li><code class=\"hljs\">T -&gt; usize</code> (you can match with a generic parameter)</li>\n</ul>\n<p>Each of the above queries is progressively looser, except the last one\nwould not match <code class=\"hljs\">dyn Iterator</code>, since that's not a type parameter.</p>\n<p>If a bound has multiple associated types, specifying the name allows you to\npick which one gets matched. If no name is specified, then the query will\nmatch of any of them. For example,</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">MyTrait</span></span> {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">First</span></span>;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Second</span></span>;\n}\n\n<span class=\"hljs-comment\">/// This function can be found using the following search queries:</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">///     MyTrait&lt;First=u8, Second=u32&gt; -&gt; bool</span>\n<span class=\"hljs-comment\">///     MyTrait&lt;u32, First=u8&gt; -&gt; bool</span>\n<span class=\"hljs-comment\">///     MyTrait&lt;Second=u32&gt; -&gt; bool</span>\n<span class=\"hljs-comment\">///     MyTrait&lt;u32, u8&gt; -&gt; bool</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">/// The following queries, however, will *not* match it:</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">///     MyTrait&lt;First=u32&gt; -&gt; bool</span>\n<span class=\"hljs-comment\">///     MyTrait&lt;u32, u32&gt; -&gt; bool</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">my_fn</span></span>(x: <span class=\"hljs-keyword\">impl</span> MyTrait&lt;First=<span class=\"hljs-built_in\">u8</span>, Second=<span class=\"hljs-built_in\">u32</span>&gt;) -&gt; <span class=\"hljs-built_in\">bool</span> { <span class=\"hljs-literal\">true</span> }\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Generics and function parameters are order-agnostic, but sensitive to nesting\nand number of matches. For example, a function with the signature\n<code class=\"hljs\">fn read_all(&amp;mut self: impl Read) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;</code>\nwill match these queries:</p>\n<ul>\n<li><code class=\"hljs\">&amp;mut Read -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;</code></li>\n<li><code class=\"hljs\">Read -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;</code></li>\n<li><code class=\"hljs\">Read -&gt; Result&lt;Error, Vec&gt;</code></li>\n<li><code class=\"hljs\">Read -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code></li>\n<li><code class=\"hljs\">Read -&gt; u8</code></li>\n</ul>\n<p>But it <em>does not</em> match <code class=\"hljs\">Result&lt;Vec, u8&gt;</code> or <code class=\"hljs\">Result&lt;u8&lt;Vec&gt;&gt;</code>.</p>\n<p>To search for a function that accepts a function as a parameter,\nlike <code class=\"hljs\">Iterator::all</code>, wrap the nested signature in parenthesis,\nas in <a href=\"../../std/vec/struct.Vec.html?search=Iterator%3CT%3E%2C+(T+-%3E+bool)+-%3E+bool&amp;filter-crate=std\"><code class=\"hljs\">Iterator&lt;T&gt;, (T -&gt; bool) -&gt; bool</code></a>.\nYou can also search for a specific closure trait,\nsuch as <code class=\"hljs\">Iterator&lt;T&gt;, (FnMut(T) -&gt; bool) -&gt; bool</code>,\nbut you need to know which one you want.</p>\n<h3 id=\"primitives-with-special-syntax\"><a class=\"header\" href=\"#primitives-with-special-syntax\">Primitives with Special Syntax</a></h3>\n<div class=\"table-wrapper\"><table><thead><tr><th>Shorthand</th><th>Explicit names</th></tr></thead><tbody>\n<tr><td><code class=\"hljs\">&amp;</code></td><td><code class=\"hljs\">primitive:reference</code></td></tr>\n<tr><td><code class=\"hljs\">&amp;T</code></td><td><code class=\"hljs\">primitive:reference&lt;T&gt;</code></td></tr>\n<tr><td><code class=\"hljs\">&amp;mut</code></td><td><code class=\"hljs\">primitive:reference&lt;keyword:mut&gt;</code></td></tr>\n<tr><td><code class=\"hljs\">&amp;mut T</code></td><td><code class=\"hljs\">primitive:reference&lt;keyword:mut, T&gt;</code></td></tr>\n<tr><td><code class=\"hljs\">[]</code></td><td><code class=\"hljs\">primitive:slice</code> and/or <code class=\"hljs\">primitive:array</code></td></tr>\n<tr><td><code class=\"hljs\">[T]</code></td><td><code class=\"hljs\">primitive:slice&lt;T&gt;</code> and/or <code class=\"hljs\">primitive:array&lt;T&gt;</code></td></tr>\n<tr><td><code class=\"hljs\">()</code></td><td><code class=\"hljs\">primitive:unit</code> and/or <code class=\"hljs\">primitive:tuple</code></td></tr>\n<tr><td><code class=\"hljs\">(T)</code></td><td><code class=\"hljs\">T</code></td></tr>\n<tr><td><code class=\"hljs\">(T,)</code></td><td><code class=\"hljs\">primitive:tuple&lt;T&gt;</code></td></tr>\n<tr><td><code class=\"hljs\">!</code></td><td><code class=\"hljs\">primitive:never</code></td></tr>\n<tr><td><code class=\"hljs\">(T, U -&gt; V, W)</code></td><td><code class=\"hljs\">fn(T, U) -&gt; (V, W)</code>, <code class=\"hljs\">Fn</code>, <code class=\"hljs\">FnMut</code>, and <code class=\"hljs\">FnOnce</code></td></tr>\n</tbody></table>\n</div>\n<p>When searching for <code class=\"hljs\">[]</code>, Rustdoc will return search results with either slices\nor arrays. If you know which one you want, you can force it to return results\nfor <code class=\"hljs\">primitive:slice</code> or <code class=\"hljs\">primitive:array</code> using the explicit name syntax.\nEmpty square brackets, <code class=\"hljs\">[]</code>, will match any slice or array regardless of what\nit contains, or an item type can be provided, such as <code class=\"hljs\">[u8]</code> or <code class=\"hljs\">[T]</code>, to\nexplicitly find functions that operate on byte slices or generic slices,\nrespectively.</p>\n<p>A single type expression wrapped in parens is the same as that type expression,\nsince parens act as the grouping operator. If they're empty, though, they will\nmatch both <code class=\"hljs\">unit</code> and <code class=\"hljs\">tuple</code>, and if there's more than one type (or a trailing\nor leading comma) it is the same as <code class=\"hljs\">primitive:tuple&lt;...&gt;</code>.</p>\n<p>However, since items can be left out of the query, <code class=\"hljs\">(T)</code> will still return\nresults for types that match tuples, even though it also matches the type on\nits own. That is, <code class=\"hljs\">(u32)</code> matches <code class=\"hljs\">(u32,)</code> for the exact same reason that it\nalso matches <code class=\"hljs\">Result&lt;u32, Error&gt;</code>.</p>\n<p>The <code class=\"hljs\">-&gt;</code> operator has lower precedence than comma. If it's not wrapped\nin brackets, it delimits the return value for the function being searched for.\nTo search for functions that take functions as parameters, use parenthesis.</p>\n<h3 id=\"limitations-and-quirks-of-type-based-search\"><a class=\"header\" href=\"#limitations-and-quirks-of-type-based-search\">Limitations and quirks of type-based search</a></h3>\n<p>Type-based search is still a buggy, experimental, work-in-progress feature.\nMost of these limitations should be addressed in future version of Rustdoc.</p>\n<ul>\n<li>\n<p>There's no way to write trait constraints on generic parameters.\nYou can name traits directly, and if there's a type parameter\nwith that bound, it'll match, but <code class=\"hljs\">option&lt;T&gt; -&gt; T where T: Default</code>\ncannot be precisely searched for (use <code class=\"hljs\">option&lt;Default&gt; -&gt; Default</code>).</p>\n</li>\n<li>\n<p>Supertraits, type aliases, and Deref are all ignored. Search mostly\noperates on type signatures <em>as written</em>, and not as they are\nrepresented within the compiler.</p>\n</li>\n<li>\n<p>Type parameters match type parameters, such that <code class=\"hljs\">Option&lt;A&gt;</code> matches\n<code class=\"hljs\">Option&lt;T&gt;</code>, but never match concrete types in function signatures.\nA trait named as if it were a type, such as <code class=\"hljs\">Option&lt;Read&gt;</code>, will match\na type parameter constrained by that trait, such as\n<code class=\"hljs\">Option&lt;T&gt; where T: Read</code>, as well as matching <code class=\"hljs\">dyn Trait</code> and\n<code class=\"hljs\">impl Trait</code>.</p>\n</li>\n<li>\n<p><code class=\"hljs\">impl Trait</code> in argument position is treated exactly like a type\nparameter, but in return position it will not match type parameters.</p>\n</li>\n<li>\n<p>Any type named in a complex type-based search will be assumed to be a\ntype parameter if nothing matching the name exactly is found. If you\nwant to force a type parameter, write <code class=\"hljs\">generic:T</code> and it will be used\nas a type parameter even if a matching name is found. If you know\nthat you don't want a type parameter, you can force it to match\nsomething else by giving it a different prefix like <code class=\"hljs\">struct:T</code>.</p>\n</li>\n<li>\n<p>It's impossible to search for references or pointers. The\nwrapped types can be searched for, so a function that takes <code class=\"hljs\">&amp;File</code> can\nbe found with <code class=\"hljs\">File</code>, but you'll get a parse error when typing an <code class=\"hljs\">&amp;</code>\ninto the search field.</p>\n</li>\n<li>\n<p>Searching for lifetimes is not supported.</p>\n</li>\n<li>\n<p>It's impossible to search based on the length of an array.</p>\n</li>\n</ul>\n<h2 id=\"item-filtering\"><a class=\"header\" href=\"#item-filtering\">Item filtering</a></h2>\n<p>Names in the search interface can be prefixed with an item type followed by a\ncolon (such as <code class=\"hljs\">mod:</code>) to restrict the results to just that kind of item. Also,\nsearching for <code class=\"hljs\">println!</code> will search for a macro named <code class=\"hljs\">println</code>, just like\nsearching for <code class=\"hljs\">macro:println</code> does. The complete list of available filters is\ngiven under the <kbd>?</kbd> Help area, and in the detailed syntax below.</p>\n<p>Item filters can be used in both name-based and type signature-based searches.</p>\n<h2 id=\"search-query-syntax\"><a class=\"header\" href=\"#search-query-syntax\">Search query syntax</a></h2>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">ident = *(ALPHA / DIGIT / \"_\")\npath = ident *(DOUBLE-COLON ident) [BANG]\nslice-like = OPEN-SQUARE-BRACKET [ nonempty-arg-list ] CLOSE-SQUARE-BRACKET\ntuple-like = OPEN-PAREN [ nonempty-arg-list ] CLOSE-PAREN\nborrow-ref = AMP *WS [MUT] *WS [arg]\narg = [type-filter *WS COLON *WS] (path [generics] / slice-like / tuple-like / borrow-ref)\ntype-sep = COMMA/WS *(COMMA/WS)\nnonempty-arg-list = *(type-sep) arg *(type-sep arg) *(type-sep) [ return-args ]\ngeneric-arg-list = *(type-sep) arg [ EQUAL arg ] *(type-sep arg [ EQUAL arg ]) *(type-sep)\nnormal-generics = OPEN-ANGLE-BRACKET [ generic-arg-list ] *(type-sep)\n            CLOSE-ANGLE-BRACKET\nfn-like-generics = OPEN-PAREN [ nonempty-arg-list ] CLOSE-PAREN [ RETURN-ARROW arg ]\ngenerics = normal-generics / fn-like-generics\nreturn-args = RETURN-ARROW *(type-sep) nonempty-arg-list\n\nexact-search = [type-filter *WS COLON] [ RETURN-ARROW ] *WS QUOTE ident QUOTE [ generics ]\ntype-search = [ nonempty-arg-list ]\n\nquery = *WS (exact-search / type-search) *WS\n\ntype-filter = (\n    \"mod\" /\n    \"externcrate\" /\n    \"import\" /\n    \"struct\" /\n    \"enum\" /\n    \"fn\" /\n    \"type\" /\n    \"static\" /\n    \"trait\" /\n    \"impl\" /\n    \"tymethod\" /\n    \"method\" /\n    \"structfield\" /\n    \"variant\" /\n    \"macro\" /\n    \"primitive\" /\n    \"associatedtype\" /\n    \"constant\" /\n    \"associatedconstant\" /\n    \"union\" /\n    \"foreigntype\" /\n    \"keyword\" /\n    \"existential\" /\n    \"attr\" /\n    \"derive\" /\n    \"traitalias\" /\n    \"generic\")\n\nOPEN-ANGLE-BRACKET = \"&lt;\"\nCLOSE-ANGLE-BRACKET = \"&gt;\"\nOPEN-SQUARE-BRACKET = \"[\"\nCLOSE-SQUARE-BRACKET = \"]\"\nOPEN-PAREN = \"(\"\nCLOSE-PAREN = \")\"\nCOLON = \":\"\nDOUBLE-COLON = \"::\"\nQUOTE = %x22\nCOMMA = \",\"\nRETURN-ARROW = \"-&gt;\"\nEQUAL = \"=\"\nBANG = \"!\"\nAMP = \"&amp;\"\nMUT = \"mut\"\n\nALPHA = %x41-5A / %x61-7A ; A-Z / a-z\nDIGIT = %x30-39\nWS = %x09 / \" \"\n</code></pre>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../read-documentation/in-doc-settings.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../how-to-write-documentation.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../read-documentation/in-doc-settings.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../how-to-write-documentation.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:26:29.697Z"
}