{
	"title": "spawn in std::thread - Rust",
	"url": "https://doc.rust-lang.org/stable/std/thread/fn.spawn.html",
	"markdown": "# spawn in std::thread - Rust\n\n## Function [std](../index.html)::[thread](index.html)::[spawn](#)\n\n1.0.0 · [source](about:blank/src/std/thread/mod.rs.html#692-699) ·\n\n```\npub fn spawn<F, T>(f: F) -> JoinHandle<T>where\n    F: FnOnce() -> T + Send + 'static,\n    T: Send + 'static,\n```\n\nExpand description\n\nSpawns a new thread, returning a [`JoinHandle`](struct.JoinHandle.html \"struct std::thread::JoinHandle\") for it.\n\nThe join handle provides a [`join`](about:blank/struct.JoinHandle.html#method.join \"method std::thread::JoinHandle::join\") method that can be used to join the spawned thread. If the spawned thread panics, [`join`](about:blank/struct.JoinHandle.html#method.join \"method std::thread::JoinHandle::join\") will return an [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") containing the argument given to [`panic!`](../macro.panic.html \"macro std::panic\").\n\nIf the join handle is dropped, the spawned thread will implicitly be _detached_. In this case, the spawned thread may no longer be joined. (It is the responsibility of the program to either eventually join threads it creates or detach them; otherwise, a resource leak will result.)\n\nThis call will create a thread using default parameters of [`Builder`](struct.Builder.html \"struct std::thread::Builder\"), if you want to specify the stack size or the name of the thread, use this API instead.\n\nAs you can see in the signature of `spawn` there are two constraints on both the closure given to `spawn` and its return value, let’s explain them:\n\n-   The `'static` constraint means that the closure and its return value must have a lifetime of the whole program execution. The reason for this is that threads can outlive the lifetime they have been created in.\n    \n    Indeed if the thread, and by extension its return value, can outlive their caller, we need to make sure that they will be valid afterwards, and since we _can’t_ know when it will return we need to have them valid as long as possible, that is until the end of the program, hence the `'static` lifetime.\n    \n-   The [`Send`](../marker/trait.Send.html \"trait std::marker::Send\") constraint is because the closure will need to be passed _by value_ from the thread where it is spawned to the new thread. Its return value will need to be passed from the new thread to the thread where it is `join`ed. As a reminder, the [`Send`](../marker/trait.Send.html \"trait std::marker::Send\") marker trait expresses that it is safe to be passed from thread to thread. [`Sync`](../marker/trait.Sync.html \"trait std::marker::Sync\") expresses that it is safe to have a reference be passed from thread to thread.\n    \n\n## [§](#panics)Panics\n\nPanics if the OS fails to create a thread; use [`Builder::spawn`](about:blank/struct.Builder.html#method.spawn \"method std::thread::Builder::spawn\") to recover from such errors.\n\n## [§](#examples)Examples\n\nCreating a thread.\n\n```\nuse std::thread;\n\nlet handler = thread::spawn(|| {\n    // thread code\n});\n\nhandler.join().unwrap();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++%0A++++let+handler+=+thread::spawn(%7C%7C+%7B%0A++++++++//+thread+code%0A++++%7D);%0A++++%0A++++handler.join().unwrap();%0A%7D&edition=2021)\n\nAs mentioned in the module documentation, threads are usually made to communicate using [`channels`](../sync/mpsc/index.html \"mod std::sync::mpsc\"), here is how it usually looks.\n\nThis example also shows how to use `move`, in order to give ownership of values to a thread.\n\n```\nuse std::thread;\nuse std::sync::mpsc::channel;\n\nlet (tx, rx) = channel();\n\nlet sender = thread::spawn(move || {\n    tx.send(\"Hello, thread\".to_owned())\n        .expect(\"Unable to send on channel\");\n});\n\nlet receiver = thread::spawn(move || {\n    let value = rx.recv().expect(\"Unable to receive from channel\");\n    println!(\"{value}\");\n});\n\nsender.join().expect(\"The sender thread has panicked\");\nreceiver.join().expect(\"The receiver thread has panicked\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++let+(tx,+rx)+=+channel();%0A++++%0A++++let+sender+=+thread::spawn(move+%7C%7C+%7B%0A++++++++tx.send(%22Hello,+thread%22.to_owned())%0A++++++++++++.expect(%22Unable+to+send+on+channel%22);%0A++++%7D);%0A++++%0A++++let+receiver+=+thread::spawn(move+%7C%7C+%7B%0A++++++++let+value+=+rx.recv().expect(%22Unable+to+receive+from+channel%22);%0A++++++++println!(%22%7Bvalue%7D%22);%0A++++%7D);%0A++++%0A++++sender.join().expect(%22The+sender+thread+has+panicked%22);%0A++++receiver.join().expect(%22The+receiver+thread+has+panicked%22);%0A%7D&edition=2021)\n\nA thread can also return a value through its [`JoinHandle`](struct.JoinHandle.html \"struct std::thread::JoinHandle\"), you can use this to make asynchronous computations (futures might be more appropriate though).\n\n```\nuse std::thread;\n\nlet computation = thread::spawn(|| {\n    // Some expensive computation.\n    42\n});\n\nlet result = computation.join().unwrap();\nprintln!(\"{result}\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++%0A++++let+computation+=+thread::spawn(%7C%7C+%7B%0A++++++++//+Some+expensive+computation.%0A++++++++42%0A++++%7D);%0A++++%0A++++let+result+=+computation.join().unwrap();%0A++++println!(%22%7Bresult%7D%22);%0A%7D&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Spawns a new thread, returning a `JoinHandle` for it.\"><title>spawn in std::thread - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::thread</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.AccessError.html\">AccessError</a></li><li><a href=\"struct.Builder.html\">Builder</a></li><li><a href=\"struct.JoinHandle.html\">JoinHandle</a></li><li><a href=\"struct.LocalKey.html\">LocalKey</a></li><li><a href=\"struct.Scope.html\">Scope</a></li><li><a href=\"struct.ScopedJoinHandle.html\">ScopedJoinHandle</a></li><li><a href=\"struct.Thread.html\">Thread</a></li><li><a href=\"struct.ThreadId.html\">ThreadId</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.available_parallelism.html\">available_parallelism</a></li><li><a href=\"fn.current.html\">current</a></li><li><a href=\"fn.panicking.html\">panicking</a></li><li><a href=\"fn.park.html\">park</a></li><li><a href=\"fn.park_timeout.html\">park_timeout</a></li><li><a href=\"fn.park_timeout_ms.html\">park_timeout_ms</a></li><li><a href=\"fn.scope.html\">scope</a></li><li><a href=\"fn.sleep.html\">sleep</a></li><li><a href=\"fn.sleep_ms.html\">sleep_ms</a></li><li><a href=\"fn.sleep_until.html\">sleep_until</a></li><li><a href=\"fn.spawn.html\">spawn</a></li><li><a href=\"fn.yield_now.html\">yield_now</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.Result.html\">Result</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">thread</a>::<wbr><a class=\"fn\" href=\"#\">spawn</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/thread/mod.rs.html#692-699\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub fn spawn&lt;F, T&gt;(f: F) -&gt; <a class=\"struct\" href=\"struct.JoinHandle.html\" title=\"struct std::thread::JoinHandle\">JoinHandle</a>&lt;T&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>() -&gt; T + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + 'static,\n    T: <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + 'static,</div></code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Spawns a new thread, returning a <a href=\"struct.JoinHandle.html\" title=\"struct std::thread::JoinHandle\"><code>JoinHandle</code></a> for it.</p>\n<p>The join handle provides a <a href=\"struct.JoinHandle.html#method.join\" title=\"method std::thread::JoinHandle::join\"><code>join</code></a> method that can be used to join the spawned\nthread. If the spawned thread panics, <a href=\"struct.JoinHandle.html#method.join\" title=\"method std::thread::JoinHandle::join\"><code>join</code></a> will return an <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> containing\nthe argument given to <a href=\"../macro.panic.html\" title=\"macro std::panic\"><code>panic!</code></a>.</p>\n<p>If the join handle is dropped, the spawned thread will implicitly be <em>detached</em>.\nIn this case, the spawned thread may no longer be joined.\n(It is the responsibility of the program to either eventually join threads it\ncreates or detach them; otherwise, a resource leak will result.)</p>\n<p>This call will create a thread using default parameters of <a href=\"struct.Builder.html\" title=\"struct std::thread::Builder\"><code>Builder</code></a>, if you\nwant to specify the stack size or the name of the thread, use this API\ninstead.</p>\n<p>As you can see in the signature of <code>spawn</code> there are two constraints on\nboth the closure given to <code>spawn</code> and its return value, let’s explain them:</p>\n<ul>\n<li>\n<p>The <code>'static</code> constraint means that the closure and its return value\nmust have a lifetime of the whole program execution. The reason for this\nis that threads can outlive the lifetime they have been created in.</p>\n<p>Indeed if the thread, and by extension its return value, can outlive their\ncaller, we need to make sure that they will be valid afterwards, and since\nwe <em>can’t</em> know when it will return we need to have them valid as long as\npossible, that is until the end of the program, hence the <code>'static</code>\nlifetime.</p>\n</li>\n<li>\n<p>The <a href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\"><code>Send</code></a> constraint is because the closure will need to be passed\n<em>by value</em> from the thread where it is spawned to the new thread. Its\nreturn value will need to be passed from the new thread to the thread\nwhere it is <code>join</code>ed.\nAs a reminder, the <a href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\"><code>Send</code></a> marker trait expresses that it is safe to be\npassed from thread to thread. <a href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\"><code>Sync</code></a> expresses that it is safe to have a\nreference be passed from thread to thread.</p>\n</li>\n</ul>\n<h2 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h2>\n<p>Panics if the OS fails to create a thread; use <a href=\"struct.Builder.html#method.spawn\" title=\"method std::thread::Builder::spawn\"><code>Builder::spawn</code></a>\nto recover from such errors.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>Creating a thread.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>handler = thread::spawn(|| {\n    <span class=\"comment\">// thread code\n</span>});\n\nhandler.join().unwrap();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++%0A++++let+handler+=+thread::spawn(%7C%7C+%7B%0A++++++++//+thread+code%0A++++%7D);%0A++++%0A++++handler.join().unwrap();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>As mentioned in the module documentation, threads are usually made to\ncommunicate using <a href=\"../sync/mpsc/index.html\" title=\"mod std::sync::mpsc\"><code>channels</code></a>, here is how it usually looks.</p>\n<p>This example also shows how to use <code>move</code>, in order to give ownership\nof values to a thread.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>std::sync::mpsc::channel;\n\n<span class=\"kw\">let </span>(tx, rx) = channel();\n\n<span class=\"kw\">let </span>sender = thread::spawn(<span class=\"kw\">move </span>|| {\n    tx.send(<span class=\"string\">\"Hello, thread\"</span>.to_owned())\n        .expect(<span class=\"string\">\"Unable to send on channel\"</span>);\n});\n\n<span class=\"kw\">let </span>receiver = thread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"kw\">let </span>value = rx.recv().expect(<span class=\"string\">\"Unable to receive from channel\"</span>);\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{value}\"</span>);\n});\n\nsender.join().expect(<span class=\"string\">\"The sender thread has panicked\"</span>);\nreceiver.join().expect(<span class=\"string\">\"The receiver thread has panicked\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++let+(tx,+rx)+=+channel();%0A++++%0A++++let+sender+=+thread::spawn(move+%7C%7C+%7B%0A++++++++tx.send(%22Hello,+thread%22.to_owned())%0A++++++++++++.expect(%22Unable+to+send+on+channel%22);%0A++++%7D);%0A++++%0A++++let+receiver+=+thread::spawn(move+%7C%7C+%7B%0A++++++++let+value+=+rx.recv().expect(%22Unable+to+receive+from+channel%22);%0A++++++++println!(%22%7Bvalue%7D%22);%0A++++%7D);%0A++++%0A++++sender.join().expect(%22The+sender+thread+has+panicked%22);%0A++++receiver.join().expect(%22The+receiver+thread+has+panicked%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A thread can also return a value through its <a href=\"struct.JoinHandle.html\" title=\"struct std::thread::JoinHandle\"><code>JoinHandle</code></a>, you can use\nthis to make asynchronous computations (futures might be more appropriate\nthough).</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>computation = thread::spawn(|| {\n    <span class=\"comment\">// Some expensive computation.\n    </span><span class=\"number\">42\n</span>});\n\n<span class=\"kw\">let </span>result = computation.join().unwrap();\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{result}\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++%0A++++let+computation+=+thread::spawn(%7C%7C+%7B%0A++++++++//+Some+expensive+computation.%0A++++++++42%0A++++%7D);%0A++++%0A++++let+result+=+computation.join().unwrap();%0A++++println!(%22%7Bresult%7D%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:20:27.341Z"
}