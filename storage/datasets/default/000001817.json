{
	"title": "Procedural Macros - The Rust Reference",
	"url": "https://doc.rust-lang.org/reference/procedural-macros.html",
	"markdown": "# Procedural Macros - The Rust Reference\n\n_Procedural macros_ allow creating syntax extensions as execution of a function. Procedural macros come in one of three flavors:\n\n-   [Function-like macros](#function-like-procedural-macros) - `custom!(...)`\n-   [Derive macros](#derive-macros) - `#[derive(CustomDerive)]`\n-   [Attribute macros](#attribute-macros) - `#[CustomAttribute]`\n\nProcedural macros allow you to run code at compile time that operates over Rust syntax, both consuming and producing Rust syntax. You can sort of think of procedural macros as functions from an AST to another AST.\n\nProcedural macros must be defined in a crate with the [crate type](linkage.html) of `proc-macro`.\n\n> **Note**: When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> \n> ```\n\nAs functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.\n\nProcedural macros run during compilation, and thus have the same resources that the compiler has. For example, standard input, error, and output are the same that the compiler has access to. Similarly, file access is the same. Because of this, procedural macros have the same security concerns that [Cargo's build scripts](../cargo/reference/build-scripts.html) have.\n\nProcedural macros have two ways of reporting errors. The first is to panic. The second is to emit a [`compile_error`](../std/macro.compile_error.html) macro invocation.\n\n### [The `proc_macro` crate](#the-proc_macro-crate)\n\nProcedural macro crates almost always will link to the compiler-provided [`proc_macro` crate](../proc_macro/index.html). The `proc_macro` crate provides types required for writing procedural macros and facilities to make it easier.\n\nThis crate primarily contains a [`TokenStream`](../proc_macro/struct.TokenStream.html) type. Procedural macros operate over _token streams_ instead of AST nodes, which is a far more stable interface over time for both the compiler and for procedural macros to target. A _token stream_ is roughly equivalent to `Vec<TokenTree>` where a `TokenTree` can roughly be thought of as lexical token. For example `foo` is an `Ident` token, `.` is a `Punct` token, and `1.2` is a `Literal` token. The `TokenStream` type, unlike `Vec<TokenTree>`, is cheap to clone.\n\nAll tokens have an associated `Span`. A `Span` is an opaque value that cannot be modified but can be manufactured. `Span`s represent an extent of source code within a program and are primarily used for error reporting. While you cannot modify a `Span` itself, you can always change the `Span` _associated_ with any token, such as through getting a `Span` from another token.\n\n### [Procedural macro hygiene](#procedural-macro-hygiene)\n\nProcedural macros are _unhygienic_. This means they behave as if the output token stream was simply written inline to the code it's next to. This means that it's affected by external items and also affects external imports.\n\nMacro authors need to be careful to ensure their macros work in as many contexts as possible given this limitation. This often includes using absolute paths to items in libraries (for example, `::std::option::Option` instead of `Option`) or by ensuring that generated functions have names that are unlikely to clash with other functions (like `__internal_foo` instead of `foo`).\n\n### [Function-like procedural macros](#function-like-procedural-macros)\n\n_Function-like procedural macros_ are procedural macros that are invoked using the macro invocation operator (`!`).\n\nThese macros are defined by a [public](visibility-and-privacy.html) [function](items/functions.html) with the `proc_macro` [attribute](attributes.html) and a signature of `(TokenStream) -> TokenStream`. The input [`TokenStream`](../proc_macro/struct.TokenStream.html) is what is inside the delimiters of the macro invocation and the output [`TokenStream`](../proc_macro/struct.TokenStream.html) replaces the entire macro invocation.\n\nFor example, the following macro definition ignores its input and outputs a function `answer` into its scope.\n\n```rust\n#![crate_type = \"proc-macro\"]\nextern crate proc_macro;\nuse proc_macro::TokenStream;\n\n#[proc_macro]\npub fn make_answer(_item: TokenStream) -> TokenStream {\n    \"fn answer() -> u32 { 42 }\".parse().unwrap()\n}\n```\n\nAnd then we use it in a binary crate to print \"42\" to standard output.\n\n```rust\nextern crate proc_macro_examples;\nuse proc_macro_examples::make_answer;\n\nmake_answer!();\n\nfn main() {\n    println!(\"{}\", answer());\n}\n```\n\nFunction-like procedural macros may be invoked in any macro invocation position, which includes [statements](statements.html), [expressions](expressions.html), [patterns](patterns.html), [type expressions](about:blank/types.html#type-expressions), [item](items.html) positions, including items in [`extern` blocks](items/external-blocks.html), inherent and trait [implementations](items/implementations.html), and [trait definitions](items/traits.html).\n\n### [Derive macros](#derive-macros)\n\n_Derive macros_ define new inputs for the [`derive` attribute](attributes/derive.html). These macros can create new [items](items.html) given the token stream of a [struct](items/structs.html), [enum](items/enumerations.html), or [union](items/unions.html). They can also define [derive macro helper attributes](#derive-macro-helper-attributes).\n\nCustom derive macros are defined by a [public](visibility-and-privacy.html) [function](items/functions.html) with the `proc_macro_derive` attribute and a signature of `(TokenStream) -> TokenStream`.\n\nThe input [`TokenStream`](../proc_macro/struct.TokenStream.html) is the token stream of the item that has the `derive` attribute on it. The output [`TokenStream`](../proc_macro/struct.TokenStream.html) must be a set of items that are then appended to the [module](items/modules.html) or [block](expressions/block-expr.html) that the item from the input [`TokenStream`](../proc_macro/struct.TokenStream.html) is in.\n\nThe following is an example of a derive macro. Instead of doing anything useful with its input, it just appends a function `answer`.\n\n```rust\n#![crate_type = \"proc-macro\"]\nextern crate proc_macro;\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(AnswerFn)]\npub fn derive_answer_fn(_item: TokenStream) -> TokenStream {\n    \"fn answer() -> u32 { 42 }\".parse().unwrap()\n}\n```\n\nAnd then using said derive macro:\n\n```rust\nextern crate proc_macro_examples;\nuse proc_macro_examples::AnswerFn;\n\n#[derive(AnswerFn)]\nstruct Struct;\n\nfn main() {\n    assert_eq!(42, answer());\n}\n```\n\n#### [Derive macro helper attributes](#derive-macro-helper-attributes)\n\nDerive macros can add additional [attributes](attributes.html) into the scope of the [item](items.html) they are on. Said attributes are called _derive macro helper attributes_. These attributes are [inert](about:blank/attributes.html#active-and-inert-attributes), and their only purpose is to be fed into the derive macro that defined them. That said, they can be seen by all macros.\n\nThe way to define helper attributes is to put an `attributes` key in the `proc_macro_derive` macro with a comma separated list of identifiers that are the names of the helper attributes.\n\nFor example, the following derive macro defines a helper attribute `helper`, but ultimately doesn't do anything with it.\n\n```rust\n#![crate_type=\"proc-macro\"]\nextern crate proc_macro;\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(HelperAttr, attributes(helper))]\npub fn derive_helper_attr(_item: TokenStream) -> TokenStream {\n    TokenStream::new()\n}\n```\n\nAnd then usage on the derive macro on a struct:\n\n```rust\n#[derive(HelperAttr)]\nstruct Struct {\n    #[helper] field: ()\n}\n```\n\n### [Attribute macros](#attribute-macros)\n\n_Attribute macros_ define new [outer attributes](attributes.html) which can be attached to [items](items.html), including items in [`extern` blocks](items/external-blocks.html), inherent and trait [implementations](items/implementations.html), and [trait definitions](items/traits.html).\n\nAttribute macros are defined by a [public](visibility-and-privacy.html) [function](items/functions.html) with the `proc_macro_attribute` [attribute](attributes.html) that has a signature of `(TokenStream, TokenStream) -> TokenStream`. The first [`TokenStream`](../proc_macro/struct.TokenStream.html) is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute [`TokenStream`](../proc_macro/struct.TokenStream.html) is empty. The second [`TokenStream`](../proc_macro/struct.TokenStream.html) is the rest of the [item](items.html) including other [attributes](attributes.html) on the [item](items.html). The returned [`TokenStream`](../proc_macro/struct.TokenStream.html) replaces the [item](items.html) with an arbitrary number of [items](items.html).\n\nFor example, this attribute macro takes the input stream and returns it as is, effectively being the no-op of attributes.\n\n```rust\n#![crate_type = \"proc-macro\"]\nextern crate proc_macro;\nuse proc_macro::TokenStream;\n\n#[proc_macro_attribute]\npub fn return_as_is(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    item\n}\n```\n\nThis following example shows the stringified [`TokenStream`s](../proc_macro/struct.TokenStream.html) that the attribute macros see. The output will show in the output of the compiler. The output is shown in the comments after the function prefixed with \"out:\".\n\n```rust\n// my-macro/src/lib.rs\nextern crate proc_macro;\nuse proc_macro::TokenStream;\n\n#[proc_macro_attribute]\npub fn show_streams(attr: TokenStream, item: TokenStream) -> TokenStream {\n    println!(\"attr: \\\"{attr}\\\"\");\n    println!(\"item: \\\"{item}\\\"\");\n    item\n}\n```\n\n```rust\n// src/lib.rs\nextern crate my_macro;\n\nuse my_macro::show_streams;\n\n// Example: Basic function\n#[show_streams]\nfn invoke1() {}\n// out: attr: \"\"\n// out: item: \"fn invoke1() {}\"\n\n// Example: Attribute with input\n#[show_streams(bar)]\nfn invoke2() {}\n// out: attr: \"bar\"\n// out: item: \"fn invoke2() {}\"\n\n// Example: Multiple tokens in the input\n#[show_streams(multiple => tokens)]\nfn invoke3() {}\n// out: attr: \"multiple => tokens\"\n// out: item: \"fn invoke3() {}\"\n\n// Example:\n#[show_streams { delimiters }]\nfn invoke4() {}\n// out: attr: \"delimiters\"\n// out: item: \"fn invoke4() {}\"\n```\n\n### [Declarative macro tokens and procedural macro tokens](#declarative-macro-tokens-and-procedural-macro-tokens)\n\nDeclarative `macro_rules` macros and procedural macros use similar, but different definitions for tokens (or rather [`TokenTree`s](../proc_macro/enum.TokenTree.html).)\n\nToken trees in `macro_rules` (corresponding to `tt` matchers) are defined as\n\n-   Delimited groups (`(...)`, `{...}`, etc)\n-   All operators supported by the language, both single-character and multi-character ones (`+`, `+=`).\n    -   Note that this set doesn't include the single quote `'`.\n-   Literals (`\"string\"`, `1`, etc)\n    -   Note that negation (e.g. `-1`) is never a part of such literal tokens, but a separate operator token.\n-   Identifiers, including keywords (`ident`, `r#ident`, `fn`)\n-   Lifetimes (`'ident`)\n-   Metavariable substitutions in `macro_rules` (e.g. `$my_expr` in `macro_rules! mac { ($my_expr: expr) => { $my_expr } }` after the `mac`'s expansion, which will be considered a single token tree regardless of the passed expression)\n\nToken trees in procedural macros are defined as\n\n-   Delimited groups (`(...)`, `{...}`, etc)\n-   All punctuation characters used in operators supported by the language (`+`, but not `+=`), and also the single quote `'` character (typically used in lifetimes, see below for lifetime splitting and joining behavior)\n-   Literals (`\"string\"`, `1`, etc)\n    -   Negation (e.g. `-1`) is supported as a part of integer and floating point literals.\n-   Identifiers, including keywords (`ident`, `r#ident`, `fn`)\n\nMismatches between these two definitions are accounted for when token streams are passed to and from procedural macros.  \nNote that the conversions below may happen lazily, so they might not happen if the tokens are not actually inspected.\n\nWhen passed to a proc-macro\n\n-   All multi-character operators are broken into single characters.\n-   Lifetimes are broken into a `'` character and an identifier.\n-   All metavariable substitutions are represented as their underlying token streams.\n    -   Such token streams may be wrapped into delimited groups ([`Group`](../proc_macro/struct.Group.html)) with implicit delimiters ([`Delimiter::None`](about:blank/proc_macro/enum.Delimiter.html#variant.None)) when it's necessary for preserving parsing priorities.\n    -   `tt` and `ident` substitutions are never wrapped into such groups and always represented as their underlying token trees.\n\nWhen emitted from a proc macro\n\n-   Punctuation characters are glued into multi-character operators when applicable.\n-   Single quotes `'` joined with identifiers are glued into lifetimes.\n-   Negative literals are converted into two tokens (the `-` and the literal) possibly wrapped into a delimited group ([`Group`](../proc_macro/struct.Group.html)) with implicit delimiters ([`Delimiter::None`](about:blank/proc_macro/enum.Delimiter.html#variant.None)) when it's necessary for preserving parsing priorities.\n\nNote that neither declarative nor procedural macros support doc comment tokens (e.g. `/// Doc`), so they are always converted to token streams representing their equivalent `#[doc = r\"str\"]` attributes when passed to macros.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Procedural Macros - The Rust Reference</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/reference.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"notation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Notation</a></li><li class=\"chapter-item expanded \"><a href=\"lexical-structure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Lexical structure</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"input-format.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Input format</a></li><li class=\"chapter-item expanded \"><a href=\"keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"identifiers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Identifiers</a></li><li class=\"chapter-item expanded \"><a href=\"comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"whitespace.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Whitespace</a></li><li class=\"chapter-item expanded \"><a href=\"tokens.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Tokens</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Macros</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macros-by-example.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Macros By Example</a></li><li class=\"chapter-item expanded \"><a href=\"procedural-macros.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Procedural Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"crates-and-source-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Crates and source files</a></li><li class=\"chapter-item expanded \"><a href=\"conditional-compilation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Conditional compilation</a></li><li class=\"chapter-item expanded \"><a href=\"items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Items</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"items/modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Modules</a></li><li class=\"chapter-item expanded \"><a href=\"items/extern-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Extern crates</a></li><li class=\"chapter-item expanded \"><a href=\"items/use-declarations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Use declarations</a></li><li class=\"chapter-item expanded \"><a href=\"items/functions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.4.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"items/type-aliases.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.5.</strong> Type aliases</a></li><li class=\"chapter-item expanded \"><a href=\"items/structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.6.</strong> Structs</a></li><li class=\"chapter-item expanded \"><a href=\"items/enumerations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.7.</strong> Enumerations</a></li><li class=\"chapter-item expanded \"><a href=\"items/unions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.8.</strong> Unions</a></li><li class=\"chapter-item expanded \"><a href=\"items/constant-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.9.</strong> Constant items</a></li><li class=\"chapter-item expanded \"><a href=\"items/static-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.10.</strong> Static items</a></li><li class=\"chapter-item expanded \"><a href=\"items/traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.11.</strong> Traits</a></li><li class=\"chapter-item expanded \"><a href=\"items/implementations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.12.</strong> Implementations</a></li><li class=\"chapter-item expanded \"><a href=\"items/external-blocks.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.13.</strong> External blocks</a></li><li class=\"chapter-item expanded \"><a href=\"items/generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.14.</strong> Generic parameters</a></li><li class=\"chapter-item expanded \"><a href=\"items/associated-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.15.</strong> Associated Items</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"attributes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Attributes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"attributes/testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Testing</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/derive.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Derive</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/diagnostics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Diagnostics</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/codegen.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Code generation</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/limits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Limits</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/type_system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.6.</strong> Type System</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/debugger.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.7.</strong> Debugger</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"statements-and-expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Statements and expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"statements.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Statements</a></li><li class=\"chapter-item expanded \"><a href=\"expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"expressions/literal-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.1.</strong> Literal expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/path-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.2.</strong> Path expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/block-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.3.</strong> Block expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/operator-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.4.</strong> Operator expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/grouped-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.5.</strong> Grouped expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/array-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.6.</strong> Array and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/tuple-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.7.</strong> Tuple and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/struct-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.8.</strong> Struct expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.9.</strong> Call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/method-call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.10.</strong> Method call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/field-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.11.</strong> Field access expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/closure-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.12.</strong> Closure expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/loop-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.13.</strong> Loop expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/range-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.14.</strong> Range expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/if-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.15.</strong> If and if let expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/match-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.16.</strong> Match expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/return-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.17.</strong> Return expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/await-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.18.</strong> Await expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/underscore-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.19.</strong> Underscore expressions</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Patterns</a></li><li class=\"chapter-item expanded \"><a href=\"type-system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Type system</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Types</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types/boolean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Boolean type</a></li><li class=\"chapter-item expanded \"><a href=\"types/numeric.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Numeric types</a></li><li class=\"chapter-item expanded \"><a href=\"types/textual.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Textual types</a></li><li class=\"chapter-item expanded \"><a href=\"types/never.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Never type</a></li><li class=\"chapter-item expanded \"><a href=\"types/tuple.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Tuple types</a></li><li class=\"chapter-item expanded \"><a href=\"types/array.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.6.</strong> Array types</a></li><li class=\"chapter-item expanded \"><a href=\"types/slice.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.7.</strong> Slice types</a></li><li class=\"chapter-item expanded \"><a href=\"types/struct.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.8.</strong> Struct types</a></li><li class=\"chapter-item expanded \"><a href=\"types/enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.9.</strong> Enumerated types</a></li><li class=\"chapter-item expanded \"><a href=\"types/union.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.10.</strong> Union types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-item.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.11.</strong> Function item types</a></li><li class=\"chapter-item expanded \"><a href=\"types/closure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.12.</strong> Closure types</a></li><li class=\"chapter-item expanded \"><a href=\"types/pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.13.</strong> Pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.14.</strong> Function pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/trait-object.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.15.</strong> Trait object types</a></li><li class=\"chapter-item expanded \"><a href=\"types/impl-trait.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.16.</strong> Impl trait type</a></li><li class=\"chapter-item expanded \"><a href=\"types/parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.17.</strong> Type parameters</a></li><li class=\"chapter-item expanded \"><a href=\"types/inferred.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.18.</strong> Inferred type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"dynamically-sized-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Dynamically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"type-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Type layout</a></li><li class=\"chapter-item expanded \"><a href=\"interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.4.</strong> Interior mutability</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.5.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"trait-bounds.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.6.</strong> Trait and lifetime bounds</a></li><li class=\"chapter-item expanded \"><a href=\"type-coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.7.</strong> Type coercions</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.8.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.9.</strong> Lifetime elision</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"special-types-and-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Special types and traits</a></li><li class=\"chapter-item expanded \"><a href=\"names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Names</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"names/namespaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Namespaces</a></li><li class=\"chapter-item expanded \"><a href=\"names/scopes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Scopes</a></li><li class=\"chapter-item expanded \"><a href=\"names/preludes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Preludes</a></li><li class=\"chapter-item expanded \"><a href=\"paths.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Paths</a></li><li class=\"chapter-item expanded \"><a href=\"names/name-resolution.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Name resolution</a></li><li class=\"chapter-item expanded \"><a href=\"visibility-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Visibility and privacy</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"memory-model.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Memory model</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"memory-allocation-and-lifetime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Memory allocation and lifetime</a></li><li class=\"chapter-item expanded \"><a href=\"variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Variables</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"linkage.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> Linkage</a></li><li class=\"chapter-item expanded \"><a href=\"inline-assembly.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Inline assembly</a></li><li class=\"chapter-item expanded \"><a href=\"unsafety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Unsafety</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"unsafe-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> The unsafe keyword</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-considered-undefined.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Behavior considered undefined</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-not-considered-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Behavior not considered unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"const_eval.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Constant Evaluation</a></li><li class=\"chapter-item expanded \"><a href=\"abi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Application Binary Interface</a></li><li class=\"chapter-item expanded \"><a href=\"runtime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> The Rust runtime</a></li><li class=\"chapter-item expanded \"><a href=\"appendices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Appendices</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macro-ambiguity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class=\"chapter-item expanded \"><a href=\"influences.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Influences</a></li><li class=\"chapter-item expanded \"><a href=\"glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Glossary</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Reference</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/edit/master/src/procedural-macros.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"procedural-macros\"><a class=\"header\" href=\"#procedural-macros\">Procedural Macros</a></h2>\n<p><em>Procedural macros</em> allow creating syntax extensions as execution of a function.\nProcedural macros come in one of three flavors:</p>\n<ul>\n<li><a href=\"#function-like-procedural-macros\">Function-like macros</a> - <code class=\"hljs\">custom!(...)</code></li>\n<li><a href=\"#derive-macros\">Derive macros</a> - <code class=\"hljs\">#[derive(CustomDerive)]</code></li>\n<li><a href=\"#attribute-macros\">Attribute macros</a> - <code class=\"hljs\">#[CustomAttribute]</code></li>\n</ul>\n<p>Procedural macros allow you to run code at compile time that operates over Rust\nsyntax, both consuming and producing Rust syntax. You can sort of think of\nprocedural macros as functions from an AST to another AST.</p>\n<p>Procedural macros must be defined in a crate with the <a href=\"linkage.html\">crate type</a> of\n<code class=\"hljs\">proc-macro</code>.</p>\n<blockquote>\n<p><strong>Note</strong>: When using Cargo, Procedural macro crates are defined with the\n<code class=\"hljs\">proc-macro</code> key in your manifest:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[lib]</span>\n<span class=\"hljs-attr\">proc-macro</span> = <span class=\"hljs-literal\">true</span>\n</code></pre>\n</blockquote>\n<p>As functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error.\nEndless loops are not caught by the compiler which hangs the compiler.</p>\n<p>Procedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that <a href=\"../cargo/reference/build-scripts.html\">Cargo's\nbuild scripts</a> have.</p>\n<p>Procedural macros have two ways of reporting errors. The first is to panic. The\nsecond is to emit a <a href=\"../std/macro.compile_error.html\"><code class=\"hljs\">compile_error</code></a> macro invocation.</p>\n<h3 id=\"the-proc_macro-crate\"><a class=\"header\" href=\"#the-proc_macro-crate\">The <code>proc_macro</code> crate</a></h3>\n<p>Procedural macro crates almost always will link to the compiler-provided\n<a href=\"../proc_macro/index.html\"><code class=\"hljs\">proc_macro</code> crate</a>. The <code class=\"hljs\">proc_macro</code> crate provides types required for\nwriting procedural macros and facilities to make it easier.</p>\n<p>This crate primarily contains a <a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a> type. Procedural macros operate\nover <em>token streams</em> instead of AST nodes, which is a far more stable interface\nover time for both the compiler and for procedural macros to target. A\n<em>token stream</em> is roughly equivalent to <code class=\"hljs\">Vec&lt;TokenTree&gt;</code> where a <code class=\"hljs\">TokenTree</code>\ncan roughly be thought of as lexical token. For example <code class=\"hljs\">foo</code> is an <code class=\"hljs\">Ident</code>\ntoken, <code class=\"hljs\">.</code> is a <code class=\"hljs\">Punct</code> token, and <code class=\"hljs\">1.2</code> is a <code class=\"hljs\">Literal</code> token. The <code class=\"hljs\">TokenStream</code>\ntype, unlike <code class=\"hljs\">Vec&lt;TokenTree&gt;</code>, is cheap to clone.</p>\n<p>All tokens have an associated <code class=\"hljs\">Span</code>. A <code class=\"hljs\">Span</code> is an opaque value that cannot\nbe modified but can be manufactured. <code class=\"hljs\">Span</code>s represent an extent of source\ncode within a program and are primarily used for error reporting. While you\ncannot modify a <code class=\"hljs\">Span</code> itself, you can always change the <code class=\"hljs\">Span</code> <em>associated</em>\nwith any token, such as through getting a <code class=\"hljs\">Span</code> from another token.</p>\n<h3 id=\"procedural-macro-hygiene\"><a class=\"header\" href=\"#procedural-macro-hygiene\">Procedural macro hygiene</a></h3>\n<p>Procedural macros are <em>unhygienic</em>. This means they behave as if the output\ntoken stream was simply written inline to the code it's next to. This means that\nit's affected by external items and also affects external imports.</p>\n<p>Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, <code class=\"hljs\">::std::option::Option</code> instead of <code class=\"hljs\">Option</code>) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like <code class=\"hljs\">__internal_foo</code> instead of <code class=\"hljs\">foo</code>).</p>\n<h3 id=\"function-like-procedural-macros\"><a class=\"header\" href=\"#function-like-procedural-macros\">Function-like procedural macros</a></h3>\n<p><em>Function-like procedural macros</em> are procedural macros that are invoked using\nthe macro invocation operator (<code class=\"hljs\">!</code>).</p>\n<p>These macros are defined by a <a href=\"visibility-and-privacy.html\">public</a> <a href=\"items/functions.html\">function</a> with the <code class=\"hljs\">proc_macro</code>\n<a href=\"attributes.html\">attribute</a> and a signature of <code class=\"hljs\">(TokenStream) -&gt; TokenStream</code>. The input\n<a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a> is what is inside the delimiters of the macro invocation and the\noutput <a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a> replaces the entire macro invocation.</p>\n<p>For example, the following macro definition ignores its input and outputs a\nfunction <code class=\"hljs\">answer</code> into its scope.</p>\n<!-- ignore: test doesn't support proc-macro -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![crate_type = <span class=\"hljs-meta-string\">\"proc-macro\"</span>]</span>\n</span><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> proc_macro;\n<span class=\"hljs-keyword\">use</span> proc_macro::TokenStream;\n\n<span class=\"hljs-meta\">#[proc_macro]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">make_answer</span></span>(_item: TokenStream) -&gt; TokenStream {\n    <span class=\"hljs-string\">\"fn answer() -&gt; u32 { 42 }\"</span>.parse().unwrap()\n}</code></pre>\n<p>And then we use it in a binary crate to print \"42\" to standard output.</p>\n<!-- ignore: requires external crates -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> proc_macro_examples;\n<span class=\"hljs-keyword\">use</span> proc_macro_examples::make_answer;\n\nmake_answer!();\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, answer());\n}</code></pre>\n<p>Function-like procedural macros may be invoked in any macro invocation\nposition, which includes <a href=\"statements.html\">statements</a>, <a href=\"expressions.html\">expressions</a>, <a href=\"patterns.html\">patterns</a>, <a href=\"types.html#type-expressions\">type\nexpressions</a>, <a href=\"items.html\">item</a> positions, including items in <a href=\"items/external-blocks.html\"><code class=\"hljs\">extern</code> blocks</a>, inherent\nand trait <a href=\"items/implementations.html\">implementations</a>, and <a href=\"items/traits.html\">trait definitions</a>.</p>\n<h3 id=\"derive-macros\"><a class=\"header\" href=\"#derive-macros\">Derive macros</a></h3>\n<p><em>Derive macros</em> define new inputs for the <a href=\"attributes/derive.html\"><code class=\"hljs\">derive</code> attribute</a>. These macros\ncan create new <a href=\"items.html\">items</a> given the token stream of a <a href=\"items/structs.html\">struct</a>, <a href=\"items/enumerations.html\">enum</a>, or <a href=\"items/unions.html\">union</a>.\nThey can also define <a href=\"#derive-macro-helper-attributes\">derive macro helper attributes</a>.</p>\n<p>Custom derive macros are defined by a <a href=\"visibility-and-privacy.html\">public</a> <a href=\"items/functions.html\">function</a> with the\n<code class=\"hljs\">proc_macro_derive</code> attribute and a signature of <code class=\"hljs\">(TokenStream) -&gt; TokenStream</code>.</p>\n<p>The input <a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a> is the token stream of the item that has the <code class=\"hljs\">derive</code>\nattribute on it. The output <a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a> must be a set of items that are\nthen appended to the <a href=\"items/modules.html\">module</a> or <a href=\"expressions/block-expr.html\">block</a> that the item from the input\n<a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a> is in.</p>\n<p>The following is an example of a derive macro. Instead of doing anything\nuseful with its input, it just appends a function <code class=\"hljs\">answer</code>.</p>\n<!-- ignore: test doesn't support proc-macro -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![crate_type = <span class=\"hljs-meta-string\">\"proc-macro\"</span>]</span>\n</span><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> proc_macro;\n<span class=\"hljs-keyword\">use</span> proc_macro::TokenStream;\n\n<span class=\"hljs-meta\">#[proc_macro_derive(AnswerFn)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">derive_answer_fn</span></span>(_item: TokenStream) -&gt; TokenStream {\n    <span class=\"hljs-string\">\"fn answer() -&gt; u32 { 42 }\"</span>.parse().unwrap()\n}</code></pre>\n<p>And then using said derive macro:</p>\n<!-- ignore: requires external crates -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> proc_macro_examples;\n<span class=\"hljs-keyword\">use</span> proc_macro_examples::AnswerFn;\n\n<span class=\"hljs-meta\">#[derive(AnswerFn)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Struct</span></span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">42</span>, answer());\n}</code></pre>\n<h4 id=\"derive-macro-helper-attributes\"><a class=\"header\" href=\"#derive-macro-helper-attributes\">Derive macro helper attributes</a></h4>\n<p>Derive macros can add additional <a href=\"attributes.html\">attributes</a> into the scope of the <a href=\"items.html\">item</a>\nthey are on. Said attributes are called <em>derive macro helper attributes</em>. These\nattributes are <a href=\"attributes.html#active-and-inert-attributes\">inert</a>, and their only purpose is to be fed into the derive\nmacro that defined them. That said, they can be seen by all macros.</p>\n<p>The way to define helper attributes is to put an <code class=\"hljs\">attributes</code> key in the\n<code class=\"hljs\">proc_macro_derive</code> macro with a comma separated list of identifiers that are\nthe names of the helper attributes.</p>\n<p>For example, the following derive macro defines a helper attribute\n<code class=\"hljs\">helper</code>, but ultimately doesn't do anything with it.</p>\n<!-- ignore: test doesn't support proc-macro -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![crate_type=<span class=\"hljs-meta-string\">\"proc-macro\"</span>]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> proc_macro;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> proc_macro::TokenStream;\n</span>\n<span class=\"hljs-meta\">#[proc_macro_derive(HelperAttr, attributes(helper))]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">derive_helper_attr</span></span>(_item: TokenStream) -&gt; TokenStream {\n    TokenStream::new()\n}</code></pre>\n<p>And then usage on the derive macro on a struct:</p>\n<!-- ignore: requires external crates -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[derive(HelperAttr)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Struct</span></span> {\n    <span class=\"hljs-meta\">#[helper]</span> field: ()\n}</code></pre>\n<h3 id=\"attribute-macros\"><a class=\"header\" href=\"#attribute-macros\">Attribute macros</a></h3>\n<p><em>Attribute macros</em> define new <a href=\"attributes.html\">outer attributes</a> which can be\nattached to <a href=\"items.html\">items</a>, including items in <a href=\"items/external-blocks.html\"><code class=\"hljs\">extern</code> blocks</a>, inherent and trait\n<a href=\"items/implementations.html\">implementations</a>, and <a href=\"items/traits.html\">trait definitions</a>.</p>\n<p>Attribute macros are defined by a <a href=\"visibility-and-privacy.html\">public</a> <a href=\"items/functions.html\">function</a> with the\n<code class=\"hljs\">proc_macro_attribute</code> <a href=\"attributes.html\">attribute</a> that has a signature of <code class=\"hljs\">(TokenStream, TokenStream) -&gt; TokenStream</code>. The first <a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a> is the delimited token\ntree following the attribute's name, not including the outer delimiters. If\nthe attribute is written as a bare attribute name, the attribute\n<a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a> is empty. The second <a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a> is the rest of the <a href=\"items.html\">item</a>\nincluding other <a href=\"attributes.html\">attributes</a> on the <a href=\"items.html\">item</a>. The returned <a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code></a>\nreplaces the <a href=\"items.html\">item</a> with an arbitrary number of <a href=\"items.html\">items</a>.</p>\n<p>For example, this attribute macro takes the input stream and returns it as is,\neffectively being the no-op of attributes.</p>\n<!-- ignore: test doesn't support proc-macro -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![crate_type = <span class=\"hljs-meta-string\">\"proc-macro\"</span>]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> proc_macro;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> proc_macro::TokenStream;\n</span>\n<span class=\"hljs-meta\">#[proc_macro_attribute]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">return_as_is</span></span>(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {\n    item\n}</code></pre>\n<p>This following example shows the stringified <a href=\"../proc_macro/struct.TokenStream.html\"><code class=\"hljs\">TokenStream</code>s</a> that the attribute\nmacros see. The output will show in the output of the compiler. The output is\nshown in the comments after the function prefixed with \"out:\".</p>\n<!-- ignore: test doesn't support proc-macro -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-comment\">// my-macro/src/lib.rs</span>\n<span class=\"boring\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> proc_macro;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> proc_macro::TokenStream;\n</span>\n<span class=\"hljs-meta\">#[proc_macro_attribute]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">show_streams</span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"attr: \\\"{attr}\\\"\"</span>);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"item: \\\"{item}\\\"\"</span>);\n    item\n}</code></pre>\n<!-- ignore: requires external crates -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// src/lib.rs</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> my_macro;\n\n<span class=\"hljs-keyword\">use</span> my_macro::show_streams;\n\n<span class=\"hljs-comment\">// Example: Basic function</span>\n<span class=\"hljs-meta\">#[show_streams]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">invoke1</span></span>() {}\n<span class=\"hljs-comment\">// out: attr: \"\"</span>\n<span class=\"hljs-comment\">// out: item: \"fn invoke1() {}\"</span>\n\n<span class=\"hljs-comment\">// Example: Attribute with input</span>\n<span class=\"hljs-meta\">#[show_streams(bar)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">invoke2</span></span>() {}\n<span class=\"hljs-comment\">// out: attr: \"bar\"</span>\n<span class=\"hljs-comment\">// out: item: \"fn invoke2() {}\"</span>\n\n<span class=\"hljs-comment\">// Example: Multiple tokens in the input</span>\n<span class=\"hljs-meta\">#[show_streams(multiple =&gt; tokens)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">invoke3</span></span>() {}\n<span class=\"hljs-comment\">// out: attr: \"multiple =&gt; tokens\"</span>\n<span class=\"hljs-comment\">// out: item: \"fn invoke3() {}\"</span>\n\n<span class=\"hljs-comment\">// Example:</span>\n<span class=\"hljs-meta\">#[show_streams { delimiters }]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">invoke4</span></span>() {}\n<span class=\"hljs-comment\">// out: attr: \"delimiters\"</span>\n<span class=\"hljs-comment\">// out: item: \"fn invoke4() {}\"</span></code></pre>\n<h3 id=\"declarative-macro-tokens-and-procedural-macro-tokens\"><a class=\"header\" href=\"#declarative-macro-tokens-and-procedural-macro-tokens\">Declarative macro tokens and procedural macro tokens</a></h3>\n<p>Declarative <code class=\"hljs\">macro_rules</code> macros and procedural macros use similar, but\ndifferent definitions for tokens (or rather <a href=\"../proc_macro/enum.TokenTree.html\"><code class=\"hljs\">TokenTree</code>s</a>.)</p>\n<p>Token trees in <code class=\"hljs\">macro_rules</code> (corresponding to <code class=\"hljs\">tt</code> matchers) are defined as</p>\n<ul>\n<li>Delimited groups (<code class=\"hljs\">(...)</code>, <code class=\"hljs\">{...}</code>, etc)</li>\n<li>All operators supported by the language, both single-character and\nmulti-character ones (<code class=\"hljs\">+</code>, <code class=\"hljs\">+=</code>).\n<ul>\n<li>Note that this set doesn't include the single quote <code class=\"hljs\">'</code>.</li>\n</ul>\n</li>\n<li>Literals (<code class=\"hljs\">\"string\"</code>, <code class=\"hljs\">1</code>, etc)\n<ul>\n<li>Note that negation (e.g. <code class=\"hljs\">-1</code>) is never a part of such literal tokens,\nbut a separate operator token.</li>\n</ul>\n</li>\n<li>Identifiers, including keywords (<code class=\"hljs\">ident</code>, <code class=\"hljs\">r#ident</code>, <code class=\"hljs\">fn</code>)</li>\n<li>Lifetimes (<code class=\"hljs\">'ident</code>)</li>\n<li>Metavariable substitutions in <code class=\"hljs\">macro_rules</code> (e.g. <code class=\"hljs\">$my_expr</code> in\n<code class=\"hljs\">macro_rules! mac { ($my_expr: expr) =&gt; { $my_expr } }</code> after the <code class=\"hljs\">mac</code>'s\nexpansion, which will be considered a single token tree regardless of the\npassed expression)</li>\n</ul>\n<p>Token trees in procedural macros are defined as</p>\n<ul>\n<li>Delimited groups (<code class=\"hljs\">(...)</code>, <code class=\"hljs\">{...}</code>, etc)</li>\n<li>All punctuation characters used in operators supported by the language (<code class=\"hljs\">+</code>,\nbut not <code class=\"hljs\">+=</code>), and also the single quote <code class=\"hljs\">'</code> character (typically used in\nlifetimes, see below for lifetime splitting and joining behavior)</li>\n<li>Literals (<code class=\"hljs\">\"string\"</code>, <code class=\"hljs\">1</code>, etc)\n<ul>\n<li>Negation (e.g. <code class=\"hljs\">-1</code>) is supported as a part of integer\nand floating point literals.</li>\n</ul>\n</li>\n<li>Identifiers, including keywords (<code class=\"hljs\">ident</code>, <code class=\"hljs\">r#ident</code>, <code class=\"hljs\">fn</code>)</li>\n</ul>\n<p>Mismatches between these two definitions are accounted for when token streams\nare passed to and from procedural macros. <br>\nNote that the conversions below may happen lazily, so they might not happen if\nthe tokens are not actually inspected.</p>\n<p>When passed to a proc-macro</p>\n<ul>\n<li>All multi-character operators are broken into single characters.</li>\n<li>Lifetimes are broken into a <code class=\"hljs\">'</code> character and an identifier.</li>\n<li>All metavariable substitutions are represented as their underlying token\nstreams.\n<ul>\n<li>Such token streams may be wrapped into delimited groups (<a href=\"../proc_macro/struct.Group.html\"><code class=\"hljs\">Group</code></a>) with\nimplicit delimiters (<a href=\"../proc_macro/enum.Delimiter.html#variant.None\"><code class=\"hljs\">Delimiter::None</code></a>) when it's necessary for\npreserving parsing priorities.</li>\n<li><code class=\"hljs\">tt</code> and <code class=\"hljs\">ident</code> substitutions are never wrapped into such groups and\nalways represented as their underlying token trees.</li>\n</ul>\n</li>\n</ul>\n<p>When emitted from a proc macro</p>\n<ul>\n<li>Punctuation characters are glued into multi-character operators\nwhen applicable.</li>\n<li>Single quotes <code class=\"hljs\">'</code> joined with identifiers are glued into lifetimes.</li>\n<li>Negative literals are converted into two tokens (the <code class=\"hljs\">-</code> and the literal)\npossibly wrapped into a delimited group (<a href=\"../proc_macro/struct.Group.html\"><code class=\"hljs\">Group</code></a>) with implicit delimiters\n(<a href=\"../proc_macro/enum.Delimiter.html#variant.None\"><code class=\"hljs\">Delimiter::None</code></a>) when it's necessary for preserving parsing priorities.</li>\n</ul>\n<p>Note that neither declarative nor procedural macros support doc comment tokens\n(e.g. <code class=\"hljs\">/// Doc</code>), so they are always converted to token streams representing\ntheir equivalent <code class=\"hljs\">#[doc = r\"str\"]</code> attributes when passed to macros.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"macros-by-example.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"crates-and-source-files.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"macros-by-example.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"crates-and-source-files.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:20:38.185Z"
}