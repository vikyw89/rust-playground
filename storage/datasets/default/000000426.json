{
	"title": "unsafe - Rust",
	"url": "https://doc.rust-lang.org/stable/std/keyword.unsafe.html",
	"markdown": "# unsafe - Rust\n\nExpand description\n\nCode or interfaces whose [memory safety](../book/ch19-01-unsafe-rust.html) cannot be verified by the type system.\n\nThe `unsafe` keyword has two uses:\n\n-   to declare the existence of contracts the compiler can’t check (`unsafe fn` and `unsafe trait`),\n-   and to declare that a programmer has checked that these contracts have been upheld (`unsafe {}` and `unsafe impl`, but also `unsafe fn` – see below).\n\nThey are not mutually exclusive, as can be seen in `unsafe fn`: the body of an `unsafe fn` is, by default, treated like an unsafe block. The `unsafe_op_in_unsafe_fn` lint can be enabled to change that.\n\n## [§](#unsafe-abilities)Unsafe abilities\n\n**No matter what, Safe Rust can’t cause Undefined Behavior**. This is referred to as [soundness](https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library): a well-typed program actually has the desired properties. The [Nomicon](../nomicon/safe-unsafe-meaning.html) has a more detailed explanation on the subject.\n\nTo ensure soundness, Safe Rust is restricted enough that it can be automatically checked. Sometimes, however, it is necessary to write code that is correct for reasons which are too clever for the compiler to understand. In those cases, you need to use Unsafe Rust.\n\nHere are the abilities Unsafe Rust has in addition to Safe Rust:\n\n-   Dereference [raw pointers](../reference/types/pointer.html)\n-   Implement `unsafe` [`trait`](keyword.trait.html)s\n-   Call `unsafe` functions\n-   Mutate [`static`](keyword.static.html)s (including [`extern`](keyword.extern.html)al ones)\n-   Access fields of [`union`](keyword.union.html)s\n\nHowever, this extra power comes with extra responsibilities: it is now up to you to ensure soundness. The `unsafe` keyword helps by clearly marking the pieces of code that need to worry about this.\n\n### [§](#the-different-meanings-of-unsafe)The different meanings of `unsafe`\n\nNot all uses of `unsafe` are equivalent: some are here to mark the existence of a contract the programmer must check, others are to say “I have checked the contract, go ahead and do this”. The following [discussion on Rust Internals](https://internals.rust-lang.org/t/what-does-unsafe-mean/6696) has more in-depth explanations about this but here is a summary of the main points:\n\n-   `unsafe fn`: calling this function means abiding by a contract the compiler cannot enforce.\n-   `unsafe trait`: implementing the [`trait`](keyword.trait.html) means abiding by a contract the compiler cannot enforce.\n-   `unsafe {}`: the contract necessary to call the operations inside the block has been checked by the programmer and is guaranteed to be respected.\n-   `unsafe impl`: the contract necessary to implement the trait has been checked by the programmer and is guaranteed to be respected.\n\nBy default, `unsafe fn` also acts like an `unsafe {}` block around the code inside the function. This means it is not just a signal to the caller, but also promises that the preconditions for the operations inside the function are upheld. Mixing these two meanings can be confusing, so the `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe blocks even inside `unsafe fn`.\n\nSee the [Rustonomicon](../nomicon/index.html) and the [Reference](../reference/unsafety.html) for more information.\n\n## [§](#examples)Examples\n\n### [§](#marking-elements-as-unsafe)Marking elements as `unsafe`\n\n`unsafe` can be used on functions. Note that functions and statics declared in [`extern`](keyword.extern.html) blocks are implicitly marked as `unsafe` (but not functions declared as `extern \"something\" fn ...`). Mutable statics are always unsafe, wherever they are declared. Methods can also be declared as `unsafe`:\n\n```\nstatic mut FOO: &str = \"hello\";\n\nunsafe fn unsafe_fn() {}\n\nextern \"C\" {\n    fn unsafe_extern_fn();\n    static BAR: *mut u32;\n}\n\ntrait SafeTraitWithUnsafeMethod {\n    unsafe fn unsafe_method(&self);\n}\n\nstruct S;\n\nimpl S {\n    unsafe fn unsafe_method_on_struct() {}\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++static+mut+FOO:+%26str+=+%22hello%22;%0A++++%0A++++unsafe+fn+unsafe_fn()+%7B%7D%0A++++%0A++++extern+%22C%22+%7B%0A++++++++fn+unsafe_extern_fn();%0A++++++++static+BAR:+*mut+u32;%0A++++%7D%0A++++%0A++++trait+SafeTraitWithUnsafeMethod+%7B%0A++++++++unsafe+fn+unsafe_method(%26self);%0A++++%7D%0A++++%0A++++struct+S;%0A++++%0A++++impl+S+%7B%0A++++++++unsafe+fn+unsafe_method_on_struct()+%7B%7D%0A++++%7D%0A%7D&edition=2021)\n\nTraits can also be declared as `unsafe`:\n\n```\nunsafe trait UnsafeTrait {}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++unsafe+trait+UnsafeTrait+%7B%7D%0A%7D&edition=2021)\n\nSince `unsafe fn` and `unsafe trait` indicate that there is a safety contract that the compiler cannot enforce, documenting it is important. The standard library has many examples of this, like the following which is an extract from [`Vec::set_len`](about:blank/vec/struct.Vec.html#method.set_len \"method std::vec::Vec::set_len\"). The `# Safety` section explains the contract that must be fulfilled to safely call the function.\n\n[ⓘ](# \"This example is not tested\")\n\n```\n/// Forces the length of the vector to `new_len`.\n///\n/// This is a low-level operation that maintains none of the normal\n/// invariants of the type. Normally changing the length of a vector\n/// is done using one of the safe operations instead, such as\n/// `truncate`, `resize`, `extend`, or `clear`.\n///\n/// # Safety\n///\n/// - `new_len` must be less than or equal to `capacity()`.\n/// - The elements at `old_len..new_len` must be initialized.\npub unsafe fn set_len(&mut self, new_len: usize)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++///+Forces+the+length+of+the+vector+to+%60new_len%60.%0A++++///%0A++++///+This+is+a+low-level+operation+that+maintains+none+of+the+normal%0A++++///+invariants+of+the+type.+Normally+changing+the+length+of+a+vector%0A++++///+is+done+using+one+of+the+safe+operations+instead,+such+as%0A++++///+%60truncate%60,+%60resize%60,+%60extend%60,+or+%60clear%60.%0A++++///%0A++++///+%23+Safety%0A++++///%0A++++///+-+%60new_len%60+must+be+less+than+or+equal+to+%60capacity()%60.%0A++++///+-+The+elements+at+%60old_len..new_len%60+must+be+initialized.%0A++++pub+unsafe+fn+set_len(%26mut+self,+new_len:+usize)%0A%7D&edition=2021)\n\n### [§](#using-unsafe--blocks-and-impls)Using `unsafe {}` blocks and `impl`s\n\nPerforming `unsafe` operations requires an `unsafe {}` block:\n\n```\n#![deny(unsafe_op_in_unsafe_fn)]\n\n/// Dereference the given pointer.\n///\n/// # Safety\n///\n/// `ptr` must be aligned and must not be dangling.\nunsafe fn deref_unchecked(ptr: *const i32) -> i32 {\n    // SAFETY: the caller is required to ensure that `ptr` is aligned and dereferenceable.\n    unsafe { *ptr }\n}\n\nlet a = 3;\nlet b = &a as *const _;\n// SAFETY: `a` has not been dropped and references are always aligned,\n// so `b` is a valid address.\nunsafe { assert_eq!(*b, deref_unchecked(b)); };\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0A%23!%5Bdeny(unsafe_op_in_unsafe_fn)%5D%0A%0Afn+main()+%7B%0A++++///+Dereference+the+given+pointer.%0A++++///%0A++++///+%23+Safety%0A++++///%0A++++///+%60ptr%60+must+be+aligned+and+must+not+be+dangling.%0A++++unsafe+fn+deref_unchecked(ptr:+*const+i32)+-%3E+i32+%7B%0A++++++++//+SAFETY:+the+caller+is+required+to+ensure+that+%60ptr%60+is+aligned+and+dereferenceable.%0A++++++++unsafe+%7B+*ptr+%7D%0A++++%7D%0A++++%0A++++let+a+=+3;%0A++++let+b+=+%26a+as+*const+_;%0A++++//+SAFETY:+%60a%60+has+not+been+dropped+and+references+are+always+aligned,%0A++++//+so+%60b%60+is+a+valid+address.%0A++++unsafe+%7B+assert_eq!(*b,+deref_unchecked(b));+%7D;%0A%7D&edition=2021)\n\n### [§](#unsafe-and-traits)`unsafe` and traits\n\nThe interactions of `unsafe` and traits can be surprising, so let us contrast the two combinations of safe `fn` in `unsafe trait` and `unsafe fn` in safe trait using two examples:\n\n```\n/// # Safety\n///\n/// `make_even` must return an even number.\nunsafe trait MakeEven {\n    fn make_even(&self) -> i32;\n}\n\n// SAFETY: Our `make_even` always returns something even.\nunsafe impl MakeEven for i32 {\n    fn make_even(&self) -> i32 {\n        self << 1\n    }\n}\n\nfn use_make_even(x: impl MakeEven) {\n    if x.make_even() % 2 == 1 {\n        // SAFETY: this can never happen, because all `MakeEven` implementations\n        // ensure that `make_even` returns something even.\n        unsafe { std::hint::unreachable_unchecked() };\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++///+%23+Safety%0A++++///%0A++++///+%60make_even%60+must+return+an+even+number.%0A++++unsafe+trait+MakeEven+%7B%0A++++++++fn+make_even(%26self)+-%3E+i32;%0A++++%7D%0A++++%0A++++//+SAFETY:+Our+%60make_even%60+always+returns+something+even.%0A++++unsafe+impl+MakeEven+for+i32+%7B%0A++++++++fn+make_even(%26self)+-%3E+i32+%7B%0A++++++++++++self+%3C%3C+1%0A++++++++%7D%0A++++%7D%0A++++%0A++++fn+use_make_even(x:+impl+MakeEven)+%7B%0A++++++++if+x.make_even()+%25+2+==+1+%7B%0A++++++++++++//+SAFETY:+this+can+never+happen,+because+all+%60MakeEven%60+implementations%0A++++++++++++//+ensure+that+%60make_even%60+returns+something+even.%0A++++++++++++unsafe+%7B+std::hint::unreachable_unchecked()+%7D;%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\nNote how the safety contract of the trait is upheld by the implementation, and is itself used to uphold the safety contract of the unsafe function `unreachable_unchecked` called by `use_make_even`. `make_even` itself is a safe function because its _callers_ do not have to worry about any contract, only the _implementation_ of `MakeEven` is required to uphold a certain contract. `use_make_even` is safe because it can use the promise made by `MakeEven` implementations to uphold the safety contract of the `unsafe fn unreachable_unchecked` it calls.\n\nIt is also possible to have `unsafe fn` in a regular safe `trait`:\n\n```\n#![deny(unsafe_op_in_unsafe_fn)]\n\ntrait Indexable {\n    const LEN: usize;\n\n    /// # Safety\n    ///\n    /// The caller must ensure that `idx < LEN`.\n    unsafe fn idx_unchecked(&self, idx: usize) -> i32;\n}\n\n// The implementation for `i32` doesn't need to do any contract reasoning.\nimpl Indexable for i32 {\n    const LEN: usize = 1;\n\n    unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n        debug_assert_eq!(idx, 0);\n        *self\n    }\n}\n\n// The implementation for arrays exploits the function contract to\n// make use of `get_unchecked` on slices and avoid a run-time check.\nimpl Indexable for [i32; 42] {\n    const LEN: usize = 42;\n\n    unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n        // SAFETY: As per this trait's documentation, the caller ensures\n        // that `idx < 42`.\n        unsafe { *self.get_unchecked(idx) }\n    }\n}\n\n// The implementation for the never type declares a length of 0,\n// which means `idx_unchecked` can never be called.\nimpl Indexable for ! {\n    const LEN: usize = 0;\n\n    unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n        // SAFETY: As per this trait's documentation, the caller ensures\n        // that `idx < 0`, which is impossible, so this is dead code.\n        unsafe { std::hint::unreachable_unchecked() }\n    }\n}\n\nfn use_indexable<I: Indexable>(x: I, idx: usize) -> i32 {\n    if idx < I::LEN {\n        // SAFETY: We have checked that `idx < I::LEN`.\n        unsafe { x.idx_unchecked(idx) }\n    } else {\n        panic!(\"index out-of-bounds\")\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(never_type)%5D%0A%23!%5Bdeny(unsafe_op_in_unsafe_fn)%5D%0A%0Afn+main()+%7B%0A++++trait+Indexable+%7B%0A++++++++const+LEN:+usize;%0A++++%0A++++++++///+%23+Safety%0A++++++++///%0A++++++++///+The+caller+must+ensure+that+%60idx+%3C+LEN%60.%0A++++++++unsafe+fn+idx_unchecked(%26self,+idx:+usize)+-%3E+i32;%0A++++%7D%0A++++%0A++++//+The+implementation+for+%60i32%60+doesn%27t+need+to+do+any+contract+reasoning.%0A++++impl+Indexable+for+i32+%7B%0A++++++++const+LEN:+usize+=+1;%0A++++%0A++++++++unsafe+fn+idx_unchecked(%26self,+idx:+usize)+-%3E+i32+%7B%0A++++++++++++debug_assert_eq!(idx,+0);%0A++++++++++++*self%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+The+implementation+for+arrays+exploits+the+function+contract+to%0A++++//+make+use+of+%60get_unchecked%60+on+slices+and+avoid+a+run-time+check.%0A++++impl+Indexable+for+%5Bi32;+42%5D+%7B%0A++++++++const+LEN:+usize+=+42;%0A++++%0A++++++++unsafe+fn+idx_unchecked(%26self,+idx:+usize)+-%3E+i32+%7B%0A++++++++++++//+SAFETY:+As+per+this+trait%27s+documentation,+the+caller+ensures%0A++++++++++++//+that+%60idx+%3C+42%60.%0A++++++++++++unsafe+%7B+*self.get_unchecked(idx)+%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+The+implementation+for+the+never+type+declares+a+length+of+0,%0A++++//+which+means+%60idx_unchecked%60+can+never+be+called.%0A++++impl+Indexable+for+!+%7B%0A++++++++const+LEN:+usize+=+0;%0A++++%0A++++++++unsafe+fn+idx_unchecked(%26self,+idx:+usize)+-%3E+i32+%7B%0A++++++++++++//+SAFETY:+As+per+this+trait%27s+documentation,+the+caller+ensures%0A++++++++++++//+that+%60idx+%3C+0%60,+which+is+impossible,+so+this+is+dead+code.%0A++++++++++++unsafe+%7B+std::hint::unreachable_unchecked()+%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++fn+use_indexable%3CI:+Indexable%3E(x:+I,+idx:+usize)+-%3E+i32+%7B%0A++++++++if+idx+%3C+I::LEN+%7B%0A++++++++++++//+SAFETY:+We+have+checked+that+%60idx+%3C+I::LEN%60.%0A++++++++++++unsafe+%7B+x.idx_unchecked(idx)+%7D%0A++++++++%7D+else+%7B%0A++++++++++++panic!(%22index+out-of-bounds%22)%0A++++++++%7D%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\nThis time, `use_indexable` is safe because it uses a run-time check to discharge the safety contract of `idx_unchecked`. Implementing `Indexable` is safe because when writing `idx_unchecked`, we don’t have to worry: our _callers_ need to discharge a proof obligation (like `use_indexable` does), but the _implementation_ of `get_unchecked` has no proof obligation to contend with. Of course, the implementation of `Indexable` may choose to call other unsafe operations, and then it needs an `unsafe` _block_ to indicate it discharged the proof obligations of its callees. (We enabled `unsafe_op_in_unsafe_fn`, so the body of `idx_unchecked` is not implicitly an unsafe block.) For that purpose it can make use of the contract that all its callers must uphold – the fact that `idx < LEN`.\n\nFormally speaking, an `unsafe fn` in a trait is a function with _preconditions_ that go beyond those encoded by the argument types (such as `idx < LEN`), whereas an `unsafe trait` can declare that some of its functions have _postconditions_ that go beyond those encoded in the return type (such as returning an even integer). If a trait needs a function with both extra precondition and extra postcondition, then it needs an `unsafe fn` in an `unsafe trait`.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Code or interfaces whose memory safety cannot be verified by the type system.\"><title>unsafe - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../\" data-static-root-path=\"../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc keyword\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../std/index.html\"><img class=\"rust-logo\" src=\"../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../std/index.html\"><img class=\"rust-logo\" src=\"../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h3><a href=\"index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"primitive.array.html\">array</a></li><li><a href=\"primitive.bool.html\">bool</a></li><li><a href=\"primitive.char.html\">char</a></li><li><a href=\"primitive.f128.html\">f128</a></li><li><a href=\"primitive.f16.html\">f16</a></li><li><a href=\"primitive.f32.html\">f32</a></li><li><a href=\"primitive.f64.html\">f64</a></li><li><a href=\"primitive.fn.html\">fn</a></li><li><a href=\"primitive.i128.html\">i128</a></li><li><a href=\"primitive.i16.html\">i16</a></li><li><a href=\"primitive.i32.html\">i32</a></li><li><a href=\"primitive.i64.html\">i64</a></li><li><a href=\"primitive.i8.html\">i8</a></li><li><a href=\"primitive.isize.html\">isize</a></li><li><a href=\"primitive.never.html\">never</a></li><li><a href=\"primitive.pointer.html\">pointer</a></li><li><a href=\"primitive.reference.html\">reference</a></li><li><a href=\"primitive.slice.html\">slice</a></li><li><a href=\"primitive.str.html\">str</a></li><li><a href=\"primitive.tuple.html\">tuple</a></li><li><a href=\"primitive.u128.html\">u128</a></li><li><a href=\"primitive.u16.html\">u16</a></li><li><a href=\"primitive.u32.html\">u32</a></li><li><a href=\"primitive.u64.html\">u64</a></li><li><a href=\"primitive.u8.html\">u8</a></li><li><a href=\"primitive.unit.html\">unit</a></li><li><a href=\"primitive.usize.html\">usize</a></li></ul><h3><a href=\"index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"alloc/index.html\">alloc</a></li><li><a href=\"any/index.html\">any</a></li><li><a href=\"arch/index.html\">arch</a></li><li><a href=\"array/index.html\">array</a></li><li><a href=\"ascii/index.html\">ascii</a></li><li><a href=\"assert_matches/index.html\">assert_matches</a></li><li><a href=\"async_iter/index.html\">async_iter</a></li><li><a href=\"backtrace/index.html\">backtrace</a></li><li><a href=\"borrow/index.html\">borrow</a></li><li><a href=\"boxed/index.html\">boxed</a></li><li><a href=\"cell/index.html\">cell</a></li><li><a href=\"char/index.html\">char</a></li><li><a href=\"clone/index.html\">clone</a></li><li><a href=\"cmp/index.html\">cmp</a></li><li><a href=\"collections/index.html\">collections</a></li><li><a href=\"convert/index.html\">convert</a></li><li><a href=\"default/index.html\">default</a></li><li><a href=\"env/index.html\">env</a></li><li><a href=\"error/index.html\">error</a></li><li><a href=\"f128/index.html\">f128</a></li><li><a href=\"f16/index.html\">f16</a></li><li><a href=\"f32/index.html\">f32</a></li><li><a href=\"f64/index.html\">f64</a></li><li><a href=\"ffi/index.html\">ffi</a></li><li><a href=\"fmt/index.html\">fmt</a></li><li><a href=\"fs/index.html\">fs</a></li><li><a href=\"future/index.html\">future</a></li><li><a href=\"hash/index.html\">hash</a></li><li><a href=\"hint/index.html\">hint</a></li><li><a href=\"i128/index.html\">i128</a></li><li><a href=\"i16/index.html\">i16</a></li><li><a href=\"i32/index.html\">i32</a></li><li><a href=\"i64/index.html\">i64</a></li><li><a href=\"i8/index.html\">i8</a></li><li><a href=\"intrinsics/index.html\">intrinsics</a></li><li><a href=\"io/index.html\">io</a></li><li><a href=\"isize/index.html\">isize</a></li><li><a href=\"iter/index.html\">iter</a></li><li><a href=\"marker/index.html\">marker</a></li><li><a href=\"mem/index.html\">mem</a></li><li><a href=\"net/index.html\">net</a></li><li><a href=\"num/index.html\">num</a></li><li><a href=\"ops/index.html\">ops</a></li><li><a href=\"option/index.html\">option</a></li><li><a href=\"os/index.html\">os</a></li><li><a href=\"panic/index.html\">panic</a></li><li><a href=\"pat/index.html\">pat</a></li><li><a href=\"path/index.html\">path</a></li><li><a href=\"pin/index.html\">pin</a></li><li><a href=\"prelude/index.html\">prelude</a></li><li><a href=\"primitive/index.html\">primitive</a></li><li><a href=\"process/index.html\">process</a></li><li><a href=\"ptr/index.html\">ptr</a></li><li><a href=\"rc/index.html\">rc</a></li><li><a href=\"result/index.html\">result</a></li><li><a href=\"simd/index.html\">simd</a></li><li><a href=\"slice/index.html\">slice</a></li><li><a href=\"str/index.html\">str</a></li><li><a href=\"string/index.html\">string</a></li><li><a href=\"sync/index.html\">sync</a></li><li><a href=\"task/index.html\">task</a></li><li><a href=\"thread/index.html\">thread</a></li><li><a href=\"time/index.html\">time</a></li><li><a href=\"u128/index.html\">u128</a></li><li><a href=\"u16/index.html\">u16</a></li><li><a href=\"u32/index.html\">u32</a></li><li><a href=\"u64/index.html\">u64</a></li><li><a href=\"u8/index.html\">u8</a></li><li><a href=\"usize/index.html\">usize</a></li><li><a href=\"vec/index.html\">vec</a></li></ul><h3><a href=\"index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"macro.assert.html\">assert</a></li><li><a href=\"macro.assert_eq.html\">assert_eq</a></li><li><a href=\"macro.assert_ne.html\">assert_ne</a></li><li><a href=\"macro.cfg.html\">cfg</a></li><li><a href=\"macro.cfg_match.html\">cfg_match</a></li><li><a href=\"macro.column.html\">column</a></li><li><a href=\"macro.compile_error.html\">compile_error</a></li><li><a href=\"macro.concat.html\">concat</a></li><li><a href=\"macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"macro.concat_idents.html\">concat_idents</a></li><li><a href=\"macro.const_format_args.html\">const_format_args</a></li><li><a href=\"macro.dbg.html\">dbg</a></li><li><a href=\"macro.debug_assert.html\">debug_assert</a></li><li><a href=\"macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"macro.env.html\">env</a></li><li><a href=\"macro.eprint.html\">eprint</a></li><li><a href=\"macro.eprintln.html\">eprintln</a></li><li><a href=\"macro.file.html\">file</a></li><li><a href=\"macro.format.html\">format</a></li><li><a href=\"macro.format_args.html\">format_args</a></li><li><a href=\"macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"macro.include.html\">include</a></li><li><a href=\"macro.include_bytes.html\">include_bytes</a></li><li><a href=\"macro.include_str.html\">include_str</a></li><li><a href=\"macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"macro.line.html\">line</a></li><li><a href=\"macro.log_syntax.html\">log_syntax</a></li><li><a href=\"macro.matches.html\">matches</a></li><li><a href=\"macro.module_path.html\">module_path</a></li><li><a href=\"macro.option_env.html\">option_env</a></li><li><a href=\"macro.panic.html\">panic</a></li><li><a href=\"macro.print.html\">print</a></li><li><a href=\"macro.println.html\">println</a></li><li><a href=\"macro.stringify.html\">stringify</a></li><li><a href=\"macro.thread_local.html\">thread_local</a></li><li><a href=\"macro.todo.html\">todo</a></li><li><a href=\"macro.trace_macros.html\">trace_macros</a></li><li><a href=\"macro.try.html\">try</a></li><li><a href=\"macro.unimplemented.html\">unimplemented</a></li><li><a href=\"macro.unreachable.html\">unreachable</a></li><li><a href=\"macro.vec.html\">vec</a></li><li><a href=\"macro.write.html\">write</a></li><li><a href=\"macro.writeln.html\">writeln</a></li></ul><h3><a href=\"index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"keyword.as.html\">as</a></li><li><a href=\"keyword.async.html\">async</a></li><li><a href=\"keyword.await.html\">await</a></li><li><a href=\"keyword.break.html\">break</a></li><li><a href=\"keyword.const.html\">const</a></li><li><a href=\"keyword.continue.html\">continue</a></li><li><a href=\"keyword.crate.html\">crate</a></li><li><a href=\"keyword.dyn.html\">dyn</a></li><li><a href=\"keyword.else.html\">else</a></li><li><a href=\"keyword.enum.html\">enum</a></li><li><a href=\"keyword.extern.html\">extern</a></li><li><a href=\"keyword.false.html\">false</a></li><li><a href=\"keyword.fn.html\">fn</a></li><li><a href=\"keyword.for.html\">for</a></li><li><a href=\"keyword.if.html\">if</a></li><li><a href=\"keyword.impl.html\">impl</a></li><li><a href=\"keyword.in.html\">in</a></li><li><a href=\"keyword.let.html\">let</a></li><li><a href=\"keyword.loop.html\">loop</a></li><li><a href=\"keyword.match.html\">match</a></li><li><a href=\"keyword.mod.html\">mod</a></li><li><a href=\"keyword.move.html\">move</a></li><li><a href=\"keyword.mut.html\">mut</a></li><li><a href=\"keyword.pub.html\">pub</a></li><li><a href=\"keyword.ref.html\">ref</a></li><li><a href=\"keyword.return.html\">return</a></li><li><a href=\"keyword.self.html\">self</a></li><li><a href=\"keyword.static.html\">static</a></li><li><a href=\"keyword.struct.html\">struct</a></li><li><a href=\"keyword.super.html\">super</a></li><li><a href=\"keyword.trait.html\">trait</a></li><li><a href=\"keyword.true.html\">true</a></li><li><a href=\"keyword.type.html\">type</a></li><li><a href=\"keyword.union.html\">union</a></li><li><a href=\"keyword.unsafe.html\">unsafe</a></li><li><a href=\"keyword.use.html\">use</a></li><li><a href=\"keyword.where.html\">where</a></li><li><a href=\"keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Keyword <a class=\"keyword\" href=\"#\">unsafe</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><a class=\"src\" href=\"../src/std/keyword_docs.rs.html#2145\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Code or interfaces whose <a href=\"../book/ch19-01-unsafe-rust.html\">memory safety</a> cannot be verified by the type\nsystem.</p>\n<p>The <code>unsafe</code> keyword has two uses:</p>\n<ul>\n<li>to declare the existence of contracts the compiler can’t check (<code>unsafe fn</code> and <code>unsafe trait</code>),</li>\n<li>and to declare that a programmer has checked that these contracts have been upheld (<code>unsafe {}</code> and <code>unsafe impl</code>, but also <code>unsafe fn</code> – see below).</li>\n</ul>\n<p>They are not mutually exclusive, as can be seen in <code>unsafe fn</code>: the body of an <code>unsafe fn</code> is,\nby default, treated like an unsafe block. The <code>unsafe_op_in_unsafe_fn</code> lint can be enabled to\nchange that.</p>\n<h2 id=\"unsafe-abilities\"><a class=\"doc-anchor\" href=\"#unsafe-abilities\">§</a>Unsafe abilities</h2>\n<p><strong>No matter what, Safe Rust can’t cause Undefined Behavior</strong>. This is\nreferred to as <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library\">soundness</a>: a well-typed program actually has the desired\nproperties. The <a href=\"../nomicon/safe-unsafe-meaning.html\">Nomicon</a> has a more detailed explanation\non the subject.</p>\n<p>To ensure soundness, Safe Rust is restricted enough that it can be\nautomatically checked. Sometimes, however, it is necessary to write code\nthat is correct for reasons which are too clever for the compiler to\nunderstand. In those cases, you need to use Unsafe Rust.</p>\n<p>Here are the abilities Unsafe Rust has in addition to Safe Rust:</p>\n<ul>\n<li>Dereference <a href=\"../reference/types/pointer.html\">raw pointers</a></li>\n<li>Implement <code>unsafe</code> <a href=\"keyword.trait.html\"><code>trait</code></a>s</li>\n<li>Call <code>unsafe</code> functions</li>\n<li>Mutate <a href=\"keyword.static.html\"><code>static</code></a>s (including <a href=\"keyword.extern.html\"><code>extern</code></a>al ones)</li>\n<li>Access fields of <a href=\"keyword.union.html\"><code>union</code></a>s</li>\n</ul>\n<p>However, this extra power comes with extra responsibilities: it is now up to\nyou to ensure soundness. The <code>unsafe</code> keyword helps by clearly marking the\npieces of code that need to worry about this.</p>\n<h3 id=\"the-different-meanings-of-unsafe\"><a class=\"doc-anchor\" href=\"#the-different-meanings-of-unsafe\">§</a>The different meanings of <code>unsafe</code></h3>\n<p>Not all uses of <code>unsafe</code> are equivalent: some are here to mark the existence\nof a contract the programmer must check, others are to say “I have checked\nthe contract, go ahead and do this”. The following\n<a href=\"https://internals.rust-lang.org/t/what-does-unsafe-mean/6696\">discussion on Rust Internals</a> has more in-depth explanations about this but\nhere is a summary of the main points:</p>\n<ul>\n<li><code>unsafe fn</code>: calling this function means abiding by a contract the\ncompiler cannot enforce.</li>\n<li><code>unsafe trait</code>: implementing the <a href=\"keyword.trait.html\"><code>trait</code></a> means abiding by a\ncontract the compiler cannot enforce.</li>\n<li><code>unsafe {}</code>: the contract necessary to call the operations inside the\nblock has been checked by the programmer and is guaranteed to be respected.</li>\n<li><code>unsafe impl</code>: the contract necessary to implement the trait has been\nchecked by the programmer and is guaranteed to be respected.</li>\n</ul>\n<p>By default, <code>unsafe fn</code> also acts like an <code>unsafe {}</code> block\naround the code inside the function. This means it is not just a signal to\nthe caller, but also promises that the preconditions for the operations\ninside the function are upheld. Mixing these two meanings can be confusing, so the\n<code>unsafe_op_in_unsafe_fn</code> lint can be enabled to warn against that and require explicit unsafe\nblocks even inside <code>unsafe fn</code>.</p>\n<p>See the <a href=\"../nomicon/index.html\">Rustonomicon</a> and the <a href=\"../reference/unsafety.html\">Reference</a> for more information.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2><h3 id=\"marking-elements-as-unsafe\"><a class=\"doc-anchor\" href=\"#marking-elements-as-unsafe\">§</a>Marking elements as <code>unsafe</code></h3>\n<p><code>unsafe</code> can be used on functions. Note that functions and statics declared\nin <a href=\"keyword.extern.html\"><code>extern</code></a> blocks are implicitly marked as <code>unsafe</code> (but not functions\ndeclared as <code>extern \"something\" fn ...</code>). Mutable statics are always unsafe,\nwherever they are declared. Methods can also be declared as <code>unsafe</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">static </span><span class=\"kw-2\">mut </span>FOO: <span class=\"kw-2\">&amp;</span>str = <span class=\"string\">\"hello\"</span>;\n\n<span class=\"kw\">unsafe fn </span>unsafe_fn() {}\n\n<span class=\"kw\">extern </span><span class=\"string\">\"C\" </span>{\n    <span class=\"kw\">fn </span>unsafe_extern_fn();\n    <span class=\"kw\">static </span>BAR: <span class=\"kw-2\">*mut </span>u32;\n}\n\n<span class=\"kw\">trait </span>SafeTraitWithUnsafeMethod {\n    <span class=\"kw\">unsafe fn </span>unsafe_method(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>);\n}\n\n<span class=\"kw\">struct </span>S;\n\n<span class=\"kw\">impl </span>S {\n    <span class=\"kw\">unsafe fn </span>unsafe_method_on_struct() {}\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++static+mut+FOO:+%26str+=+%22hello%22;%0A++++%0A++++unsafe+fn+unsafe_fn()+%7B%7D%0A++++%0A++++extern+%22C%22+%7B%0A++++++++fn+unsafe_extern_fn();%0A++++++++static+BAR:+*mut+u32;%0A++++%7D%0A++++%0A++++trait+SafeTraitWithUnsafeMethod+%7B%0A++++++++unsafe+fn+unsafe_method(%26self);%0A++++%7D%0A++++%0A++++struct+S;%0A++++%0A++++impl+S+%7B%0A++++++++unsafe+fn+unsafe_method_on_struct()+%7B%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Traits can also be declared as <code>unsafe</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">unsafe trait </span>UnsafeTrait {}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++unsafe+trait+UnsafeTrait+%7B%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Since <code>unsafe fn</code> and <code>unsafe trait</code> indicate that there is a safety\ncontract that the compiler cannot enforce, documenting it is important. The\nstandard library has many examples of this, like the following which is an\nextract from <a href=\"vec/struct.Vec.html#method.set_len\" title=\"method std::vec::Vec::set_len\"><code>Vec::set_len</code></a>. The <code># Safety</code> section explains the contract\nthat must be fulfilled to safely call the function.</p>\n\n<div class=\"example-wrap ignore\"><a href=\"#\" class=\"tooltip\" title=\"This example is not tested\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"doccomment\">/// Forces the length of the vector to `new_len`.\n///\n/// This is a low-level operation that maintains none of the normal\n/// invariants of the type. Normally changing the length of a vector\n/// is done using one of the safe operations instead, such as\n/// `truncate`, `resize`, `extend`, or `clear`.\n///\n/// # Safety\n///\n/// - `new_len` must be less than or equal to `capacity()`.\n/// - The elements at `old_len..new_len` must be initialized.\n</span><span class=\"kw\">pub unsafe fn </span>set_len(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>, new_len: usize)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++///+Forces+the+length+of+the+vector+to+%60new_len%60.%0A++++///%0A++++///+This+is+a+low-level+operation+that+maintains+none+of+the+normal%0A++++///+invariants+of+the+type.+Normally+changing+the+length+of+a+vector%0A++++///+is+done+using+one+of+the+safe+operations+instead,+such+as%0A++++///+%60truncate%60,+%60resize%60,+%60extend%60,+or+%60clear%60.%0A++++///%0A++++///+%23+Safety%0A++++///%0A++++///+-+%60new_len%60+must+be+less+than+or+equal+to+%60capacity()%60.%0A++++///+-+The+elements+at+%60old_len..new_len%60+must+be+initialized.%0A++++pub+unsafe+fn+set_len(%26mut+self,+new_len:+usize)%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"using-unsafe--blocks-and-impls\"><a class=\"doc-anchor\" href=\"#using-unsafe--blocks-and-impls\">§</a>Using <code>unsafe {}</code> blocks and <code>impl</code>s</h3>\n<p>Performing <code>unsafe</code> operations requires an <code>unsafe {}</code> block:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![deny(unsafe_op_in_unsafe_fn)]\n\n</span><span class=\"doccomment\">/// Dereference the given pointer.\n///\n/// # Safety\n///\n/// `ptr` must be aligned and must not be dangling.\n</span><span class=\"kw\">unsafe fn </span>deref_unchecked(ptr: <span class=\"kw-2\">*const </span>i32) -&gt; i32 {\n    <span class=\"comment\">// SAFETY: the caller is required to ensure that `ptr` is aligned and dereferenceable.\n    </span><span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">*</span>ptr }\n}\n\n<span class=\"kw\">let </span>a = <span class=\"number\">3</span>;\n<span class=\"kw\">let </span>b = <span class=\"kw-2\">&amp;</span>a <span class=\"kw\">as </span><span class=\"kw-2\">*const </span><span class=\"kw\">_</span>;\n<span class=\"comment\">// SAFETY: `a` has not been dropped and references are always aligned,\n// so `b` is a valid address.\n</span><span class=\"kw\">unsafe </span>{ <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>b, deref_unchecked(b)); };</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0A%23!%5Bdeny(unsafe_op_in_unsafe_fn)%5D%0A%0Afn+main()+%7B%0A++++///+Dereference+the+given+pointer.%0A++++///%0A++++///+%23+Safety%0A++++///%0A++++///+%60ptr%60+must+be+aligned+and+must+not+be+dangling.%0A++++unsafe+fn+deref_unchecked(ptr:+*const+i32)+-%3E+i32+%7B%0A++++++++//+SAFETY:+the+caller+is+required+to+ensure+that+%60ptr%60+is+aligned+and+dereferenceable.%0A++++++++unsafe+%7B+*ptr+%7D%0A++++%7D%0A++++%0A++++let+a+=+3;%0A++++let+b+=+%26a+as+*const+_;%0A++++//+SAFETY:+%60a%60+has+not+been+dropped+and+references+are+always+aligned,%0A++++//+so+%60b%60+is+a+valid+address.%0A++++unsafe+%7B+assert_eq!(*b,+deref_unchecked(b));+%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"unsafe-and-traits\"><a class=\"doc-anchor\" href=\"#unsafe-and-traits\">§</a><code>unsafe</code> and traits</h3>\n<p>The interactions of <code>unsafe</code> and traits can be surprising, so let us contrast the\ntwo combinations of safe <code>fn</code> in <code>unsafe trait</code> and <code>unsafe fn</code> in safe trait using two\nexamples:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"doccomment\">/// # Safety\n///\n/// `make_even` must return an even number.\n</span><span class=\"kw\">unsafe trait </span>MakeEven {\n    <span class=\"kw\">fn </span>make_even(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; i32;\n}\n\n<span class=\"comment\">// SAFETY: Our `make_even` always returns something even.\n</span><span class=\"kw\">unsafe impl </span>MakeEven <span class=\"kw\">for </span>i32 {\n    <span class=\"kw\">fn </span>make_even(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; i32 {\n        <span class=\"self\">self </span>&lt;&lt; <span class=\"number\">1\n    </span>}\n}\n\n<span class=\"kw\">fn </span>use_make_even(x: <span class=\"kw\">impl </span>MakeEven) {\n    <span class=\"kw\">if </span>x.make_even() % <span class=\"number\">2 </span>== <span class=\"number\">1 </span>{\n        <span class=\"comment\">// SAFETY: this can never happen, because all `MakeEven` implementations\n        // ensure that `make_even` returns something even.\n        </span><span class=\"kw\">unsafe </span>{ std::hint::unreachable_unchecked() };\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++///+%23+Safety%0A++++///%0A++++///+%60make_even%60+must+return+an+even+number.%0A++++unsafe+trait+MakeEven+%7B%0A++++++++fn+make_even(%26self)+-%3E+i32;%0A++++%7D%0A++++%0A++++//+SAFETY:+Our+%60make_even%60+always+returns+something+even.%0A++++unsafe+impl+MakeEven+for+i32+%7B%0A++++++++fn+make_even(%26self)+-%3E+i32+%7B%0A++++++++++++self+%3C%3C+1%0A++++++++%7D%0A++++%7D%0A++++%0A++++fn+use_make_even(x:+impl+MakeEven)+%7B%0A++++++++if+x.make_even()+%25+2+==+1+%7B%0A++++++++++++//+SAFETY:+this+can+never+happen,+because+all+%60MakeEven%60+implementations%0A++++++++++++//+ensure+that+%60make_even%60+returns+something+even.%0A++++++++++++unsafe+%7B+std::hint::unreachable_unchecked()+%7D;%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note how the safety contract of the trait is upheld by the implementation, and is itself used to\nuphold the safety contract of the unsafe function <code>unreachable_unchecked</code> called by\n<code>use_make_even</code>. <code>make_even</code> itself is a safe function because its <em>callers</em> do not have to\nworry about any contract, only the <em>implementation</em> of <code>MakeEven</code> is required to uphold a\ncertain contract. <code>use_make_even</code> is safe because it can use the promise made by <code>MakeEven</code>\nimplementations to uphold the safety contract of the <code>unsafe fn unreachable_unchecked</code> it calls.</p>\n<p>It is also possible to have <code>unsafe fn</code> in a regular safe <code>trait</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![deny(unsafe_op_in_unsafe_fn)]\n\n</span><span class=\"kw\">trait </span>Indexable {\n    <span class=\"kw\">const </span>LEN: usize;\n\n    <span class=\"doccomment\">/// # Safety\n    ///\n    /// The caller must ensure that `idx &lt; LEN`.\n    </span><span class=\"kw\">unsafe fn </span>idx_unchecked(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, idx: usize) -&gt; i32;\n}\n\n<span class=\"comment\">// The implementation for `i32` doesn't need to do any contract reasoning.\n</span><span class=\"kw\">impl </span>Indexable <span class=\"kw\">for </span>i32 {\n    <span class=\"kw\">const </span>LEN: usize = <span class=\"number\">1</span>;\n\n    <span class=\"kw\">unsafe fn </span>idx_unchecked(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, idx: usize) -&gt; i32 {\n        <span class=\"macro\">debug_assert_eq!</span>(idx, <span class=\"number\">0</span>);\n        <span class=\"kw-2\">*</span><span class=\"self\">self\n    </span>}\n}\n\n<span class=\"comment\">// The implementation for arrays exploits the function contract to\n// make use of `get_unchecked` on slices and avoid a run-time check.\n</span><span class=\"kw\">impl </span>Indexable <span class=\"kw\">for </span>[i32; <span class=\"number\">42</span>] {\n    <span class=\"kw\">const </span>LEN: usize = <span class=\"number\">42</span>;\n\n    <span class=\"kw\">unsafe fn </span>idx_unchecked(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, idx: usize) -&gt; i32 {\n        <span class=\"comment\">// SAFETY: As per this trait's documentation, the caller ensures\n        // that `idx &lt; 42`.\n        </span><span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">*</span><span class=\"self\">self</span>.get_unchecked(idx) }\n    }\n}\n\n<span class=\"comment\">// The implementation for the never type declares a length of 0,\n// which means `idx_unchecked` can never be called.\n</span><span class=\"kw\">impl </span>Indexable <span class=\"kw\">for </span>! {\n    <span class=\"kw\">const </span>LEN: usize = <span class=\"number\">0</span>;\n\n    <span class=\"kw\">unsafe fn </span>idx_unchecked(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, idx: usize) -&gt; i32 {\n        <span class=\"comment\">// SAFETY: As per this trait's documentation, the caller ensures\n        // that `idx &lt; 0`, which is impossible, so this is dead code.\n        </span><span class=\"kw\">unsafe </span>{ std::hint::unreachable_unchecked() }\n    }\n}\n\n<span class=\"kw\">fn </span>use_indexable&lt;I: Indexable&gt;(x: I, idx: usize) -&gt; i32 {\n    <span class=\"kw\">if </span>idx &lt; I::LEN {\n        <span class=\"comment\">// SAFETY: We have checked that `idx &lt; I::LEN`.\n        </span><span class=\"kw\">unsafe </span>{ x.idx_unchecked(idx) }\n    } <span class=\"kw\">else </span>{\n        <span class=\"macro\">panic!</span>(<span class=\"string\">\"index out-of-bounds\"</span>)\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(never_type)%5D%0A%23!%5Bdeny(unsafe_op_in_unsafe_fn)%5D%0A%0Afn+main()+%7B%0A++++trait+Indexable+%7B%0A++++++++const+LEN:+usize;%0A++++%0A++++++++///+%23+Safety%0A++++++++///%0A++++++++///+The+caller+must+ensure+that+%60idx+%3C+LEN%60.%0A++++++++unsafe+fn+idx_unchecked(%26self,+idx:+usize)+-%3E+i32;%0A++++%7D%0A++++%0A++++//+The+implementation+for+%60i32%60+doesn't+need+to+do+any+contract+reasoning.%0A++++impl+Indexable+for+i32+%7B%0A++++++++const+LEN:+usize+=+1;%0A++++%0A++++++++unsafe+fn+idx_unchecked(%26self,+idx:+usize)+-%3E+i32+%7B%0A++++++++++++debug_assert_eq!(idx,+0);%0A++++++++++++*self%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+The+implementation+for+arrays+exploits+the+function+contract+to%0A++++//+make+use+of+%60get_unchecked%60+on+slices+and+avoid+a+run-time+check.%0A++++impl+Indexable+for+%5Bi32;+42%5D+%7B%0A++++++++const+LEN:+usize+=+42;%0A++++%0A++++++++unsafe+fn+idx_unchecked(%26self,+idx:+usize)+-%3E+i32+%7B%0A++++++++++++//+SAFETY:+As+per+this+trait's+documentation,+the+caller+ensures%0A++++++++++++//+that+%60idx+%3C+42%60.%0A++++++++++++unsafe+%7B+*self.get_unchecked(idx)+%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+The+implementation+for+the+never+type+declares+a+length+of+0,%0A++++//+which+means+%60idx_unchecked%60+can+never+be+called.%0A++++impl+Indexable+for+!+%7B%0A++++++++const+LEN:+usize+=+0;%0A++++%0A++++++++unsafe+fn+idx_unchecked(%26self,+idx:+usize)+-%3E+i32+%7B%0A++++++++++++//+SAFETY:+As+per+this+trait's+documentation,+the+caller+ensures%0A++++++++++++//+that+%60idx+%3C+0%60,+which+is+impossible,+so+this+is+dead+code.%0A++++++++++++unsafe+%7B+std::hint::unreachable_unchecked()+%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++fn+use_indexable%3CI:+Indexable%3E(x:+I,+idx:+usize)+-%3E+i32+%7B%0A++++++++if+idx+%3C+I::LEN+%7B%0A++++++++++++//+SAFETY:+We+have+checked+that+%60idx+%3C+I::LEN%60.%0A++++++++++++unsafe+%7B+x.idx_unchecked(idx)+%7D%0A++++++++%7D+else+%7B%0A++++++++++++panic!(%22index+out-of-bounds%22)%0A++++++++%7D%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>This time, <code>use_indexable</code> is safe because it uses a run-time check to discharge the safety\ncontract of <code>idx_unchecked</code>. Implementing <code>Indexable</code> is safe because when writing\n<code>idx_unchecked</code>, we don’t have to worry: our <em>callers</em> need to discharge a proof obligation\n(like <code>use_indexable</code> does), but the <em>implementation</em> of <code>get_unchecked</code> has no proof obligation\nto contend with. Of course, the implementation of <code>Indexable</code> may choose to call other unsafe\noperations, and then it needs an <code>unsafe</code> <em>block</em> to indicate it discharged the proof\nobligations of its callees. (We enabled <code>unsafe_op_in_unsafe_fn</code>, so the body of <code>idx_unchecked</code>\nis not implicitly an unsafe block.) For that purpose it can make use of the contract that all\nits callers must uphold – the fact that <code>idx &lt; LEN</code>.</p>\n<p>Formally speaking, an <code>unsafe fn</code> in a trait is a function with <em>preconditions</em> that go beyond\nthose encoded by the argument types (such as <code>idx &lt; LEN</code>), whereas an <code>unsafe trait</code> can declare\nthat some of its functions have <em>postconditions</em> that go beyond those encoded in the return type\n(such as returning an even integer). If a trait needs a function with both extra precondition\nand extra postcondition, then it needs an <code>unsafe fn</code> in an <code>unsafe trait</code>.</p>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:32.933Z"
}