{
	"title": "Destructors - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/destructors.html",
	"markdown": "# Destructors - The Rustonomicon\n\nWhat the language _does_ provide is full-blown automatic destructors through the `Drop` trait, which provides the following method:\n\n```rust\nfn drop(&mut self);\n```\n\nThis method gives the type time to somehow finish what it was doing.\n\n**After `drop` is run, Rust will recursively try to drop all of the fields of `self`.**\n\nThis is a convenience feature so that you don't have to write \"destructor boilerplate\" to drop children. If a struct has no special logic for being dropped other than dropping its children, then it means `Drop` doesn't need to be implemented at all!\n\n**There is no stable way to prevent this behavior in Rust 1.0.**\n\nNote that taking `&mut self` means that even if you could suppress recursive Drop, Rust will prevent you from e.g. moving fields out of self. For most types, this is totally fine.\n\nFor instance, a custom implementation of `Box` might write `Drop` like this:\n\n```rust\n#![feature(ptr_internals, allocator_api)]\n\nuse std::alloc::{Allocator, Global, GlobalAlloc, Layout};\nuse std::mem;\nuse std::ptr::{drop_in_place, NonNull, Unique};\n\nstruct Box<T>{ ptr: Unique<T> }\n\nimpl<T> Drop for Box<T> {\n    fn drop(&mut self) {\n        unsafe {\n            drop_in_place(self.ptr.as_ptr());\n            let c: NonNull<T> = self.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>())\n        }\n    }\n}\nfn main() {}\n```\n\nand this works fine because when Rust goes to drop the `ptr` field it just sees a [Unique](phantom-data.html) that has no actual `Drop` implementation. Similarly nothing can use-after-free the `ptr` because when drop exits, it becomes inaccessible.\n\nHowever this wouldn't work:\n\n```rust\n#![feature(allocator_api, ptr_internals)]\n\nuse std::alloc::{Allocator, Global, GlobalAlloc, Layout};\nuse std::ptr::{drop_in_place, Unique, NonNull};\nuse std::mem;\n\nstruct Box<T>{ ptr: Unique<T> }\n\nimpl<T> Drop for Box<T> {\n    fn drop(&mut self) {\n        unsafe {\n            drop_in_place(self.ptr.as_ptr());\n            let c: NonNull<T> = self.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>());\n        }\n    }\n}\n\nstruct SuperBox<T> { my_box: Box<T> }\n\nimpl<T> Drop for SuperBox<T> {\n    fn drop(&mut self) {\n        unsafe {\n            // Hyper-optimized: deallocate the box's contents for it\n            // without `drop`ing the contents\n            let c: NonNull<T> = self.my_box.ptr.into();\n            Global.deallocate(c.cast::<u8>(), Layout::new::<T>());\n        }\n    }\n}\nfn main() {}\n```\n\nAfter we deallocate the `box`'s ptr in SuperBox's destructor, Rust will happily proceed to tell the box to Drop itself and everything will blow up with use-after-frees and double-frees.\n\nNote that the recursive drop behavior applies to all structs and enums regardless of whether they implement Drop. Therefore something like\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Boxy<T> {\n    data1: Box<T>,\n    data2: Box<T>,\n    info: u32,\n}\n}\n```\n\nwill have its data1 and data2's fields destructors whenever it \"would\" be dropped, even though it itself doesn't implement Drop. We say that such a type _needs Drop_, even though it is not itself Drop.\n\nSimilarly,\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Link {\n    Next(Box<Link>),\n    None,\n}\n}\n```\n\nwill have its inner Box field dropped if and only if an instance stores the Next variant.\n\nIn general this works really nicely because you don't need to worry about adding/removing drops when you refactor your data layout. Still there's certainly many valid use cases for needing to do trickier things with destructors.\n\nThe classic safe solution to overriding recursive drop and allowing moving out of Self during `drop` is to use an Option:\n\n```rust\n#![feature(allocator_api, ptr_internals)]\n\nuse std::alloc::{Allocator, GlobalAlloc, Global, Layout};\nuse std::ptr::{drop_in_place, Unique, NonNull};\nuse std::mem;\n\nstruct Box<T>{ ptr: Unique<T> }\n\nimpl<T> Drop for Box<T> {\n    fn drop(&mut self) {\n        unsafe {\n            drop_in_place(self.ptr.as_ptr());\n            let c: NonNull<T> = self.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>());\n        }\n    }\n}\n\nstruct SuperBox<T> { my_box: Option<Box<T>> }\n\nimpl<T> Drop for SuperBox<T> {\n    fn drop(&mut self) {\n        unsafe {\n            // Hyper-optimized: deallocate the box's contents for it\n            // without `drop`ing the contents. Need to set the `box`\n            // field as `None` to prevent Rust from trying to Drop it.\n            let my_box = self.my_box.take().unwrap();\n            let c: NonNull<T> = my_box.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>());\n            mem::forget(my_box);\n        }\n    }\n}\nfn main() {}\n```\n\nHowever this has fairly odd semantics: you're saying that a field that _should_ always be Some _may_ be None, just because that happens in the destructor. Of course this conversely makes a lot of sense: you can call arbitrary methods on self during the destructor, and this should prevent you from ever doing so after deinitializing the field. Not that it will prevent you from producing any other arbitrarily invalid state in there.\n\nOn balance this is an ok choice. Certainly what you should reach for by default. However, in the future we expect there to be a first-class way to announce that a field shouldn't be automatically dropped.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Destructors - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"destructors\"><a class=\"header\" href=\"#destructors\">Destructors</a></h1>\n<p>What the language <em>does</em> provide is full-blown automatic destructors through the\n<code class=\"hljs\">Drop</code> trait, which provides the following method:</p>\n<!-- ignore: function header -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>);</code></pre>\n<p>This method gives the type time to somehow finish what it was doing.</p>\n<p><strong>After <code class=\"hljs\">drop</code> is run, Rust will recursively try to drop all of the fields\nof <code class=\"hljs\">self</code>.</strong></p>\n<p>This is a convenience feature so that you don't have to write \"destructor\nboilerplate\" to drop children. If a struct has no special logic for being\ndropped other than dropping its children, then it means <code class=\"hljs\">Drop</code> doesn't need to\nbe implemented at all!</p>\n<p><strong>There is no stable way to prevent this behavior in Rust 1.0.</strong></p>\n<p>Note that taking <code class=\"hljs\">&amp;mut self</code> means that even if you could suppress recursive\nDrop, Rust will prevent you from e.g. moving fields out of self. For most types,\nthis is totally fine.</p>\n<p>For instance, a custom implementation of <code class=\"hljs\">Box</code> might write <code class=\"hljs\">Drop</code> like this:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"hljs-meta\">#![feature(ptr_internals, allocator_api)]</span>\n\n<span class=\"hljs-keyword\">use</span> std::alloc::{Allocator, Global, GlobalAlloc, Layout};\n<span class=\"hljs-keyword\">use</span> std::mem;\n<span class=\"hljs-keyword\">use</span> std::ptr::{drop_in_place, NonNull, Unique};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Box</span></span>&lt;T&gt;{ ptr: Unique&lt;T&gt; }\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">Box</span>&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            drop_in_place(<span class=\"hljs-keyword\">self</span>.ptr.as_ptr());\n            <span class=\"hljs-keyword\">let</span> c: NonNull&lt;T&gt; = <span class=\"hljs-keyword\">self</span>.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;())\n        }\n    }\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p>and this works fine because when Rust goes to drop the <code class=\"hljs\">ptr</code> field it just sees\na <a href=\"phantom-data.html\">Unique</a> that has no actual <code class=\"hljs\">Drop</code> implementation. Similarly nothing can\nuse-after-free the <code class=\"hljs\">ptr</code> because when drop exits, it becomes inaccessible.</p>\n<p>However this wouldn't work:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"hljs-meta\">#![feature(allocator_api, ptr_internals)]</span>\n\n<span class=\"hljs-keyword\">use</span> std::alloc::{Allocator, Global, GlobalAlloc, Layout};\n<span class=\"hljs-keyword\">use</span> std::ptr::{drop_in_place, Unique, NonNull};\n<span class=\"hljs-keyword\">use</span> std::mem;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Box</span></span>&lt;T&gt;{ ptr: Unique&lt;T&gt; }\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">Box</span>&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            drop_in_place(<span class=\"hljs-keyword\">self</span>.ptr.as_ptr());\n            <span class=\"hljs-keyword\">let</span> c: NonNull&lt;T&gt; = <span class=\"hljs-keyword\">self</span>.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;());\n        }\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SuperBox</span></span>&lt;T&gt; { my_box: <span class=\"hljs-built_in\">Box</span>&lt;T&gt; }\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> SuperBox&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-comment\">// Hyper-optimized: deallocate the box's contents for it</span>\n            <span class=\"hljs-comment\">// without `drop`ing the contents</span>\n            <span class=\"hljs-keyword\">let</span> c: NonNull&lt;T&gt; = <span class=\"hljs-keyword\">self</span>.my_box.ptr.into();\n            Global.deallocate(c.cast::&lt;<span class=\"hljs-built_in\">u8</span>&gt;(), Layout::new::&lt;T&gt;());\n        }\n    }\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p>After we deallocate the <code class=\"hljs\">box</code>'s ptr in SuperBox's destructor, Rust will\nhappily proceed to tell the box to Drop itself and everything will blow up with\nuse-after-frees and double-frees.</p>\n<p>Note that the recursive drop behavior applies to all structs and enums\nregardless of whether they implement Drop. Therefore something like</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Boxy</span></span>&lt;T&gt; {\n    data1: <span class=\"hljs-built_in\">Box</span>&lt;T&gt;,\n    data2: <span class=\"hljs-built_in\">Box</span>&lt;T&gt;,\n    info: <span class=\"hljs-built_in\">u32</span>,\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>will have its data1 and data2's fields destructors whenever it \"would\" be\ndropped, even though it itself doesn't implement Drop. We say that such a type\n<em>needs Drop</em>, even though it is not itself Drop.</p>\n<p>Similarly,</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Link</span></span> {\n    Next(<span class=\"hljs-built_in\">Box</span>&lt;Link&gt;),\n    <span class=\"hljs-literal\">None</span>,\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>will have its inner Box field dropped if and only if an instance stores the\nNext variant.</p>\n<p>In general this works really nicely because you don't need to worry about\nadding/removing drops when you refactor your data layout. Still there's\ncertainly many valid use cases for needing to do trickier things with\ndestructors.</p>\n<p>The classic safe solution to overriding recursive drop and allowing moving out\nof Self during <code class=\"hljs\">drop</code> is to use an Option:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"hljs-meta\">#![feature(allocator_api, ptr_internals)]</span>\n\n<span class=\"hljs-keyword\">use</span> std::alloc::{Allocator, GlobalAlloc, Global, Layout};\n<span class=\"hljs-keyword\">use</span> std::ptr::{drop_in_place, Unique, NonNull};\n<span class=\"hljs-keyword\">use</span> std::mem;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Box</span></span>&lt;T&gt;{ ptr: Unique&lt;T&gt; }\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">Box</span>&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            drop_in_place(<span class=\"hljs-keyword\">self</span>.ptr.as_ptr());\n            <span class=\"hljs-keyword\">let</span> c: NonNull&lt;T&gt; = <span class=\"hljs-keyword\">self</span>.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;());\n        }\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SuperBox</span></span>&lt;T&gt; { my_box: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">Box</span>&lt;T&gt;&gt; }\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> SuperBox&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-comment\">// Hyper-optimized: deallocate the box's contents for it</span>\n            <span class=\"hljs-comment\">// without `drop`ing the contents. Need to set the `box`</span>\n            <span class=\"hljs-comment\">// field as `None` to prevent Rust from trying to Drop it.</span>\n            <span class=\"hljs-keyword\">let</span> my_box = <span class=\"hljs-keyword\">self</span>.my_box.take().unwrap();\n            <span class=\"hljs-keyword\">let</span> c: NonNull&lt;T&gt; = my_box.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;());\n            mem::forget(my_box);\n        }\n    }\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p>However this has fairly odd semantics: you're saying that a field that <em>should</em>\nalways be Some <em>may</em> be None, just because that happens in the destructor. Of\ncourse this conversely makes a lot of sense: you can call arbitrary methods on\nself during the destructor, and this should prevent you from ever doing so after\ndeinitializing the field. Not that it will prevent you from producing any other\narbitrarily invalid state in there.</p>\n<p>On balance this is an ok choice. Certainly what you should reach for by default.\nHowever, in the future we expect there to be a first-class way to announce that\na field shouldn't be automatically dropped.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"constructors.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"leaking.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"constructors.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"leaking.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:08.906Z"
}