{
	"title": "std::sync::atomic - Rust",
	"url": "https://doc.rust-lang.org/stable/std/sync/atomic/index.html",
	"markdown": "# std::sync::atomic - Rust\n\n## Module [std](../../index.html)::[sync](../index.html)::[atomic](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/sync/mod.rs.html#5) ·\n\nExpand description\n\nAtomic types\n\nAtomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.\n\nThis module defines atomic versions of a select number of primitive types, including [`AtomicBool`](struct.AtomicBool.html \"struct std::sync::atomic::AtomicBool\"), [`AtomicIsize`](struct.AtomicIsize.html \"struct std::sync::atomic::AtomicIsize\"), [`AtomicUsize`](struct.AtomicUsize.html \"struct std::sync::atomic::AtomicUsize\"), [`AtomicI8`](struct.AtomicI8.html \"struct std::sync::atomic::AtomicI8\"), [`AtomicU16`](struct.AtomicU16.html \"struct std::sync::atomic::AtomicU16\"), etc. Atomic types present operations that, when used correctly, synchronize updates between threads.\n\nAtomic variables are safe to share between threads (they implement [`Sync`](../../marker/trait.Sync.html \"trait std::marker::Sync\")) but they do not themselves provide the mechanism for sharing and follow the [threading model](about:blank/std/thread/index.html#the-threading-model) of Rust. The most common way to share an atomic variable is to put it into an [`Arc`](../../../std/sync/struct.Arc.html) (an atomically-reference-counted shared pointer).\n\nAtomic types may be stored in static variables, initialized using the constant initializers like [`AtomicBool::new`](about:blank/struct.AtomicBool.html#method.new \"associated function std::sync::atomic::AtomicBool::new\"). Atomic statics are often used for lazy global initialization.\n\n### [§](#memory-model-for-atomic-accesses)Memory model for atomic accesses\n\nRust atomics currently follow the same rules as [C++20 atomics](https://en.cppreference.com/w/cpp/atomic), specifically `atomic_ref`. Basically, creating a _shared reference_ to one of the Rust atomic types corresponds to creating an `atomic_ref` in C++; the `atomic_ref` is destroyed when the lifetime of the shared reference ends. A Rust atomic type that is exclusively owned or behind a mutable reference does _not_ correspond to an “atomic object” in C++, since the underlying primitive can be mutably accessed, for example with `get_mut`, to perform non-atomic operations.\n\nEach method takes an [`Ordering`](enum.Ordering.html \"enum std::sync::atomic::Ordering\") which represents the strength of the memory barrier for that operation. These orderings are the same as the [C++20 atomic orderings](https://en.cppreference.com/w/cpp/atomic/memory_order). For more information see the [nomicon](../../../nomicon/atomics.html).\n\nSince C++ does not support mixing atomic and non-atomic accesses, or non-synchronized different-sized accesses to the same data, Rust does not support those operations either. Note that both of those restrictions only apply if the accesses are non-synchronized.\n\n```\nuse std::sync::atomic::{AtomicU16, AtomicU8, Ordering};\nuse std::mem::transmute;\nuse std::thread;\n\nlet atomic = AtomicU16::new(0);\n\nthread::scope(|s| {\n    // This is UB: mixing atomic and non-atomic accesses\n    s.spawn(|| atomic.store(1, Ordering::Relaxed));\n    s.spawn(|| unsafe { atomic.as_ptr().write(2) });\n});\n\nthread::scope(|s| {\n    // This is UB: even reads are not allowed to be mixed\n    s.spawn(|| atomic.load(Ordering::Relaxed));\n    s.spawn(|| unsafe { atomic.as_ptr().read() });\n});\n\nthread::scope(|s| {\n    // This is fine, `join` synchronizes the code in a way such that atomic\n    // and non-atomic accesses can't happen \"at the same time\"\n    let handle = s.spawn(|| atomic.store(1, Ordering::Relaxed));\n    handle.join().unwrap();\n    s.spawn(|| unsafe { atomic.as_ptr().write(2) });\n});\n\nthread::scope(|s| {\n    // This is UB: using different-sized atomic accesses to the same data\n    s.spawn(|| atomic.store(1, Ordering::Relaxed));\n    s.spawn(|| unsafe {\n        let differently_sized = transmute::<&AtomicU16, &AtomicU8>(&atomic);\n        differently_sized.store(2, Ordering::Relaxed);\n    });\n});\n\nthread::scope(|s| {\n    // This is fine, `join` synchronizes the code in a way such that\n    // differently-sized accesses can't happen \"at the same time\"\n    let handle = s.spawn(|| atomic.store(1, Ordering::Relaxed));\n    handle.join().unwrap();\n    s.spawn(|| unsafe {\n        let differently_sized = transmute::<&AtomicU16, &AtomicU8>(&atomic);\n        differently_sized.store(2, Ordering::Relaxed);\n    });\n});\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::atomic::%7BAtomicU16,+AtomicU8,+Ordering%7D;%0A++++use+std::mem::transmute;%0A++++use+std::thread;%0A++++%0A++++let+atomic+=+AtomicU16::new(0);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+UB:+mixing+atomic+and+non-atomic+accesses%0A++++++++s.spawn(%7C%7C+atomic.store(1,+Ordering::Relaxed));%0A++++++++s.spawn(%7C%7C+unsafe+%7B+atomic.as_ptr().write(2)+%7D);%0A++++%7D);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+UB:+even+reads+are+not+allowed+to+be+mixed%0A++++++++s.spawn(%7C%7C+atomic.load(Ordering::Relaxed));%0A++++++++s.spawn(%7C%7C+unsafe+%7B+atomic.as_ptr().read()+%7D);%0A++++%7D);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+fine,+%60join%60+synchronizes+the+code+in+a+way+such+that+atomic%0A++++++++//+and+non-atomic+accesses+can%27t+happen+%22at+the+same+time%22%0A++++++++let+handle+=+s.spawn(%7C%7C+atomic.store(1,+Ordering::Relaxed));%0A++++++++handle.join().unwrap();%0A++++++++s.spawn(%7C%7C+unsafe+%7B+atomic.as_ptr().write(2)+%7D);%0A++++%7D);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+UB:+using+different-sized+atomic+accesses+to+the+same+data%0A++++++++s.spawn(%7C%7C+atomic.store(1,+Ordering::Relaxed));%0A++++++++s.spawn(%7C%7C+unsafe+%7B%0A++++++++++++let+differently_sized+=+transmute::%3C%26AtomicU16,+%26AtomicU8%3E(%26atomic);%0A++++++++++++differently_sized.store(2,+Ordering::Relaxed);%0A++++++++%7D);%0A++++%7D);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+fine,+%60join%60+synchronizes+the+code+in+a+way+such+that%0A++++++++//+differently-sized+accesses+can%27t+happen+%22at+the+same+time%22%0A++++++++let+handle+=+s.spawn(%7C%7C+atomic.store(1,+Ordering::Relaxed));%0A++++++++handle.join().unwrap();%0A++++++++s.spawn(%7C%7C+unsafe+%7B%0A++++++++++++let+differently_sized+=+transmute::%3C%26AtomicU16,+%26AtomicU8%3E(%26atomic);%0A++++++++++++differently_sized.store(2,+Ordering::Relaxed);%0A++++++++%7D);%0A++++%7D);%0A%7D&edition=2021)\n\n## [§](#portability)Portability\n\nAll atomic types in this module are guaranteed to be [lock-free](https://en.wikipedia.org/wiki/Non-blocking_algorithm) if they’re available. This means they don’t internally acquire a global mutex. Atomic types and operations are not guaranteed to be wait-free. This means that operations like `fetch_or` may be implemented with a compare-and-swap loop.\n\nAtomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement `AtomicI8`. Note that this emulation should not have an impact on correctness of code, it’s just something to be aware of.\n\nThe atomic types in this module might not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:\n\n-   PowerPC and MIPS platforms with 32-bit pointers do not have `AtomicU64` or `AtomicI64` types.\n-   ARM platforms like `armv5te` that aren’t for Linux only provide `load` and `store` operations, and do not support Compare and Swap (CAS) operations, such as `swap`, `fetch_add`, etc. Additionally on Linux, these CAS operations are implemented via [operating system support](https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt), which may come with a performance penalty.\n-   ARM targets with `thumbv6m` only provide `load` and `store` operations, and do not support Compare and Swap (CAS) operations, such as `swap`, `fetch_add`, etc.\n\nNote that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. `AtomicUsize` and `AtomicIsize` are generally the most portable, but even then they’re not available everywhere. For reference, the `std` library requires `AtomicBool`s and pointer-sized atomics, although `core` does not.\n\nThe `#[cfg(target_has_atomic)]` attribute can be used to conditionally compile based on the target’s supported bit widths. It is a key-value option set for each supported size, with values “8”, “16”, “32”, “64”, “128”, and “ptr” for pointer-sized atomics.\n\n## [§](#atomic-accesses-to-read-only-memory)Atomic accesses to read-only memory\n\nIn general, _all_ atomic accesses on read-only memory are Undefined Behavior. For instance, attempting to do a `compare_exchange` that will definitely fail (making it conceptually a read-only operation) can still cause a segmentation fault if the underlying memory page is mapped read-only. Since atomic `load`s might be implemented using compare-exchange operations, even a `load` can fault on read-only memory.\n\nFor the purpose of this section, “read-only memory” is defined as memory that is read-only in the underlying target, i.e., the pages are mapped with a read-only flag and any attempt to write will cause a page fault. In particular, an `&u128` reference that points to memory that is read-write mapped is _not_ considered to point to “read-only memory”. In Rust, almost all memory is read-write; the only exceptions are memory created by `const` items or `static` items without interior mutability, and memory that was specifically marked as read-only by the operating system via platform-specific APIs.\n\nAs an exception from the general rule stated above, “sufficiently small” atomic loads with `Ordering::Relaxed` are implemented in a way that works on read-only memory, and are hence not Undefined Behavior. The exact size limit for what makes a load “sufficiently small” varies depending on the target:\n\n| `target_arch` | Size limit |\n| --- | --- |\n| `x86`, `arm`, `mips`, `mips32r6`, `powerpc`, `riscv32`, `sparc`, `hexagon` | 4 bytes |\n| `x86_64`, `aarch64`, `loongarch64`, `mips64`, `mips64r6`, `powerpc64`, `riscv64`, `sparc64`, `s390x` | 8 bytes |\n\nAtomics loads that are larger than this limit as well as atomic loads with ordering other than `Relaxed`, as well as _all_ atomic loads on targets not listed in the table, might still be read-only under certain conditions, but that is not a stable guarantee and should not be relied upon.\n\nIf you need to do an acquire load on read-only memory, you can do a relaxed load followed by an acquire fence instead.\n\n## [§](#examples)Examples\n\nA simple spinlock:\n\n```\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::{hint, thread};\n\nfn main() {\n    let spinlock = Arc::new(AtomicUsize::new(1));\n\n    let spinlock_clone = Arc::clone(&spinlock);\n\n    let thread = thread::spawn(move|| {\n        spinlock_clone.store(0, Ordering::Release);\n    });\n\n    // Wait for the other thread to release the lock\n    while spinlock.load(Ordering::Acquire) != 0 {\n        hint::spin_loop();\n    }\n\n    if let Err(panic) = thread.join() {\n        println!(\"Thread had an error: {panic:?}\");\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::sync::Arc;%0Ause+std::sync::atomic::%7BAtomicUsize,+Ordering%7D;%0Ause+std::%7Bhint,+thread%7D;%0A%0Afn+main()+%7B%0A++++let+spinlock+=+Arc::new(AtomicUsize::new(1));%0A%0A++++let+spinlock_clone+=+Arc::clone(%26spinlock);%0A%0A++++let+thread+=+thread::spawn(move%7C%7C+%7B%0A++++++++spinlock_clone.store(0,+Ordering::Release);%0A++++%7D);%0A%0A++++//+Wait+for+the+other+thread+to+release+the+lock%0A++++while+spinlock.load(Ordering::Acquire)+!=+0+%7B%0A++++++++hint::spin_loop();%0A++++%7D%0A%0A++++if+let+Err(panic)+=+thread.join()+%7B%0A++++++++println!(%22Thread+had+an+error:+%7Bpanic:?%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\nKeep a global count of live threads:\n\n```\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nstatic GLOBAL_THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n// Note that Relaxed ordering doesn't synchronize anything\n// except the global thread counter itself.\nlet old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(1, Ordering::Relaxed);\n// Note that this number may not be true at the moment of printing\n// because some other thread may have changed static value already.\nprintln!(\"live threads: {}\", old_thread_count + 1);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::atomic::%7BAtomicUsize,+Ordering%7D;%0A++++%0A++++static+GLOBAL_THREAD_COUNT:+AtomicUsize+=+AtomicUsize::new(0);%0A++++%0A++++//+Note+that+Relaxed+ordering+doesn%27t+synchronize+anything%0A++++//+except+the+global+thread+counter+itself.%0A++++let+old_thread_count+=+GLOBAL_THREAD_COUNT.fetch_add(1,+Ordering::Relaxed);%0A++++//+Note+that+this+number+may+not+be+true+at+the+moment+of+printing%0A++++//+because+some+other+thread+may+have+changed+static+value+already.%0A++++println!(%22live+threads:+%7B%7D%22,+old_thread_count+%2B+1);%0A%7D&edition=2021)\n\n-   A boolean type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n-   A raw pointer type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n-   An integer type which can be safely shared between threads.\n    \n\n-   Atomic memory orderings\n    \n\n-   A compiler memory fence.\n    \n-   An atomic fence.\n    \n-   Signals the processor that it is inside a busy-wait spin-loop (“spin lock”).",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Atomic types\"><title>std::sync::atomic - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../../\" data-static-root-path=\"../../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module atomic</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module atomic</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li><li><a href=\"#enums\">Enums</a></li><li><a href=\"#constants\">Constants</a></li><li><a href=\"#functions\">Functions</a></li></ul></section><h2><a href=\"../index.html\">In std::sync</a></h2><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../atomic/index.html\">atomic</a></li><li><a href=\"../mpsc/index.html\">mpsc</a></li></ul><h3><a href=\"../index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"../struct.Arc.html\">Arc</a></li><li><a href=\"../struct.Barrier.html\">Barrier</a></li><li><a href=\"../struct.BarrierWaitResult.html\">BarrierWaitResult</a></li><li><a href=\"../struct.Condvar.html\">Condvar</a></li><li><a href=\"../struct.Exclusive.html\">Exclusive</a></li><li><a href=\"../struct.LazyLock.html\">LazyLock</a></li><li><a href=\"../struct.MappedMutexGuard.html\">MappedMutexGuard</a></li><li><a href=\"../struct.MappedRwLockReadGuard.html\">MappedRwLockReadGuard</a></li><li><a href=\"../struct.MappedRwLockWriteGuard.html\">MappedRwLockWriteGuard</a></li><li><a href=\"../struct.Mutex.html\">Mutex</a></li><li><a href=\"../struct.MutexGuard.html\">MutexGuard</a></li><li><a href=\"../struct.Once.html\">Once</a></li><li><a href=\"../struct.OnceLock.html\">OnceLock</a></li><li><a href=\"../struct.OnceState.html\">OnceState</a></li><li><a href=\"../struct.PoisonError.html\">PoisonError</a></li><li><a href=\"../struct.ReentrantLock.html\">ReentrantLock</a></li><li><a href=\"../struct.ReentrantLockGuard.html\">ReentrantLockGuard</a></li><li><a href=\"../struct.RwLock.html\">RwLock</a></li><li><a href=\"../struct.RwLockReadGuard.html\">RwLockReadGuard</a></li><li><a href=\"../struct.RwLockWriteGuard.html\">RwLockWriteGuard</a></li><li><a href=\"../struct.WaitTimeoutResult.html\">WaitTimeoutResult</a></li><li><a href=\"../struct.Weak.html\">Weak</a></li></ul><h3><a href=\"../index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"../enum.TryLockError.html\">TryLockError</a></li></ul><h3><a href=\"../index.html#constants\">Constants</a></h3><ul class=\"block constant\"><li><a href=\"../constant.ONCE_INIT.html\">ONCE_INIT</a></li></ul><h3><a href=\"../index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"../type.LockResult.html\">LockResult</a></li><li><a href=\"../type.TryLockResult.html\">TryLockResult</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../../index.html\">std</a>::<wbr><a href=\"../index.html\">sync</a>::<wbr><a class=\"mod\" href=\"#\">atomic</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/sync/mod.rs.html#5\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Atomic types</p>\n<p>Atomic types provide primitive shared-memory communication between\nthreads, and are the building blocks of other concurrent\ntypes.</p>\n<p>This module defines atomic versions of a select number of primitive\ntypes, including <a href=\"struct.AtomicBool.html\" title=\"struct std::sync::atomic::AtomicBool\"><code>AtomicBool</code></a>, <a href=\"struct.AtomicIsize.html\" title=\"struct std::sync::atomic::AtomicIsize\"><code>AtomicIsize</code></a>, <a href=\"struct.AtomicUsize.html\" title=\"struct std::sync::atomic::AtomicUsize\"><code>AtomicUsize</code></a>,\n<a href=\"struct.AtomicI8.html\" title=\"struct std::sync::atomic::AtomicI8\"><code>AtomicI8</code></a>, <a href=\"struct.AtomicU16.html\" title=\"struct std::sync::atomic::AtomicU16\"><code>AtomicU16</code></a>, etc.\nAtomic types present operations that, when used correctly, synchronize\nupdates between threads.</p>\n<p>Atomic variables are safe to share between threads (they implement <a href=\"../../marker/trait.Sync.html\" title=\"trait std::marker::Sync\"><code>Sync</code></a>)\nbut they do not themselves provide the mechanism for sharing and follow the\n<a href=\"../../../std/thread/index.html#the-threading-model\">threading model</a> of Rust.\nThe most common way to share an atomic variable is to put it into an <a href=\"../../../std/sync/struct.Arc.html\"><code>Arc</code></a> (an\natomically-reference-counted shared pointer).</p>\n<p>Atomic types may be stored in static variables, initialized using\nthe constant initializers like <a href=\"struct.AtomicBool.html#method.new\" title=\"associated function std::sync::atomic::AtomicBool::new\"><code>AtomicBool::new</code></a>. Atomic statics\nare often used for lazy global initialization.</p>\n<h3 id=\"memory-model-for-atomic-accesses\"><a class=\"doc-anchor\" href=\"#memory-model-for-atomic-accesses\">§</a>Memory model for atomic accesses</h3>\n<p>Rust atomics currently follow the same rules as <a href=\"https://en.cppreference.com/w/cpp/atomic\">C++20 atomics</a>, specifically <code>atomic_ref</code>.\nBasically, creating a <em>shared reference</em> to one of the Rust atomic types corresponds to creating\nan <code>atomic_ref</code> in C++; the <code>atomic_ref</code> is destroyed when the lifetime of the shared reference\nends. A Rust atomic type that is exclusively owned or behind a mutable reference does <em>not</em>\ncorrespond to an “atomic object” in C++, since the underlying primitive can be mutably accessed,\nfor example with <code>get_mut</code>, to perform non-atomic operations.</p>\n<p>Each method takes an <a href=\"enum.Ordering.html\" title=\"enum std::sync::atomic::Ordering\"><code>Ordering</code></a> which represents the strength of\nthe memory barrier for that operation. These orderings are the\nsame as the <a href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\">C++20 atomic orderings</a>. For more information see the <a href=\"../../../nomicon/atomics.html\">nomicon</a>.</p>\n<p>Since C++ does not support mixing atomic and non-atomic accesses, or non-synchronized\ndifferent-sized accesses to the same data, Rust does not support those operations either.\nNote that both of those restrictions only apply if the accesses are non-synchronized.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::atomic::{AtomicU16, AtomicU8, Ordering};\n<span class=\"kw\">use </span>std::mem::transmute;\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>atomic = AtomicU16::new(<span class=\"number\">0</span>);\n\nthread::scope(|s| {\n    <span class=\"comment\">// This is UB: mixing atomic and non-atomic accesses\n    </span>s.spawn(|| atomic.store(<span class=\"number\">1</span>, Ordering::Relaxed));\n    s.spawn(|| <span class=\"kw\">unsafe </span>{ atomic.as_ptr().write(<span class=\"number\">2</span>) });\n});\n\nthread::scope(|s| {\n    <span class=\"comment\">// This is UB: even reads are not allowed to be mixed\n    </span>s.spawn(|| atomic.load(Ordering::Relaxed));\n    s.spawn(|| <span class=\"kw\">unsafe </span>{ atomic.as_ptr().read() });\n});\n\nthread::scope(|s| {\n    <span class=\"comment\">// This is fine, `join` synchronizes the code in a way such that atomic\n    // and non-atomic accesses can't happen \"at the same time\"\n    </span><span class=\"kw\">let </span>handle = s.spawn(|| atomic.store(<span class=\"number\">1</span>, Ordering::Relaxed));\n    handle.join().unwrap();\n    s.spawn(|| <span class=\"kw\">unsafe </span>{ atomic.as_ptr().write(<span class=\"number\">2</span>) });\n});\n\nthread::scope(|s| {\n    <span class=\"comment\">// This is UB: using different-sized atomic accesses to the same data\n    </span>s.spawn(|| atomic.store(<span class=\"number\">1</span>, Ordering::Relaxed));\n    s.spawn(|| <span class=\"kw\">unsafe </span>{\n        <span class=\"kw\">let </span>differently_sized = transmute::&lt;<span class=\"kw-2\">&amp;</span>AtomicU16, <span class=\"kw-2\">&amp;</span>AtomicU8&gt;(<span class=\"kw-2\">&amp;</span>atomic);\n        differently_sized.store(<span class=\"number\">2</span>, Ordering::Relaxed);\n    });\n});\n\nthread::scope(|s| {\n    <span class=\"comment\">// This is fine, `join` synchronizes the code in a way such that\n    // differently-sized accesses can't happen \"at the same time\"\n    </span><span class=\"kw\">let </span>handle = s.spawn(|| atomic.store(<span class=\"number\">1</span>, Ordering::Relaxed));\n    handle.join().unwrap();\n    s.spawn(|| <span class=\"kw\">unsafe </span>{\n        <span class=\"kw\">let </span>differently_sized = transmute::&lt;<span class=\"kw-2\">&amp;</span>AtomicU16, <span class=\"kw-2\">&amp;</span>AtomicU8&gt;(<span class=\"kw-2\">&amp;</span>atomic);\n        differently_sized.store(<span class=\"number\">2</span>, Ordering::Relaxed);\n    });\n});</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::atomic::%7BAtomicU16,+AtomicU8,+Ordering%7D;%0A++++use+std::mem::transmute;%0A++++use+std::thread;%0A++++%0A++++let+atomic+=+AtomicU16::new(0);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+UB:+mixing+atomic+and+non-atomic+accesses%0A++++++++s.spawn(%7C%7C+atomic.store(1,+Ordering::Relaxed));%0A++++++++s.spawn(%7C%7C+unsafe+%7B+atomic.as_ptr().write(2)+%7D);%0A++++%7D);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+UB:+even+reads+are+not+allowed+to+be+mixed%0A++++++++s.spawn(%7C%7C+atomic.load(Ordering::Relaxed));%0A++++++++s.spawn(%7C%7C+unsafe+%7B+atomic.as_ptr().read()+%7D);%0A++++%7D);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+fine,+%60join%60+synchronizes+the+code+in+a+way+such+that+atomic%0A++++++++//+and+non-atomic+accesses+can't+happen+%22at+the+same+time%22%0A++++++++let+handle+=+s.spawn(%7C%7C+atomic.store(1,+Ordering::Relaxed));%0A++++++++handle.join().unwrap();%0A++++++++s.spawn(%7C%7C+unsafe+%7B+atomic.as_ptr().write(2)+%7D);%0A++++%7D);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+UB:+using+different-sized+atomic+accesses+to+the+same+data%0A++++++++s.spawn(%7C%7C+atomic.store(1,+Ordering::Relaxed));%0A++++++++s.spawn(%7C%7C+unsafe+%7B%0A++++++++++++let+differently_sized+=+transmute::%3C%26AtomicU16,+%26AtomicU8%3E(%26atomic);%0A++++++++++++differently_sized.store(2,+Ordering::Relaxed);%0A++++++++%7D);%0A++++%7D);%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++//+This+is+fine,+%60join%60+synchronizes+the+code+in+a+way+such+that%0A++++++++//+differently-sized+accesses+can't+happen+%22at+the+same+time%22%0A++++++++let+handle+=+s.spawn(%7C%7C+atomic.store(1,+Ordering::Relaxed));%0A++++++++handle.join().unwrap();%0A++++++++s.spawn(%7C%7C+unsafe+%7B%0A++++++++++++let+differently_sized+=+transmute::%3C%26AtomicU16,+%26AtomicU8%3E(%26atomic);%0A++++++++++++differently_sized.store(2,+Ordering::Relaxed);%0A++++++++%7D);%0A++++%7D);%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"portability\"><a class=\"doc-anchor\" href=\"#portability\">§</a>Portability</h2>\n<p>All atomic types in this module are guaranteed to be <a href=\"https://en.wikipedia.org/wiki/Non-blocking_algorithm\">lock-free</a> if they’re\navailable. This means they don’t internally acquire a global mutex. Atomic\ntypes and operations are not guaranteed to be wait-free. This means that\noperations like <code>fetch_or</code> may be implemented with a compare-and-swap loop.</p>\n<p>Atomic operations may be implemented at the instruction layer with\nlarger-size atomics. For example some platforms use 4-byte atomic\ninstructions to implement <code>AtomicI8</code>. Note that this emulation should not\nhave an impact on correctness of code, it’s just something to be aware of.</p>\n<p>The atomic types in this module might not be available on all platforms. The\natomic types here are all widely available, however, and can generally be\nrelied upon existing. Some notable exceptions are:</p>\n<ul>\n<li>PowerPC and MIPS platforms with 32-bit pointers do not have <code>AtomicU64</code> or\n<code>AtomicI64</code> types.</li>\n<li>ARM platforms like <code>armv5te</code> that aren’t for Linux only provide <code>load</code>\nand <code>store</code> operations, and do not support Compare and Swap (CAS)\noperations, such as <code>swap</code>, <code>fetch_add</code>, etc. Additionally on Linux,\nthese CAS operations are implemented via <a href=\"https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt\">operating system support</a>, which\nmay come with a performance penalty.</li>\n<li>ARM targets with <code>thumbv6m</code> only provide <code>load</code> and <code>store</code> operations,\nand do not support Compare and Swap (CAS) operations, such as <code>swap</code>,\n<code>fetch_add</code>, etc.</li>\n</ul>\n<p>Note that future platforms may be added that also do not have support for\nsome atomic operations. Maximally portable code will want to be careful\nabout which atomic types are used. <code>AtomicUsize</code> and <code>AtomicIsize</code> are\ngenerally the most portable, but even then they’re not available everywhere.\nFor reference, the <code>std</code> library requires <code>AtomicBool</code>s and pointer-sized atomics, although\n<code>core</code> does not.</p>\n<p>The <code>#[cfg(target_has_atomic)]</code> attribute can be used to conditionally\ncompile based on the target’s supported bit widths. It is a key-value\noption set for each supported size, with values “8”, “16”, “32”, “64”,\n“128”, and “ptr” for pointer-sized atomics.</p>\n<h2 id=\"atomic-accesses-to-read-only-memory\"><a class=\"doc-anchor\" href=\"#atomic-accesses-to-read-only-memory\">§</a>Atomic accesses to read-only memory</h2>\n<p>In general, <em>all</em> atomic accesses on read-only memory are Undefined Behavior. For instance, attempting\nto do a <code>compare_exchange</code> that will definitely fail (making it conceptually a read-only\noperation) can still cause a segmentation fault if the underlying memory page is mapped read-only. Since\natomic <code>load</code>s might be implemented using compare-exchange operations, even a <code>load</code> can fault\non read-only memory.</p>\n<p>For the purpose of this section, “read-only memory” is defined as memory that is read-only in\nthe underlying target, i.e., the pages are mapped with a read-only flag and any attempt to write\nwill cause a page fault. In particular, an <code>&amp;u128</code> reference that points to memory that is\nread-write mapped is <em>not</em> considered to point to “read-only memory”. In Rust, almost all memory\nis read-write; the only exceptions are memory created by <code>const</code> items or <code>static</code> items without\ninterior mutability, and memory that was specifically marked as read-only by the operating\nsystem via platform-specific APIs.</p>\n<p>As an exception from the general rule stated above, “sufficiently small” atomic loads with\n<code>Ordering::Relaxed</code> are implemented in a way that works on read-only memory, and are hence not\nUndefined Behavior. The exact size limit for what makes a load “sufficiently small” varies\ndepending on the target:</p>\n<div><table><thead><tr><th><code>target_arch</code></th><th>Size limit</th></tr></thead><tbody>\n<tr><td><code>x86</code>, <code>arm</code>, <code>mips</code>, <code>mips32r6</code>, <code>powerpc</code>, <code>riscv32</code>, <code>sparc</code>, <code>hexagon</code></td><td>4 bytes</td></tr>\n<tr><td><code>x86_64</code>, <code>aarch64</code>, <code>loongarch64</code>, <code>mips64</code>, <code>mips64r6</code>, <code>powerpc64</code>, <code>riscv64</code>, <code>sparc64</code>, <code>s390x</code></td><td>8 bytes</td></tr>\n</tbody></table>\n</div>\n<p>Atomics loads that are larger than this limit as well as atomic loads with ordering other\nthan <code>Relaxed</code>, as well as <em>all</em> atomic loads on targets not listed in the table, might still be\nread-only under certain conditions, but that is not a stable guarantee and should not be relied\nupon.</p>\n<p>If you need to do an acquire load on read-only memory, you can do a relaxed load followed by an\nacquire fence instead.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>A simple spinlock:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::sync::atomic::{AtomicUsize, Ordering};\n<span class=\"kw\">use </span>std::{hint, thread};\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span>spinlock = Arc::new(AtomicUsize::new(<span class=\"number\">1</span>));\n\n    <span class=\"kw\">let </span>spinlock_clone = Arc::clone(<span class=\"kw-2\">&amp;</span>spinlock);\n\n    <span class=\"kw\">let </span>thread = thread::spawn(<span class=\"kw\">move</span>|| {\n        spinlock_clone.store(<span class=\"number\">0</span>, Ordering::Release);\n    });\n\n    <span class=\"comment\">// Wait for the other thread to release the lock\n    </span><span class=\"kw\">while </span>spinlock.load(Ordering::Acquire) != <span class=\"number\">0 </span>{\n        hint::spin_loop();\n    }\n\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Err</span>(panic) = thread.join() {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"Thread had an error: {panic:?}\"</span>);\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::sync::Arc;%0Ause+std::sync::atomic::%7BAtomicUsize,+Ordering%7D;%0Ause+std::%7Bhint,+thread%7D;%0A%0Afn+main()+%7B%0A++++let+spinlock+=+Arc::new(AtomicUsize::new(1));%0A%0A++++let+spinlock_clone+=+Arc::clone(%26spinlock);%0A%0A++++let+thread+=+thread::spawn(move%7C%7C+%7B%0A++++++++spinlock_clone.store(0,+Ordering::Release);%0A++++%7D);%0A%0A++++//+Wait+for+the+other+thread+to+release+the+lock%0A++++while+spinlock.load(Ordering::Acquire)+!=+0+%7B%0A++++++++hint::spin_loop();%0A++++%7D%0A%0A++++if+let+Err(panic)+=+thread.join()+%7B%0A++++++++println!(%22Thread+had+an+error:+%7Bpanic:?%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Keep a global count of live threads:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::atomic::{AtomicUsize, Ordering};\n\n<span class=\"kw\">static </span>GLOBAL_THREAD_COUNT: AtomicUsize = AtomicUsize::new(<span class=\"number\">0</span>);\n\n<span class=\"comment\">// Note that Relaxed ordering doesn't synchronize anything\n// except the global thread counter itself.\n</span><span class=\"kw\">let </span>old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(<span class=\"number\">1</span>, Ordering::Relaxed);\n<span class=\"comment\">// Note that this number may not be true at the moment of printing\n// because some other thread may have changed static value already.\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"live threads: {}\"</span>, old_thread_count + <span class=\"number\">1</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::atomic::%7BAtomicUsize,+Ordering%7D;%0A++++%0A++++static+GLOBAL_THREAD_COUNT:+AtomicUsize+=+AtomicUsize::new(0);%0A++++%0A++++//+Note+that+Relaxed+ordering+doesn't+synchronize+anything%0A++++//+except+the+global+thread+counter+itself.%0A++++let+old_thread_count+=+GLOBAL_THREAD_COUNT.fetch_add(1,+Ordering::Relaxed);%0A++++//+Note+that+this+number+may+not+be+true+at+the+moment+of+printing%0A++++//+because+some+other+thread+may+have+changed+static+value+already.%0A++++println!(%22live+threads:+%7B%7D%22,+old_thread_count+%2B+1);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicBool.html\" title=\"struct std::sync::atomic::AtomicBool\">AtomicBool</a></div><div class=\"desc docblock-short\">A boolean type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicI8.html\" title=\"struct std::sync::atomic::AtomicI8\">AtomicI8</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicI16.html\" title=\"struct std::sync::atomic::AtomicI16\">AtomicI16</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicI32.html\" title=\"struct std::sync::atomic::AtomicI32\">AtomicI32</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicI64.html\" title=\"struct std::sync::atomic::AtomicI64\">AtomicI64</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicIsize.html\" title=\"struct std::sync::atomic::AtomicIsize\">AtomicIsize</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicPtr.html\" title=\"struct std::sync::atomic::AtomicPtr\">AtomicPtr</a></div><div class=\"desc docblock-short\">A raw pointer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicU8.html\" title=\"struct std::sync::atomic::AtomicU8\">AtomicU8</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicU16.html\" title=\"struct std::sync::atomic::AtomicU16\">AtomicU16</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicU32.html\" title=\"struct std::sync::atomic::AtomicU32\">AtomicU32</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicU64.html\" title=\"struct std::sync::atomic::AtomicU64\">AtomicU64</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.AtomicUsize.html\" title=\"struct std::sync::atomic::AtomicUsize\">AtomicUsize</a></div><div class=\"desc docblock-short\">An integer type which can be safely shared between threads.</div></li></ul><h2 id=\"enums\" class=\"section-header\">Enums<a href=\"#enums\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.Ordering.html\" title=\"enum std::sync::atomic::Ordering\">Ordering</a></div><div class=\"desc docblock-short\">Atomic memory orderings</div></li></ul><h2 id=\"constants\" class=\"section-header\">Constants<a href=\"#constants\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"constant\" href=\"constant.ATOMIC_BOOL_INIT.html\" title=\"constant std::sync::atomic::ATOMIC_BOOL_INIT\">ATOMIC_BOOL_INIT</a><span class=\"stab deprecated\" title=\"\">Deprecated</span></div><div class=\"desc docblock-short\">An <a href=\"struct.AtomicBool.html\" title=\"struct std::sync::atomic::AtomicBool\"><code>AtomicBool</code></a> initialized to <code>false</code>.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant.ATOMIC_ISIZE_INIT.html\" title=\"constant std::sync::atomic::ATOMIC_ISIZE_INIT\">ATOMIC_ISIZE_INIT</a><span class=\"stab deprecated\" title=\"\">Deprecated</span></div><div class=\"desc docblock-short\">An <a href=\"struct.AtomicIsize.html\" title=\"struct std::sync::atomic::AtomicIsize\"><code>AtomicIsize</code></a> initialized to <code>0</code>.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant.ATOMIC_USIZE_INIT.html\" title=\"constant std::sync::atomic::ATOMIC_USIZE_INIT\">ATOMIC_USIZE_INIT</a><span class=\"stab deprecated\" title=\"\">Deprecated</span></div><div class=\"desc docblock-short\">An <a href=\"struct.AtomicUsize.html\" title=\"struct std::sync::atomic::AtomicUsize\"><code>AtomicUsize</code></a> initialized to <code>0</code>.</div></li></ul><h2 id=\"functions\" class=\"section-header\">Functions<a href=\"#functions\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.compiler_fence.html\" title=\"fn std::sync::atomic::compiler_fence\">compiler_fence</a></div><div class=\"desc docblock-short\">A compiler memory fence.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.fence.html\" title=\"fn std::sync::atomic::fence\">fence</a></div><div class=\"desc docblock-short\">An atomic fence.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.spin_loop_hint.html\" title=\"fn std::sync::atomic::spin_loop_hint\">spin_loop_hint</a><span class=\"stab deprecated\" title=\"\">Deprecated</span></div><div class=\"desc docblock-short\">Signals the processor that it is inside a busy-wait spin-loop (“spin lock”).</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:09:17.206Z"
}