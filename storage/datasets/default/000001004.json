{
	"title": "std::sync::mpsc - Rust",
	"url": "https://doc.rust-lang.org/stable/std/sync/mpsc/index.html",
	"markdown": "# std::sync::mpsc - Rust\n\n## Module [std](../../index.html)::[sync](../index.html)::[mpsc](#)\n\n1.0.0 · [source](about:blank/src/std/sync/mpsc/mod.rs.html#1-1246) ·\n\nExpand description\n\nMulti-producer, single-consumer FIFO queue communication primitives.\n\nThis module provides message-based communication over channels, concretely defined among three types:\n\n-   [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\")\n-   [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\")\n-   [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\")\n\nA [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\") or [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\") is used to send data to a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\"). Both senders are clone-able (multi-producer) such that many threads can send simultaneously to one receiver (single-consumer).\n\nThese channels come in two flavors:\n\n1.  An asynchronous, infinitely buffered channel. The [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") function will return a `(Sender, Receiver)` tuple where all sends will be **asynchronous** (they never block). The channel conceptually has an infinite buffer.\n    \n2.  A synchronous, bounded channel. The [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync_channel\") function will return a `(SyncSender, Receiver)` tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be **synchronous** by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a “rendezvous” channel where each sender atomically hands off a message to a receiver.\n    \n\n### [§](#disconnection)Disconnection\n\nThe send and receive operations on channels will all return a [`Result`](../../result/enum.Result.html \"enum std::result::Result\") indicating whether the operation succeeded or not. An unsuccessful operation is normally indicative of the other half of a channel having “hung up” by being dropped in its corresponding thread.\n\nOnce half of a channel has been deallocated, most operations can no longer continue to make progress, so [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") will be returned. Many applications will continue to [`unwrap`](about:blank/result/enum.Result.html#method.unwrap \"method std::result::Result::unwrap\") the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies.\n\n## [§](#examples)Examples\n\nSimple usage:\n\n```\nuse std::thread;\nuse std::sync::mpsc::channel;\n\n// Create a simple streaming channel\nlet (tx, rx) = channel();\nthread::spawn(move|| {\n    tx.send(10).unwrap();\n});\nassert_eq!(rx.recv().unwrap(), 10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++//+Create+a+simple+streaming+channel%0A++++let+(tx,+rx)+=+channel();%0A++++thread::spawn(move%7C%7C+%7B%0A++++++++tx.send(10).unwrap();%0A++++%7D);%0A++++assert_eq!(rx.recv().unwrap(),+10);%0A%7D&edition=2021)\n\nShared usage:\n\n```\nuse std::thread;\nuse std::sync::mpsc::channel;\n\n// Create a shared channel that can be sent along from many threads\n// where tx is the sending half (tx for transmission), and rx is the receiving\n// half (rx for receiving).\nlet (tx, rx) = channel();\nfor i in 0..10 {\n    let tx = tx.clone();\n    thread::spawn(move|| {\n        tx.send(i).unwrap();\n    });\n}\n\nfor _ in 0..10 {\n    let j = rx.recv().unwrap();\n    assert!(0 <= j && j < 10);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++//+Create+a+shared+channel+that+can+be+sent+along+from+many+threads%0A++++//+where+tx+is+the+sending+half+(tx+for+transmission),+and+rx+is+the+receiving%0A++++//+half+(rx+for+receiving).%0A++++let+(tx,+rx)+=+channel();%0A++++for+i+in+0..10+%7B%0A++++++++let+tx+=+tx.clone();%0A++++++++thread::spawn(move%7C%7C+%7B%0A++++++++++++tx.send(i).unwrap();%0A++++++++%7D);%0A++++%7D%0A++++%0A++++for+_+in+0..10+%7B%0A++++++++let+j+=+rx.recv().unwrap();%0A++++++++assert!(0+%3C=+j+%26%26+j+%3C+10);%0A++++%7D%0A%7D&edition=2021)\n\nPropagating panics:\n\n```\nuse std::sync::mpsc::channel;\n\n// The call to recv() will return an error because the channel has already\n// hung up (or been deallocated)\nlet (tx, rx) = channel::<i32>();\ndrop(tx);\nassert!(rx.recv().is_err());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++//+The+call+to+recv()+will+return+an+error+because+the+channel+has+already%0A++++//+hung+up+(or+been+deallocated)%0A++++let+(tx,+rx)+=+channel::%3Ci32%3E();%0A++++drop(tx);%0A++++assert!(rx.recv().is_err());%0A%7D&edition=2021)\n\nSynchronous channels:\n\n```\nuse std::thread;\nuse std::sync::mpsc::sync_channel;\n\nlet (tx, rx) = sync_channel::<i32>(0);\nthread::spawn(move|| {\n    // This will wait for the parent thread to start receiving\n    tx.send(53).unwrap();\n});\nrx.recv().unwrap();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::mpsc::sync_channel;%0A++++%0A++++let+(tx,+rx)+=+sync_channel::%3Ci32%3E(0);%0A++++thread::spawn(move%7C%7C+%7B%0A++++++++//+This+will+wait+for+the+parent+thread+to+start+receiving%0A++++++++tx.send(53).unwrap();%0A++++%7D);%0A++++rx.recv().unwrap();%0A%7D&edition=2021)\n\nUnbounded receive loop:\n\n```\nuse std::sync::mpsc::sync_channel;\nuse std::thread;\n\nlet (tx, rx) = sync_channel(3);\n\nfor _ in 0..3 {\n    // It would be the same without thread and clone here\n    // since there will still be one `tx` left.\n    let tx = tx.clone();\n    // cloned tx dropped within thread\n    thread::spawn(move || tx.send(\"ok\").unwrap());\n}\n\n// Drop the last sender to stop `rx` waiting for message.\n// The program will not complete if we comment this out.\n// **All** `tx` needs to be dropped for `rx` to have `Err`.\ndrop(tx);\n\n// Unbounded receiver waiting for all senders to complete.\nwhile let Ok(msg) = rx.recv() {\n    println!(\"{msg}\");\n}\n\nprintln!(\"completed\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::mpsc::sync_channel;%0A++++use+std::thread;%0A++++%0A++++let+(tx,+rx)+=+sync_channel(3);%0A++++%0A++++for+_+in+0..3+%7B%0A++++++++//+It+would+be+the+same+without+thread+and+clone+here%0A++++++++//+since+there+will+still+be+one+%60tx%60+left.%0A++++++++let+tx+=+tx.clone();%0A++++++++//+cloned+tx+dropped+within+thread%0A++++++++thread::spawn(move+%7C%7C+tx.send(%22ok%22).unwrap());%0A++++%7D%0A++++%0A++++//+Drop+the+last+sender+to+stop+%60rx%60+waiting+for+message.%0A++++//+The+program+will+not+complete+if+we+comment+this+out.%0A++++//+**All**+%60tx%60+needs+to+be+dropped+for+%60rx%60+to+have+%60Err%60.%0A++++drop(tx);%0A++++%0A++++//+Unbounded+receiver+waiting+for+all+senders+to+complete.%0A++++while+let+Ok(msg)+=+rx.recv()+%7B%0A++++++++println!(%22%7Bmsg%7D%22);%0A++++%7D%0A++++%0A++++println!(%22completed%22);%0A%7D&edition=2021)\n\n-   An owning iterator over messages on a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\"), created by [`into_iter`](about:blank/struct.Receiver.html#method.into_iter \"method std::sync::mpsc::Receiver::into_iter\").\n    \n-   An iterator over messages on a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\"), created by [`iter`](about:blank/struct.Receiver.html#method.iter \"method std::sync::mpsc::Receiver::iter\").\n    \n-   The receiving half of Rust’s [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") (or [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync_channel\")) type. This half can only be owned by one thread.\n    \n-   An error returned from the [`recv`](about:blank/struct.Receiver.html#method.recv \"method std::sync::mpsc::Receiver::recv\") function on a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\").\n    \n\n-   The sending-half of Rust’s asynchronous [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") type.\n    \n-   The sending-half of Rust’s synchronous [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync_channel\") type.\n    \n-   An iterator that attempts to yield all pending values for a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\"), created by [`try_iter`](about:blank/struct.Receiver.html#method.try_iter \"method std::sync::mpsc::Receiver::try_iter\").\n    \n\n-   This enumeration is the list of possible errors that made [`recv_timeout`](about:blank/struct.Receiver.html#method.recv_timeout \"method std::sync::mpsc::Receiver::recv_timeout\") unable to return data when called. This can occur with both a [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") and a [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync_channel\").\n    \n-   This enumeration is the list of the possible reasons that [`try_recv`](about:blank/struct.Receiver.html#method.try_recv \"method std::sync::mpsc::Receiver::try_recv\") could not return data when called. This can occur with both a [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") and a [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync_channel\").\n    \n-   This enumeration is the list of the possible error outcomes for the [`try_send`](about:blank/struct.SyncSender.html#method.try_send \"method std::sync::mpsc::SyncSender::try_send\") method.\n    \n\n-   Creates a new asynchronous channel, returning the sender/receiver halves. All data sent on the [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\") will become available on the [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\") in the same order as it was sent, and no [`send`](about:blank/struct.Sender.html#method.send \"method std::sync::mpsc::Sender::send\") will block the calling thread (this channel has an “infinite buffer”, unlike [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync_channel\"), which will block after its buffer limit is reached). [`recv`](about:blank/struct.Receiver.html#method.recv \"method std::sync::mpsc::Receiver::recv\") will block until a message is available while there is at least one [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\") alive (including clones).\n    \n-   Creates a new synchronous, bounded channel. All data sent on the [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\") will become available on the [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\") in the same order as it was sent. Like asynchronous [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\")s, the [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\") will block until a message becomes available. `sync_channel` differs greatly in the semantics of the sender, however.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Multi-producer, single-consumer FIFO queue communication primitives.\"><title>std::sync::mpsc - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../../\" data-static-root-path=\"../../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module mpsc</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module mpsc</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li><li><a href=\"#enums\">Enums</a></li><li><a href=\"#functions\">Functions</a></li></ul></section><h2><a href=\"../index.html\">In std::sync</a></h2><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../atomic/index.html\">atomic</a></li><li><a href=\"../mpsc/index.html\">mpsc</a></li></ul><h3><a href=\"../index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"../struct.Arc.html\">Arc</a></li><li><a href=\"../struct.Barrier.html\">Barrier</a></li><li><a href=\"../struct.BarrierWaitResult.html\">BarrierWaitResult</a></li><li><a href=\"../struct.Condvar.html\">Condvar</a></li><li><a href=\"../struct.Exclusive.html\">Exclusive</a></li><li><a href=\"../struct.LazyLock.html\">LazyLock</a></li><li><a href=\"../struct.MappedMutexGuard.html\">MappedMutexGuard</a></li><li><a href=\"../struct.MappedRwLockReadGuard.html\">MappedRwLockReadGuard</a></li><li><a href=\"../struct.MappedRwLockWriteGuard.html\">MappedRwLockWriteGuard</a></li><li><a href=\"../struct.Mutex.html\">Mutex</a></li><li><a href=\"../struct.MutexGuard.html\">MutexGuard</a></li><li><a href=\"../struct.Once.html\">Once</a></li><li><a href=\"../struct.OnceLock.html\">OnceLock</a></li><li><a href=\"../struct.OnceState.html\">OnceState</a></li><li><a href=\"../struct.PoisonError.html\">PoisonError</a></li><li><a href=\"../struct.ReentrantLock.html\">ReentrantLock</a></li><li><a href=\"../struct.ReentrantLockGuard.html\">ReentrantLockGuard</a></li><li><a href=\"../struct.RwLock.html\">RwLock</a></li><li><a href=\"../struct.RwLockReadGuard.html\">RwLockReadGuard</a></li><li><a href=\"../struct.RwLockWriteGuard.html\">RwLockWriteGuard</a></li><li><a href=\"../struct.WaitTimeoutResult.html\">WaitTimeoutResult</a></li><li><a href=\"../struct.Weak.html\">Weak</a></li></ul><h3><a href=\"../index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"../enum.TryLockError.html\">TryLockError</a></li></ul><h3><a href=\"../index.html#constants\">Constants</a></h3><ul class=\"block constant\"><li><a href=\"../constant.ONCE_INIT.html\">ONCE_INIT</a></li></ul><h3><a href=\"../index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"../type.LockResult.html\">LockResult</a></li><li><a href=\"../type.TryLockResult.html\">TryLockResult</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../../index.html\">std</a>::<wbr><a href=\"../index.html\">sync</a>::<wbr><a class=\"mod\" href=\"#\">mpsc</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../../src/std/sync/mpsc/mod.rs.html#1-1246\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Multi-producer, single-consumer FIFO queue communication primitives.</p>\n<p>This module provides message-based communication over channels, concretely\ndefined among three types:</p>\n<ul>\n<li><a href=\"struct.Sender.html\" title=\"struct std::sync::mpsc::Sender\"><code>Sender</code></a></li>\n<li><a href=\"struct.SyncSender.html\" title=\"struct std::sync::mpsc::SyncSender\"><code>SyncSender</code></a></li>\n<li><a href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\"><code>Receiver</code></a></li>\n</ul>\n<p>A <a href=\"struct.Sender.html\" title=\"struct std::sync::mpsc::Sender\"><code>Sender</code></a> or <a href=\"struct.SyncSender.html\" title=\"struct std::sync::mpsc::SyncSender\"><code>SyncSender</code></a> is used to send data to a <a href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\"><code>Receiver</code></a>. Both\nsenders are clone-able (multi-producer) such that many threads can send\nsimultaneously to one receiver (single-consumer).</p>\n<p>These channels come in two flavors:</p>\n<ol>\n<li>\n<p>An asynchronous, infinitely buffered channel. The <a href=\"fn.channel.html\" title=\"fn std::sync::mpsc::channel\"><code>channel</code></a> function\nwill return a <code>(Sender, Receiver)</code> tuple where all sends will be\n<strong>asynchronous</strong> (they never block). The channel conceptually has an\ninfinite buffer.</p>\n</li>\n<li>\n<p>A synchronous, bounded channel. The <a href=\"fn.sync_channel.html\" title=\"fn std::sync::mpsc::sync_channel\"><code>sync_channel</code></a> function will\nreturn a <code>(SyncSender, Receiver)</code> tuple where the storage for pending\nmessages is a pre-allocated buffer of a fixed size. All sends will be\n<strong>synchronous</strong> by blocking until there is buffer space available. Note\nthat a bound of 0 is allowed, causing the channel to become a “rendezvous”\nchannel where each sender atomically hands off a message to a receiver.</p>\n</li>\n</ol>\n<h3 id=\"disconnection\"><a class=\"doc-anchor\" href=\"#disconnection\">§</a>Disconnection</h3>\n<p>The send and receive operations on channels will all return a <a href=\"../../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>\nindicating whether the operation succeeded or not. An unsuccessful operation\nis normally indicative of the other half of a channel having “hung up” by\nbeing dropped in its corresponding thread.</p>\n<p>Once half of a channel has been deallocated, most operations can no longer\ncontinue to make progress, so <a href=\"../../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> will be returned. Many applications\nwill continue to <a href=\"../../result/enum.Result.html#method.unwrap\" title=\"method std::result::Result::unwrap\"><code>unwrap</code></a> the results returned from this module,\ninstigating a propagation of failure among threads if one unexpectedly dies.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>Simple usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>std::sync::mpsc::channel;\n\n<span class=\"comment\">// Create a simple streaming channel\n</span><span class=\"kw\">let </span>(tx, rx) = channel();\nthread::spawn(<span class=\"kw\">move</span>|| {\n    tx.send(<span class=\"number\">10</span>).unwrap();\n});\n<span class=\"macro\">assert_eq!</span>(rx.recv().unwrap(), <span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++//+Create+a+simple+streaming+channel%0A++++let+(tx,+rx)+=+channel();%0A++++thread::spawn(move%7C%7C+%7B%0A++++++++tx.send(10).unwrap();%0A++++%7D);%0A++++assert_eq!(rx.recv().unwrap(),+10);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Shared usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>std::sync::mpsc::channel;\n\n<span class=\"comment\">// Create a shared channel that can be sent along from many threads\n// where tx is the sending half (tx for transmission), and rx is the receiving\n// half (rx for receiving).\n</span><span class=\"kw\">let </span>(tx, rx) = channel();\n<span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n    <span class=\"kw\">let </span>tx = tx.clone();\n    thread::spawn(<span class=\"kw\">move</span>|| {\n        tx.send(i).unwrap();\n    });\n}\n\n<span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n    <span class=\"kw\">let </span>j = rx.recv().unwrap();\n    <span class=\"macro\">assert!</span>(<span class=\"number\">0 </span>&lt;= j &amp;&amp; j &lt; <span class=\"number\">10</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++//+Create+a+shared+channel+that+can+be+sent+along+from+many+threads%0A++++//+where+tx+is+the+sending+half+(tx+for+transmission),+and+rx+is+the+receiving%0A++++//+half+(rx+for+receiving).%0A++++let+(tx,+rx)+=+channel();%0A++++for+i+in+0..10+%7B%0A++++++++let+tx+=+tx.clone();%0A++++++++thread::spawn(move%7C%7C+%7B%0A++++++++++++tx.send(i).unwrap();%0A++++++++%7D);%0A++++%7D%0A++++%0A++++for+_+in+0..10+%7B%0A++++++++let+j+=+rx.recv().unwrap();%0A++++++++assert!(0+%3C=+j+%26%26+j+%3C+10);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Propagating panics:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::mpsc::channel;\n\n<span class=\"comment\">// The call to recv() will return an error because the channel has already\n// hung up (or been deallocated)\n</span><span class=\"kw\">let </span>(tx, rx) = channel::&lt;i32&gt;();\ndrop(tx);\n<span class=\"macro\">assert!</span>(rx.recv().is_err());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++//+The+call+to+recv()+will+return+an+error+because+the+channel+has+already%0A++++//+hung+up+(or+been+deallocated)%0A++++let+(tx,+rx)+=+channel::%3Ci32%3E();%0A++++drop(tx);%0A++++assert!(rx.recv().is_err());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Synchronous channels:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>std::sync::mpsc::sync_channel;\n\n<span class=\"kw\">let </span>(tx, rx) = sync_channel::&lt;i32&gt;(<span class=\"number\">0</span>);\nthread::spawn(<span class=\"kw\">move</span>|| {\n    <span class=\"comment\">// This will wait for the parent thread to start receiving\n    </span>tx.send(<span class=\"number\">53</span>).unwrap();\n});\nrx.recv().unwrap();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::mpsc::sync_channel;%0A++++%0A++++let+(tx,+rx)+=+sync_channel::%3Ci32%3E(0);%0A++++thread::spawn(move%7C%7C+%7B%0A++++++++//+This+will+wait+for+the+parent+thread+to+start+receiving%0A++++++++tx.send(53).unwrap();%0A++++%7D);%0A++++rx.recv().unwrap();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Unbounded receive loop:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::mpsc::sync_channel;\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>(tx, rx) = sync_channel(<span class=\"number\">3</span>);\n\n<span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">3 </span>{\n    <span class=\"comment\">// It would be the same without thread and clone here\n    // since there will still be one `tx` left.\n    </span><span class=\"kw\">let </span>tx = tx.clone();\n    <span class=\"comment\">// cloned tx dropped within thread\n    </span>thread::spawn(<span class=\"kw\">move </span>|| tx.send(<span class=\"string\">\"ok\"</span>).unwrap());\n}\n\n<span class=\"comment\">// Drop the last sender to stop `rx` waiting for message.\n// The program will not complete if we comment this out.\n// **All** `tx` needs to be dropped for `rx` to have `Err`.\n</span>drop(tx);\n\n<span class=\"comment\">// Unbounded receiver waiting for all senders to complete.\n</span><span class=\"kw\">while let </span><span class=\"prelude-val\">Ok</span>(msg) = rx.recv() {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{msg}\"</span>);\n}\n\n<span class=\"macro\">println!</span>(<span class=\"string\">\"completed\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::mpsc::sync_channel;%0A++++use+std::thread;%0A++++%0A++++let+(tx,+rx)+=+sync_channel(3);%0A++++%0A++++for+_+in+0..3+%7B%0A++++++++//+It+would+be+the+same+without+thread+and+clone+here%0A++++++++//+since+there+will+still+be+one+%60tx%60+left.%0A++++++++let+tx+=+tx.clone();%0A++++++++//+cloned+tx+dropped+within+thread%0A++++++++thread::spawn(move+%7C%7C+tx.send(%22ok%22).unwrap());%0A++++%7D%0A++++%0A++++//+Drop+the+last+sender+to+stop+%60rx%60+waiting+for+message.%0A++++//+The+program+will+not+complete+if+we+comment+this+out.%0A++++//+**All**+%60tx%60+needs+to+be+dropped+for+%60rx%60+to+have+%60Err%60.%0A++++drop(tx);%0A++++%0A++++//+Unbounded+receiver+waiting+for+all+senders+to+complete.%0A++++while+let+Ok(msg)+=+rx.recv()+%7B%0A++++++++println!(%22%7Bmsg%7D%22);%0A++++%7D%0A++++%0A++++println!(%22completed%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.IntoIter.html\" title=\"struct std::sync::mpsc::IntoIter\">IntoIter</a></div><div class=\"desc docblock-short\">An owning iterator over messages on a <a href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\"><code>Receiver</code></a>,\ncreated by <a href=\"struct.Receiver.html#method.into_iter\" title=\"method std::sync::mpsc::Receiver::into_iter\"><code>into_iter</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct std::sync::mpsc::Iter\">Iter</a></div><div class=\"desc docblock-short\">An iterator over messages on a <a href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\"><code>Receiver</code></a>, created by <a href=\"struct.Receiver.html#method.iter\" title=\"method std::sync::mpsc::Receiver::iter\"><code>iter</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\">Receiver</a></div><div class=\"desc docblock-short\">The receiving half of Rust’s <a href=\"fn.channel.html\" title=\"fn std::sync::mpsc::channel\"><code>channel</code></a> (or <a href=\"fn.sync_channel.html\" title=\"fn std::sync::mpsc::sync_channel\"><code>sync_channel</code></a>) type.\nThis half can only be owned by one thread.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.RecvError.html\" title=\"struct std::sync::mpsc::RecvError\">RecvError</a></div><div class=\"desc docblock-short\">An error returned from the <a href=\"struct.Receiver.html#method.recv\" title=\"method std::sync::mpsc::Receiver::recv\"><code>recv</code></a> function on a <a href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\"><code>Receiver</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.SendError.html\" title=\"struct std::sync::mpsc::SendError\">SendError</a></div><div class=\"desc docblock-short\">An error returned from the <a href=\"struct.Sender.html#method.send\" title=\"method std::sync::mpsc::Sender::send\"><code>Sender::send</code></a> or <a href=\"struct.SyncSender.html#method.send\" title=\"method std::sync::mpsc::SyncSender::send\"><code>SyncSender::send</code></a>\nfunction on <strong>channel</strong>s.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Sender.html\" title=\"struct std::sync::mpsc::Sender\">Sender</a></div><div class=\"desc docblock-short\">The sending-half of Rust’s asynchronous <a href=\"fn.channel.html\" title=\"fn std::sync::mpsc::channel\"><code>channel</code></a> type.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.SyncSender.html\" title=\"struct std::sync::mpsc::SyncSender\">SyncSender</a></div><div class=\"desc docblock-short\">The sending-half of Rust’s synchronous <a href=\"fn.sync_channel.html\" title=\"fn std::sync::mpsc::sync_channel\"><code>sync_channel</code></a> type.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.TryIter.html\" title=\"struct std::sync::mpsc::TryIter\">TryIter</a></div><div class=\"desc docblock-short\">An iterator that attempts to yield all pending values for a <a href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\"><code>Receiver</code></a>,\ncreated by <a href=\"struct.Receiver.html#method.try_iter\" title=\"method std::sync::mpsc::Receiver::try_iter\"><code>try_iter</code></a>.</div></li></ul><h2 id=\"enums\" class=\"section-header\">Enums<a href=\"#enums\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.RecvTimeoutError.html\" title=\"enum std::sync::mpsc::RecvTimeoutError\">RecvTimeoutError</a></div><div class=\"desc docblock-short\">This enumeration is the list of possible errors that made <a href=\"struct.Receiver.html#method.recv_timeout\" title=\"method std::sync::mpsc::Receiver::recv_timeout\"><code>recv_timeout</code></a>\nunable to return data when called. This can occur with both a <a href=\"fn.channel.html\" title=\"fn std::sync::mpsc::channel\"><code>channel</code></a> and\na <a href=\"fn.sync_channel.html\" title=\"fn std::sync::mpsc::sync_channel\"><code>sync_channel</code></a>.</div></li><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.TryRecvError.html\" title=\"enum std::sync::mpsc::TryRecvError\">TryRecvError</a></div><div class=\"desc docblock-short\">This enumeration is the list of the possible reasons that <a href=\"struct.Receiver.html#method.try_recv\" title=\"method std::sync::mpsc::Receiver::try_recv\"><code>try_recv</code></a> could\nnot return data when called. This can occur with both a <a href=\"fn.channel.html\" title=\"fn std::sync::mpsc::channel\"><code>channel</code></a> and\na <a href=\"fn.sync_channel.html\" title=\"fn std::sync::mpsc::sync_channel\"><code>sync_channel</code></a>.</div></li><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.TrySendError.html\" title=\"enum std::sync::mpsc::TrySendError\">TrySendError</a></div><div class=\"desc docblock-short\">This enumeration is the list of the possible error outcomes for the\n<a href=\"struct.SyncSender.html#method.try_send\" title=\"method std::sync::mpsc::SyncSender::try_send\"><code>try_send</code></a> method.</div></li></ul><h2 id=\"functions\" class=\"section-header\">Functions<a href=\"#functions\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.channel.html\" title=\"fn std::sync::mpsc::channel\">channel</a></div><div class=\"desc docblock-short\">Creates a new asynchronous channel, returning the sender/receiver halves.\nAll data sent on the <a href=\"struct.Sender.html\" title=\"struct std::sync::mpsc::Sender\"><code>Sender</code></a> will become available on the <a href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\"><code>Receiver</code></a> in\nthe same order as it was sent, and no <a href=\"struct.Sender.html#method.send\" title=\"method std::sync::mpsc::Sender::send\"><code>send</code></a> will block the calling thread\n(this channel has an “infinite buffer”, unlike <a href=\"fn.sync_channel.html\" title=\"fn std::sync::mpsc::sync_channel\"><code>sync_channel</code></a>, which will\nblock after its buffer limit is reached). <a href=\"struct.Receiver.html#method.recv\" title=\"method std::sync::mpsc::Receiver::recv\"><code>recv</code></a> will block until a message\nis available while there is at least one <a href=\"struct.Sender.html\" title=\"struct std::sync::mpsc::Sender\"><code>Sender</code></a> alive (including clones).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.sync_channel.html\" title=\"fn std::sync::mpsc::sync_channel\">sync_channel</a></div><div class=\"desc docblock-short\">Creates a new synchronous, bounded channel.\nAll data sent on the <a href=\"struct.SyncSender.html\" title=\"struct std::sync::mpsc::SyncSender\"><code>SyncSender</code></a> will become available on the <a href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\"><code>Receiver</code></a>\nin the same order as it was sent. Like asynchronous <a href=\"fn.channel.html\" title=\"fn std::sync::mpsc::channel\"><code>channel</code></a>s, the\n<a href=\"struct.Receiver.html\" title=\"struct std::sync::mpsc::Receiver\"><code>Receiver</code></a> will block until a message becomes available. <code>sync_channel</code>\ndiffers greatly in the semantics of the sender, however.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:14:45.107Z"
}