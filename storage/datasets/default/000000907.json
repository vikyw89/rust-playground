{
	"title": "Allocating - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/vec/vec-alloc.html",
	"markdown": "# Allocating - The Rustonomicon\n\n## [Allocating Memory](#allocating-memory)\n\nUsing `NonNull` throws a wrench in an important feature of Vec (and indeed all of the std collections): creating an empty Vec doesn't actually allocate at all. This is not the same as allocating a zero-sized memory block, which is not allowed by the global allocator (it results in undefined behavior!). So if we can't allocate, but also can't put a null pointer in `ptr`, what do we do in `Vec::new`? Well, we just put some other garbage in there!\n\nThis is perfectly fine because we already have `cap == 0` as our sentinel for no allocation. We don't even need to handle it specially in almost any code because we usually need to check if `cap > len` or `len > 0` anyway. The recommended Rust value to put here is `mem::align_of::<T>()`. `NonNull` provides a convenience for this: `NonNull::dangling()`. There are quite a few places where we'll want to use `dangling` because there's no real allocation to talk about but `null` would make the compiler do bad things.\n\nSo:\n\n```rust\nuse std::mem;\n\nimpl<T> Vec<T> {\n    pub fn new() -> Self {\n        assert!(mem::size_of::<T>() != 0, \"We're not ready to handle ZSTs\");\n        Vec {\n            ptr: NonNull::dangling(),\n            len: 0,\n            cap: 0,\n        }\n    }\n}\nfn main() {}\n```\n\nI slipped in that assert there because zero-sized types will require some special handling throughout our code, and I want to defer the issue for now. Without this assert, some of our early drafts will do some Very Bad Things.\n\nNext we need to figure out what to actually do when we _do_ want space. For that, we use the global allocation functions [`alloc`](../../alloc/alloc/fn.alloc.html), [`realloc`](../../alloc/alloc/fn.realloc.html), and [`dealloc`](../../alloc/alloc/fn.dealloc.html) which are available in stable Rust in [`std::alloc`](../../alloc/alloc/index.html). These functions are expected to become deprecated in favor of the methods of [`std::alloc::Global`](../../std/alloc/struct.Global.html) after this type is stabilized.\n\nWe'll also need a way to handle out-of-memory (OOM) conditions. The standard library provides a function [`alloc::handle_alloc_error`](../../alloc/alloc/fn.handle_alloc_error.html), which will abort the program in a platform-specific manner. The reason we abort and don't panic is because unwinding can cause allocations to happen, and that seems like a bad thing to do when your allocator just came back with \"hey I don't have any more memory\".\n\nOf course, this is a bit silly since most platforms don't actually run out of memory in a conventional way. Your operating system will probably kill the application by another means if you legitimately start using up all the memory. The most likely way we'll trigger OOM is by just asking for ludicrous quantities of memory at once (e.g. half the theoretical address space). As such it's _probably_ fine to panic and nothing bad will happen. Still, we're trying to be like the standard library as much as possible, so we'll just kill the whole program.\n\nOkay, now we can write growing. Roughly, we want to have this logic:\n\n```text\nif cap == 0:\n    allocate()\n    cap = 1\nelse:\n    reallocate()\n    cap *= 2\n\n```\n\nBut Rust's only supported allocator API is so low level that we'll need to do a fair bit of extra work. We also need to guard against some special conditions that can occur with really large allocations or empty allocations.\n\nIn particular, `ptr::offset` will cause us a lot of trouble, because it has the semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to not have dealt with this instruction, here's the basic story with GEP: alias analysis, alias analysis, alias analysis. It's super important to an optimizing compiler to be able to reason about data dependencies and aliasing.\n\nAs a simple example, consider the following fragment of code:\n\n```rust\n*x *= 7;\n*y *= 3;\n```\n\nIf the compiler can prove that `x` and `y` point to different locations in memory, the two operations can in theory be executed in parallel (by e.g. loading them into different registers and working on them independently). However the compiler can't do this in general because if x and y point to the same location in memory, the operations need to be done to the same value, and they can't just be merged afterwards.\n\nWhen you use GEP inbounds, you are specifically telling LLVM that the offsets you're about to do are within the bounds of a single \"allocated\" entity. The ultimate payoff being that LLVM can assume that if two pointers are known to point to two disjoint objects, all the offsets of those pointers are _also_ known to not alias (because you won't just end up in some random place in memory). LLVM is heavily optimized to work with GEP offsets, and inbounds offsets are the best of all, so it's important that we use them as much as possible.\n\nSo that's what GEP's about, how can it cause us trouble?\n\nThe first problem is that we index into arrays with unsigned integers, but GEP (and as a consequence `ptr::offset`) takes a signed integer. This means that half of the seemingly valid indices into an array will overflow GEP and actually go in the wrong direction! As such we must limit all allocations to `isize::MAX` elements. This actually means we only need to worry about byte-sized objects, because e.g. `> isize::MAX` `u16`s will truly exhaust all of the system's memory. However in order to avoid subtle corner cases where someone reinterprets some array of `< isize::MAX` objects as bytes, std limits all allocations to `isize::MAX` bytes.\n\nOn all 64-bit targets that Rust currently supports we're artificially limited to significantly less than all 64 bits of the address space (modern x64 platforms only expose 48-bit addressing), so we can rely on just running out of memory first. However on 32-bit targets, particularly those with extensions to use more of the address space (PAE x86 or x32), it's theoretically possible to successfully allocate more than `isize::MAX` bytes of memory.\n\nHowever since this is a tutorial, we're not going to be particularly optimal here, and just unconditionally check, rather than use clever platform-specific `cfg`s.\n\nThe other corner-case we need to worry about is empty allocations. There will be two kinds of empty allocations we need to worry about: `cap = 0` for all T, and `cap > 0` for zero-sized types.\n\nThese cases are tricky because they come down to what LLVM means by \"allocated\". LLVM's notion of an allocation is significantly more abstract than how we usually use it. Because LLVM needs to work with different languages' semantics and custom allocators, it can't really intimately understand allocation. Instead, the main idea behind allocation is \"doesn't overlap with other stuff\". That is, heap allocations, stack allocations, and globals don't randomly overlap. Yep, it's about alias analysis. As such, Rust can technically play a bit fast and loose with the notion of an allocation as long as it's _consistent_.\n\nGetting back to the empty allocation case, there are a couple of places where we want to offset by 0 as a consequence of generic code. The question is then: is it consistent to do so? For zero-sized types, we have concluded that it is indeed consistent to do a GEP inbounds offset by an arbitrary number of elements. This is a runtime no-op because every element takes up no space, and it's fine to pretend that there's infinite zero-sized types allocated at `0x01`. No allocator will ever allocate that address, because they won't allocate `0x00` and they generally allocate to some minimal alignment higher than a byte. Also generally the whole first page of memory is protected from being allocated anyway (a whole 4k, on many platforms).\n\nHowever what about for positive-sized types? That one's a bit trickier. In principle, you can argue that offsetting by 0 gives LLVM no information: either there's an element before the address or after it, but it can't know which. However we've chosen to conservatively assume that it may do bad things. As such we will guard against this case explicitly.\n\n_Phew_\n\nOk with all the nonsense out of the way, let's actually allocate some memory:\n\n```rust\nuse std::alloc::{self, Layout};\n\nimpl<T> Vec<T> {\n    fn grow(&mut self) {\n        let (new_cap, new_layout) = if self.cap == 0 {\n            (1, Layout::array::<T>(1).unwrap())\n        } else {\n            // This can't overflow since self.cap <= isize::MAX.\n            let new_cap = 2 * self.cap;\n\n            // `Layout::array` checks that the number of bytes is <= usize::MAX,\n            // but this is redundant since old_layout.size() <= isize::MAX,\n            // so the `unwrap` should never fail.\n            let new_layout = Layout::array::<T>(new_cap).unwrap();\n            (new_cap, new_layout)\n        };\n\n        // Ensure that the new allocation doesn't exceed `isize::MAX` bytes.\n        assert!(new_layout.size() <= isize::MAX as usize, \"Allocation too large\");\n\n        let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        // If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}\nfn main() {}\n```",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Allocating - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"../favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"../theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"../intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"../meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"../what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"../working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"../exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"../other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"../aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"../unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"../hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"../subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"../dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"../phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"../borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"../dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"../casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"../transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"../drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"../unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"../destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"../leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"../poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"../send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"../atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-alloc.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"../beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"allocating-memory\"><a class=\"header\" href=\"#allocating-memory\">Allocating Memory</a></h1>\n<p>Using <code class=\"hljs\">NonNull</code> throws a wrench in an important feature of Vec (and indeed all of\nthe std collections): creating an empty Vec doesn't actually allocate at all. This\nis not the same as allocating a zero-sized memory block, which is not allowed by\nthe global allocator (it results in undefined behavior!). So if we can't allocate,\nbut also can't put a null pointer in <code class=\"hljs\">ptr</code>, what do we do in <code class=\"hljs\">Vec::new</code>? Well, we\njust put some other garbage in there!</p>\n<p>This is perfectly fine because we already have <code class=\"hljs\">cap == 0</code> as our sentinel for no\nallocation. We don't even need to handle it specially in almost any code because\nwe usually need to check if <code class=\"hljs\">cap &gt; len</code> or <code class=\"hljs\">len &gt; 0</code> anyway. The recommended\nRust value to put here is <code class=\"hljs\">mem::align_of::&lt;T&gt;()</code>. <code class=\"hljs\">NonNull</code> provides a convenience\nfor this: <code class=\"hljs\">NonNull::dangling()</code>. There are quite a few places where we'll\nwant to use <code class=\"hljs\">dangling</code> because there's no real allocation to talk about but\n<code class=\"hljs\">null</code> would make the compiler do bad things.</p>\n<p>So:</p>\n<!-- ignore: explanation code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::mem;\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Vec</span>&lt;T&gt; {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>() -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-built_in\">assert!</span>(mem::size_of::&lt;T&gt;() != <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">\"We're not ready to handle ZSTs\"</span>);\n        <span class=\"hljs-built_in\">Vec</span> {\n            ptr: NonNull::dangling(),\n            len: <span class=\"hljs-number\">0</span>,\n            cap: <span class=\"hljs-number\">0</span>,\n        }\n    }\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre>\n<p>I slipped in that assert there because zero-sized types will require some\nspecial handling throughout our code, and I want to defer the issue for now.\nWithout this assert, some of our early drafts will do some Very Bad Things.</p>\n<p>Next we need to figure out what to actually do when we <em>do</em> want space. For that,\nwe use the global allocation functions <a href=\"../../alloc/alloc/fn.alloc.html\"><code class=\"hljs\">alloc</code></a>, <a href=\"../../alloc/alloc/fn.realloc.html\"><code class=\"hljs\">realloc</code></a>,\nand <a href=\"../../alloc/alloc/fn.dealloc.html\"><code class=\"hljs\">dealloc</code></a> which are available in stable Rust in\n<a href=\"../../alloc/alloc/index.html\"><code class=\"hljs\">std::alloc</code></a>. These functions are expected to become deprecated in\nfavor of the methods of <a href=\"../../std/alloc/struct.Global.html\"><code class=\"hljs\">std::alloc::Global</code></a> after this type is stabilized.</p>\n<p>We'll also need a way to handle out-of-memory (OOM) conditions. The standard\nlibrary provides a function <a href=\"../../alloc/alloc/fn.handle_alloc_error.html\"><code class=\"hljs\">alloc::handle_alloc_error</code></a>,\nwhich will abort the program in a platform-specific manner.\nThe reason we abort and don't panic is because unwinding can cause allocations\nto happen, and that seems like a bad thing to do when your allocator just came\nback with \"hey I don't have any more memory\".</p>\n<p>Of course, this is a bit silly since most platforms don't actually run out of\nmemory in a conventional way. Your operating system will probably kill the\napplication by another means if you legitimately start using up all the memory.\nThe most likely way we'll trigger OOM is by just asking for ludicrous quantities\nof memory at once (e.g. half the theoretical address space). As such it's\n<em>probably</em> fine to panic and nothing bad will happen. Still, we're trying to be\nlike the standard library as much as possible, so we'll just kill the whole\nprogram.</p>\n<p>Okay, now we can write growing. Roughly, we want to have this logic:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">if cap == 0:\n    allocate()\n    cap = 1\nelse:\n    reallocate()\n    cap *= 2\n</code></pre>\n<p>But Rust's only supported allocator API is so low level that we'll need to do a\nfair bit of extra work. We also need to guard against some special\nconditions that can occur with really large allocations or empty allocations.</p>\n<p>In particular, <code class=\"hljs\">ptr::offset</code> will cause us a lot of trouble, because it has\nthe semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to\nnot have dealt with this instruction, here's the basic story with GEP: alias\nanalysis, alias analysis, alias analysis. It's super important to an optimizing\ncompiler to be able to reason about data dependencies and aliasing.</p>\n<p>As a simple example, consider the following fragment of code:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">*x *= <span class=\"hljs-number\">7</span>;\n*y *= <span class=\"hljs-number\">3</span>;</code></pre>\n<p>If the compiler can prove that <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> point to different locations in\nmemory, the two operations can in theory be executed in parallel (by e.g.\nloading them into different registers and working on them independently).\nHowever the compiler can't do this in general because if x and y point to\nthe same location in memory, the operations need to be done to the same value,\nand they can't just be merged afterwards.</p>\n<p>When you use GEP inbounds, you are specifically telling LLVM that the offsets\nyou're about to do are within the bounds of a single \"allocated\" entity. The\nultimate payoff being that LLVM can assume that if two pointers are known to\npoint to two disjoint objects, all the offsets of those pointers are <em>also</em>\nknown to not alias (because you won't just end up in some random place in\nmemory). LLVM is heavily optimized to work with GEP offsets, and inbounds\noffsets are the best of all, so it's important that we use them as much as\npossible.</p>\n<p>So that's what GEP's about, how can it cause us trouble?</p>\n<p>The first problem is that we index into arrays with unsigned integers, but\nGEP (and as a consequence <code class=\"hljs\">ptr::offset</code>) takes a signed integer. This means\nthat half of the seemingly valid indices into an array will overflow GEP and\nactually go in the wrong direction! As such we must limit all allocations to\n<code class=\"hljs\">isize::MAX</code> elements. This actually means we only need to worry about\nbyte-sized objects, because e.g. <code class=\"hljs\">&gt; isize::MAX</code> <code class=\"hljs\">u16</code>s will truly exhaust all of\nthe system's memory. However in order to avoid subtle corner cases where someone\nreinterprets some array of <code class=\"hljs\">&lt; isize::MAX</code> objects as bytes, std limits all\nallocations to <code class=\"hljs\">isize::MAX</code> bytes.</p>\n<p>On all 64-bit targets that Rust currently supports we're artificially limited\nto significantly less than all 64 bits of the address space (modern x64\nplatforms only expose 48-bit addressing), so we can rely on just running out of\nmemory first. However on 32-bit targets, particularly those with extensions to\nuse more of the address space (PAE x86 or x32), it's theoretically possible to\nsuccessfully allocate more than <code class=\"hljs\">isize::MAX</code> bytes of memory.</p>\n<p>However since this is a tutorial, we're not going to be particularly optimal\nhere, and just unconditionally check, rather than use clever platform-specific\n<code class=\"hljs\">cfg</code>s.</p>\n<p>The other corner-case we need to worry about is empty allocations. There will\nbe two kinds of empty allocations we need to worry about: <code class=\"hljs\">cap = 0</code> for all T,\nand <code class=\"hljs\">cap &gt; 0</code> for zero-sized types.</p>\n<p>These cases are tricky because they come\ndown to what LLVM means by \"allocated\". LLVM's notion of an\nallocation is significantly more abstract than how we usually use it. Because\nLLVM needs to work with different languages' semantics and custom allocators,\nit can't really intimately understand allocation. Instead, the main idea behind\nallocation is \"doesn't overlap with other stuff\". That is, heap allocations,\nstack allocations, and globals don't randomly overlap. Yep, it's about alias\nanalysis. As such, Rust can technically play a bit fast and loose with the notion of\nan allocation as long as it's <em>consistent</em>.</p>\n<p>Getting back to the empty allocation case, there are a couple of places where\nwe want to offset by 0 as a consequence of generic code. The question is then:\nis it consistent to do so? For zero-sized types, we have concluded that it is\nindeed consistent to do a GEP inbounds offset by an arbitrary number of\nelements. This is a runtime no-op because every element takes up no space,\nand it's fine to pretend that there's infinite zero-sized types allocated\nat <code class=\"hljs\">0x01</code>. No allocator will ever allocate that address, because they won't\nallocate <code class=\"hljs\">0x00</code> and they generally allocate to some minimal alignment higher\nthan a byte. Also generally the whole first page of memory is\nprotected from being allocated anyway (a whole 4k, on many platforms).</p>\n<p>However what about for positive-sized types? That one's a bit trickier. In\nprinciple, you can argue that offsetting by 0 gives LLVM no information: either\nthere's an element before the address or after it, but it can't know which.\nHowever we've chosen to conservatively assume that it may do bad things. As\nsuch we will guard against this case explicitly.</p>\n<p><em>Phew</em></p>\n<p>Ok with all the nonsense out of the way, let's actually allocate some memory:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::alloc::{<span class=\"hljs-keyword\">self</span>, Layout};\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Vec</span>&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">grow</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">let</span> (new_cap, new_layout) = <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.cap == <span class=\"hljs-number\">0</span> {\n            (<span class=\"hljs-number\">1</span>, Layout::array::&lt;T&gt;(<span class=\"hljs-number\">1</span>).unwrap())\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// This can't overflow since self.cap &lt;= isize::MAX.</span>\n            <span class=\"hljs-keyword\">let</span> new_cap = <span class=\"hljs-number\">2</span> * <span class=\"hljs-keyword\">self</span>.cap;\n\n            <span class=\"hljs-comment\">// `Layout::array` checks that the number of bytes is &lt;= usize::MAX,</span>\n            <span class=\"hljs-comment\">// but this is redundant since old_layout.size() &lt;= isize::MAX,</span>\n            <span class=\"hljs-comment\">// so the `unwrap` should never fail.</span>\n            <span class=\"hljs-keyword\">let</span> new_layout = Layout::array::&lt;T&gt;(new_cap).unwrap();\n            (new_cap, new_layout)\n        };\n\n        <span class=\"hljs-comment\">// Ensure that the new allocation doesn't exceed `isize::MAX` bytes.</span>\n        <span class=\"hljs-built_in\">assert!</span>(new_layout.size() &lt;= <span class=\"hljs-built_in\">isize</span>::MAX <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>, <span class=\"hljs-string\">\"Allocation too large\"</span>);\n\n        <span class=\"hljs-keyword\">let</span> new_ptr = <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.cap == <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-keyword\">unsafe</span> { alloc::alloc(new_layout) }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">let</span> old_layout = Layout::array::&lt;T&gt;(<span class=\"hljs-keyword\">self</span>.cap).unwrap();\n            <span class=\"hljs-keyword\">let</span> old_ptr = <span class=\"hljs-keyword\">self</span>.ptr.as_ptr() <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>;\n            <span class=\"hljs-keyword\">unsafe</span> { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        <span class=\"hljs-comment\">// If allocation fails, `new_ptr` will be null, in which case we abort.</span>\n        <span class=\"hljs-keyword\">self</span>.ptr = <span class=\"hljs-keyword\">match</span> NonNull::new(new_ptr <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> T) {\n            <span class=\"hljs-literal\">Some</span>(p) =&gt; p,\n            <span class=\"hljs-literal\">None</span> =&gt; alloc::handle_alloc_error(new_layout),\n        };\n        <span class=\"hljs-keyword\">self</span>.cap = new_cap;\n    }\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../vec/vec-layout.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../vec/vec-push-pop.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../vec/vec-layout.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../vec/vec-push-pop.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:10.182Z"
}