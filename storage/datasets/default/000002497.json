{
	"title": "std::os::unix::io - Rust",
	"url": "https://doc.rust-lang.org/stable/std/os/unix/io/index.html",
	"markdown": "# std::os::unix::io - Rust\n\n## Module [std](../../../index.html)::[os](../../index.html)::[unix](../index.html)::[io](#)\n\n1.0.0 · [source](about:blank/src/std/os/unix/io/mod.rs.html#1-100) ·\n\nAvailable on **Unix** only.\n\nExpand description\n\nUnix-specific extensions to general I/O primitives.\n\nJust like raw pointers, raw file descriptors point to resources with dynamic lifetimes, and they can dangle if they outlive their resources or be forged if they’re created from invalid values.\n\nThis module provides three types for representing file descriptors, with different ownership properties: raw, borrowed, and owned, which are analogous to types used for representing pointers. These types reflect concepts of [I/O safety](about:blank/io/index.html#io-safety \"mod std::io\") on Unix.\n\nLike raw pointers, `RawFd` values are primitive values. And in new code, they should be considered unsafe to do I/O on (analogous to dereferencing them). Rust did not always provide this guidance, so existing code in the Rust ecosystem often doesn’t mark `RawFd` usage as unsafe. Libraries are encouraged to migrate, either by adding `unsafe` to APIs that dereference `RawFd` values, or by using to `BorrowedFd` or `OwnedFd` instead.\n\nThe use of `Arc` for borrowed/owned file descriptors may be surprising. Unix file descriptors are mere references to internal kernel objects called “open file descriptions”, and the same open file description can be referenced by multiple file descriptors (e.g. if `dup` is used). State such as the offset within the file is shared among all file descriptors that refer to the same open file description, and the kernel internally does reference-counting to only close the underlying resource once all file descriptors referencing it are closed. That’s why `Arc` (and not `Box`) is the closest Rust analogy to an “owned” file descriptor.\n\nLike references, `BorrowedFd` values are tied to a lifetime, to ensure that they don’t outlive the resource they point to. These are safe to use. `BorrowedFd` values may be used in APIs which provide safe access to any system call except for:\n\n-   `close`, because that would end the dynamic lifetime of the resource without ending the lifetime of the file descriptor. (Equivalently: an `&Arc<_>` cannot be `drop`ed.)\n    \n-   `dup2`/`dup3`, in the second argument, because this argument is closed and assigned a new resource, which may break the assumptions of other code using that file descriptor.\n    \n\n`BorrowedFd` values may be used in APIs which provide safe access to `dup` system calls, so code working with `OwnedFd` cannot assume to have exclusive access to the underlying open file description. (Equivalently: `&Arc` may be used in APIs that provide safe access to `clone`, so code working with an `Arc` cannot assume that the reference count is 1.)\n\n`BorrowedFd` values may also be used with `mmap`, since `mmap` uses the provided file descriptor in a manner similar to `dup` and does not require the `BorrowedFd` passed to it to live for the lifetime of the resulting mapping. That said, `mmap` is unsafe for other reasons: it operates on raw pointers, and it can have undefined behavior if the underlying storage is mutated. Mutations may come from other processes, or from the same process if the API provides `BorrowedFd` access, since as mentioned earlier, `BorrowedFd` values may be used in APIs which provide safe access to any system call. Consequently, code using `mmap` and presenting a safe API must take full responsibility for ensuring that safe Rust code cannot evoke undefined behavior through it.\n\nLike `Arc`, `OwnedFd` values conceptually own one reference to the resource they point to, and decrement the reference count when they are dropped (by calling `close`). When the reference count reaches 0, the underlying open file description will be freed by the kernel.\n\nSee the [`io` module docs](about:blank/io/index.html#io-safety \"mod std::io\") for a general explanation of I/O safety.\n\n### [§](#procselfmem-and-similar-os-features)`/proc/self/mem` and similar OS features\n\nSome platforms have special files, such as `/proc/self/mem`, which provide read and write access to the process’s memory. Such reads and writes happen outside the control of the Rust compiler, so they do not uphold Rust’s memory safety guarantees.\n\nThis does not mean that all APIs that might allow `/proc/self/mem` to be opened and read from or written must be `unsafe`. Rust’s safety guarantees only cover what the program itself can do, and not what entities outside the program can do to it. `/proc/self/mem` is considered to be such an external entity, along with `/proc/self/fd/*`, debugging interfaces, and people with physical access to the hardware. This is true even in cases where the program is controlling the external entity.\n\nIf you desire to comprehensively prevent programs from reaching out and causing external entities to reach back in and violate memory safety, it’s necessary to use _sandboxing_, which is outside the scope of `std`.\n\n-   `pub use crate::os::[fd](../../fd/index.html \"mod std::os::fd\")::*;`",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Unix-specific extensions to general I/O primitives.\"><title>std::os::unix::io - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../../../\" data-static-root-path=\"../../../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module io</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module io</a></h2><div class=\"sidebar-elems\"><h2><a href=\"../index.html\">In std::os::unix</a></h2><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../raw/index.html\">raw</a></li><li><a href=\"../thread/index.html\">thread</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../../../index.html\">std</a>::<wbr><a href=\"../../index.html\">os</a>::<wbr><a href=\"../index.html\">unix</a>::<wbr><a class=\"mod\" href=\"#\">io</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/io/mod.rs.html#1-100\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>Unix</strong> only.</div></span><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Unix-specific extensions to general I/O primitives.</p>\n<p>Just like raw pointers, raw file descriptors point to resources with\ndynamic lifetimes, and they can dangle if they outlive their resources\nor be forged if they’re created from invalid values.</p>\n<p>This module provides three types for representing file descriptors,\nwith different ownership properties: raw, borrowed, and owned, which are\nanalogous to types used for representing pointers. These types reflect concepts of <a href=\"../../../io/index.html#io-safety\" title=\"mod std::io\">I/O\nsafety</a> on Unix.</p>\n<div><table><thead><tr><th>Type</th><th>Analogous to</th></tr></thead><tbody>\n<tr><td><a href=\"../../fd/type.RawFd.html\" title=\"type std::os::fd::RawFd\"><code>RawFd</code></a></td><td><code>*const _</code></td></tr>\n<tr><td><a href=\"../../fd/struct.BorrowedFd.html\" title=\"struct std::os::fd::BorrowedFd\"><code>BorrowedFd&lt;'a&gt;</code></a></td><td><code>&amp;'a Arc&lt;_&gt;</code></td></tr>\n<tr><td><a href=\"../../fd/struct.OwnedFd.html\" title=\"struct std::os::fd::OwnedFd\"><code>OwnedFd</code></a></td><td><code>Arc&lt;_&gt;</code></td></tr>\n</tbody></table>\n</div>\n<p>Like raw pointers, <code>RawFd</code> values are primitive values. And in new code,\nthey should be considered unsafe to do I/O on (analogous to dereferencing\nthem). Rust did not always provide this guidance, so existing code in the\nRust ecosystem often doesn’t mark <code>RawFd</code> usage as unsafe.\nLibraries are encouraged to migrate,\neither by adding <code>unsafe</code> to APIs that dereference <code>RawFd</code> values, or by\nusing to <code>BorrowedFd</code> or <code>OwnedFd</code> instead.</p>\n<p>The use of <code>Arc</code> for borrowed/owned file descriptors may be surprising. Unix file descriptors\nare mere references to internal kernel objects called “open file descriptions”, and the same\nopen file description can be referenced by multiple file descriptors (e.g. if <code>dup</code> is used).\nState such as the offset within the file is shared among all file descriptors that refer to the\nsame open file description, and the kernel internally does reference-counting to only close the\nunderlying resource once all file descriptors referencing it are closed. That’s why <code>Arc</code> (and\nnot <code>Box</code>) is the closest Rust analogy to an “owned” file descriptor.</p>\n<p>Like references, <code>BorrowedFd</code> values are tied to a lifetime, to ensure\nthat they don’t outlive the resource they point to. These are safe to\nuse. <code>BorrowedFd</code> values may be used in APIs which provide safe access to\nany system call except for:</p>\n<ul>\n<li>\n<p><code>close</code>, because that would end the dynamic lifetime of the resource\nwithout ending the lifetime of the file descriptor. (Equivalently:\nan <code>&amp;Arc&lt;_&gt;</code> cannot be <code>drop</code>ed.)</p>\n</li>\n<li>\n<p><code>dup2</code>/<code>dup3</code>, in the second argument, because this argument is\nclosed and assigned a new resource, which may break the assumptions of\nother code using that file descriptor.</p>\n</li>\n</ul>\n<p><code>BorrowedFd</code> values may be used in APIs which provide safe access to <code>dup</code> system calls, so code\nworking with <code>OwnedFd</code> cannot assume to have exclusive access to the underlying open file\ndescription. (Equivalently: <code>&amp;Arc</code> may be used in APIs that provide safe access to <code>clone</code>, so\ncode working with an <code>Arc</code> cannot assume that the reference count is 1.)</p>\n<p><code>BorrowedFd</code> values may also be used with <code>mmap</code>, since <code>mmap</code> uses the\nprovided file descriptor in a manner similar to <code>dup</code> and does not require\nthe <code>BorrowedFd</code> passed to it to live for the lifetime of the resulting\nmapping. That said, <code>mmap</code> is unsafe for other reasons: it operates on raw\npointers, and it can have undefined behavior if the underlying storage is\nmutated. Mutations may come from other processes, or from the same process\nif the API provides <code>BorrowedFd</code> access, since as mentioned earlier,\n<code>BorrowedFd</code> values may be used in APIs which provide safe access to any\nsystem call. Consequently, code using <code>mmap</code> and presenting a safe API must\ntake full responsibility for ensuring that safe Rust code cannot evoke\nundefined behavior through it.</p>\n<p>Like <code>Arc</code>, <code>OwnedFd</code> values conceptually own one reference to the resource they point to,\nand decrement the reference count when they are dropped (by calling <code>close</code>).\nWhen the reference count reaches 0, the underlying open file description will be freed\nby the kernel.</p>\n<p>See the <a href=\"../../../io/index.html#io-safety\" title=\"mod std::io\"><code>io</code> module docs</a> for a general explanation of I/O safety.</p>\n<h3 id=\"procselfmem-and-similar-os-features\"><a class=\"doc-anchor\" href=\"#procselfmem-and-similar-os-features\">§</a><code>/proc/self/mem</code> and similar OS features</h3>\n<p>Some platforms have special files, such as <code>/proc/self/mem</code>, which\nprovide read and write access to the process’s memory. Such reads\nand writes happen outside the control of the Rust compiler, so they do not\nuphold Rust’s memory safety guarantees.</p>\n<p>This does not mean that all APIs that might allow <code>/proc/self/mem</code>\nto be opened and read from or written must be <code>unsafe</code>. Rust’s safety guarantees\nonly cover what the program itself can do, and not what entities outside\nthe program can do to it. <code>/proc/self/mem</code> is considered to be such an\nexternal entity, along with <code>/proc/self/fd/*</code>, debugging interfaces, and people with physical\naccess to the hardware. This is true even in cases where the program is controlling the external\nentity.</p>\n<p>If you desire to comprehensively prevent programs from reaching out and\ncausing external entities to reach back in and violate memory safety, it’s\nnecessary to use <em>sandboxing</em>, which is outside the scope of <code>std</code>.</p>\n</div></details><h2 id=\"reexports\" class=\"section-header\">Re-exports<a href=\"#reexports\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><code>pub use crate::os::<a class=\"mod\" href=\"../../fd/index.html\" title=\"mod std::os::fd\">fd</a>::*;</code></div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:23:48.004Z"
}