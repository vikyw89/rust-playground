{
	"title": "String in std::string - Rust",
	"url": "https://doc.rust-lang.org/stable/std/string/struct.String.html",
	"markdown": "# String in std::string - Rust\n\n## Struct [std](../index.html)::[string](index.html)::[String](#)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#365) ¬∑\n\n```\npub struct String { /* private fields */ }\n```\n\nExpand description\n\nA UTF-8‚Äìencoded, growable string.\n\n`String` is the most common string type. It has ownership over the contents of the string, stored in a heap-allocated buffer (see [Representation](#representation)). It is closely related to its borrowed counterpart, the primitive [`str`](../primitive.str.html \"str\").\n\n## [¬ß](#examples)Examples\n\nYou can create a `String` from [a literal string](../primitive.str.html \"&str\") with [`String::from`](about:blank/convert/trait.From.html#tymethod.from \"associated function std::convert::From::from\"):\n\n```\nlet hello = String::from(\"Hello, world!\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+hello+=+String::from(%22Hello,+world!%22);%0A%7D&edition=2021)\n\nYou can append a [`char`](../primitive.char.html \"primitive char\") to a `String` with the [`push`](about:blank/struct.String.html#method.push \"method std::string::String::push\") method, and append a [`&str`](../primitive.str.html \"&str\") with the [`push_str`](about:blank/struct.String.html#method.push_str \"method std::string::String::push_str\") method:\n\n```\nlet mut hello = String::from(\"Hello, \");\n\nhello.push('w');\nhello.push_str(\"orld!\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+hello+=+String::from(%22Hello,+%22);%0A++++%0A++++hello.push(%27w%27);%0A++++hello.push_str(%22orld!%22);%0A%7D&edition=2021)\n\nIf you have a vector of UTF-8 bytes, you can create a `String` from it with the [`from_utf8`](about:blank/struct.String.html#method.from_utf8 \"associated function std::string::String::from_utf8\") method:\n\n```\n// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we'll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(\"üíñ\", sparkle_heart);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++//+We+know+these+bytes+are+valid,+so+we%27ll+use+%60unwrap()%60.%0A++++let+sparkle_heart+=+String::from_utf8(sparkle_heart).unwrap();%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&edition=2021)\n\n## [¬ß](#utf-8)UTF-8\n\n`String`s are always valid UTF-8. If you need a non-UTF-8 string, consider [`OsString`](../../std/ffi/struct.OsString.html \"ffi::OsString\"). It is similar, but without the UTF-8 constraint. Because UTF-8 is a variable width encoding, `String`s are typically smaller than an array of the same `chars`:\n\n```\nuse std::mem;\n\n// `s` is ASCII which represents each `char` as one byte\nlet s = \"hello\";\nassert_eq!(s.len(), 5);\n\n// A `char` array with the same contents would be longer because\n// every `char` is four bytes\nlet s = ['h', 'e', 'l', 'l', 'o'];\nlet size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\nassert_eq!(size, 20);\n\n// However, for non-ASCII strings, the difference will be smaller\n// and sometimes they are the same\nlet s = \"üíñüíñüíñüíñüíñ\";\nassert_eq!(s.len(), 20);\n\nlet s = ['üíñ', 'üíñ', 'üíñ', 'üíñ', 'üíñ'];\nlet size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\nassert_eq!(size, 20);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++//+%60s%60+is+ASCII+which+represents+each+%60char%60+as+one+byte%0A++++let+s+=+%22hello%22;%0A++++assert_eq!(s.len(),+5);%0A++++%0A++++//+A+%60char%60+array+with+the+same+contents+would+be+longer+because%0A++++//+every+%60char%60+is+four+bytes%0A++++let+s+=+%5B%27h%27,+%27e%27,+%27l%27,+%27l%27,+%27o%27%5D;%0A++++let+size:+usize+=+s.into_iter().map(%7Cc%7C+mem::size_of_val(%26c)).sum();%0A++++assert_eq!(size,+20);%0A++++%0A++++//+However,+for+non-ASCII+strings,+the+difference+will+be+smaller%0A++++//+and+sometimes+they+are+the+same%0A++++let+s+=+%22%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%22;%0A++++assert_eq!(s.len(),+20);%0A++++%0A++++let+s+=+%5B%27%F0%9F%92%96%27,+%27%F0%9F%92%96%27,+%27%F0%9F%92%96%27,+%27%F0%9F%92%96%27,+%27%F0%9F%92%96%27%5D;%0A++++let+size:+usize+=+s.into_iter().map(%7Cc%7C+mem::size_of_val(%26c)).sum();%0A++++assert_eq!(size,+20);%0A%7D&edition=2021)\n\nThis raises interesting questions as to how `s[i]` should work. What should `i` be here? Several options include byte indices and `char` indices but, because of UTF-8 encoding, only byte indices would provide constant time indexing. Getting the `i`th `char`, for example, is available using [`chars`](about:blank/primitive.str.html#method.chars \"method str::chars\"):\n\n```\nlet s = \"hello\";\nlet third_character = s.chars().nth(2);\nassert_eq!(third_character, Some('l'));\n\nlet s = \"üíñüíñüíñüíñüíñ\";\nlet third_character = s.chars().nth(2);\nassert_eq!(third_character, Some('üíñ'));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22hello%22;%0A++++let+third_character+=+s.chars().nth(2);%0A++++assert_eq!(third_character,+Some(%27l%27));%0A++++%0A++++let+s+=+%22%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%22;%0A++++let+third_character+=+s.chars().nth(2);%0A++++assert_eq!(third_character,+Some(%27%F0%9F%92%96%27));%0A%7D&edition=2021)\n\nNext, what should `s[i]` return? Because indexing returns a reference to underlying data it could be `&u8`, `&[u8]`, or something else similar. Since we‚Äôre only providing one index, `&u8` makes the most sense but that might not be what the user expects and can be explicitly achieved with [`as_bytes()`](about:blank/primitive.str.html#method.as_bytes \"method str::as_bytes\"):\n\n```\n// The first byte is 104 - the byte value of `'h'`\nlet s = \"hello\";\nassert_eq!(s.as_bytes()[0], 104);\n// or\nassert_eq!(s.as_bytes()[0], b'h');\n\n// The first byte is 240 which isn't obviously useful\nlet s = \"üíñüíñüíñüíñüíñ\";\nassert_eq!(s.as_bytes()[0], 240);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+The+first+byte+is+104+-+the+byte+value+of+%60%27h%27%60%0Afn+main()+%7B%0A++++let+s+=+%22hello%22;%0A++++assert_eq!(s.as_bytes()%5B0%5D,+104);%0A++++//+or%0A++++assert_eq!(s.as_bytes()%5B0%5D,+b%27h%27);%0A++++%0A++++//+The+first+byte+is+240+which+isn%27t+obviously+useful%0A++++let+s+=+%22%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%22;%0A++++assert_eq!(s.as_bytes()%5B0%5D,+240);%0A%7D&edition=2021)\n\nDue to these ambiguities/restrictions, indexing with a `usize` is simply forbidden:\n\n[‚ìò](# \"This example deliberately fails to compile\")\n\n```\nlet s = \"hello\";\n\n// The following will not compile!\nprintln!(\"The first letter of s is {}\", s[0]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22hello%22;%0A++++%0A++++//+The+following+will+not+compile!%0A++++println!(%22The+first+letter+of+s+is+%7B%7D%22,+s%5B0%5D);%0A%7D&edition=2021)\n\nIt is more clear, however, how `&s[i..j]` should work (that is, indexing with a range). It should accept byte indices (to be constant-time) and return a `&str` which is UTF-8 encoded. This is also called ‚Äústring slicing‚Äù. Note this will panic if the byte indices provided are not character boundaries - see [`is_char_boundary`](about:blank/primitive.str.html#method.is_char_boundary \"method str::is_char_boundary\") for more details. See the implementations for [`SliceIndex<str>`](../slice/trait.SliceIndex.html \"trait std::slice::SliceIndex\") for more details on string slicing. For a non-panicking version of string slicing, see [`get`](about:blank/primitive.str.html#method.get \"method str::get\").\n\nThe [`bytes`](about:blank/primitive.str.html#method.bytes \"method str::bytes\") and [`chars`](about:blank/primitive.str.html#method.chars \"method str::chars\") methods return iterators over the bytes and codepoints of the string, respectively. To iterate over codepoints along with byte indices, use [`char_indices`](about:blank/primitive.str.html#method.char_indices \"method str::char_indices\").\n\n## [¬ß](#deref)Deref\n\n`String` implements `[Deref](../ops/trait.Deref.html \"ops::Deref\")<Target = [str](../primitive.str.html \"str\")>`, and so inherits all of [`str`](../primitive.str.html \"str\")‚Äôs methods. In addition, this means that you can pass a `String` to a function which takes a [`&str`](../primitive.str.html \"&str\") by using an ampersand (`&`):\n\n```\nfn takes_str(s: &str) { }\n\nlet s = String::from(\"Hello\");\n\ntakes_str(&s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+takes_str(s:+%26str)+%7B+%7D%0A++++%0A++++let+s+=+String::from(%22Hello%22);%0A++++%0A++++takes_str(%26s);%0A%7D&edition=2021)\n\nThis will create a [`&str`](../primitive.str.html \"&str\") from the `String` and pass it in. This conversion is very inexpensive, and so generally, functions will accept [`&str`](../primitive.str.html \"&str\")s as arguments unless they need a `String` for some specific reason.\n\nIn certain cases Rust doesn‚Äôt have enough information to make this conversion, known as [`Deref`](../ops/trait.Deref.html \"ops::Deref\") coercion. In the following example a string slice [`&'a str`](../primitive.str.html \"&str\") implements the trait `TraitExample`, and the function `example_func` takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn‚Äôt have the means to do. For that reason, the following example will not compile.\n\n[‚ìò](# \"This example deliberately fails to compile\")\n\n```\ntrait TraitExample {}\n\nimpl<'a> TraitExample for &'a str {}\n\nfn example_func<A: TraitExample>(example_arg: A) {}\n\nlet example_string = String::from(\"example_string\");\nexample_func(&example_string);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++trait+TraitExample+%7B%7D%0A++++%0A++++impl%3C%27a%3E+TraitExample+for+%26%27a+str+%7B%7D%0A++++%0A++++fn+example_func%3CA:+TraitExample%3E(example_arg:+A)+%7B%7D%0A++++%0A++++let+example_string+=+String::from(%22example_string%22);%0A++++example_func(%26example_string);%0A%7D&edition=2021)\n\nThere are two options that would work instead. The first would be to change the line `example_func(&example_string);` to `example_func(example_string.as_str());`, using the method [`as_str()`](about:blank/struct.String.html#method.as_str \"method std::string::String::as_str\") to explicitly extract the string slice containing the string. The second way changes `example_func(&example_string);` to `example_func(&*example_string);`. In this case we are dereferencing a `String` to a [`str`](../primitive.str.html \"str\"), then referencing the [`str`](../primitive.str.html \"str\") back to [`&str`](../primitive.str.html \"&str\"). The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion.\n\n## [¬ß](#representation)Representation\n\nA `String` is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to the internal buffer which `String` uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.\n\nThis buffer is always stored on the heap.\n\nYou can look at these with the [`as_ptr`](about:blank/primitive.str.html#method.as_ptr \"method str::as_ptr\"), [`len`](about:blank/struct.String.html#method.len \"method std::string::String::len\"), and [`capacity`](about:blank/struct.String.html#method.capacity \"method std::string::String::capacity\") methods:\n\n```\nuse std::mem;\n\nlet story = String::from(\"Once upon a time...\");\n\n// Prevent automatically dropping the String's data\nlet mut story = mem::ManuallyDrop::new(story);\n\nlet ptr = story.as_mut_ptr();\nlet len = story.len();\nlet capacity = story.capacity();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a String out of ptr, len, and capacity. This is all\n// unsafe because we are responsible for making sure the components are\n// valid:\nlet s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n\nassert_eq!(String::from(\"Once upon a time...\"), s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++let+story+=+String::from(%22Once+upon+a+time...%22);%0A++++%0A++++//+Prevent+automatically+dropping+the+String%27s+data%0A++++let+mut+story+=+mem::ManuallyDrop::new(story);%0A++++%0A++++let+ptr+=+story.as_mut_ptr();%0A++++let+len+=+story.len();%0A++++let+capacity+=+story.capacity();%0A++++%0A++++//+story+has+nineteen+bytes%0A++++assert_eq!(19,+len);%0A++++%0A++++//+We+can+re-build+a+String+out+of+ptr,+len,+and+capacity.+This+is+all%0A++++//+unsafe+because+we+are+responsible+for+making+sure+the+components+are%0A++++//+valid:%0A++++let+s+=+unsafe+%7B+String::from_raw_parts(ptr,+len,+capacity)+%7D+;%0A++++%0A++++assert_eq!(String::from(%22Once+upon+a+time...%22),+s);%0A%7D&edition=2021)\n\nIf a `String` has enough capacity, adding elements to it will not re-allocate. For example, consider this program:\n\n```\nlet mut s = String::new();\n\nprintln!(\"{}\", s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(\"hello\");\n    println!(\"{}\", s.capacity());\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::new();%0A++++%0A++++println!(%22%7B%7D%22,+s.capacity());%0A++++%0A++++for+_+in+0..5+%7B%0A++++++++s.push_str(%22hello%22);%0A++++++++println!(%22%7B%7D%22,+s.capacity());%0A++++%7D%0A%7D&edition=2021)\n\nThis will output the following:\n\nAt first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the [`with_capacity`](about:blank/struct.String.html#method.with_capacity \"associated function std::string::String::with_capacity\") method to allocate the correct capacity initially:\n\n```\nlet mut s = String::with_capacity(25);\n\nprintln!(\"{}\", s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(\"hello\");\n    println!(\"{}\", s.capacity());\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(25);%0A++++%0A++++println!(%22%7B%7D%22,+s.capacity());%0A++++%0A++++for+_+in+0..5+%7B%0A++++++++s.push_str(%22hello%22);%0A++++++++println!(%22%7B%7D%22,+s.capacity());%0A++++%7D%0A%7D&edition=2021)\n\nWe end up with a different output:\n\nHere, there‚Äôs no need to allocate more memory inside the loop.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#427)[¬ß](#impl-String)\n\n1.0.0 (const: 1.39.0) ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#448)\n\nCreates a new empty `String`.\n\nGiven that the `String` is empty, this will not allocate any initial buffer. While that means that this initial operation is very inexpensive, it may cause excessive allocation later when you add data. If you have an idea of how much data the `String` will hold, consider the [`with_capacity`](about:blank/struct.String.html#method.with_capacity \"associated function std::string::String::with_capacity\") method to prevent excessive re-allocation.\n\n##### [¬ß](#examples-1)Examples\n\n```\nlet s = String::new();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::new();%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#491)\n\nCreates a new empty `String` with at least the specified capacity.\n\n`String`s have an internal buffer to hold their data. The capacity is the length of that buffer, and can be queried with the [`capacity`](about:blank/struct.String.html#method.capacity \"method std::string::String::capacity\") method. This method creates an empty `String`, but one with an initial buffer that can hold at least `capacity` bytes. This is useful when you may be appending a bunch of data to the `String`, reducing the number of reallocations it needs to do.\n\nIf the given capacity is `0`, no allocation will occur, and this method is identical to the [`new`](about:blank/struct.String.html#method.new \"associated function std::string::String::new\") method.\n\n##### [¬ß](#examples-2)Examples\n\n```\nlet mut s = String::with_capacity(10);\n\n// The String contains no chars, even though it has capacity for more\nassert_eq!(s.len(), 0);\n\n// These are all done without reallocating...\nlet cap = s.capacity();\nfor _ in 0..10 {\n    s.push('a');\n}\n\nassert_eq!(s.capacity(), cap);\n\n// ...but this may make the string reallocate\ns.push('a');\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(10);%0A++++%0A++++//+The+String+contains+no+chars,+even+though+it+has+capacity+for+more%0A++++assert_eq!(s.len(),+0);%0A++++%0A++++//+These+are+all+done+without+reallocating...%0A++++let+cap+=+s.capacity();%0A++++for+_+in+0..10+%7B%0A++++++++s.push(%27a%27);%0A++++%7D%0A++++%0A++++assert_eq!(s.capacity(),+cap);%0A++++%0A++++//+...but+this+may+make+the+string+reallocate%0A++++s.push(%27a%27);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#504)\n\nüî¨This is a nightly-only experimental API. (`try_with_capacity`¬†[#91913](https://github.com/rust-lang/rust/issues/91913))\n\nCreates a new empty `String` with at least the specified capacity.\n\n##### [¬ß](#errors)Errors\n\nReturns [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") if the capacity exceeds `isize::MAX` bytes, or if the memory allocator reports failure.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#576)\n\nConverts a vector of bytes to a `String`.\n\nA string ([`String`](struct.String.html \"struct std::string::String\")) is made of bytes ([`u8`](../primitive.u8.html \"primitive u8\")), and a vector of bytes ([`Vec<u8>`](../vec/struct.Vec.html \"Vec\")) is made of bytes, so this function converts between the two. Not all byte slices are valid `String`s, however: `String` requires that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid UTF-8, and then does the conversion.\n\nIf you are sure that the byte slice is valid UTF-8, and you don‚Äôt want to incur the overhead of the validity check, there is an unsafe version of this function, [`from_utf8_unchecked`](about:blank/struct.String.html#method.from_utf8_unchecked \"associated function std::string::String::from_utf8_unchecked\"), which has the same behavior but skips the check.\n\nThis method will take care to not copy the vector, for efficiency‚Äôs sake.\n\nIf you need a [`&str`](../primitive.str.html \"&str\") instead of a `String`, consider [`str::from_utf8`](../str/fn.from_utf8.html \"fn std::str::from_utf8\").\n\nThe inverse of this method is [`into_bytes`](about:blank/struct.String.html#method.into_bytes \"method std::string::String::into_bytes\").\n\n##### [¬ß](#errors-1)Errors\n\nReturns [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") if the slice is not UTF-8 with a description as to why the provided bytes are not UTF-8. The vector you moved in is also included.\n\n##### [¬ß](#examples-3)Examples\n\nBasic usage:\n\n```\n// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we'll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(\"üíñ\", sparkle_heart);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++//+We+know+these+bytes+are+valid,+so+we%27ll+use+%60unwrap()%60.%0A++++let+sparkle_heart+=+String::from_utf8(sparkle_heart).unwrap();%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&edition=2021)\n\nIncorrect bytes:\n\n```\n// some invalid bytes, in a vector\nlet sparkle_heart = vec![0, 159, 146, 150];\n\nassert!(String::from_utf8(sparkle_heart).is_err());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+invalid+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B0,+159,+146,+150%5D;%0A++++%0A++++assert!(String::from_utf8(sparkle_heart).is_err());%0A%7D&edition=2021)\n\nSee the docs for [`FromUtf8Error`](struct.FromUtf8Error.html \"struct std::string::FromUtf8Error\") for more details on what you can do with this error.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#635)\n\nConverts a slice of bytes to a string, including invalid characters.\n\nStrings are made of bytes ([`u8`](../primitive.u8.html \"primitive u8\")), and a slice of bytes ([`&[u8]`](../primitive.slice.html \"primitive slice\")) is made of bytes, so this function converts between the two. Not all byte slices are valid strings, however: strings are required to be valid UTF-8. During this conversion, `from_utf8_lossy()` will replace any invalid UTF-8 sequences with [`U+FFFD REPLACEMENT CHARACTER`](../char/constant.REPLACEMENT_CHARACTER.html \"constant std::char::REPLACEMENT_CHARACTER\"), which looks like this: ÔøΩ\n\nIf you are sure that the byte slice is valid UTF-8, and you don‚Äôt want to incur the overhead of the conversion, there is an unsafe version of this function, [`from_utf8_unchecked`](about:blank/struct.String.html#method.from_utf8_unchecked \"associated function std::string::String::from_utf8_unchecked\"), which has the same behavior but skips the checks.\n\nThis function returns a [`Cow<'a, str>`](../borrow/enum.Cow.html \"borrow::Cow\"). If our byte slice is invalid UTF-8, then we need to insert the replacement characters, which will change the size of the string, and hence, require a `String`. But if it‚Äôs already valid UTF-8, we don‚Äôt need a new allocation. This return type allows us to handle both cases.\n\n##### [¬ß](#examples-4)Examples\n\nBasic usage:\n\n```\n// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\nlet sparkle_heart = String::from_utf8_lossy(&sparkle_heart);\n\nassert_eq!(\"üíñ\", sparkle_heart);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++let+sparkle_heart+=+String::from_utf8_lossy(%26sparkle_heart);%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&edition=2021)\n\nIncorrect bytes:\n\n```\n// some invalid bytes\nlet input = b\"Hello \\xF0\\x90\\x80World\";\nlet output = String::from_utf8_lossy(input);\n\nassert_eq!(\"Hello ÔøΩWorld\", output);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+invalid+bytes%0Afn+main()+%7B%0A++++let+input+=+b%22Hello+%5CxF0%5Cx90%5Cx80World%22;%0A++++let+output+=+String::from_utf8_lossy(input);%0A++++%0A++++assert_eq!(%22Hello+%EF%BF%BDWorld%22,+output);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#684)\n\nDecode a UTF-16‚Äìencoded vector `v` into a `String`, returning [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") if `v` contains any invalid data.\n\n##### [¬ß](#examples-5)Examples\n\n```\n// ùÑûmusic\nlet v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n          0x0073, 0x0069, 0x0063];\nassert_eq!(String::from(\"ùÑûmusic\"),\n           String::from_utf16(v).unwrap());\n\n// ùÑûmu<invalid>ic\nlet v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n          0xD800, 0x0069, 0x0063];\nassert!(String::from_utf16(v).is_err());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%F0%9D%84%9Emusic%0Afn+main()+%7B%0A++++let+v+=+%26%5B0xD834,+0xDD1E,+0x006d,+0x0075,%0A++++++++++++++0x0073,+0x0069,+0x0063%5D;%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emusic%22),%0A+++++++++++++++String::from_utf16(v).unwrap());%0A++++%0A++++//+%F0%9D%84%9Emu%3Cinvalid%3Eic%0A++++let+v+=+%26%5B0xD834,+0xDD1E,+0x006d,+0x0075,%0A++++++++++++++0xD800,+0x0069,+0x0063%5D;%0A++++assert!(String::from_utf16(v).is_err());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#724)\n\nDecode a UTF-16‚Äìencoded slice `v` into a `String`, replacing invalid data with [the replacement character (`U+FFFD`)](../char/constant.REPLACEMENT_CHARACTER.html \"constant std::char::REPLACEMENT_CHARACTER\").\n\nUnlike [`from_utf8_lossy`](about:blank/struct.String.html#method.from_utf8_lossy \"associated function std::string::String::from_utf8_lossy\") which returns a [`Cow<'a, str>`](../borrow/enum.Cow.html \"borrow::Cow\"), `from_utf16_lossy` returns a `String` since the UTF-16 to UTF-8 conversion requires a memory allocation.\n\n##### [¬ß](#examples-6)Examples\n\n```\n// ùÑûmus<invalid>ic<invalid>\nlet v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n          0x0073, 0xDD1E, 0x0069, 0x0063,\n          0xD834];\n\nassert_eq!(String::from(\"ùÑûmus\\u{FFFD}ic\\u{FFFD}\"),\n           String::from_utf16_lossy(v));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%F0%9D%84%9Emus%3Cinvalid%3Eic%3Cinvalid%3E%0Afn+main()+%7B%0A++++let+v+=+%26%5B0xD834,+0xDD1E,+0x006d,+0x0075,%0A++++++++++++++0x0073,+0xDD1E,+0x0069,+0x0063,%0A++++++++++++++0xD834%5D;%0A++++%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emus%5Cu%7BFFFD%7Dic%5Cu%7BFFFD%7D%22),%0A+++++++++++++++String::from_utf16_lossy(v));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#752)\n\nüî¨This is a nightly-only experimental API. (`str_from_utf16_endian`¬†[#116258](https://github.com/rust-lang/rust/issues/116258))\n\nDecode a UTF-16LE‚Äìencoded vector `v` into a `String`, returning [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") if `v` contains any invalid data.\n\n##### [¬ß](#examples-7)Examples\n\nBasic usage:\n\n```\n#![feature(str_from_utf16_endian)]\n// ùÑûmusic\nlet v = &[0x34, 0xD8, 0x1E, 0xDD, 0x6d, 0x00, 0x75, 0x00,\n          0x73, 0x00, 0x69, 0x00, 0x63, 0x00];\nassert_eq!(String::from(\"ùÑûmusic\"),\n           String::from_utf16le(v).unwrap());\n\n// ùÑûmu<invalid>ic\nlet v = &[0x34, 0xD8, 0x1E, 0xDD, 0x6d, 0x00, 0x75, 0x00,\n          0x00, 0xD8, 0x69, 0x00, 0x63, 0x00];\nassert!(String::from_utf16le(v).is_err());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(str_from_utf16_endian)%5D%0A//+%F0%9D%84%9Emusic%0Afn+main()+%7B%0A++++let+v+=+%26%5B0x34,+0xD8,+0x1E,+0xDD,+0x6d,+0x00,+0x75,+0x00,%0A++++++++++++++0x73,+0x00,+0x69,+0x00,+0x63,+0x00%5D;%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emusic%22),%0A+++++++++++++++String::from_utf16le(v).unwrap());%0A++++%0A++++//+%F0%9D%84%9Emu%3Cinvalid%3Eic%0A++++let+v+=+%26%5B0x34,+0xD8,+0x1E,+0xDD,+0x6d,+0x00,+0x75,+0x00,%0A++++++++++++++0x00,+0xD8,+0x69,+0x00,+0x63,+0x00%5D;%0A++++assert!(String::from_utf16le(v).is_err());%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#791)\n\nüî¨This is a nightly-only experimental API. (`str_from_utf16_endian`¬†[#116258](https://github.com/rust-lang/rust/issues/116258))\n\nDecode a UTF-16LE‚Äìencoded slice `v` into a `String`, replacing invalid data with [the replacement character (`U+FFFD`)](../char/constant.REPLACEMENT_CHARACTER.html \"constant std::char::REPLACEMENT_CHARACTER\").\n\nUnlike [`from_utf8_lossy`](about:blank/struct.String.html#method.from_utf8_lossy \"associated function std::string::String::from_utf8_lossy\") which returns a [`Cow<'a, str>`](../borrow/enum.Cow.html \"borrow::Cow\"), `from_utf16le_lossy` returns a `String` since the UTF-16 to UTF-8 conversion requires a memory allocation.\n\n##### [¬ß](#examples-8)Examples\n\nBasic usage:\n\n```\n#![feature(str_from_utf16_endian)]\n// ùÑûmus<invalid>ic<invalid>\nlet v = &[0x34, 0xD8, 0x1E, 0xDD, 0x6d, 0x00, 0x75, 0x00,\n          0x73, 0x00, 0x1E, 0xDD, 0x69, 0x00, 0x63, 0x00,\n          0x34, 0xD8];\n\nassert_eq!(String::from(\"ùÑûmus\\u{FFFD}ic\\u{FFFD}\"),\n           String::from_utf16le_lossy(v));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(str_from_utf16_endian)%5D%0A//+%F0%9D%84%9Emus%3Cinvalid%3Eic%3Cinvalid%3E%0Afn+main()+%7B%0A++++let+v+=+%26%5B0x34,+0xD8,+0x1E,+0xDD,+0x6d,+0x00,+0x75,+0x00,%0A++++++++++++++0x73,+0x00,+0x1E,+0xDD,+0x69,+0x00,+0x63,+0x00,%0A++++++++++++++0x34,+0xD8%5D;%0A++++%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emus%5Cu%7BFFFD%7Dic%5Cu%7BFFFD%7D%22),%0A+++++++++++++++String::from_utf16le_lossy(v));%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#827)\n\nüî¨This is a nightly-only experimental API. (`str_from_utf16_endian`¬†[#116258](https://github.com/rust-lang/rust/issues/116258))\n\nDecode a UTF-16BE‚Äìencoded vector `v` into a `String`, returning [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") if `v` contains any invalid data.\n\n##### [¬ß](#examples-9)Examples\n\nBasic usage:\n\n```\n#![feature(str_from_utf16_endian)]\n// ùÑûmusic\nlet v = &[0xD8, 0x34, 0xDD, 0x1E, 0x00, 0x6d, 0x00, 0x75,\n          0x00, 0x73, 0x00, 0x69, 0x00, 0x63];\nassert_eq!(String::from(\"ùÑûmusic\"),\n           String::from_utf16be(v).unwrap());\n\n// ùÑûmu<invalid>ic\nlet v = &[0xD8, 0x34, 0xDD, 0x1E, 0x00, 0x6d, 0x00, 0x75,\n          0xD8, 0x00, 0x00, 0x69, 0x00, 0x63];\nassert!(String::from_utf16be(v).is_err());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(str_from_utf16_endian)%5D%0A//+%F0%9D%84%9Emusic%0Afn+main()+%7B%0A++++let+v+=+%26%5B0xD8,+0x34,+0xDD,+0x1E,+0x00,+0x6d,+0x00,+0x75,%0A++++++++++++++0x00,+0x73,+0x00,+0x69,+0x00,+0x63%5D;%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emusic%22),%0A+++++++++++++++String::from_utf16be(v).unwrap());%0A++++%0A++++//+%F0%9D%84%9Emu%3Cinvalid%3Eic%0A++++let+v+=+%26%5B0xD8,+0x34,+0xDD,+0x1E,+0x00,+0x6d,+0x00,+0x75,%0A++++++++++++++0xD8,+0x00,+0x00,+0x69,+0x00,+0x63%5D;%0A++++assert!(String::from_utf16be(v).is_err());%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#866)\n\nüî¨This is a nightly-only experimental API. (`str_from_utf16_endian`¬†[#116258](https://github.com/rust-lang/rust/issues/116258))\n\nDecode a UTF-16BE‚Äìencoded slice `v` into a `String`, replacing invalid data with [the replacement character (`U+FFFD`)](../char/constant.REPLACEMENT_CHARACTER.html \"constant std::char::REPLACEMENT_CHARACTER\").\n\nUnlike [`from_utf8_lossy`](about:blank/struct.String.html#method.from_utf8_lossy \"associated function std::string::String::from_utf8_lossy\") which returns a [`Cow<'a, str>`](../borrow/enum.Cow.html \"borrow::Cow\"), `from_utf16le_lossy` returns a `String` since the UTF-16 to UTF-8 conversion requires a memory allocation.\n\n##### [¬ß](#examples-10)Examples\n\nBasic usage:\n\n```\n#![feature(str_from_utf16_endian)]\n// ùÑûmus<invalid>ic<invalid>\nlet v = &[0xD8, 0x34, 0xDD, 0x1E, 0x00, 0x6d, 0x00, 0x75,\n          0x00, 0x73, 0xDD, 0x1E, 0x00, 0x69, 0x00, 0x63,\n          0xD8, 0x34];\n\nassert_eq!(String::from(\"ùÑûmus\\u{FFFD}ic\\u{FFFD}\"),\n           String::from_utf16be_lossy(v));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(str_from_utf16_endian)%5D%0A//+%F0%9D%84%9Emus%3Cinvalid%3Eic%3Cinvalid%3E%0Afn+main()+%7B%0A++++let+v+=+%26%5B0xD8,+0x34,+0xDD,+0x1E,+0x00,+0x6d,+0x00,+0x75,%0A++++++++++++++0x00,+0x73,+0xDD,+0x1E,+0x00,+0x69,+0x00,+0x63,%0A++++++++++++++0xD8,+0x34%5D;%0A++++%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emus%5Cu%7BFFFD%7Dic%5Cu%7BFFFD%7D%22),%0A+++++++++++++++String::from_utf16be_lossy(v));%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#908)\n\nüî¨This is a nightly-only experimental API. (`vec_into_raw_parts`¬†[#65816](https://github.com/rust-lang/rust/issues/65816))\n\nDecomposes a `String` into its raw components: `(pointer, length, capacity)`.\n\nReturns the raw pointer to the underlying data, the length of the string (in bytes), and the allocated capacity of the data (in bytes). These are the same arguments in the same order as the arguments to [`from_raw_parts`](about:blank/struct.String.html#method.from_raw_parts \"associated function std::string::String::from_raw_parts\").\n\nAfter calling this function, the caller is responsible for the memory previously managed by the `String`. The only way to do this is to convert the raw pointer, length, and capacity back into a `String` with the [`from_raw_parts`](about:blank/struct.String.html#method.from_raw_parts \"associated function std::string::String::from_raw_parts\") function, allowing the destructor to perform the cleanup.\n\n##### [¬ß](#examples-11)Examples\n\n```\n#![feature(vec_into_raw_parts)]\nlet s = String::from(\"hello\");\n\nlet (ptr, len, cap) = s.into_raw_parts();\n\nlet rebuilt = unsafe { String::from_raw_parts(ptr, len, cap) };\nassert_eq!(rebuilt, \"hello\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(vec_into_raw_parts)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22hello%22);%0A++++%0A++++let+(ptr,+len,+cap)+=+s.into_raw_parts();%0A++++%0A++++let+rebuilt+=+unsafe+%7B+String::from_raw_parts(ptr,+len,+cap)+%7D;%0A++++assert_eq!(rebuilt,+%22hello%22);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#960)\n\nCreates a new `String` from a pointer, a length and a capacity.\n\n##### [¬ß](#safety)Safety\n\nThis is highly unsafe, due to the number of invariants that aren‚Äôt checked:\n\n-   The memory at `buf` needs to have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.\n-   `length` needs to be less than or equal to `capacity`.\n-   `capacity` needs to be the correct value.\n-   The first `length` bytes at `buf` need to be valid UTF-8.\n\nViolating these may cause problems like corrupting the allocator‚Äôs internal data structures. For example, it is normally **not** safe to build a `String` from a pointer to a C `char` array containing UTF-8 _unless_ you are certain that array was originally allocated by the Rust standard library‚Äôs allocator.\n\nThe ownership of `buf` is effectively transferred to the `String` which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.\n\n##### [¬ß](#examples-12)Examples\n\n```\nuse std::mem;\n\nunsafe {\n    let s = String::from(\"hello\");\n\n    // Prevent automatically dropping the String's data\n    let mut s = mem::ManuallyDrop::new(s);\n\n    let ptr = s.as_mut_ptr();\n    let len = s.len();\n    let capacity = s.capacity();\n\n    let s = String::from_raw_parts(ptr, len, capacity);\n\n    assert_eq!(String::from(\"hello\"), s);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++unsafe+%7B%0A++++++++let+s+=+String::from(%22hello%22);%0A++++%0A++++++++//+Prevent+automatically+dropping+the+String%27s+data%0A++++++++let+mut+s+=+mem::ManuallyDrop::new(s);%0A++++%0A++++++++let+ptr+=+s.as_mut_ptr();%0A++++++++let+len+=+s.len();%0A++++++++let+capacity+=+s.capacity();%0A++++%0A++++++++let+s+=+String::from_raw_parts(ptr,+len,+capacity);%0A++++%0A++++++++assert_eq!(String::from(%22hello%22),+s);%0A++++%7D%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#993)\n\nConverts a vector of bytes to a `String` without checking that the string contains valid UTF-8.\n\nSee the safe version, [`from_utf8`](about:blank/struct.String.html#method.from_utf8 \"associated function std::string::String::from_utf8\"), for more details.\n\n##### [¬ß](#safety-1)Safety\n\nThis function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the `String`, as the rest of the standard library assumes that `String`s are valid UTF-8.\n\n##### [¬ß](#examples-13)Examples\n\n```\n// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\nlet sparkle_heart = unsafe {\n    String::from_utf8_unchecked(sparkle_heart)\n};\n\nassert_eq!(\"üíñ\", sparkle_heart);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++let+sparkle_heart+=+unsafe+%7B%0A++++++++String::from_utf8_unchecked(sparkle_heart)%0A++++%7D;%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1012)\n\nConverts a `String` into a byte vector.\n\nThis consumes the `String`, so we do not need to copy its contents.\n\n##### [¬ß](#examples-14)Examples\n\n```\nlet s = String::from(\"hello\");\nlet bytes = s.into_bytes();\n\nassert_eq!(&[104, 101, 108, 108, 111][..], &bytes[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22hello%22);%0A++++let+bytes+=+s.into_bytes();%0A++++%0A++++assert_eq!(%26%5B104,+101,+108,+108,+111%5D%5B..%5D,+%26bytes%5B..%5D);%0A%7D&edition=2021)\n\n1.7.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1028)\n\nExtracts a string slice containing the entire `String`.\n\n##### [¬ß](#examples-15)Examples\n\n```\nlet s = String::from(\"foo\");\n\nassert_eq!(\"foo\", s.as_str());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22foo%22);%0A++++%0A++++assert_eq!(%22foo%22,+s.as_str());%0A%7D&edition=2021)\n\n1.7.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1047)\n\nConverts a `String` into a mutable string slice.\n\n##### [¬ß](#examples-16)Examples\n\n```\nlet mut s = String::from(\"foobar\");\nlet s_mut_str = s.as_mut_str();\n\ns_mut_str.make_ascii_uppercase();\n\nassert_eq!(\"FOOBAR\", s_mut_str);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foobar%22);%0A++++let+s_mut_str+=+s.as_mut_str();%0A++++%0A++++s_mut_str.make_ascii_uppercase();%0A++++%0A++++assert_eq!(%22FOOBAR%22,+s_mut_str);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1066)\n\nAppends a given string slice onto the end of this `String`.\n\n##### [¬ß](#examples-17)Examples\n\n```\nlet mut s = String::from(\"foo\");\n\ns.push_str(\"bar\");\n\nassert_eq!(\"foobar\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foo%22);%0A++++%0A++++s.push_str(%22bar%22);%0A++++%0A++++assert_eq!(%22foobar%22,+s);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1094-1096)\n\nüî¨This is a nightly-only experimental API. (`string_extend_from_within`¬†[#103806](https://github.com/rust-lang/rust/issues/103806))\n\nCopies elements from `src` range to the end of the string.\n\n##### [¬ß](#panics)Panics\n\nPanics if the starting point or end point do not lie on a [`char`](../primitive.char.html \"primitive char\") boundary, or if they‚Äôre out of bounds.\n\n##### [¬ß](#examples-18)Examples\n\n```\n#![feature(string_extend_from_within)]\nlet mut string = String::from(\"abcde\");\n\nstring.extend_from_within(2..);\nassert_eq!(string, \"abcdecde\");\n\nstring.extend_from_within(..2);\nassert_eq!(string, \"abcdecdeab\");\n\nstring.extend_from_within(4..8);\nassert_eq!(string, \"abcdecdeabecde\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(string_extend_from_within)%5D%0Afn+main()+%7B%0A++++let+mut+string+=+String::from(%22abcde%22);%0A++++%0A++++string.extend_from_within(2..);%0A++++assert_eq!(string,+%22abcdecde%22);%0A++++%0A++++string.extend_from_within(..2);%0A++++assert_eq!(string,+%22abcdecdeab%22);%0A++++%0A++++string.extend_from_within(4..8);%0A++++assert_eq!(string,+%22abcdecdeabecde%22);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1118)\n\nReturns this `String`‚Äôs capacity, in bytes.\n\n##### [¬ß](#examples-19)Examples\n\n```\nlet s = String::with_capacity(10);\n\nassert!(s.capacity() >= 10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::with_capacity(10);%0A++++%0A++++assert!(s.capacity()+%3E=+10);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1165)\n\nReserves capacity for at least `additional` bytes more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling `reserve`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if capacity is already sufficient.\n\n##### [¬ß](#panics-1)Panics\n\nPanics if the new capacity overflows [`usize`](../primitive.usize.html \"primitive usize\").\n\n##### [¬ß](#examples-20)Examples\n\nBasic usage:\n\n```\nlet mut s = String::new();\n\ns.reserve(10);\n\nassert!(s.capacity() >= 10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::new();%0A++++%0A++++s.reserve(10);%0A++++%0A++++assert!(s.capacity()+%3E=+10);%0A%7D&edition=2021)\n\nThis might not actually increase the capacity:\n\n```\nlet mut s = String::with_capacity(10);\ns.push('a');\ns.push('b');\n\n// s now has a length of 2 and a capacity of at least 10\nlet capacity = s.capacity();\nassert_eq!(2, s.len());\nassert!(capacity >= 10);\n\n// Since we already have at least an extra 8 capacity, calling this...\ns.reserve(8);\n\n// ... doesn't actually increase.\nassert_eq!(capacity, s.capacity());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(10);%0A++++s.push(%27a%27);%0A++++s.push(%27b%27);%0A++++%0A++++//+s+now+has+a+length+of+2+and+a+capacity+of+at+least+10%0A++++let+capacity+=+s.capacity();%0A++++assert_eq!(2,+s.len());%0A++++assert!(capacity+%3E=+10);%0A++++%0A++++//+Since+we+already+have+at+least+an+extra+8+capacity,+calling+this...%0A++++s.reserve(8);%0A++++%0A++++//+...+doesn%27t+actually+increase.%0A++++assert_eq!(capacity,+s.capacity());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1215)\n\nReserves the minimum capacity for at least `additional` bytes more than the current length. Unlike [`reserve`](about:blank/struct.String.html#method.reserve \"method std::string::String::reserve\"), this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling `reserve_exact`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if the capacity is already sufficient.\n\n##### [¬ß](#panics-2)Panics\n\nPanics if the new capacity overflows [`usize`](../primitive.usize.html \"primitive usize\").\n\n##### [¬ß](#examples-21)Examples\n\nBasic usage:\n\n```\nlet mut s = String::new();\n\ns.reserve_exact(10);\n\nassert!(s.capacity() >= 10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::new();%0A++++%0A++++s.reserve_exact(10);%0A++++%0A++++assert!(s.capacity()+%3E=+10);%0A%7D&edition=2021)\n\nThis might not actually increase the capacity:\n\n```\nlet mut s = String::with_capacity(10);\ns.push('a');\ns.push('b');\n\n// s now has a length of 2 and a capacity of at least 10\nlet capacity = s.capacity();\nassert_eq!(2, s.len());\nassert!(capacity >= 10);\n\n// Since we already have at least an extra 8 capacity, calling this...\ns.reserve_exact(8);\n\n// ... doesn't actually increase.\nassert_eq!(capacity, s.capacity());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(10);%0A++++s.push(%27a%27);%0A++++s.push(%27b%27);%0A++++%0A++++//+s+now+has+a+length+of+2+and+a+capacity+of+at+least+10%0A++++let+capacity+=+s.capacity();%0A++++assert_eq!(2,+s.len());%0A++++assert!(capacity+%3E=+10);%0A++++%0A++++//+Since+we+already+have+at+least+an+extra+8+capacity,+calling+this...%0A++++s.reserve_exact(8);%0A++++%0A++++//+...+doesn%27t+actually+increase.%0A++++assert_eq!(capacity,+s.capacity());%0A%7D&edition=2021)\n\n1.57.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1250)\n\nTries to reserve capacity for at least `additional` bytes more than the current length. The allocator may reserve more space to speculatively avoid frequent allocations. After calling `try_reserve`, capacity will be greater than or equal to `self.len() + additional` if it returns `Ok(())`. Does nothing if capacity is already sufficient. This method preserves the contents even if an error occurs.\n\n##### [¬ß](#errors-2)Errors\n\nIf the capacity overflows, or the allocator reports a failure, then an error is returned.\n\n##### [¬ß](#examples-22)Examples\n\n```\nuse std::collections::TryReserveError;\n\nfn process_data(data: &str) -> Result<String, TryReserveError> {\n    let mut output = String::new();\n\n    // Pre-reserve the memory, exiting if we can't\n    output.try_reserve(data.len())?;\n\n    // Now we know this can't OOM in the middle of our complex work\n    output.push_str(data);\n\n    Ok(output)\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+process_data(data:+%26str)+-%3E+Result%3CString,+TryReserveError%3E+%7B%0A++++++++let+mut+output+=+String::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can%27t%0A++++++++output.try_reserve(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can%27t+OOM+in+the+middle+of+our+complex+work%0A++++++++output.push_str(data);%0A++++%0A++++++++Ok(output)%0A++++%7D%0A++++process_data(%22rust%22).expect(%22why+is+the+test+harness+OOMing+on+4+bytes?%22);%0A%7D&edition=2021)\n\n1.57.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1291)\n\nTries to reserve the minimum capacity for at least `additional` bytes more than the current length. Unlike [`try_reserve`](about:blank/struct.String.html#method.try_reserve \"method std::string::String::try_reserve\"), this will not deliberately over-allocate to speculatively avoid frequent allocations. After calling `try_reserve_exact`, capacity will be greater than or equal to `self.len() + additional` if it returns `Ok(())`. Does nothing if the capacity is already sufficient.\n\nNote that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer [`try_reserve`](about:blank/struct.String.html#method.try_reserve \"method std::string::String::try_reserve\") if future insertions are expected.\n\n##### [¬ß](#errors-3)Errors\n\nIf the capacity overflows, or the allocator reports a failure, then an error is returned.\n\n##### [¬ß](#examples-23)Examples\n\n```\nuse std::collections::TryReserveError;\n\nfn process_data(data: &str) -> Result<String, TryReserveError> {\n    let mut output = String::new();\n\n    // Pre-reserve the memory, exiting if we can't\n    output.try_reserve_exact(data.len())?;\n\n    // Now we know this can't OOM in the middle of our complex work\n    output.push_str(data);\n\n    Ok(output)\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+process_data(data:+%26str)+-%3E+Result%3CString,+TryReserveError%3E+%7B%0A++++++++let+mut+output+=+String::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can%27t%0A++++++++output.try_reserve_exact(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can%27t+OOM+in+the+middle+of+our+complex+work%0A++++++++output.push_str(data);%0A++++%0A++++++++Ok(output)%0A++++%7D%0A++++process_data(%22rust%22).expect(%22why+is+the+test+harness+OOMing+on+4+bytes?%22);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1311)\n\nShrinks the capacity of this `String` to match its length.\n\n##### [¬ß](#examples-24)Examples\n\n```\nlet mut s = String::from(\"foo\");\n\ns.reserve(100);\nassert!(s.capacity() >= 100);\n\ns.shrink_to_fit();\nassert_eq!(3, s.capacity());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foo%22);%0A++++%0A++++s.reserve(100);%0A++++assert!(s.capacity()+%3E=+100);%0A++++%0A++++s.shrink_to_fit();%0A++++assert_eq!(3,+s.capacity());%0A%7D&edition=2021)\n\n1.56.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1338)\n\nShrinks the capacity of this `String` with a lower bound.\n\nThe capacity will remain at least as large as both the length and the supplied value.\n\nIf the current capacity is less than the lower limit, this is a no-op.\n\n##### [¬ß](#examples-25)Examples\n\n```\nlet mut s = String::from(\"foo\");\n\ns.reserve(100);\nassert!(s.capacity() >= 100);\n\ns.shrink_to(10);\nassert!(s.capacity() >= 10);\ns.shrink_to(0);\nassert!(s.capacity() >= 3);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foo%22);%0A++++%0A++++s.reserve(100);%0A++++assert!(s.capacity()+%3E=+100);%0A++++%0A++++s.shrink_to(10);%0A++++assert!(s.capacity()+%3E=+10);%0A++++s.shrink_to(0);%0A++++assert!(s.capacity()+%3E=+3);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1358)\n\nAppends the given [`char`](../primitive.char.html \"primitive char\") to the end of this `String`.\n\n##### [¬ß](#examples-26)Examples\n\n```\nlet mut s = String::from(\"abc\");\n\ns.push('1');\ns.push('2');\ns.push('3');\n\nassert_eq!(\"abc123\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22abc%22);%0A++++%0A++++s.push(%271%27);%0A++++s.push(%272%27);%0A++++s.push(%273%27);%0A++++%0A++++assert_eq!(%22abc123%22,+s);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1381)\n\nReturns a byte slice of this `String`‚Äôs contents.\n\nThe inverse of this method is [`from_utf8`](about:blank/struct.String.html#method.from_utf8 \"associated function std::string::String::from_utf8\").\n\n##### [¬ß](#examples-27)Examples\n\n```\nlet s = String::from(\"hello\");\n\nassert_eq!(&[104, 101, 108, 108, 111], s.as_bytes());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22hello%22);%0A++++%0A++++assert_eq!(%26%5B104,+101,+108,+108,+111%5D,+s.as_bytes());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1408)\n\nShortens this `String` to the specified length.\n\nIf `new_len` is greater than or equal to the string‚Äôs current length, this has no effect.\n\nNote that this method has no effect on the allocated capacity of the string\n\n##### [¬ß](#panics-3)Panics\n\nPanics if `new_len` does not lie on a [`char`](../primitive.char.html \"primitive char\") boundary.\n\n##### [¬ß](#examples-28)Examples\n\n```\nlet mut s = String::from(\"hello\");\n\ns.truncate(2);\n\nassert_eq!(\"he\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22hello%22);%0A++++%0A++++s.truncate(2);%0A++++%0A++++assert_eq!(%22he%22,+s);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1432)\n\nRemoves the last character from the string buffer and returns it.\n\nReturns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") if this `String` is empty.\n\n##### [¬ß](#examples-29)Examples\n\n```\nlet mut s = String::from(\"abƒç\");\n\nassert_eq!(s.pop(), Some('ƒç'));\nassert_eq!(s.pop(), Some('b'));\nassert_eq!(s.pop(), Some('a'));\n\nassert_eq!(s.pop(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22ab%C4%8D%22);%0A++++%0A++++assert_eq!(s.pop(),+Some(%27%C4%8D%27));%0A++++assert_eq!(s.pop(),+Some(%27b%27));%0A++++assert_eq!(s.pop(),+Some(%27a%27));%0A++++%0A++++assert_eq!(s.pop(),+None);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1463)\n\nRemoves a [`char`](../primitive.char.html \"primitive char\") from this `String` at a byte position and returns it.\n\nThis is an _O_(_n_) operation, as it requires copying every element in the buffer.\n\n##### [¬ß](#panics-4)Panics\n\nPanics if `idx` is larger than or equal to the `String`‚Äôs length, or if it does not lie on a [`char`](../primitive.char.html \"primitive char\") boundary.\n\n##### [¬ß](#examples-30)Examples\n\n```\nlet mut s = String::from(\"ab√ß\");\n\nassert_eq!(s.remove(0), 'a');\nassert_eq!(s.remove(1), '√ß');\nassert_eq!(s.remove(0), 'b');\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22ab%C3%A7%22);%0A++++%0A++++assert_eq!(s.remove(0),+%27a%27);%0A++++assert_eq!(s.remove(1),+%27%C3%A7%27);%0A++++assert_eq!(s.remove(0),+%27b%27);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1500-1502)\n\nüî¨This is a nightly-only experimental API. (`string_remove_matches`¬†[#72826](https://github.com/rust-lang/rust/issues/72826))\n\nRemove all matches of pattern `pat` in the `String`.\n\n##### [¬ß](#examples-31)Examples\n\n```\n#![feature(string_remove_matches)]\nlet mut s = String::from(\"Trees are not green, the sky is not blue.\");\ns.remove_matches(\"not \");\nassert_eq!(\"Trees are green, the sky is blue.\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(string_remove_matches)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Trees+are+not+green,+the+sky+is+not+blue.%22);%0A++++s.remove_matches(%22not+%22);%0A++++assert_eq!(%22Trees+are+green,+the+sky+is+blue.%22,+s);%0A%7D&version=nightly&edition=2021)\n\nMatches will be detected and removed iteratively, so in cases where patterns overlap, only the first pattern will be removed:\n\n```\n#![feature(string_remove_matches)]\nlet mut s = String::from(\"banana\");\ns.remove_matches(\"ana\");\nassert_eq!(\"bna\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(string_remove_matches)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22banana%22);%0A++++s.remove_matches(%22ana%22);%0A++++assert_eq!(%22bna%22,+s);%0A%7D&version=nightly&edition=2021)\n\n1.26.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1580-1582)\n\nRetains only the characters specified by the predicate.\n\nIn other words, remove all characters `c` such that `f(c)` returns `false`. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.\n\n##### [¬ß](#examples-32)Examples\n\n```\nlet mut s = String::from(\"f_o_ob_ar\");\n\ns.retain(|c| c != '_');\n\nassert_eq!(s, \"foobar\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22f_o_ob_ar%22);%0A++++%0A++++s.retain(%7Cc%7C+c+!=+%27_%27);%0A++++%0A++++assert_eq!(s,+%22foobar%22);%0A%7D&edition=2021)\n\nBecause the elements are visited exactly once in the original order, external state may be used to decide which elements to keep.\n\n```\nlet mut s = String::from(\"abcde\");\nlet keep = [false, true, true, false, true];\nlet mut iter = keep.iter();\ns.retain(|_| *iter.next().unwrap());\nassert_eq!(s, \"bce\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22abcde%22);%0A++++let+keep+=+%5Bfalse,+true,+true,+false,+true%5D;%0A++++let+mut+iter+=+keep.iter();%0A++++s.retain(%7C_%7C+*iter.next().unwrap());%0A++++assert_eq!(s,+%22bce%22);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1658)\n\nInserts a character into this `String` at a byte position.\n\nThis is an _O_(_n_) operation as it requires copying every element in the buffer.\n\n##### [¬ß](#panics-5)Panics\n\nPanics if `idx` is larger than the `String`‚Äôs length, or if it does not lie on a [`char`](../primitive.char.html \"primitive char\") boundary.\n\n##### [¬ß](#examples-33)Examples\n\n```\nlet mut s = String::with_capacity(3);\n\ns.insert(0, 'f');\ns.insert(1, 'o');\ns.insert(2, 'o');\n\nassert_eq!(\"foo\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(3);%0A++++%0A++++s.insert(0,+%27f%27);%0A++++s.insert(1,+%27o%27);%0A++++s.insert(2,+%27o%27);%0A++++%0A++++assert_eq!(%22foo%22,+s);%0A%7D&edition=2021)\n\n1.16.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1703)\n\nInserts a string slice into this `String` at a byte position.\n\nThis is an _O_(_n_) operation as it requires copying every element in the buffer.\n\n##### [¬ß](#panics-6)Panics\n\nPanics if `idx` is larger than the `String`‚Äôs length, or if it does not lie on a [`char`](../primitive.char.html \"primitive char\") boundary.\n\n##### [¬ß](#examples-34)Examples\n\n```\nlet mut s = String::from(\"bar\");\n\ns.insert_str(0, \"foo\");\n\nassert_eq!(\"foobar\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22bar%22);%0A++++%0A++++s.insert_str(0,+%22foo%22);%0A++++%0A++++assert_eq!(%22foobar%22,+s);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1736)\n\nReturns a mutable reference to the contents of this `String`.\n\n##### [¬ß](#safety-2)Safety\n\nThis function is unsafe because the returned `&mut Vec` allows writing bytes which are not valid UTF-8. If this constraint is violated, using the original `String` after dropping the `&mut Vec` may violate memory safety, as the rest of the standard library assumes that `String`s are valid UTF-8.\n\n##### [¬ß](#examples-35)Examples\n\n```\nlet mut s = String::from(\"hello\");\n\nunsafe {\n    let vec = s.as_mut_vec();\n    assert_eq!(&[104, 101, 108, 108, 111][..], &vec[..]);\n\n    vec.reverse();\n}\nassert_eq!(s, \"olleh\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22hello%22);%0A++++%0A++++unsafe+%7B%0A++++++++let+vec+=+s.as_mut_vec();%0A++++++++assert_eq!(%26%5B104,+101,+108,+108,+111%5D%5B..%5D,+%26vec%5B..%5D);%0A++++%0A++++++++vec.reverse();%0A++++%7D%0A++++assert_eq!(s,+%22olleh%22);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1758)\n\nReturns the length of this `String`, in bytes, not [`char`](../primitive.char.html \"primitive char\")s or graphemes. In other words, it might not be what a human considers the length of the string.\n\n##### [¬ß](#examples-36)Examples\n\n```\nlet a = String::from(\"foo\");\nassert_eq!(a.len(), 3);\n\nlet fancy_f = String::from(\"∆íoo\");\nassert_eq!(fancy_f.len(), 4);\nassert_eq!(fancy_f.chars().count(), 3);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+String::from(%22foo%22);%0A++++assert_eq!(a.len(),+3);%0A++++%0A++++let+fancy_f+=+String::from(%22%C6%92oo%22);%0A++++assert_eq!(fancy_f.len(),+4);%0A++++assert_eq!(fancy_f.chars().count(),+3);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1776)\n\nReturns `true` if this `String` has a length of zero, and `false` otherwise.\n\n##### [¬ß](#examples-37)Examples\n\n```\nlet mut v = String::new();\nassert!(v.is_empty());\n\nv.push('a');\nassert!(!v.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::new();%0A++++assert!(v.is_empty());%0A++++%0A++++v.push(%27a%27);%0A++++assert!(!v.is_empty());%0A%7D&edition=2021)\n\n1.16.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1807)\n\nSplits the string into two at the given byte index.\n\nReturns a newly allocated `String`. `self` contains bytes `[0, at)`, and the returned `String` contains bytes `[at, len)`. `at` must be on the boundary of a UTF-8 code point.\n\nNote that the capacity of `self` does not change.\n\n##### [¬ß](#panics-7)Panics\n\nPanics if `at` is not on a `UTF-8` code point boundary, or if it is beyond the last code point of the string.\n\n##### [¬ß](#examples-38)Examples\n\n```\nlet mut hello = String::from(\"Hello, World!\");\nlet world = hello.split_off(7);\nassert_eq!(hello, \"Hello, \");\nassert_eq!(world, \"World!\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+mut+hello+=+String::from(%22Hello,+World!%22);%0Alet+world+=+hello.split_off(7);%0Aassert_eq!(hello,+%22Hello,+%22);%0Aassert_eq!(world,+%22World!%22);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1831)\n\nTruncates this `String`, removing all contents.\n\nWhile this means the `String` will have a length of zero, it does not touch its capacity.\n\n##### [¬ß](#examples-39)Examples\n\n```\nlet mut s = String::from(\"foo\");\n\ns.clear();\n\nassert!(s.is_empty());\nassert_eq!(0, s.len());\nassert_eq!(3, s.capacity());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foo%22);%0A++++%0A++++s.clear();%0A++++%0A++++assert!(s.is_empty());%0A++++assert_eq!(0,+s.len());%0A++++assert_eq!(3,+s.capacity());%0A%7D&edition=2021)\n\n1.6.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1869-1871)\n\nRemoves the specified range from the string in bulk, returning all removed characters as an iterator.\n\nThe returned iterator keeps a mutable borrow on the string to optimize its implementation.\n\n##### [¬ß](#panics-8)Panics\n\nPanics if the starting point or end point do not lie on a [`char`](../primitive.char.html \"primitive char\") boundary, or if they‚Äôre out of bounds.\n\n##### [¬ß](#leaking)Leaking\n\nIf the returned iterator goes out of scope without being dropped (due to [`core::mem::forget`](../mem/fn.forget.html \"fn std::mem::forget\"), for example), the string may still contain a copy of any drained characters, or may have lost characters arbitrarily, including characters outside the range.\n\n##### [¬ß](#examples-40)Examples\n\n```\nlet mut s = String::from(\"Œ± is alpha, Œ≤ is beta\");\nlet beta_offset = s.find('Œ≤').unwrap_or(s.len());\n\n// Remove the range up until the Œ≤ from the string\nlet t: String = s.drain(..beta_offset).collect();\nassert_eq!(t, \"Œ± is alpha, \");\nassert_eq!(s, \"Œ≤ is beta\");\n\n// A full range clears the string, like `clear()` does\ns.drain(..);\nassert_eq!(s, \"\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22%CE%B1+is+alpha,+%CE%B2+is+beta%22);%0A++++let+beta_offset+=+s.find(%27%CE%B2%27).unwrap_or(s.len());%0A++++%0A++++//+Remove+the+range+up+until+the+%CE%B2+from+the+string%0A++++let+t:+String+=+s.drain(..beta_offset).collect();%0A++++assert_eq!(t,+%22%CE%B1+is+alpha,+%22);%0A++++assert_eq!(s,+%22%CE%B2+is+beta%22);%0A++++%0A++++//+A+full+range+clears+the+string,+like+%60clear()%60+does%0A++++s.drain(..);%0A++++assert_eq!(s,+%22%22);%0A%7D&edition=2021)\n\n1.27.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1913-1915)\n\nRemoves the specified range in the string, and replaces it with the given string. The given string doesn‚Äôt need to be the same length as the range.\n\n##### [¬ß](#panics-9)Panics\n\nPanics if the starting point or end point do not lie on a [`char`](../primitive.char.html \"primitive char\") boundary, or if they‚Äôre out of bounds.\n\n##### [¬ß](#examples-41)Examples\n\n```\nlet mut s = String::from(\"Œ± is alpha, Œ≤ is beta\");\nlet beta_offset = s.find('Œ≤').unwrap_or(s.len());\n\n// Replace the range up until the Œ≤ from the string\ns.replace_range(..beta_offset, \"Œë is capital alpha; \");\nassert_eq!(s, \"Œë is capital alpha; Œ≤ is beta\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22%CE%B1+is+alpha,+%CE%B2+is+beta%22);%0A++++let+beta_offset+=+s.find(%27%CE%B2%27).unwrap_or(s.len());%0A++++%0A++++//+Replace+the+range+up+until+the+%CE%B2+from+the+string%0A++++s.replace_range(..beta_offset,+%22%CE%91+is+capital+alpha;+%22);%0A++++assert_eq!(s,+%22%CE%91+is+capital+alpha;+%CE%B2+is+beta%22);%0A%7D&edition=2021)\n\n1.4.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1962)\n\nConverts this `String` into a `[Box](../boxed/struct.Box.html \"struct std::boxed::Box\")<[str](../primitive.str.html \"str\")>`.\n\nBefore doing the conversion, this method discards excess capacity like [`shrink_to_fit`](about:blank/struct.String.html#method.shrink_to_fit \"method std::string::String::shrink_to_fit\"). Note that this call may reallocate and copy the bytes of the string.\n\n##### [¬ß](#examples-42)Examples\n\n```\nlet s = String::from(\"hello\");\n\nlet b = s.into_boxed_str();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22hello%22);%0A++++%0A++++let+b+=+s.into_boxed_str();%0A%7D&edition=2021)\n\n1.72.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1990)\n\nConsumes and leaks the `String`, returning a mutable reference to the contents, `&'a mut str`.\n\nThe caller has free choice over the returned lifetime, including `'static`. Indeed, this function is ideally used for data that lives for the remainder of the program‚Äôs life, as dropping the returned reference will cause a memory leak.\n\nIt does not reallocate or shrink the `String`, so the leaked allocation may include unused capacity that is not part of the returned slice. If you want to discard excess capacity, call [`into_boxed_str`](about:blank/struct.String.html#method.into_boxed_str \"method std::string::String::into_boxed_str\"), and then [`Box::leak`](about:blank/boxed/struct.Box.html#method.leak \"associated function std::boxed::Box::leak\") instead. However, keep in mind that trimming the capacity may result in a reallocation and copy.\n\n##### [¬ß](#examples-43)Examples\n\n```\nlet x = String::from(\"bucket\");\nlet static_ref: &'static mut str = x.leak();\nassert_eq!(static_ref, \"bucket\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+String::from(%22bucket%22);%0A++++let+static_ref:+%26%27static+mut+str+=+x.leak();%0A++++assert_eq!(static_ref,+%22bucket%22);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#160)\n\nReturns the length of `self`.\n\nThis length is in bytes, not [`char`](../primitive.char.html \"primitive char\")s or graphemes. In other words, it might not be what a human considers the length of the string.\n\n##### [¬ß](#examples-44)Examples\n\n```\nlet len = \"foo\".len();\nassert_eq!(3, len);\n\nassert_eq!(\"∆íoo\".len(), 4); // fancy f!\nassert_eq!(\"∆íoo\".chars().count(), 3);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+len+=+%22foo%22.len();%0A++++assert_eq!(3,+len);%0A++++%0A++++assert_eq!(%22%C6%92oo%22.len(),+4);+//+fancy+f!%0A++++assert_eq!(%22%C6%92oo%22.chars().count(),+3);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#179)\n\nReturns `true` if `self` has a length of zero bytes.\n\n##### [¬ß](#examples-45)Examples\n\n```\nlet s = \"\";\nassert!(s.is_empty());\n\nlet s = \"not empty\";\nassert!(!s.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%22;%0A++++assert!(s.is_empty());%0A++++%0A++++let+s+=+%22not+empty%22;%0A++++assert!(!s.is_empty());%0A%7D&edition=2021)\n\n1.9.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#209)\n\nChecks that `index`\\-th byte is the first byte in a UTF-8 code point sequence or the end of the string.\n\nThe start and end of the string (when `index == self.len()`) are considered to be boundaries.\n\nReturns `false` if `index` is greater than `self.len()`.\n\n##### [¬ß](#examples-46)Examples\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\nassert!(s.is_char_boundary(0));\n// start of `ËÄÅ`\nassert!(s.is_char_boundary(6));\nassert!(s.is_char_boundary(s.len()));\n\n// second byte of `√∂`\nassert!(!s.is_char_boundary(2));\n\n// third byte of `ËÄÅ`\nassert!(!s.is_char_boundary(8));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++assert!(s.is_char_boundary(0));%0A++++//+start+of+%60%E8%80%81%60%0A++++assert!(s.is_char_boundary(6));%0A++++assert!(s.is_char_boundary(s.len()));%0A++++%0A++++//+second+byte+of+%60%C3%B6%60%0A++++assert!(!s.is_char_boundary(2));%0A++++%0A++++//+third+byte+of+%60%E8%80%81%60%0A++++assert!(!s.is_char_boundary(8));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#256)\n\nüî¨This is a nightly-only experimental API. (`round_char_boundary`¬†[#93743](https://github.com/rust-lang/rust/issues/93743))\n\nFinds the closest `x` not exceeding `index` where `is_char_boundary(x)` is `true`.\n\nThis method can help you truncate a string so that it‚Äôs still valid UTF-8, but doesn‚Äôt exceed a given number of bytes. Note that this is done purely at the character level and can still visually split graphemes, even though the underlying characters aren‚Äôt split. For example, the emoji üßë‚Äçüî¨ (scientist) could be split so that the string only includes üßë (person) instead.\n\n##### [¬ß](#examples-47)Examples\n\n```\n#![feature(round_char_boundary)]\nlet s = \"‚ù§Ô∏èüß°üíõüíöüíôüíú\";\nassert_eq!(s.len(), 26);\nassert!(!s.is_char_boundary(13));\n\nlet closest = s.floor_char_boundary(13);\nassert_eq!(closest, 10);\nassert_eq!(&s[..closest], \"‚ù§Ô∏èüß°\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(round_char_boundary)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22;%0A++++assert_eq!(s.len(),+26);%0A++++assert!(!s.is_char_boundary(13));%0A++++%0A++++let+closest+=+s.floor_char_boundary(13);%0A++++assert_eq!(closest,+10);%0A++++assert_eq!(%26s%5B..closest%5D,+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%22);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#294)\n\nüî¨This is a nightly-only experimental API. (`round_char_boundary`¬†[#93743](https://github.com/rust-lang/rust/issues/93743))\n\nFinds the closest `x` not below `index` where `is_char_boundary(x)` is `true`.\n\nIf `index` is greater than the length of the string, this returns the length of the string.\n\nThis method is the natural complement to [`floor_char_boundary`](about:blank/primitive.str.html#method.floor_char_boundary \"method str::floor_char_boundary\"). See that method for more details.\n\n##### [¬ß](#examples-48)Examples\n\n```\n#![feature(round_char_boundary)]\nlet s = \"‚ù§Ô∏èüß°üíõüíöüíôüíú\";\nassert_eq!(s.len(), 26);\nassert!(!s.is_char_boundary(13));\n\nlet closest = s.ceil_char_boundary(13);\nassert_eq!(closest, 14);\nassert_eq!(&s[..closest], \"‚ù§Ô∏èüß°üíõ\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(round_char_boundary)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22;%0A++++assert_eq!(s.len(),+26);%0A++++assert!(!s.is_char_boundary(13));%0A++++%0A++++let+closest+=+s.ceil_char_boundary(13);%0A++++assert_eq!(closest,+14);%0A++++assert_eq!(%26s%5B..closest%5D,+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%22);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#320)\n\nConverts a string slice to a byte slice. To convert the byte slice back into a string slice, use the [`from_utf8`](../str/fn.from_utf8.html \"fn std::str::from_utf8\") function.\n\n##### [¬ß](#examples-49)Examples\n\n```\nlet bytes = \"bors\".as_bytes();\nassert_eq!(b\"bors\", bytes);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+%22bors%22.as_bytes();%0A++++assert_eq!(b%22bors%22,+bytes);%0A%7D&edition=2021)\n\n1.20.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#364)\n\nConverts a mutable string slice to a mutable byte slice.\n\n##### [¬ß](#safety-3)Safety\n\nThe caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying `str` is used.\n\nUse of a `str` whose contents are not valid UTF-8 is undefined behavior.\n\n##### [¬ß](#examples-50)Examples\n\nBasic usage:\n\n```\nlet mut s = String::from(\"Hello\");\nlet bytes = unsafe { s.as_bytes_mut() };\n\nassert_eq!(b\"Hello\", bytes);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Hello%22);%0A++++let+bytes+=+unsafe+%7B+s.as_bytes_mut()+%7D;%0A++++%0A++++assert_eq!(b%22Hello%22,+bytes);%0A%7D&edition=2021)\n\nMutability:\n\n```\nlet mut s = String::from(\"üóª‚ààüåè\");\n\nunsafe {\n    let bytes = s.as_bytes_mut();\n\n    bytes[0] = 0xF0;\n    bytes[1] = 0x9F;\n    bytes[2] = 0x8D;\n    bytes[3] = 0x94;\n}\n\nassert_eq!(\"üçî‚ààüåè\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++%0A++++unsafe+%7B%0A++++++++let+bytes+=+s.as_bytes_mut();%0A++++%0A++++++++bytes%5B0%5D+=+0xF0;%0A++++++++bytes%5B1%5D+=+0x9F;%0A++++++++bytes%5B2%5D+=+0x8D;%0A++++++++bytes%5B3%5D+=+0x94;%0A++++%7D%0A++++%0A++++assert_eq!(%22%F0%9F%8D%94%E2%88%88%F0%9F%8C%8F%22,+s);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#394)\n\nConverts a string slice to a raw pointer.\n\nAs string slices are a slice of bytes, the raw pointer points to a [`u8`](../primitive.u8.html \"primitive u8\"). This pointer will be pointing to the first byte of the string slice.\n\nThe caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use [`as_mut_ptr`](about:blank/primitive.str.html#method.as_mut_ptr \"method str::as_mut_ptr\").\n\n##### [¬ß](#examples-51)Examples\n\n```\nlet s = \"Hello\";\nlet ptr = s.as_ptr();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Hello%22;%0A++++let+ptr+=+s.as_ptr();%0A%7D&edition=2021)\n\n1.36.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#410)\n\nConverts a mutable string slice to a raw pointer.\n\nAs string slices are a slice of bytes, the raw pointer points to a [`u8`](../primitive.u8.html \"primitive u8\"). This pointer will be pointing to the first byte of the string slice.\n\nIt is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8.\n\n1.20.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#435)\n\nReturns a subslice of `str`.\n\nThis is the non-panicking alternative to indexing the `str`. Returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") whenever equivalent indexing operation would panic.\n\n##### [¬ß](#examples-52)Examples\n\n```\nlet v = String::from(\"üóª‚ààüåè\");\n\nassert_eq!(Some(\"üóª\"), v.get(0..4));\n\n// indices not on UTF-8 sequence boundaries\nassert!(v.get(1..).is_none());\nassert!(v.get(..8).is_none());\n\n// out of bounds\nassert!(v.get(..42).is_none());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++%0A++++assert_eq!(Some(%22%F0%9F%97%BB%22),+v.get(0..4));%0A++++%0A++++//+indices+not+on+UTF-8+sequence+boundaries%0A++++assert!(v.get(1..).is_none());%0A++++assert!(v.get(..8).is_none());%0A++++%0A++++//+out+of+bounds%0A++++assert!(v.get(..42).is_none());%0A%7D&edition=2021)\n\n1.20.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#467)\n\nReturns a mutable subslice of `str`.\n\nThis is the non-panicking alternative to indexing the `str`. Returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") whenever equivalent indexing operation would panic.\n\n##### [¬ß](#examples-53)Examples\n\n```\nlet mut v = String::from(\"hello\");\n// correct length\nassert!(v.get_mut(0..5).is_some());\n// out of bounds\nassert!(v.get_mut(..42).is_none());\nassert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n\nassert_eq!(\"hello\", v);\n{\n    let s = v.get_mut(0..2);\n    let s = s.map(|s| {\n        s.make_ascii_uppercase();\n        &*s\n    });\n    assert_eq!(Some(\"HE\"), s);\n}\nassert_eq!(\"HEllo\", v);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::from(%22hello%22);%0A++++//+correct+length%0A++++assert!(v.get_mut(0..5).is_some());%0A++++//+out+of+bounds%0A++++assert!(v.get_mut(..42).is_none());%0A++++assert_eq!(Some(%22he%22),+v.get_mut(0..2).map(%7Cv%7C+%26*v));%0A++++%0A++++assert_eq!(%22hello%22,+v);%0A++++%7B%0A++++++++let+s+=+v.get_mut(0..2);%0A++++++++let+s+=+s.map(%7Cs%7C+%7B%0A++++++++++++s.make_ascii_uppercase();%0A++++++++++++%26*s%0A++++++++%7D);%0A++++++++assert_eq!(Some(%22HE%22),+s);%0A++++%7D%0A++++assert_eq!(%22HEllo%22,+v);%0A%7D&edition=2021)\n\n1.20.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#499)\n\nReturns an unchecked subslice of `str`.\n\nThis is the unchecked alternative to indexing the `str`.\n\n##### [¬ß](#safety-4)Safety\n\nCallers of this function are responsible that these preconditions are satisfied:\n\n-   The starting index must not exceed the ending index;\n-   Indexes must be within bounds of the original slice;\n-   Indexes must lie on UTF-8 sequence boundaries.\n\nFailing that, the returned string slice may reference invalid memory or violate the invariants communicated by the `str` type.\n\n##### [¬ß](#examples-54)Examples\n\n```\nlet v = \"üóª‚ààüåè\";\nunsafe {\n    assert_eq!(\"üóª\", v.get_unchecked(0..4));\n    assert_eq!(\"‚àà\", v.get_unchecked(4..7));\n    assert_eq!(\"üåè\", v.get_unchecked(7..11));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22;%0A++++unsafe+%7B%0A++++++++assert_eq!(%22%F0%9F%97%BB%22,+v.get_unchecked(0..4));%0A++++++++assert_eq!(%22%E2%88%88%22,+v.get_unchecked(4..7));%0A++++++++assert_eq!(%22%F0%9F%8C%8F%22,+v.get_unchecked(7..11));%0A++++%7D%0A%7D&edition=2021)\n\n1.20.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#534)\n\nReturns a mutable, unchecked subslice of `str`.\n\nThis is the unchecked alternative to indexing the `str`.\n\n##### [¬ß](#safety-5)Safety\n\nCallers of this function are responsible that these preconditions are satisfied:\n\n-   The starting index must not exceed the ending index;\n-   Indexes must be within bounds of the original slice;\n-   Indexes must lie on UTF-8 sequence boundaries.\n\nFailing that, the returned string slice may reference invalid memory or violate the invariants communicated by the `str` type.\n\n##### [¬ß](#examples-55)Examples\n\n```\nlet mut v = String::from(\"üóª‚ààüåè\");\nunsafe {\n    assert_eq!(\"üóª\", v.get_unchecked_mut(0..4));\n    assert_eq!(\"‚àà\", v.get_unchecked_mut(4..7));\n    assert_eq!(\"üåè\", v.get_unchecked_mut(7..11));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++unsafe+%7B%0A++++++++assert_eq!(%22%F0%9F%97%BB%22,+v.get_unchecked_mut(0..4));%0A++++++++assert_eq!(%22%E2%88%88%22,+v.get_unchecked_mut(4..7));%0A++++++++assert_eq!(%22%F0%9F%8C%8F%22,+v.get_unchecked_mut(7..11));%0A++++%7D%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#585)\n\nüëéDeprecated since 1.29.0: use `get_unchecked(begin..end)` instead\n\nCreates a string slice from another string slice, bypassing safety checks.\n\nThis is generally not recommended, use with caution! For a safe alternative see [`str`](../primitive.str.html \"primitive str\") and [`Index`](../ops/trait.Index.html \"trait std::ops::Index\").\n\nThis new slice goes from `begin` to `end`, including `begin` but excluding `end`.\n\nTo get a mutable string slice instead, see the [`slice_mut_unchecked`](about:blank/primitive.str.html#method.slice_mut_unchecked \"method str::slice_mut_unchecked\") method.\n\n##### [¬ß](#safety-6)Safety\n\nCallers of this function are responsible that three preconditions are satisfied:\n\n-   `begin` must not exceed `end`.\n-   `begin` and `end` must be byte positions within the string slice.\n-   `begin` and `end` must lie on UTF-8 sequence boundaries.\n\n##### [¬ß](#examples-56)Examples\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\n\nunsafe {\n    assert_eq!(\"L√∂we ËÄÅËôé L√©opard\", s.slice_unchecked(0, 21));\n}\n\nlet s = \"Hello, world!\";\n\nunsafe {\n    assert_eq!(\"world\", s.slice_unchecked(7, 12));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22,+s.slice_unchecked(0,+21));%0A++++%7D%0A++++%0A++++let+s+=+%22Hello,+world!%22;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(%22world%22,+s.slice_unchecked(7,+12));%0A++++%7D%0A%7D&edition=2021)\n\n1.5.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#618)\n\nüëéDeprecated since 1.29.0: use `get_unchecked_mut(begin..end)` instead\n\nCreates a string slice from another string slice, bypassing safety checks. This is generally not recommended, use with caution! For a safe alternative see [`str`](../primitive.str.html \"primitive str\") and [`IndexMut`](../ops/trait.IndexMut.html \"trait std::ops::IndexMut\").\n\nThis new slice goes from `begin` to `end`, including `begin` but excluding `end`.\n\nTo get an immutable string slice instead, see the [`slice_unchecked`](about:blank/primitive.str.html#method.slice_unchecked \"method str::slice_unchecked\") method.\n\n##### [¬ß](#safety-7)Safety\n\nCallers of this function are responsible that three preconditions are satisfied:\n\n-   `begin` must not exceed `end`.\n-   `begin` and `end` must be byte positions within the string slice.\n-   `begin` and `end` must lie on UTF-8 sequence boundaries.\n\n1.4.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#657)\n\nDivide one string slice into two at an index.\n\nThe argument, `mid`, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.\n\nThe two slices returned go from the start of the string slice to `mid`, and from `mid` to the end of the string slice.\n\nTo get mutable string slices instead, see the [`split_at_mut`](about:blank/primitive.str.html#method.split_at_mut \"method str::split_at_mut\") method.\n\n##### [¬ß](#panics-10)Panics\n\nPanics if `mid` is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see [`split_at_checked`](about:blank/primitive.str.html#method.split_at_checked \"method str::split_at_checked\").\n\n##### [¬ß](#examples-57)Examples\n\n```\nlet s = \"Per Martin-L√∂f\";\n\nlet (first, last) = s.split_at(3);\n\nassert_eq!(\"Per\", first);\nassert_eq!(\" Martin-L√∂f\", last);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Per+Martin-L%C3%B6f%22;%0A++++%0A++++let+(first,+last)+=+s.split_at(3);%0A++++%0A++++assert_eq!(%22Per%22,+first);%0A++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A%7D&edition=2021)\n\n1.4.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#697)\n\nDivide one mutable string slice into two at an index.\n\nThe argument, `mid`, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.\n\nThe two slices returned go from the start of the string slice to `mid`, and from `mid` to the end of the string slice.\n\nTo get immutable string slices instead, see the [`split_at`](about:blank/primitive.str.html#method.split_at \"method str::split_at\") method.\n\n##### [¬ß](#panics-11)Panics\n\nPanics if `mid` is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see [`split_at_mut_checked`](about:blank/primitive.str.html#method.split_at_mut_checked \"method str::split_at_mut_checked\").\n\n##### [¬ß](#examples-58)Examples\n\n```\nlet mut s = \"Per Martin-L√∂f\".to_string();\n{\n    let (first, last) = s.split_at_mut(3);\n    first.make_ascii_uppercase();\n    assert_eq!(\"PER\", first);\n    assert_eq!(\" Martin-L√∂f\", last);\n}\nassert_eq!(\"PER Martin-L√∂f\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%22Per+Martin-L%C3%B6f%22.to_string();%0A++++%7B%0A++++++++let+(first,+last)+=+s.split_at_mut(3);%0A++++++++first.make_ascii_uppercase();%0A++++++++assert_eq!(%22PER%22,+first);%0A++++++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%7D%0A++++assert_eq!(%22PER+Martin-L%C3%B6f%22,+s);%0A%7D&edition=2021)\n\n1.80.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#736)\n\nDivide one string slice into two at an index.\n\nThe argument, `mid`, should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns `None` if that‚Äôs not the case.\n\nThe two slices returned go from the start of the string slice to `mid`, and from `mid` to the end of the string slice.\n\nTo get mutable string slices instead, see the [`split_at_mut_checked`](about:blank/primitive.str.html#method.split_at_mut_checked \"method str::split_at_mut_checked\") method.\n\n##### [¬ß](#examples-59)Examples\n\n```\nlet s = \"Per Martin-L√∂f\";\n\nlet (first, last) = s.split_at_checked(3).unwrap();\nassert_eq!(\"Per\", first);\nassert_eq!(\" Martin-L√∂f\", last);\n\nassert_eq!(None, s.split_at_checked(13));  // Inside ‚Äú√∂‚Äù\nassert_eq!(None, s.split_at_checked(16));  // Beyond the string length\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Per+Martin-L%C3%B6f%22;%0A++++%0A++++let+(first,+last)+=+s.split_at_checked(3).unwrap();%0A++++assert_eq!(%22Per%22,+first);%0A++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%0A++++assert_eq!(None,+s.split_at_checked(13));++//+Inside+%E2%80%9C%C3%B6%E2%80%9D%0A++++assert_eq!(None,+s.split_at_checked(16));++//+Beyond+the+string+length%0A%7D&edition=2021)\n\n1.80.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#776)\n\nDivide one mutable string slice into two at an index.\n\nThe argument, `mid`, should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns `None` if that‚Äôs not the case.\n\nThe two slices returned go from the start of the string slice to `mid`, and from `mid` to the end of the string slice.\n\nTo get immutable string slices instead, see the [`split_at_checked`](about:blank/primitive.str.html#method.split_at_checked \"method str::split_at_checked\") method.\n\n##### [¬ß](#examples-60)Examples\n\n```\nlet mut s = \"Per Martin-L√∂f\".to_string();\nif let Some((first, last)) = s.split_at_mut_checked(3) {\n    first.make_ascii_uppercase();\n    assert_eq!(\"PER\", first);\n    assert_eq!(\" Martin-L√∂f\", last);\n}\nassert_eq!(\"PER Martin-L√∂f\", s);\n\nassert_eq!(None, s.split_at_mut_checked(13));  // Inside ‚Äú√∂‚Äù\nassert_eq!(None, s.split_at_mut_checked(16));  // Beyond the string length\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%22Per+Martin-L%C3%B6f%22.to_string();%0A++++if+let+Some((first,+last))+=+s.split_at_mut_checked(3)+%7B%0A++++++++first.make_ascii_uppercase();%0A++++++++assert_eq!(%22PER%22,+first);%0A++++++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%7D%0A++++assert_eq!(%22PER+Martin-L%C3%B6f%22,+s);%0A++++%0A++++assert_eq!(None,+s.split_at_mut_checked(13));++//+Inside+%E2%80%9C%C3%B6%E2%80%9D%0A++++assert_eq!(None,+s.split_at_mut_checked(16));++//+Beyond+the+string+length%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#853)\n\nReturns an iterator over the [`char`](../primitive.char.html \"primitive char\")s of a string slice.\n\nAs a string slice consists of valid UTF-8, we can iterate through a string slice by [`char`](../primitive.char.html \"primitive char\"). This method returns such an iterator.\n\nIt‚Äôs important to remember that [`char`](../primitive.char.html \"primitive char\") represents a Unicode Scalar Value, and might not match your idea of what a ‚Äòcharacter‚Äô is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust‚Äôs standard library, check crates.io instead.\n\n##### [¬ß](#examples-61)Examples\n\nBasic usage:\n\n```\nlet word = \"goodbye\";\n\nlet count = word.chars().count();\nassert_eq!(7, count);\n\nlet mut chars = word.chars();\n\nassert_eq!(Some('g'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('d'), chars.next());\nassert_eq!(Some('b'), chars.next());\nassert_eq!(Some('y'), chars.next());\nassert_eq!(Some('e'), chars.next());\n\nassert_eq!(None, chars.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+word+=+%22goodbye%22;%0A++++%0A++++let+count+=+word.chars().count();%0A++++assert_eq!(7,+count);%0A++++%0A++++let+mut+chars+=+word.chars();%0A++++%0A++++assert_eq!(Some(%27g%27),+chars.next());%0A++++assert_eq!(Some(%27o%27),+chars.next());%0A++++assert_eq!(Some(%27o%27),+chars.next());%0A++++assert_eq!(Some(%27d%27),+chars.next());%0A++++assert_eq!(Some(%27b%27),+chars.next());%0A++++assert_eq!(Some(%27y%27),+chars.next());%0A++++assert_eq!(Some(%27e%27),+chars.next());%0A++++%0A++++assert_eq!(None,+chars.next());%0A%7D&edition=2021)\n\nRemember, [`char`](../primitive.char.html \"primitive char\")s might not match your intuition about characters:\n\n```\nlet y = \"yÃÜ\";\n\nlet mut chars = y.chars();\n\nassert_eq!(Some('y'), chars.next()); // not 'yÃÜ'\nassert_eq!(Some('\\u{0306}'), chars.next());\n\nassert_eq!(None, chars.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+y+=+%22y%CC%86%22;%0A++++%0A++++let+mut+chars+=+y.chars();%0A++++%0A++++assert_eq!(Some(%27y%27),+chars.next());+//+not+%27y%CC%86%27%0A++++assert_eq!(Some(%27%5Cu%7B0306%7D%27),+chars.next());%0A++++%0A++++assert_eq!(None,+chars.next());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#910)\n\nReturns an iterator over the [`char`](../primitive.char.html \"primitive char\")s of a string slice, and their positions.\n\nAs a string slice consists of valid UTF-8, we can iterate through a string slice by [`char`](../primitive.char.html \"primitive char\"). This method returns an iterator of both these [`char`](../primitive.char.html \"primitive char\")s, as well as their byte positions.\n\nThe iterator yields tuples. The position is first, the [`char`](../primitive.char.html \"primitive char\") is second.\n\n##### [¬ß](#examples-62)Examples\n\nBasic usage:\n\n```\nlet word = \"goodbye\";\n\nlet count = word.char_indices().count();\nassert_eq!(7, count);\n\nlet mut char_indices = word.char_indices();\n\nassert_eq!(Some((0, 'g')), char_indices.next());\nassert_eq!(Some((1, 'o')), char_indices.next());\nassert_eq!(Some((2, 'o')), char_indices.next());\nassert_eq!(Some((3, 'd')), char_indices.next());\nassert_eq!(Some((4, 'b')), char_indices.next());\nassert_eq!(Some((5, 'y')), char_indices.next());\nassert_eq!(Some((6, 'e')), char_indices.next());\n\nassert_eq!(None, char_indices.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+word+=+%22goodbye%22;%0A++++%0A++++let+count+=+word.char_indices().count();%0A++++assert_eq!(7,+count);%0A++++%0A++++let+mut+char_indices+=+word.char_indices();%0A++++%0A++++assert_eq!(Some((0,+%27g%27)),+char_indices.next());%0A++++assert_eq!(Some((1,+%27o%27)),+char_indices.next());%0A++++assert_eq!(Some((2,+%27o%27)),+char_indices.next());%0A++++assert_eq!(Some((3,+%27d%27)),+char_indices.next());%0A++++assert_eq!(Some((4,+%27b%27)),+char_indices.next());%0A++++assert_eq!(Some((5,+%27y%27)),+char_indices.next());%0A++++assert_eq!(Some((6,+%27e%27)),+char_indices.next());%0A++++%0A++++assert_eq!(None,+char_indices.next());%0A%7D&edition=2021)\n\nRemember, [`char`](../primitive.char.html \"primitive char\")s might not match your intuition about characters:\n\n```\nlet yes = \"yÃÜes\";\n\nlet mut char_indices = yes.char_indices();\n\nassert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'yÃÜ')\nassert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n\n// note the 3 here - the previous character took up two bytes\nassert_eq!(Some((3, 'e')), char_indices.next());\nassert_eq!(Some((4, 's')), char_indices.next());\n\nassert_eq!(None, char_indices.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+yes+=+%22y%CC%86es%22;%0A++++%0A++++let+mut+char_indices+=+yes.char_indices();%0A++++%0A++++assert_eq!(Some((0,+%27y%27)),+char_indices.next());+//+not+(0,+%27y%CC%86%27)%0A++++assert_eq!(Some((1,+%27%5Cu%7B0306%7D%27)),+char_indices.next());%0A++++%0A++++//+note+the+3+here+-+the+previous+character+took+up+two+bytes%0A++++assert_eq!(Some((3,+%27e%27)),+char_indices.next());%0A++++assert_eq!(Some((4,+%27s%27)),+char_indices.next());%0A++++%0A++++assert_eq!(None,+char_indices.next());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#933)\n\nAn iterator over the bytes of a string slice.\n\nAs a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.\n\n##### [¬ß](#examples-63)Examples\n\n```\nlet mut bytes = \"bors\".bytes();\n\nassert_eq!(Some(b'b'), bytes.next());\nassert_eq!(Some(b'o'), bytes.next());\nassert_eq!(Some(b'r'), bytes.next());\nassert_eq!(Some(b's'), bytes.next());\n\nassert_eq!(None, bytes.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+bytes+=+%22bors%22.bytes();%0A++++%0A++++assert_eq!(Some(b%27b%27),+bytes.next());%0A++++assert_eq!(Some(b%27o%27),+bytes.next());%0A++++assert_eq!(Some(b%27r%27),+bytes.next());%0A++++assert_eq!(Some(b%27s%27),+bytes.next());%0A++++%0A++++assert_eq!(None,+bytes.next());%0A%7D&edition=2021)\n\n1.1.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#985)\n\nSplits a string slice by whitespace.\n\nThe iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.\n\n‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property `White_Space`. If you only want to split on ASCII whitespace instead, use [`split_ascii_whitespace`](about:blank/primitive.str.html#method.split_ascii_whitespace \"method str::split_ascii_whitespace\").\n\n##### [¬ß](#examples-64)Examples\n\nBasic usage:\n\n```\nlet mut iter = \"A few words\".split_whitespace();\n\nassert_eq!(Some(\"A\"), iter.next());\nassert_eq!(Some(\"few\"), iter.next());\nassert_eq!(Some(\"words\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22A+few+words%22.split_whitespace();%0A++++%0A++++assert_eq!(Some(%22A%22),+iter.next());%0A++++assert_eq!(Some(%22few%22),+iter.next());%0A++++assert_eq!(Some(%22words%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&edition=2021)\n\nAll kinds of whitespace are considered:\n\n```\nlet mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\nassert_eq!(Some(\"Mary\"), iter.next());\nassert_eq!(Some(\"had\"), iter.next());\nassert_eq!(Some(\"a\"), iter.next());\nassert_eq!(Some(\"little\"), iter.next());\nassert_eq!(Some(\"lamb\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22+Mary+++had%5Cta%5Cu%7B2009%7Dlittle++%5Cn%5Ct+lamb%22.split_whitespace();%0A++++assert_eq!(Some(%22Mary%22),+iter.next());%0A++++assert_eq!(Some(%22had%22),+iter.next());%0A++++assert_eq!(Some(%22a%22),+iter.next());%0A++++assert_eq!(Some(%22little%22),+iter.next());%0A++++assert_eq!(Some(%22lamb%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&edition=2021)\n\nIf the string is empty or all whitespace, the iterator yields no string slices:\n\n```\nassert_eq!(\"\".split_whitespace().next(), None);\nassert_eq!(\"   \".split_whitespace().next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%22.split_whitespace().next(),+None);%0A++++assert_eq!(%22+++%22.split_whitespace().next(),+None);%0A%7D&edition=2021)\n\n1.34.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1034)\n\nSplits a string slice by ASCII whitespace.\n\nThe iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.\n\nTo split by Unicode `Whitespace` instead, use [`split_whitespace`](about:blank/primitive.str.html#method.split_whitespace \"method str::split_whitespace\").\n\n##### [¬ß](#examples-65)Examples\n\nBasic usage:\n\n```\nlet mut iter = \"A few words\".split_ascii_whitespace();\n\nassert_eq!(Some(\"A\"), iter.next());\nassert_eq!(Some(\"few\"), iter.next());\nassert_eq!(Some(\"words\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22A+few+words%22.split_ascii_whitespace();%0A++++%0A++++assert_eq!(Some(%22A%22),+iter.next());%0A++++assert_eq!(Some(%22few%22),+iter.next());%0A++++assert_eq!(Some(%22words%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&edition=2021)\n\nAll kinds of ASCII whitespace are considered:\n\n```\nlet mut iter = \" Mary   had\\ta little  \\n\\t lamb\".split_ascii_whitespace();\nassert_eq!(Some(\"Mary\"), iter.next());\nassert_eq!(Some(\"had\"), iter.next());\nassert_eq!(Some(\"a\"), iter.next());\nassert_eq!(Some(\"little\"), iter.next());\nassert_eq!(Some(\"lamb\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22+Mary+++had%5Cta+little++%5Cn%5Ct+lamb%22.split_ascii_whitespace();%0A++++assert_eq!(Some(%22Mary%22),+iter.next());%0A++++assert_eq!(Some(%22had%22),+iter.next());%0A++++assert_eq!(Some(%22a%22),+iter.next());%0A++++assert_eq!(Some(%22little%22),+iter.next());%0A++++assert_eq!(Some(%22lamb%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&edition=2021)\n\nIf the string is empty or all ASCII whitespace, the iterator yields no string slices:\n\n```\nassert_eq!(\"\".split_ascii_whitespace().next(), None);\nassert_eq!(\"   \".split_ascii_whitespace().next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%22.split_ascii_whitespace().next(),+None);%0A++++assert_eq!(%22+++%22.split_ascii_whitespace().next(),+None);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1092)\n\nAn iterator over the lines of a string, as string slices.\n\nLines are split at line endings that are either newlines (`\\n`) or sequences of a carriage return followed by a line feed (`\\r\\n`).\n\nLine terminators are not included in the lines returned by the iterator.\n\nNote that any carriage return (`\\r`) not immediately followed by a line feed (`\\n`) does not split a line. These carriage returns are thereby included in the produced lines.\n\nThe final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.\n\n##### [¬ß](#examples-66)Examples\n\nBasic usage:\n\n```\nlet text = \"foo\\r\\nbar\\n\\nbaz\\r\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\n// Trailing carriage return is included in the last line\nassert_eq!(Some(\"baz\\r\"), lines.next());\n\nassert_eq!(None, lines.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22foo%5Cr%5Cnbar%5Cn%5Cnbaz%5Cr%22;%0A++++let+mut+lines+=+text.lines();%0A++++%0A++++assert_eq!(Some(%22foo%22),+lines.next());%0A++++assert_eq!(Some(%22bar%22),+lines.next());%0A++++assert_eq!(Some(%22%22),+lines.next());%0A++++//+Trailing+carriage+return+is+included+in+the+last+line%0A++++assert_eq!(Some(%22baz%5Cr%22),+lines.next());%0A++++%0A++++assert_eq!(None,+lines.next());%0A%7D&edition=2021)\n\nThe final line does not require any ending:\n\n```\nlet text = \"foo\\nbar\\n\\r\\nbaz\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\nassert_eq!(Some(\"baz\"), lines.next());\n\nassert_eq!(None, lines.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22foo%5Cnbar%5Cn%5Cr%5Cnbaz%22;%0A++++let+mut+lines+=+text.lines();%0A++++%0A++++assert_eq!(Some(%22foo%22),+lines.next());%0A++++assert_eq!(Some(%22bar%22),+lines.next());%0A++++assert_eq!(Some(%22%22),+lines.next());%0A++++assert_eq!(Some(%22baz%22),+lines.next());%0A++++%0A++++assert_eq!(None,+lines.next());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1105)\n\nüëéDeprecated since 1.4.0: use lines() instead now\n\nAn iterator over the lines of a string.\n\n1.8.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1124)\n\nReturns an iterator of `u16` over the string encoded as UTF-16.\n\n##### [¬ß](#examples-67)Examples\n\n```\nlet text = \"Za≈º√≥≈Çƒá gƒô≈õlƒÖ ja≈∫≈Ñ\";\n\nlet utf8_len = text.len();\nlet utf16_len = text.encode_utf16().count();\n\nassert!(utf16_len <= utf8_len);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22Za%C5%BC%C3%B3%C5%82%C4%87+g%C4%99%C5%9Bl%C4%85+ja%C5%BA%C5%84%22;%0A++++%0A++++let+utf8_len+=+text.len();%0A++++let+utf16_len+=+text.encode_utf16().count();%0A++++%0A++++assert!(utf16_len+%3C=+utf8_len);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1149)\n\nReturns `true` if the given pattern matches a sub-slice of this string slice.\n\nReturns `false` if it does not.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#examples-68)Examples\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.contains(\"nana\"));\nassert!(!bananas.contains(\"apples\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.contains(%22nana%22));%0A++++assert!(!bananas.contains(%22apples%22));%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1186)\n\nReturns `true` if the given pattern matches a prefix of this string slice.\n\nReturns `false` if it does not.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, in which case this function will return true if the `&str` is a prefix of this string slice.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can also be a [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches. These will only be checked against the first character of this string slice. Look at the second example below regarding behavior for slices of [`char`](../primitive.char.html \"primitive char\")s.\n\n##### [¬ß](#examples-69)Examples\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.starts_with(\"bana\"));\nassert!(!bananas.starts_with(\"nana\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.starts_with(%22bana%22));%0A++++assert!(!bananas.starts_with(%22nana%22));%0A%7D&edition=2021)\n\n```\nlet bananas = \"bananas\";\n\n// Note that both of these assert successfully.\nassert!(bananas.starts_with(&['b', 'a', 'n', 'a']));\nassert!(bananas.starts_with(&['a', 'b', 'c', 'd']));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++//+Note+that+both+of+these+assert+successfully.%0A++++assert!(bananas.starts_with(%26%5B%27b%27,+%27a%27,+%27n%27,+%27a%27%5D));%0A++++assert!(bananas.starts_with(%26%5B%27a%27,+%27b%27,+%27c%27,+%27d%27%5D));%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1210-1212)\n\nReturns `true` if the given pattern matches a suffix of this string slice.\n\nReturns `false` if it does not.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#examples-70)Examples\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.ends_with(\"anas\"));\nassert!(!bananas.ends_with(\"nana\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.ends_with(%22anas%22));%0A++++assert!(!bananas.ends_with(%22nana%22));%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1261)\n\nReturns the byte index of the first character of this string slice that matches the pattern.\n\nReturns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") if the pattern doesn‚Äôt match.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#examples-71)Examples\n\nSimple patterns:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard Gepardi\";\n\nassert_eq!(s.find('L'), Some(0));\nassert_eq!(s.find('√©'), Some(14));\nassert_eq!(s.find(\"pard\"), Some(17));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard+Gepardi%22;%0A++++%0A++++assert_eq!(s.find(%27L%27),+Some(0));%0A++++assert_eq!(s.find(%27%C3%A9%27),+Some(14));%0A++++assert_eq!(s.find(%22pard%22),+Some(17));%0A%7D&edition=2021)\n\nMore complex patterns using point-free style and closures:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.find(char::is_whitespace), Some(5));\nassert_eq!(s.find(char::is_lowercase), Some(1));\nassert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\nassert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++assert_eq!(s.find(char::is_whitespace),+Some(5));%0A++++assert_eq!(s.find(char::is_lowercase),+Some(1));%0A++++assert_eq!(s.find(%7Cc:+char%7C+c.is_whitespace()+%7C%7C+c.is_lowercase()),+Some(1));%0A++++assert_eq!(s.find(%7Cc:+char%7C+(c+%3C+%27o%27)+%26%26+(c+%3E+%27a%27)),+Some(4));%0A%7D&edition=2021)\n\nNot finding the pattern:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.find(x), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++let+x:+%26%5B_%5D+=+%26%5B%271%27,+%272%27%5D;%0A++++%0A++++assert_eq!(s.find(x),+None);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1307-1309)\n\nReturns the byte index for the first character of the last match of the pattern in this string slice.\n\nReturns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") if the pattern doesn‚Äôt match.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#examples-72)Examples\n\nSimple patterns:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard Gepardi\";\n\nassert_eq!(s.rfind('L'), Some(13));\nassert_eq!(s.rfind('√©'), Some(14));\nassert_eq!(s.rfind(\"pard\"), Some(24));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard+Gepardi%22;%0A++++%0A++++assert_eq!(s.rfind(%27L%27),+Some(13));%0A++++assert_eq!(s.rfind(%27%C3%A9%27),+Some(14));%0A++++assert_eq!(s.rfind(%22pard%22),+Some(24));%0A%7D&edition=2021)\n\nMore complex patterns with closures:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.rfind(char::is_whitespace), Some(12));\nassert_eq!(s.rfind(char::is_lowercase), Some(20));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++assert_eq!(s.rfind(char::is_whitespace),+Some(12));%0A++++assert_eq!(s.rfind(char::is_lowercase),+Some(20));%0A%7D&edition=2021)\n\nNot finding the pattern:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.rfind(x), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++let+x:+%26%5B_%5D+=+%26%5B%271%27,+%272%27%5D;%0A++++%0A++++assert_eq!(s.rfind(x),+None);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1429)\n\nAn iterator over substrings of this string slice, separated by characters matched by a pattern.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#iterator-behavior)Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`](../iter/trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., [`char`](../primitive.char.html \"primitive char\"), but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ from a forward search, the [`rsplit`](about:blank/primitive.str.html#method.rsplit \"method str::rsplit\") method can be used.\n\n##### [¬ß](#examples-73)Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n\nlet v: Vec<&str> = \"\".split('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\nassert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n\nlet v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.split(%27+%27).collect();%0A++++assert_eq!(v,+%5B%22Mary%22,+%22had%22,+%22a%22,+%22little%22,+%22lamb%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.split(%27X%27).collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.split(%27X%27).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22%22,+%22tiger%22,+%22leopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.split(%22::%22).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22tiger%22,+%22leopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1def2ghi%22.split(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22def%22,+%22ghi%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXtigerXleopard%22.split(char::is_uppercase).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22tiger%22,+%22leopard%22%5D);%0A%7D&edition=2021)\n\nIf the pattern is a slice of chars, split on each occurrence of any of the characters:\n\n```\nlet v: Vec<&str> = \"2020-11-03 23:59\".split(&['-', ' ', ':', '@'][..]).collect();\nassert_eq!(v, [\"2020\", \"11\", \"03\", \"23\", \"59\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%222020-11-03+23:59%22.split(%26%5B%27-%27,+%27+%27,+%27:%27,+%27%40%27%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%222020%22,+%2211%22,+%2203%22,+%2223%22,+%2259%22%5D);%0A%7D&edition=2021)\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.split(%7Cc%7C+c+==+%271%27+%7C%7C+c+==+%27X%27).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22def%22,+%22ghi%22%5D);%0A%7D&edition=2021)\n\nIf a string contains multiple contiguous separators, you will end up with empty strings in the output:\n\n```\nlet x = \"||||a||b|c\".to_string();\nlet d: Vec<_> = x.split('|').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22%7C%7C%7C%7Ca%7C%7Cb%7Cc%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split(%27%7C%27).collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22%22,+%22%22,+%22%22,+%22%22,+%22a%22,+%22%22,+%22b%22,+%22c%22%5D);%0A%7D&edition=2021)\n\nContiguous separators are separated by the empty string.\n\n```\nlet x = \"(///)\".to_string();\nlet d: Vec<_> = x.split('/').collect();\n\nassert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22(///)%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split(%27/%27).collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22(%22,+%22%22,+%22%22,+%22)%22%5D);%0A%7D&edition=2021)\n\nSeparators at the start or end of a string are neighbored by empty strings.\n\n```\nlet d: Vec<_> = \"010\".split(\"0\").collect();\nassert_eq!(d, &[\"\", \"1\", \"\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+d:+Vec%3C_%3E+=+%22010%22.split(%220%22).collect();%0A++++assert_eq!(d,+%26%5B%22%22,+%221%22,+%22%22%5D);%0A%7D&edition=2021)\n\nWhen the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.\n\n```\nlet f: Vec<_> = \"rust\".split(\"\").collect();\nassert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f:+Vec%3C_%3E+=+%22rust%22.split(%22%22).collect();%0A++++assert_eq!(f,+%26%5B%22%22,+%22r%22,+%22u%22,+%22s%22,+%22t%22,+%22%22%5D);%0A%7D&edition=2021)\n\nContiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct:\n\n```\nlet x = \"    a  b c\".to_string();\nlet d: Vec<_> = x.split(' ').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22++++a++b+c%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split(%27+%27).collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22%22,+%22%22,+%22%22,+%22%22,+%22a%22,+%22%22,+%22b%22,+%22c%22%5D);%0A%7D&edition=2021)\n\nIt does _not_ give you:\n\n[‚ìò](# \"This example is not tested\")\n\n```\nassert_eq!(d, &[\"a\", \"b\", \"c\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(d,+%26%5B%22a%22,+%22b%22,+%22c%22%5D);%0A%7D&edition=2021)\n\nUse [`split_whitespace`](about:blank/primitive.str.html#method.split_whitespace \"method str::split_whitespace\") for this behavior.\n\n1.51.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1469)\n\nAn iterator over substrings of this string slice, separated by characters matched by a pattern. Differs from the iterator produced by `split` in that `split_inclusive` leaves the matched part as the terminator of the substring.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#examples-74)Examples\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\"\n    .split_inclusive('\\n').collect();\nassert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%5Cnlittle+lamb%5Cnlittle+lamb.%22%0A++++++++.split_inclusive(%27%5Cn%27).collect();%0A++++assert_eq!(v,+%5B%22Mary+had+a+little+lamb%5Cn%22,+%22little+lamb%5Cn%22,+%22little+lamb.%22%5D);%0A%7D&edition=2021)\n\nIf the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\\n\"\n    .split_inclusive('\\n').collect();\nassert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\\n\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%5Cnlittle+lamb%5Cnlittle+lamb.%5Cn%22%0A++++++++.split_inclusive(%27%5Cn%27).collect();%0A++++assert_eq!(v,+%5B%22Mary+had+a+little+lamb%5Cn%22,+%22little+lamb%5Cn%22,+%22little+lamb.%5Cn%22%5D);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1524-1526)\n\nAn iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#iterator-behavior-1)Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse search, and it will be a [`DoubleEndedIterator`](../iter/trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") if a forward/reverse search yields the same elements.\n\nFor iterating from the front, the [`split`](about:blank/primitive.str.html#method.split \"method str::split\") method can be used.\n\n##### [¬ß](#examples-75)Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n\nlet v: Vec<&str> = \"\".rsplit('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.rsplit(%27+%27).collect();%0A++++assert_eq!(v,+%5B%22lamb%22,+%22little%22,+%22a%22,+%22had%22,+%22Mary%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.rsplit(%27X%27).collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.rsplit(%27X%27).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22%22,+%22lion%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.rsplit(%22::%22).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22lion%22%5D);%0A%7D&edition=2021)\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.rsplit(%7Cc%7C+c+==+%271%27+%7C%7C+c+==+%27X%27).collect();%0A++++assert_eq!(v,+%5B%22ghi%22,+%22def%22,+%22abc%22%5D);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1573)\n\nAn iterator over substrings of the given string slice, separated by characters matched by a pattern.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\nEquivalent to [`split`](about:blank/primitive.str.html#method.split \"method str::split\"), except that the trailing substring is skipped if empty.\n\nThis method can be used for string data that is _terminated_, rather than _separated_ by a pattern.\n\n##### [¬ß](#iterator-behavior-2)Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`](../iter/trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., [`char`](../primitive.char.html \"primitive char\"), but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ from a forward search, the [`rsplit_terminator`](about:blank/primitive.str.html#method.rsplit_terminator \"method str::rsplit_terminator\") method can be used.\n\n##### [¬ß](#examples-76)Examples\n\n```\nlet v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\nassert_eq!(v, [\"A\", \"B\"]);\n\nlet v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\nassert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n\nlet v: Vec<&str> = \"A.B:C.D\".split_terminator(&['.', ':'][..]).collect();\nassert_eq!(v, [\"A\", \"B\", \"C\", \"D\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B.%22.split_terminator(%27.%27).collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22B%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A..B..%22.split_terminator(%22.%22).collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22%22,+%22B%22,+%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B:C.D%22.split_terminator(%26%5B%27.%27,+%27:%27%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22B%22,+%22C%22,+%22D%22%5D);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1619-1621)\n\nAn iterator over substrings of `self`, separated by characters matched by a pattern and yielded in reverse order.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\nEquivalent to [`split`](about:blank/primitive.str.html#method.split \"method str::split\"), except that the trailing substring is skipped if empty.\n\nThis method can be used for string data that is _terminated_, rather than _separated_ by a pattern.\n\n##### [¬ß](#iterator-behavior-3)Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.\n\nFor iterating from the front, the [`split_terminator`](about:blank/primitive.str.html#method.split_terminator \"method str::split_terminator\") method can be used.\n\n##### [¬ß](#examples-77)Examples\n\n```\nlet v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\nassert_eq!(v, [\"B\", \"A\"]);\n\nlet v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\nassert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n\nlet v: Vec<&str> = \"A.B:C.D\".rsplit_terminator(&['.', ':'][..]).collect();\nassert_eq!(v, [\"D\", \"C\", \"B\", \"A\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B.%22.rsplit_terminator(%27.%27).collect();%0A++++assert_eq!(v,+%5B%22B%22,+%22A%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A..B..%22.rsplit_terminator(%22.%22).collect();%0A++++assert_eq!(v,+%5B%22%22,+%22B%22,+%22%22,+%22A%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B:C.D%22.rsplit_terminator(%26%5B%27.%27,+%27:%27%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%22D%22,+%22C%22,+%22B%22,+%22A%22%5D);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1674)\n\nAn iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most `n` items.\n\nIf `n` substrings are returned, the last substring (the `n`th substring) will contain the remainder of the string.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#iterator-behavior-4)Iterator behavior\n\nThe returned iterator will not be double ended, because it is not efficient to support.\n\nIf the pattern allows a reverse search, the [`rsplitn`](about:blank/primitive.str.html#method.rsplitn \"method str::rsplitn\") method can be used.\n\n##### [¬ß](#examples-78)Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\nassert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n\nlet v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\nassert_eq!(v, [\"abcXdef\"]);\n\nlet v: Vec<&str> = \"\".splitn(1, 'X').collect();\nassert_eq!(v, [\"\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lambda%22.splitn(3,+%27+%27).collect();%0A++++assert_eq!(v,+%5B%22Mary%22,+%22had%22,+%22a+little+lambda%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.splitn(3,+%22X%22).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22%22,+%22tigerXleopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXdef%22.splitn(1,+%27X%27).collect();%0A++++assert_eq!(v,+%5B%22abcXdef%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.splitn(1,+%27X%27).collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A%7D&edition=2021)\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"defXghi\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.splitn(2,+%7Cc%7C+c+==+%271%27+%7C%7C+c+==+%27X%27).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22defXghi%22%5D);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1723-1725)\n\nAn iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most `n` items.\n\nIf `n` substrings are returned, the last substring (the `n`th substring) will contain the remainder of the string.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#iterator-behavior-5)Iterator behavior\n\nThe returned iterator will not be double ended, because it is not efficient to support.\n\nFor splitting from the front, the [`splitn`](about:blank/primitive.str.html#method.splitn \"method str::splitn\") method can be used.\n\n##### [¬ß](#examples-79)Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\nassert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.rsplitn(3,+%27+%27).collect();%0A++++assert_eq!(v,+%5B%22lamb%22,+%22little%22,+%22Mary+had+a%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.rsplitn(3,+%27X%27).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22lionX%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.rsplitn(2,+%22::%22).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22lion::tiger%22%5D);%0A%7D&edition=2021)\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"abc1def\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.rsplitn(2,+%7Cc%7C+c+==+%271%27+%7C%7C+c+==+%27X%27).collect();%0A++++assert_eq!(v,+%5B%22ghi%22,+%22abc1def%22%5D);%0A%7D&edition=2021)\n\n1.52.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1743)\n\nSplits the string on the first occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.\n\n##### [¬ß](#examples-80)Examples\n\n```\nassert_eq!(\"cfg\".split_once('='), None);\nassert_eq!(\"cfg=\".split_once('='), Some((\"cfg\", \"\")));\nassert_eq!(\"cfg=foo\".split_once('='), Some((\"cfg\", \"foo\")));\nassert_eq!(\"cfg=foo=bar\".split_once('='), Some((\"cfg\", \"foo=bar\")));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22cfg%22.split_once(%27=%27),+None);%0A++++assert_eq!(%22cfg=%22.split_once(%27=%27),+Some((%22cfg%22,+%22%22)));%0A++++assert_eq!(%22cfg=foo%22.split_once(%27=%27),+Some((%22cfg%22,+%22foo%22)));%0A++++assert_eq!(%22cfg=foo=bar%22.split_once(%27=%27),+Some((%22cfg%22,+%22foo=bar%22)));%0A%7D&edition=2021)\n\n1.52.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1761-1763)\n\nSplits the string on the last occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.\n\n##### [¬ß](#examples-81)Examples\n\n```\nassert_eq!(\"cfg\".rsplit_once('='), None);\nassert_eq!(\"cfg=foo\".rsplit_once('='), Some((\"cfg\", \"foo\")));\nassert_eq!(\"cfg=foo=bar\".rsplit_once('='), Some((\"cfg=foo\", \"bar\")));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22cfg%22.rsplit_once(%27=%27),+None);%0A++++assert_eq!(%22cfg=foo%22.rsplit_once(%27=%27),+Some((%22cfg%22,+%22foo%22)));%0A++++assert_eq!(%22cfg=foo=bar%22.rsplit_once(%27=%27),+Some((%22cfg=foo%22,+%22bar%22)));%0A%7D&edition=2021)\n\n1.2.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1801)\n\nAn iterator over the disjoint matches of a pattern within the given string slice.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#iterator-behavior-6)Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`](../iter/trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., [`char`](../primitive.char.html \"primitive char\"), but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ from a forward search, the [`rmatches`](about:blank/primitive.str.html#method.rmatches \"method str::rmatches\") method can be used.\n\n##### [¬ß](#examples-82)Examples\n\n```\nlet v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\nassert_eq!(v, [\"1\", \"2\", \"3\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXXXabcYYYabc%22.matches(%22abc%22).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22abc%22,+%22abc%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%221abc2abc3%22.matches(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%221%22,+%222%22,+%223%22%5D);%0A%7D&edition=2021)\n\n1.2.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1835-1837)\n\nAn iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#iterator-behavior-7)Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse search, and it will be a [`DoubleEndedIterator`](../iter/trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") if a forward/reverse search yields the same elements.\n\nFor iterating from the front, the [`matches`](about:blank/primitive.str.html#method.matches \"method str::matches\") method can be used.\n\n##### [¬ß](#examples-83)Examples\n\n```\nlet v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\nassert_eq!(v, [\"3\", \"2\", \"1\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXXXabcYYYabc%22.rmatches(%22abc%22).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22abc%22,+%22abc%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%221abc2abc3%22.rmatches(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%223%22,+%222%22,+%221%22%5D);%0A%7D&edition=2021)\n\n1.5.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1879)\n\nAn iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.\n\nFor matches of `pat` within `self` that overlap, only the indices corresponding to the first match are returned.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#iterator-behavior-8)Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`](../iter/trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., [`char`](../primitive.char.html \"primitive char\"), but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ from a forward search, the [`rmatch_indices`](about:blank/primitive.str.html#method.rmatch_indices \"method str::rmatch_indices\") method can be used.\n\n##### [¬ß](#examples-84)Examples\n\n```\nlet v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\nassert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\nassert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\nassert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C_%3E+=+%22abcXXXabcYYYabc%22.match_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(0,+%22abc%22),+(6,+%22abc%22),+(12,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%221abcabc2%22.match_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(1,+%22abc%22),+(4,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%22ababa%22.match_indices(%22aba%22).collect();%0A++++assert_eq!(v,+%5B(0,+%22aba%22)%5D);+//+only+the+first+%60aba%60%0A%7D&edition=2021)\n\n1.5.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1919-1921)\n\nAn iterator over the disjoint matches of a pattern within `self`, yielded in reverse order along with the index of the match.\n\nFor matches of `pat` within `self` that overlap, only the indices corresponding to the last match are returned.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#iterator-behavior-9)Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse search, and it will be a [`DoubleEndedIterator`](../iter/trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") if a forward/reverse search yields the same elements.\n\nFor iterating from the front, the [`match_indices`](about:blank/primitive.str.html#method.match_indices \"method str::match_indices\") method can be used.\n\n##### [¬ß](#examples-85)Examples\n\n```\nlet v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\nassert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C_%3E+=+%22abcXXXabcYYYabc%22.rmatch_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(12,+%22abc%22),+(6,+%22abc%22),+(0,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%221abcabc2%22.rmatch_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(4,+%22abc%22),+(1,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%22ababa%22.rmatch_indices(%22aba%22).collect();%0A++++assert_eq!(v,+%5B(2,+%22aba%22)%5D);+//+only+the+last+%60aba%60%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1943)\n\nReturns a string slice with leading and trailing whitespace removed.\n\n‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property `White_Space`, which includes newlines.\n\n##### [¬ß](#examples-86)Examples\n\n```\nlet s = \"\\n Hello\\tworld\\t\\n\";\n\nassert_eq!(\"Hello\\tworld\", s.trim());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++%0A++++assert_eq!(%22Hello%5Ctworld%22,+s.trim());%0A%7D&edition=2021)\n\n1.30.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1982)\n\nReturns a string slice with leading whitespace removed.\n\n‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property `White_Space`, which includes newlines.\n\n##### [¬ß](#text-directionality)Text directionality\n\nA string is a sequence of bytes. `start` in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.\n\n##### [¬ß](#examples-87)Examples\n\nBasic usage:\n\n```\nlet s = \"\\n Hello\\tworld\\t\\n\";\nassert_eq!(\"Hello\\tworld\\t\\n\", s.trim_start());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++assert_eq!(%22Hello%5Ctworld%5Ct%5Cn%22,+s.trim_start());%0A%7D&edition=2021)\n\nDirectionality:\n\n```\nlet s = \"  English  \";\nassert!(Some('E') == s.trim_start().chars().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊¢') == s.trim_start().chars().next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English++%22;%0A++++assert!(Some(%27E%27)+==+s.trim_start().chars().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some(%27%D7%A2%27)+==+s.trim_start().chars().next());%0A%7D&edition=2021)\n\n1.30.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2021)\n\nReturns a string slice with trailing whitespace removed.\n\n‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property `White_Space`, which includes newlines.\n\n##### [¬ß](#text-directionality-1)Text directionality\n\nA string is a sequence of bytes. `end` in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.\n\n##### [¬ß](#examples-88)Examples\n\nBasic usage:\n\n```\nlet s = \"\\n Hello\\tworld\\t\\n\";\nassert_eq!(\"\\n Hello\\tworld\", s.trim_end());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++assert_eq!(%22%5Cn+Hello%5Ctworld%22,+s.trim_end());%0A%7D&edition=2021)\n\nDirectionality:\n\n```\nlet s = \"  English  \";\nassert!(Some('h') == s.trim_end().chars().rev().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊™') == s.trim_end().chars().rev().next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English++%22;%0A++++assert!(Some(%27h%27)+==+s.trim_end().chars().rev().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some(%27%D7%AA%27)+==+s.trim_end().chars().rev().next());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2061)\n\nüëéDeprecated since 1.33.0: superseded by `trim_start`\n\nReturns a string slice with leading whitespace removed.\n\n‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property `White_Space`.\n\n##### [¬ß](#text-directionality-2)Text directionality\n\nA string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the _right_ side, not the left.\n\n##### [¬ß](#examples-89)Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\n\nassert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22+Hello%5Ctworld%5Ct%22;%0A++++%0A++++assert_eq!(%22Hello%5Ctworld%5Ct%22,+s.trim_left());%0A%7D&edition=2021)\n\nDirectionality:\n\n```\nlet s = \"  English\";\nassert!(Some('E') == s.trim_left().chars().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™\";\nassert!(Some('◊¢') == s.trim_left().chars().next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English%22;%0A++++assert!(Some(%27E%27)+==+s.trim_left().chars().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA%22;%0A++++assert!(Some(%27%D7%A2%27)+==+s.trim_left().chars().next());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2101)\n\nüëéDeprecated since 1.33.0: superseded by `trim_end`\n\nReturns a string slice with trailing whitespace removed.\n\n‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property `White_Space`.\n\n##### [¬ß](#text-directionality-3)Text directionality\n\nA string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the _left_ side, not the right.\n\n##### [¬ß](#examples-90)Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\n\nassert_eq!(\" Hello\\tworld\", s.trim_right());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22+Hello%5Ctworld%5Ct%22;%0A++++%0A++++assert_eq!(%22+Hello%5Ctworld%22,+s.trim_right());%0A%7D&edition=2021)\n\nDirectionality:\n\n```\nlet s = \"English  \";\nassert!(Some('h') == s.trim_right().chars().rev().next());\n\nlet s = \"◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊™') == s.trim_right().chars().rev().next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22English++%22;%0A++++assert!(Some(%27h%27)+==+s.trim_right().chars().rev().next());%0A++++%0A++++let+s+=+%22%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some(%27%D7%AA%27)+==+s.trim_right().chars().rev().next());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2134-2136)\n\nReturns a string slice with all prefixes and suffixes that match a pattern repeatedly removed.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#examples-91)Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_matches(%271%27),+%22foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_matches(char::is_numeric),+%22foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B%271%27,+%272%27%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_matches(x),+%22foo1bar%22);%0A%7D&edition=2021)\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221foo1barXX%22.trim_matches(%7Cc%7C+c+==+%271%27+%7C%7C+c+==+%27X%27),+%22foo1bar%22);%0A%7D&edition=2021)\n\n1.30.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2181)\n\nReturns a string slice with all prefixes that match a pattern repeatedly removed.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#text-directionality-4)Text directionality\n\nA string is a sequence of bytes. `start` in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.\n\n##### [¬ß](#examples-92)Examples\n\n```\nassert_eq!(\"11foo1bar11\".trim_start_matches('1'), \"foo1bar11\");\nassert_eq!(\"123foo1bar123\".trim_start_matches(char::is_numeric), \"foo1bar123\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_start_matches(x), \"foo1bar12\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_start_matches(%271%27),+%22foo1bar11%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_start_matches(char::is_numeric),+%22foo1bar123%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B%271%27,+%272%27%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_start_matches(x),+%22foo1bar12%22);%0A%7D&edition=2021)\n\n1.45.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2214)\n\nReturns a string slice with the prefix removed.\n\nIf the string starts with the pattern `prefix`, returns the substring after the prefix, wrapped in `Some`. Unlike `trim_start_matches`, this method removes the prefix exactly once.\n\nIf the string does not start with `prefix`, returns `None`.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#examples-93)Examples\n\n```\nassert_eq!(\"foo:bar\".strip_prefix(\"foo:\"), Some(\"bar\"));\nassert_eq!(\"foo:bar\".strip_prefix(\"bar\"), None);\nassert_eq!(\"foofoo\".strip_prefix(\"foo\"), Some(\"foo\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22foo:bar%22.strip_prefix(%22foo:%22),+Some(%22bar%22));%0A++++assert_eq!(%22foo:bar%22.strip_prefix(%22bar%22),+None);%0A++++assert_eq!(%22foofoo%22.strip_prefix(%22foo%22),+Some(%22foo%22));%0A%7D&edition=2021)\n\n1.45.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2241-2244)\n\nReturns a string slice with the suffix removed.\n\nIf the string ends with the pattern `suffix`, returns the substring before the suffix, wrapped in `Some`. Unlike `trim_end_matches`, this method removes the suffix exactly once.\n\nIf the string does not end with `suffix`, returns `None`.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#examples-94)Examples\n\n```\nassert_eq!(\"bar:foo\".strip_suffix(\":foo\"), Some(\"bar\"));\nassert_eq!(\"bar:foo\".strip_suffix(\"bar\"), None);\nassert_eq!(\"foofoo\".strip_suffix(\"foo\"), Some(\"foo\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22bar:foo%22.strip_suffix(%22:foo%22),+Some(%22bar%22));%0A++++assert_eq!(%22bar:foo%22.strip_suffix(%22bar%22),+None);%0A++++assert_eq!(%22foofoo%22.strip_suffix(%22foo%22),+Some(%22foo%22));%0A%7D&edition=2021)\n\n1.30.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2285-2287)\n\nReturns a string slice with all suffixes that match a pattern repeatedly removed.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#text-directionality-5)Text directionality\n\nA string is a sequence of bytes. `end` in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.\n\n##### [¬ß](#examples-95)Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_end_matches('1'), \"11foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_end_matches(char::is_numeric), \"123foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_end_matches(x), \"12foo1bar\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_end_matches(%271%27),+%2211foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_end_matches(char::is_numeric),+%22123foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B%271%27,+%272%27%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_end_matches(x),+%2212foo1bar%22);%0A%7D&edition=2021)\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1fooX\".trim_end_matches(|c| c == '1' || c == 'X'), \"1foo\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221fooX%22.trim_end_matches(%7Cc%7C+c+==+%271%27+%7C%7C+c+==+%27X%27),+%221foo%22);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2329)\n\nüëéDeprecated since 1.33.0: superseded by `trim_start_matches`\n\nReturns a string slice with all prefixes that match a pattern repeatedly removed.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#text-directionality-6)Text directionality\n\nA string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the _right_ side, not the left.\n\n##### [¬ß](#examples-96)Examples\n\n```\nassert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\nassert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_left_matches(%271%27),+%22foo1bar11%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_left_matches(char::is_numeric),+%22foo1bar123%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B%271%27,+%272%27%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_left_matches(x),+%22foo1bar12%22);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2372-2374)\n\nüëéDeprecated since 1.33.0: superseded by `trim_end_matches`\n\nReturns a string slice with all suffixes that match a pattern repeatedly removed.\n\nThe [pattern](../str/pattern/index.html \"mod std::str::pattern\") can be a `&str`, [`char`](../primitive.char.html \"primitive char\"), a slice of [`char`](../primitive.char.html \"primitive char\")s, or a function or closure that determines if a character matches.\n\n##### [¬ß](#text-directionality-7)Text directionality\n\nA string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the _left_ side, not the right.\n\n##### [¬ß](#examples-97)Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_right_matches(%271%27),+%2211foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_right_matches(char::is_numeric),+%22123foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B%271%27,+%272%27%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_right_matches(x),+%2212foo1bar%22);%0A%7D&edition=2021)\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221fooX%22.trim_right_matches(%7Cc%7C+c+==+%271%27+%7C%7C+c+==+%27X%27),+%221foo%22);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2424)\n\nParses this string slice into another type.\n\nBecause `parse` is so general, it can cause problems with type inference. As such, `parse` is one of the few times you‚Äôll see the syntax affectionately known as the ‚Äòturbofish‚Äô: `::<>`. This helps the inference algorithm understand specifically which type you‚Äôre trying to parse into.\n\n`parse` can parse into any type that implements the [`FromStr`](../str/trait.FromStr.html \"trait std::str::FromStr\") trait.\n\n##### [¬ß](#errors-4)Errors\n\nWill return [`Err`](about:blank/str/trait.FromStr.html#associatedtype.Err \"associated type std::str::FromStr::Err\") if it‚Äôs not possible to parse this string slice into the desired type.\n\n##### [¬ß](#examples-98)Examples\n\nBasic usage\n\n```\nlet four: u32 = \"4\".parse().unwrap();\n\nassert_eq!(4, four);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+four:+u32+=+%224%22.parse().unwrap();%0A++++%0A++++assert_eq!(4,+four);%0A%7D&edition=2021)\n\nUsing the ‚Äòturbofish‚Äô instead of annotating `four`:\n\n```\nlet four = \"4\".parse::<u32>();\n\nassert_eq!(Ok(4), four);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+four+=+%224%22.parse::%3Cu32%3E();%0A++++%0A++++assert_eq!(Ok(4),+four);%0A%7D&edition=2021)\n\nFailing to parse:\n\n```\nlet nope = \"j\".parse::<u32>();\n\nassert!(nope.is_err());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+nope+=+%22j%22.parse::%3Cu32%3E();%0A++++%0A++++assert!(nope.is_err());%0A%7D&edition=2021)\n\n1.23.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2443)\n\nChecks if all characters in this string are within the ASCII range.\n\n##### [¬ß](#examples-99)Examples\n\n```\nlet ascii = \"hello!\\n\";\nlet non_ascii = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert!(ascii.is_ascii());\nassert!(!non_ascii.is_ascii());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ascii+=+%22hello!%5Cn%22;%0A++++let+non_ascii+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert!(ascii.is_ascii());%0A++++assert!(!non_ascii.is_ascii());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2455)\n\nüî¨This is a nightly-only experimental API. (`ascii_char`¬†[#110998](https://github.com/rust-lang/rust/issues/110998))\n\nIf this string slice [`is_ascii`](about:blank/primitive.str.html#method.is_ascii \"method str::is_ascii\"), returns it as a slice of [ASCII characters](../ascii/enum.Char.html \"enum std::ascii::Char\"), otherwise returns `None`.\n\n1.23.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2475)\n\nChecks that two strings are an ASCII case-insensitive match.\n\nSame as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`, but without allocating and copying temporaries.\n\n##### [¬ß](#examples-100)Examples\n\n```\nassert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\nassert!(\"Ferr√∂s\".eq_ignore_ascii_case(\"FERR√∂S\"));\nassert!(!\"Ferr√∂s\".eq_ignore_ascii_case(\"FERR√ñS\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!(%22Ferris%22.eq_ignore_ascii_case(%22FERRIS%22));%0A++++assert!(%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%B6S%22));%0A++++assert!(!%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%96S%22));%0A%7D&edition=2021)\n\n1.23.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2500)\n\nConverts this string to its ASCII upper case equivalent in-place.\n\nASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô, but non-ASCII letters are unchanged.\n\nTo return a new uppercased value without modifying the existing one, use [`to_ascii_uppercase()`](#method.to_ascii_uppercase).\n\n##### [¬ß](#examples-101)Examples\n\n```\nlet mut s = String::from(\"Gr√º√üe, J√ºrgen ‚ù§\");\n\ns.make_ascii_uppercase();\n\nassert_eq!(\"GR√º√üE, J√ºRGEN ‚ù§\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22);%0A++++%0A++++s.make_ascii_uppercase();%0A++++%0A++++assert_eq!(%22GR%C3%BC%C3%9FE,+J%C3%BCRGEN+%E2%9D%A4%22,+s);%0A%7D&edition=2021)\n\n1.23.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2527)\n\nConverts this string to its ASCII lower case equivalent in-place.\n\nASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô, but non-ASCII letters are unchanged.\n\nTo return a new lowercased value without modifying the existing one, use [`to_ascii_lowercase()`](#method.to_ascii_lowercase).\n\n##### [¬ß](#examples-102)Examples\n\n```\nlet mut s = String::from(\"GR√ú√üE, J√úRGEN ‚ù§\");\n\ns.make_ascii_lowercase();\n\nassert_eq!(\"gr√ú√üe, j√úrgen ‚ù§\", s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22GR%C3%9C%C3%9FE,+J%C3%9CRGEN+%E2%9D%A4%22);%0A++++%0A++++s.make_ascii_lowercase();%0A++++%0A++++assert_eq!(%22gr%C3%9C%C3%9Fe,+j%C3%9Crgen+%E2%9D%A4%22,+s);%0A%7D&edition=2021)\n\n1.80.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2552)\n\nReturns a string slice with leading ASCII whitespace removed.\n\n‚ÄòWhitespace‚Äô refers to the definition used by [`u8::is_ascii_whitespace`](about:blank/primitive.u8.html#method.is_ascii_whitespace \"method u8::is_ascii_whitespace\").\n\n##### [¬ß](#examples-103)Examples\n\n```\nassert_eq!(\" \\t \\u{3000}hello world\\n\".trim_ascii_start(), \"\\u{3000}hello world\\n\");\nassert_eq!(\"  \".trim_ascii_start(), \"\");\nassert_eq!(\"\".trim_ascii_start(), \"\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22+%5Ct+%5Cu%7B3000%7Dhello+world%5Cn%22.trim_ascii_start(),+%22%5Cu%7B3000%7Dhello+world%5Cn%22);%0A++++assert_eq!(%22++%22.trim_ascii_start(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii_start(),+%22%22);%0A%7D&edition=2021)\n\n1.80.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2577)\n\nReturns a string slice with trailing ASCII whitespace removed.\n\n‚ÄòWhitespace‚Äô refers to the definition used by [`u8::is_ascii_whitespace`](about:blank/primitive.u8.html#method.is_ascii_whitespace \"method u8::is_ascii_whitespace\").\n\n##### [¬ß](#examples-104)Examples\n\n```\nassert_eq!(\"\\r hello world\\u{3000}\\n \".trim_ascii_end(), \"\\r hello world\\u{3000}\");\nassert_eq!(\"  \".trim_ascii_end(), \"\");\nassert_eq!(\"\".trim_ascii_end(), \"\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%5Cr+hello+world%5Cu%7B3000%7D%5Cn+%22.trim_ascii_end(),+%22%5Cr+hello+world%5Cu%7B3000%7D%22);%0A++++assert_eq!(%22++%22.trim_ascii_end(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii_end(),+%22%22);%0A%7D&edition=2021)\n\n1.80.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2603)\n\nReturns a string slice with leading and trailing ASCII whitespace removed.\n\n‚ÄòWhitespace‚Äô refers to the definition used by [`u8::is_ascii_whitespace`](about:blank/primitive.u8.html#method.is_ascii_whitespace \"method u8::is_ascii_whitespace\").\n\n##### [¬ß](#examples-105)Examples\n\n```\nassert_eq!(\"\\r hello world\\n \".trim_ascii(), \"hello world\");\nassert_eq!(\"  \".trim_ascii(), \"\");\nassert_eq!(\"\".trim_ascii(), \"\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%5Cr+hello+world%5Cn+%22.trim_ascii(),+%22hello+world%22);%0A++++assert_eq!(%22++%22.trim_ascii(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii(),+%22%22);%0A%7D&edition=2021)\n\n1.34.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2646)\n\nReturn an iterator that escapes each char in `self` with [`char::escape_debug`](about:blank/primitive.char.html#method.escape_debug \"method char::escape_debug\").\n\nNote: only extended grapheme codepoints that begin the string will be escaped.\n\n##### [¬ß](#examples-106)Examples\n\nAs an iterator:\n\n```\nfor c in \"‚ù§\\n!\".escape_debug() {\n    print!(\"{c}\");\n}\nprintln!();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_debug()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&edition=2021)\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"‚ù§\\n!\".escape_debug());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_debug());%0A%7D&edition=2021)\n\nBoth are equivalent to:\n\nUsing `to_string`:\n\n```\nassert_eq!(\"‚ù§\\n!\".escape_debug().to_string(), \"‚ù§\\\\n!\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_debug().to_string(),+%22%E2%9D%A4%5C%5Cn!%22);%0A%7D&edition=2021)\n\n1.34.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2697)\n\nReturn an iterator that escapes each char in `self` with [`char::escape_default`](about:blank/primitive.char.html#method.escape_default \"method char::escape_default\").\n\n##### [¬ß](#examples-107)Examples\n\nAs an iterator:\n\n```\nfor c in \"‚ù§\\n!\".escape_default() {\n    print!(\"{c}\");\n}\nprintln!();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_default()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&edition=2021)\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"‚ù§\\n!\".escape_default());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_default());%0A%7D&edition=2021)\n\nBoth are equivalent to:\n\n```\nprintln!(\"\\\\u{{2764}}\\\\n!\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cn!%22);%0A%7D&edition=2021)\n\nUsing `to_string`:\n\n```\nassert_eq!(\"‚ù§\\n!\".escape_default().to_string(), \"\\\\u{2764}\\\\n!\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_default().to_string(),+%22%5C%5Cu%7B2764%7D%5C%5Cn!%22);%0A%7D&edition=2021)\n\n1.34.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2735)\n\nReturn an iterator that escapes each char in `self` with [`char::escape_unicode`](about:blank/primitive.char.html#method.escape_unicode \"method char::escape_unicode\").\n\n##### [¬ß](#examples-108)Examples\n\nAs an iterator:\n\n```\nfor c in \"‚ù§\\n!\".escape_unicode() {\n    print!(\"{c}\");\n}\nprintln!();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_unicode()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&edition=2021)\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"‚ù§\\n!\".escape_unicode());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_unicode());%0A%7D&edition=2021)\n\nBoth are equivalent to:\n\n```\nprintln!(\"\\\\u{{2764}}\\\\u{{a}}\\\\u{{21}}\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cu%7B%7Ba%7D%7D%5C%5Cu%7B%7B21%7D%7D%22);%0A%7D&edition=2021)\n\nUsing `to_string`:\n\n```\nassert_eq!(\"‚ù§\\n!\".escape_unicode().to_string(), \"\\\\u{2764}\\\\u{a}\\\\u{21}\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_unicode().to_string(),+%22%5C%5Cu%7B2764%7D%5C%5Cu%7Ba%7D%5C%5Cu%7B21%7D%22);%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#271)\n\nReplaces all matches of a pattern with another string.\n\n`replace` creates a new [`String`](struct.String.html \"struct std::string::String\"), and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice.\n\n##### [¬ß](#examples-109)Examples\n\nBasic usage:\n\n```\nlet s = \"this is old\";\n\nassert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\nassert_eq!(\"than an old\", s.replace(\"is\", \"an\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+old%22;%0A++++%0A++++assert_eq!(%22this+is+new%22,+s.replace(%22old%22,+%22new%22));%0A++++assert_eq!(%22than+an+old%22,+s.replace(%22is%22,+%22an%22));%0A%7D&edition=2021)\n\nWhen the pattern doesn‚Äôt match, it returns this string slice as [`String`](struct.String.html \"struct std::string::String\"):\n\n```\nlet s = \"this is old\";\nassert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+old%22;%0A++++assert_eq!(s,+s.replace(%22cookie+monster%22,+%22little+lamb%22));%0A%7D&edition=2021)\n\n1.16.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#311)\n\nReplaces first N matches of a pattern with another string.\n\n`replacen` creates a new [`String`](struct.String.html \"struct std::string::String\"), and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most `count` times.\n\n##### [¬ß](#examples-110)Examples\n\nBasic usage:\n\n```\nlet s = \"foo foo 123 foo\";\nassert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\nassert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\nassert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22foo+foo+123+foo%22;%0A++++assert_eq!(%22new+new+123+foo%22,+s.replacen(%22foo%22,+%22new%22,+2));%0A++++assert_eq!(%22faa+fao+123+foo%22,+s.replacen(%27o%27,+%22a%22,+3));%0A++++assert_eq!(%22foo+foo+new23+foo%22,+s.replacen(char::is_numeric,+%22new%22,+1));%0A%7D&edition=2021)\n\nWhen the pattern doesn‚Äôt match, it returns this string slice as [`String`](struct.String.html \"struct std::string::String\"):\n\n```\nlet s = \"this is old\";\nassert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+old%22;%0A++++assert_eq!(s,+s.replacen(%22cookie+monster%22,+%22little+lamb%22,+10));%0A%7D&edition=2021)\n\n1.2.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#368)\n\nReturns the lowercase equivalent of this string slice, as a new [`String`](struct.String.html \"struct std::string::String\").\n\n‚ÄòLowercase‚Äô is defined according to the terms of the Unicode Derived Core Property `Lowercase`.\n\nSince some characters can expand into multiple characters when changing the case, this function returns a [`String`](struct.String.html \"struct std::string::String\") instead of modifying the parameter in-place.\n\n##### [¬ß](#examples-111)Examples\n\nBasic usage:\n\n```\nlet s = \"HELLO\";\n\nassert_eq!(\"hello\", s.to_lowercase());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22HELLO%22;%0A++++%0A++++assert_eq!(%22hello%22,+s.to_lowercase());%0A%7D&edition=2021)\n\nA tricky example, with sigma:\n\n```\nlet sigma = \"Œ£\";\n\nassert_eq!(\"œÉ\", sigma.to_lowercase());\n\n// but at the end of a word, it's œÇ, not œÉ:\nlet odysseus = \"·ΩàŒîŒ•Œ£Œ£ŒïŒéŒ£\";\n\nassert_eq!(\"·ΩÄŒ¥œÖœÉœÉŒµœçœÇ\", odysseus.to_lowercase());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+sigma+=+%22%CE%A3%22;%0A++++%0A++++assert_eq!(%22%CF%83%22,+sigma.to_lowercase());%0A++++%0A++++//+but+at+the+end+of+a+word,+it%27s+%CF%82,+not+%CF%83:%0A++++let+odysseus+=+%22%E1%BD%88%CE%94%CE%A5%CE%A3%CE%A3%CE%95%CE%8E%CE%A3%22;%0A++++%0A++++assert_eq!(%22%E1%BD%80%CE%B4%CF%85%CF%83%CF%83%CE%B5%CF%8D%CF%82%22,+odysseus.to_lowercase());%0A%7D&edition=2021)\n\nLanguages without case are not changed:\n\n```\nlet new_year = \"ÂÜúÂéÜÊñ∞Âπ¥\";\n\nassert_eq!(new_year, new_year.to_lowercase());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+new_year+=+%22%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%22;%0A++++%0A++++assert_eq!(new_year,+new_year.to_lowercase());%0A%7D&edition=2021)\n\n1.2.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#461)\n\nReturns the uppercase equivalent of this string slice, as a new [`String`](struct.String.html \"struct std::string::String\").\n\n‚ÄòUppercase‚Äô is defined according to the terms of the Unicode Derived Core Property `Uppercase`.\n\nSince some characters can expand into multiple characters when changing the case, this function returns a [`String`](struct.String.html \"struct std::string::String\") instead of modifying the parameter in-place.\n\n##### [¬ß](#examples-112)Examples\n\nBasic usage:\n\n```\nlet s = \"hello\";\n\nassert_eq!(\"HELLO\", s.to_uppercase());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22hello%22;%0A++++%0A++++assert_eq!(%22HELLO%22,+s.to_uppercase());%0A%7D&edition=2021)\n\nScripts without case are not changed:\n\n```\nlet new_year = \"ÂÜúÂéÜÊñ∞Âπ¥\";\n\nassert_eq!(new_year, new_year.to_uppercase());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+new_year+=+%22%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%22;%0A++++%0A++++assert_eq!(new_year,+new_year.to_uppercase());%0A%7D&edition=2021)\n\nOne character can become multiple:\n\n```\nlet s = \"tsch√º√ü\";\n\nassert_eq!(\"TSCH√úSS\", s.to_uppercase());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22tsch%C3%BC%C3%9F%22;%0A++++%0A++++assert_eq!(%22TSCH%C3%9CSS%22,+s.to_uppercase());%0A%7D&edition=2021)\n\n1.16.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#531)\n\nCreates a new [`String`](struct.String.html \"struct std::string::String\") by repeating a string `n` times.\n\n##### [¬ß](#panics-12)Panics\n\nThis function will panic if the capacity would overflow.\n\n##### [¬ß](#examples-113)Examples\n\nBasic usage:\n\n```\nassert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22abc%22.repeat(4),+String::from(%22abcabcabcabc%22));%0A%7D&edition=2021)\n\nA panic upon overflow:\n\n[‚ìò](# \"This example panics\")\n\n```\n// this will panic at runtime\nlet huge = \"0123456789abcdef\".repeat(usize::MAX);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+this+will+panic+at+runtime%0Afn+main()+%7B%0A++++let+huge+=+%220123456789abcdef%22.repeat(usize::MAX);%0A%7D&edition=2021)\n\n1.23.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#561)\n\nReturns a copy of this string where each character is mapped to its ASCII upper case equivalent.\n\nASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô, but non-ASCII letters are unchanged.\n\nTo uppercase the value in-place, use [`make_ascii_uppercase`](about:blank/primitive.str.html#method.make_ascii_uppercase \"method str::make_ascii_uppercase\").\n\nTo uppercase ASCII characters in addition to non-ASCII characters, use [`to_uppercase`](#method.to_uppercase).\n\n##### [¬ß](#examples-114)Examples\n\n```\nlet s = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert_eq!(\"GR√º√üE, J√ºRGEN ‚ù§\", s.to_ascii_uppercase());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert_eq!(%22GR%C3%BC%C3%9FE,+J%C3%BCRGEN+%E2%9D%A4%22,+s.to_ascii_uppercase());%0A%7D&edition=2021)\n\n1.23.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#593)\n\nReturns a copy of this string where each character is mapped to its ASCII lower case equivalent.\n\nASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô, but non-ASCII letters are unchanged.\n\nTo lowercase the value in-place, use [`make_ascii_lowercase`](about:blank/primitive.str.html#method.make_ascii_lowercase \"method str::make_ascii_lowercase\").\n\nTo lowercase ASCII characters in addition to non-ASCII characters, use [`to_lowercase`](#method.to_lowercase).\n\n##### [¬ß](#examples-115)Examples\n\n```\nlet s = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert_eq!(\"gr√º√üe, j√ºrgen ‚ù§\", s.to_ascii_lowercase());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert_eq!(%22gr%C3%BC%C3%9Fe,+j%C3%BCrgen+%E2%9D%A4%22,+s.to_ascii_lowercase());%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2432)[¬ß](#impl-Add%3C%26str%3E-for-String)\n\nImplements the `+` operator for concatenating two strings.\n\nThis consumes the `String` on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new `String` and copying the entire contents on every operation, which would lead to _O_(_n_^2) running time when building an _n_\\-byte string by repeated concatenation.\n\nThe string on the right-hand side is only borrowed; its contents are copied into the returned `String`.\n\n#### [¬ß](#examples-116)Examples\n\nConcatenating two `String`s takes the first by value and borrows the second:\n\n```\nlet a = String::from(\"hello\");\nlet b = String::from(\" world\");\nlet c = a + &b;\n// `a` is moved and can no longer be used here.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+String::from(%22hello%22);%0A++++let+b+=+String::from(%22+world%22);%0A++++let+c+=+a+%2B+%26b;%0A++++//+%60a%60+is+moved+and+can+no+longer+be+used+here.%0A%7D&edition=2021)\n\nIf you want to keep using the first `String`, you can clone it and append to the clone instead:\n\n```\nlet a = String::from(\"hello\");\nlet b = String::from(\" world\");\nlet c = a.clone() + &b;\n// `a` is still valid here.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+String::from(%22hello%22);%0A++++let+b+=+String::from(%22+world%22);%0A++++let+c+=+a.clone()+%2B+%26b;%0A++++//+%60a%60+is+still+valid+here.%0A%7D&edition=2021)\n\nConcatenating `&str` slices can be done by converting the first to a `String`:\n\n```\nlet a = \"hello\";\nlet b = \" world\";\nlet c = a.to_string() + b;\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%22hello%22;%0A++++let+b+=+%22+world%22;%0A++++let+c+=+a.to_string()+%2B+b;%0A%7D&edition=2021)\n\n[¬ß](#associatedtype.Output)\n\nThe resulting type after applying the `+` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2436)[¬ß](#method.add)\n\n1.12.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2447)[¬ß](#impl-AddAssign%3C%26str%3E-for-String)\n\nImplements the `+=` operator for appending to a `String`.\n\nThis has the same behavior as the [`push_str`](about:blank/struct.String.html#method.push_str \"method std::string::String::push_str\") method.\n\n1.43.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2692)[¬ß](#impl-AsMut%3Cstr%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2694)[¬ß](#method.as_mut)\n\nConverts this type into a mutable reference of the (usually inferred) input type.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2700)[¬ß](#impl-AsRef%3C%5Bu8%5D%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2702)[¬ß](#method.as_ref-1)\n\nConverts this type into a shared reference of the (usually inferred) input type.\n\n1.0.0 ¬∑ [source](about:blank/src/std/ffi/os_str.rs.html#1584-1589)[¬ß](#impl-AsRef%3COsStr%3E-for-String)\n\n[source](about:blank/src/std/ffi/os_str.rs.html#1586-1588)[¬ß](#method.as_ref-3)\n\nConverts this type into a shared reference of the (usually inferred) input type.\n\n1.0.0 ¬∑ [source](about:blank/src/std/path.rs.html#3182-3187)[¬ß](#impl-AsRef%3CPath%3E-for-String)\n\n[source](about:blank/src/std/path.rs.html#3184-3186)[¬ß](#method.as_ref-2)\n\nConverts this type into a shared reference of the (usually inferred) input type.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2684)[¬ß](#impl-AsRef%3Cstr%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2686)[¬ß](#method.as_ref)\n\nConverts this type into a shared reference of the (usually inferred) input type.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#190)[¬ß](#impl-Borrow%3Cstr%3E-for-String)\n\n1.36.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#198)[¬ß](#impl-BorrowMut%3Cstr%3E-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2097)[¬ß](#impl-Clone-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2106)[¬ß](#method.clone_from)\n\nClones the contents of `source` into `self`.\n\nThis method is preferred over simply assigning `source.clone()` to `self`, as it avoids reallocation if possible.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2098)[¬ß](#method.clone)\n\nReturns a copy of the value. [Read more](about:blank/clone/trait.Clone.html#tymethod.clone)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2378)[¬ß](#impl-Debug-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2361)[¬ß](#impl-Default-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2479)[¬ß](#impl-Deref-for-String)\n\n[¬ß](#associatedtype.Target)\n\nThe resulting type after dereferencing.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2483)[¬ß](#method.deref)\n\nDereferences the value.\n\n1.3.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2492)[¬ß](#impl-DerefMut-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2494)[¬ß](#method.deref_mut)\n\nMutably dereferences the value.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2370)[¬ß](#impl-Display-for-String)\n\n1.2.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2213)[¬ß](#impl-Extend%3C%26char%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2214)[¬ß](#method.extend-4)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2219)[¬ß](#method.extend_one-4)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2224)[¬ß](#method.extend_reserve-4)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2231)[¬ß](#impl-Extend%3C%26str%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2232)[¬ß](#method.extend-5)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2237)[¬ß](#method.extend_one-5)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461)[¬ß](#method.extend_reserve-5)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.45.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2244)[¬ß](#impl-Extend%3CBox%3Cstr,+A%3E%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2245)[¬ß](#method.extend-2)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#453)[¬ß](#method.extend_one-2)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461)[¬ß](#method.extend_reserve-2)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.19.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2265)[¬ß](#impl-Extend%3CCow%3C'a,+str%3E%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2266)[¬ß](#method.extend)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2271)[¬ß](#method.extend_one)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461)[¬ß](#method.extend_reserve)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.4.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2252)[¬ß](#impl-Extend%3CString%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2253)[¬ß](#method.extend-3)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2258)[¬ß](#method.extend_one-3)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461)[¬ß](#method.extend_reserve-3)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2192)[¬ß](#impl-Extend%3Cchar%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2193)[¬ß](#method.extend-1)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2201)[¬ß](#method.extend_one-1)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2206)[¬ß](#method.extend_reserve-1)\n\nüî¨This is a nightly-only experimental API. (`extend_one`¬†[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.28.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2853)[¬ß](#impl-From%3C%26String%3E-for-Cow%3C'a,+str%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2868)[¬ß](#method.from-7)\n\nConverts a [`String`](struct.String.html \"struct std::string::String\") reference into a [`Borrowed`](about:blank/borrow/enum.Cow.html#variant.Borrowed \"borrow::Cow::Borrowed\") variant. No heap allocation is performed, and the string is not copied.\n\n##### [¬ß](#example-2)Example\n\n```\nlet s = \"eggplant\".to_string();\nassert_eq!(Cow::from(&s), Cow::Borrowed(\"eggplant\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Cow;%0A++++let+s+=+%22eggplant%22.to_string();%0A++++assert_eq!(Cow::from(%26s),+Cow::Borrowed(%22eggplant%22));%0A%7D&edition=2021)\n\n1.35.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2733)[¬ß](#impl-From%3C%26String%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2738)[¬ß](#method.from-5)\n\nConverts a `&String` into a [`String`](struct.String.html \"struct std::string::String\").\n\nThis clones `s` and returns the clone.\n\n1.44.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2721)[¬ß](#impl-From%3C%26mut+str%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2726)[¬ß](#method.from-2)\n\nConverts a `&mut str` into a [`String`](struct.String.html \"struct std::string::String\").\n\nThe result is allocated on the heap.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2709)[¬ß](#impl-From%3C%26str%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2714)[¬ß](#method.from-13)\n\nConverts a `&str` into a [`String`](struct.String.html \"struct std::string::String\").\n\nThe result is allocated on the heap.\n\n1.18.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2746)[¬ß](#impl-From%3CBox%3Cstr%3E%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2759)[¬ß](#method.from-6)\n\nConverts the given boxed `str` slice to a [`String`](struct.String.html \"struct std::string::String\"). It is notable that the `str` slice is owned.\n\n##### [¬ß](#examples-119)Examples\n\n```\nlet s1: String = String::from(\"hello world\");\nlet s2: Box<str> = s1.into_boxed_str();\nlet s3: String = String::from(s2);\n\nassert_eq!(\"hello world\", s3)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1:+String+=+String::from(%22hello+world%22);%0A++++let+s2:+Box%3Cstr%3E+=+s1.into_boxed_str();%0A++++let+s3:+String+=+String::from(s2);%0A++++%0A++++assert_eq!(%22hello+world%22,+s3)%0A%7D&edition=2021)\n\n1.14.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2785)[¬ß](#impl-From%3CCow%3C'a,+str%3E%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2802)[¬ß](#method.from-11)\n\nConverts a clone-on-write string to an owned instance of [`String`](struct.String.html \"struct std::string::String\").\n\nThis extracts the owned string, clones the string if it is not already owned.\n\n##### [¬ß](#example-5)Example\n\n```\n// If the string is not owned...\nlet cow: Cow<'_, str> = Cow::Borrowed(\"eggplant\");\n// It will allocate on the heap and copy the string.\nlet owned: String = String::from(cow);\nassert_eq!(&owned[..], \"eggplant\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Cow;%0A++++//+If+the+string+is+not+owned...%0A++++let+cow:+Cow%3C%27_,+str%3E+=+Cow::Borrowed(%22eggplant%22);%0A++++//+It+will+allocate+on+the+heap+and+copy+the+string.%0A++++let+owned:+String+=+String::from(cow);%0A++++assert_eq!(%26owned%5B..%5D,+%22eggplant%22);%0A%7D&edition=2021)\n\n1.21.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3558)[¬ß](#impl-From%3CString%3E-for-Arc%3Cstr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3570)[¬ß](#method.from-10)\n\nAllocate a reference-counted `str` and copy `v` into it.\n\n##### [¬ß](#example-4)Example\n\n```\nlet unique: String = \"eggplant\".to_owned();\nlet shared: Arc<str> = Arc::from(unique);\nassert_eq!(\"eggplant\", &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+unique:+String+=+%22eggplant%22.to_owned();%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(unique);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.6.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2513)[¬ß](#impl-From%3CString%3E-for-Box%3Cdyn+Error%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2526)[¬ß](#method.from-12)\n\nConverts a [`String`](struct.String.html \"struct std::string::String\") into a box of dyn [`Error`](../error/trait.Error.html \"trait std::error::Error\").\n\n##### [¬ß](#examples-121)Examples\n\n```\nuse std::error::Error;\nuse std::mem;\n\nlet a_string_error = \"a string error\".to_string();\nlet a_boxed_error = Box::<dyn Error>::from(a_string_error);\nassert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::error::Error;%0A++++use+std::mem;%0A++++%0A++++let+a_string_error+=+%22a+string+error%22.to_string();%0A++++let+a_boxed_error+=+Box::%3Cdyn+Error%3E::from(a_string_error);%0A++++assert!(mem::size_of::%3CBox%3Cdyn+Error%3E%3E()+==+mem::size_of_val(%26a_boxed_error))%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2469)[¬ß](#impl-From%3CString%3E-for-Box%3Cdyn+Error+%2B+Send+%2B+Sync%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2484)[¬ß](#method.from-8)\n\nConverts a [`String`](struct.String.html \"struct std::string::String\") into a box of dyn [`Error`](../error/trait.Error.html \"trait std::error::Error\") + [`Send`](../marker/trait.Send.html \"trait std::marker::Send\") + [`Sync`](../marker/trait.Sync.html \"trait std::marker::Sync\").\n\n##### [¬ß](#examples-120)Examples\n\n```\nuse std::error::Error;\nuse std::mem;\n\nlet a_string_error = \"a string error\".to_string();\nlet a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_string_error);\nassert!(\n    mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::error::Error;%0A++++use+std::mem;%0A++++%0A++++let+a_string_error+=+%22a+string+error%22.to_string();%0A++++let+a_boxed_error+=+Box::%3Cdyn+Error+%2B+Send+%2B+Sync%3E::from(a_string_error);%0A++++assert!(%0A++++++++mem::size_of::%3CBox%3Cdyn+Error+%2B+Send+%2B+Sync%3E%3E()+==+mem::size_of_val(%26a_boxed_error))%0A%7D&edition=2021)\n\n1.20.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2766)[¬ß](#impl-From%3CString%3E-for-Box%3Cstr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2778)[¬ß](#method.from-3)\n\nConverts the given [`String`](struct.String.html \"struct std::string::String\") to a boxed `str` slice that is owned.\n\n##### [¬ß](#examples-118)Examples\n\n```\nlet s1: String = String::from(\"hello world\");\nlet s2: Box<str> = Box::from(s1);\nlet s3: String = String::from(s2);\n\nassert_eq!(\"hello world\", s3)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1:+String+=+String::from(%22hello+world%22);%0A++++let+s2:+Box%3Cstr%3E+=+Box::from(s1);%0A++++let+s3:+String+=+String::from(s2);%0A++++%0A++++assert_eq!(%22hello+world%22,+s3)%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2830)[¬ß](#impl-From%3CString%3E-for-Cow%3C'a,+str%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2846)[¬ß](#method.from-4)\n\nConverts a [`String`](struct.String.html \"struct std::string::String\") into an [`Owned`](about:blank/borrow/enum.Cow.html#variant.Owned \"borrow::Cow::Owned\") variant. No heap allocation is performed, and the string is not copied.\n\n##### [¬ß](#example-1)Example\n\n```\nlet s = \"eggplant\".to_string();\nlet s2 = \"eggplant\".to_string();\nassert_eq!(Cow::from(s), Cow::<'static, str>::Owned(s2));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Cow;%0A++++let+s+=+%22eggplant%22.to_string();%0A++++let+s2+=+%22eggplant%22.to_string();%0A++++assert_eq!(Cow::from(s),+Cow::%3C%27static,+str%3E::Owned(s2));%0A%7D&edition=2021)\n\n1.0.0 ¬∑ [source](about:blank/src/std/ffi/os_str.rs.html#544-552)[¬ß](#impl-From%3CString%3E-for-OsString)\n\n1.0.0 ¬∑ [source](about:blank/src/std/path.rs.html#1739-1747)[¬ß](#impl-From%3CString%3E-for-PathBuf)\n\n1.21.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2599)[¬ß](#impl-From%3CString%3E-for-Rc%3Cstr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2611)[¬ß](#method.from-9)\n\nAllocate a reference-counted string slice and copy `v` into it.\n\n##### [¬ß](#example-3)Example\n\n```\nlet original: String = \"statue\".to_owned();\nlet shared: Rc<str> = Rc::from(original);\nassert_eq!(\"statue\", &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+String+=+%22statue%22.to_owned();%0A++++let+shared:+Rc%3Cstr%3E+=+Rc::from(original);%0A++++assert_eq!(%22statue%22,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.14.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2898)[¬ß](#impl-From%3CString%3E-for-Vec%3Cu8%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2911)[¬ß](#method.from-1)\n\nConverts the given [`String`](struct.String.html \"struct std::string::String\") to a vector [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") that holds values of type [`u8`](../primitive.u8.html \"primitive u8\").\n\n##### [¬ß](#examples-117)Examples\n\n```\nlet s1 = String::from(\"hello world\");\nlet v1 = Vec::from(s1);\n\nfor b in v1 {\n    println!(\"{b}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1+=+String::from(%22hello+world%22);%0A++++let+v1+=+Vec::from(s1);%0A++++%0A++++for+b+in+v1+%7B%0A++++++++println!(%22%7Bb%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\n1.46.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#3041)[¬ß](#impl-From%3Cchar%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#3051)[¬ß](#method.from)\n\nAllocates an owned [`String`](struct.String.html \"struct std::string::String\") from a single character.\n\n##### [¬ß](#example)Example\n\n```\nlet c: char = 'a';\nlet s: String = String::from(c);\nassert_eq!(\"a\", &s[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+c:+char+=+%27a%27;%0A++++let+s:+String+=+String::from(c);%0A++++assert_eq!(%22a%22,+%26s%5B..%5D);%0A%7D&edition=2021)\n\n1.17.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2123)[¬ß](#impl-FromIterator%3C%26char%3E-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2133)[¬ß](#impl-FromIterator%3C%26str%3E-for-String)\n\n1.45.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2162)[¬ß](#impl-FromIterator%3CBox%3Cstr,+A%3E%3E-for-String)\n\n1.19.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2172)[¬ß](#impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-String)\n\n1.80.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2195)[¬ß](#impl-FromIterator%3CString%3E-for-Box%3Cstr%3E)\n\n1.12.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2891)[¬ß](#impl-FromIterator%3CString%3E-for-Cow%3C'a,+str%3E)\n\n1.4.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2143)[¬ß](#impl-FromIterator%3CString%3E-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2113)[¬ß](#impl-FromIterator%3Cchar%3E-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2509)[¬ß](#impl-FromStr-for-String)\n\n[¬ß](#associatedtype.Err)\n\nThe associated error which can be returned from parsing.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2512)[¬ß](#method.from_str)\n\nParses a string `s` to return a value of this type. [Read more](about:blank/str/trait.FromStr.html#tymethod.from_str)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2386)[¬ß](#impl-Hash-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2455-2457)[¬ß](#impl-Index%3CI%3E-for-String)\n\n[¬ß](#associatedtype.Output-1)\n\nThe returned type after indexing.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2462)[¬ß](#method.index)\n\nPerforms the indexing (`container[index]`) operation. [Read more](about:blank/ops/trait.Index.html#tymethod.index)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2468-2470)[¬ß](#impl-IndexMut%3CI%3E-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362)[¬ß](#impl-Ord-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352)[¬ß](#impl-PartialEq%3C%26str%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352)[¬ß](#method.eq)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352)[¬ß](#method.ne)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358)[¬ß](#impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358)[¬ß](#method.eq-3)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358)[¬ß](#method.ne-3)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352)[¬ß](#impl-PartialEq%3CString%3E-for-%26str)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352)[¬ß](#method.eq-5)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352)[¬ß](#method.ne-5)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358)[¬ß](#impl-PartialEq%3CString%3E-for-Cow%3C'a,+str%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358)[¬ß](#method.eq-1)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358)[¬ß](#method.ne-1)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351)[¬ß](#impl-PartialEq%3CString%3E-for-str)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351)[¬ß](#method.eq-2)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351)[¬ß](#method.ne-2)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351)[¬ß](#impl-PartialEq%3Cstr%3E-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351)[¬ß](#method.eq-6)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351)[¬ß](#method.ne-6)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362)[¬ß](#impl-PartialEq-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362)[¬ß](#method.eq-4)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263)[¬ß](#method.ne-4)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362)[¬ß](#impl-PartialOrd-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362)[¬ß](#method.partial_cmp)\n\nThis method returns an ordering between `self` and `other` values if one exists. [Read more](about:blank/cmp/trait.PartialOrd.html#tymethod.partial_cmp)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180)[¬ß](#method.lt)\n\nThis method tests less than (for `self` and `other`) and is used by the `<` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.lt)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198)[¬ß](#method.le)\n\nThis method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.le)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215)[¬ß](#method.gt)\n\nThis method tests greater than (for `self` and `other`) and is used by the `>` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.gt)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233)[¬ß](#method.ge)\n\nThis method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.ge)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2288)[¬ß](#impl-Pattern%3C'a%3E-for-%26String)\n\nA convenience impl that delegates to the impl for `&str`.\n\n#### [¬ß](#examples-122)Examples\n\n```\nassert_eq!(String::from(\"Hello world\").find(\"world\"), Some(6));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(String::from(%22Hello+world%22).find(%22world%22),+Some(6));%0A%7D&edition=2021)\n\n[¬ß](#associatedtype.Searcher)\n\nüî¨This is a nightly-only experimental API. (`pattern`¬†[#27721](https://github.com/rust-lang/rust/issues/27721))\n\nAssociated searcher for this pattern\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2291)[¬ß](#method.into_searcher)\n\nüî¨This is a nightly-only experimental API. (`pattern`¬†[#27721](https://github.com/rust-lang/rust/issues/27721))\n\nConstructs the associated searcher from `self` and the `haystack` to search in.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2296)[¬ß](#method.is_contained_in)\n\nüî¨This is a nightly-only experimental API. (`pattern`¬†[#27721](https://github.com/rust-lang/rust/issues/27721))\n\nChecks whether the pattern matches anywhere in the haystack\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2301)[¬ß](#method.is_prefix_of)\n\nüî¨This is a nightly-only experimental API. (`pattern`¬†[#27721](https://github.com/rust-lang/rust/issues/27721))\n\nChecks whether the pattern matches at the front of the haystack\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2306)[¬ß](#method.strip_prefix_of)\n\nüî¨This is a nightly-only experimental API. (`pattern`¬†[#27721](https://github.com/rust-lang/rust/issues/27721))\n\nRemoves the pattern from the front of haystack, if it matches.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2311)[¬ß](#method.is_suffix_of)\n\nüî¨This is a nightly-only experimental API. (`pattern`¬†[#27721](https://github.com/rust-lang/rust/issues/27721))\n\nChecks whether the pattern matches at the back of the haystack\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2316)[¬ß](#method.strip_suffix_of)\n\nüî¨This is a nightly-only experimental API. (`pattern`¬†[#27721](https://github.com/rust-lang/rust/issues/27721))\n\nRemoves the pattern from the back of haystack, if it matches.\n\n1.16.0 ¬∑ [source](about:blank/src/std/net/socket_addr.rs.html#310-315)[¬ß](#impl-ToSocketAddrs-for-String)\n\n[¬ß](#associatedtype.Iter)\n\nReturned iterator over socket addresses which this type may correspond to.\n\n[source](about:blank/src/std/net/socket_addr.rs.html#312-314)[¬ß](#method.to_socket_addrs)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2918)[¬ß](#impl-Write-for-String)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2489)[¬ß](#impl-DerefPure-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362)[¬ß](#impl-Eq-for-String)\n\n1.0.0 ¬∑ [source](https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362)[¬ß](#impl-StructuralPartialEq-for-String)\n\n[¬ß](#impl-Freeze-for-String)\n\n[¬ß](#impl-RefUnwindSafe-for-String)\n\n[¬ß](#impl-Send-for-String)\n\n[¬ß](#impl-Sync-for-String)\n\n[¬ß](#impl-Unpin-for-String)\n\n[¬ß](#impl-UnwindSafe-for-String)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A UTF-8‚Äìencoded, growable string.\"><title>String in std::string - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc struct\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">String</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">String</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.as_bytes\">as_bytes</a></li><li><a href=\"#method.as_mut_str\">as_mut_str</a></li><li><a href=\"#method.as_mut_vec\">as_mut_vec</a></li><li><a href=\"#method.as_str\">as_str</a></li><li><a href=\"#method.capacity\">capacity</a></li><li><a href=\"#method.clear\">clear</a></li><li><a href=\"#method.drain\">drain</a></li><li><a href=\"#method.extend_from_within\">extend_from_within</a></li><li><a href=\"#method.from_raw_parts\">from_raw_parts</a></li><li><a href=\"#method.from_utf16\">from_utf16</a></li><li><a href=\"#method.from_utf16_lossy\">from_utf16_lossy</a></li><li><a href=\"#method.from_utf16be\">from_utf16be</a></li><li><a href=\"#method.from_utf16be_lossy\">from_utf16be_lossy</a></li><li><a href=\"#method.from_utf16le\">from_utf16le</a></li><li><a href=\"#method.from_utf16le_lossy\">from_utf16le_lossy</a></li><li><a href=\"#method.from_utf8\">from_utf8</a></li><li><a href=\"#method.from_utf8_lossy\">from_utf8_lossy</a></li><li><a href=\"#method.from_utf8_unchecked\">from_utf8_unchecked</a></li><li><a href=\"#method.insert\">insert</a></li><li><a href=\"#method.insert_str\">insert_str</a></li><li><a href=\"#method.into_boxed_str\">into_boxed_str</a></li><li><a href=\"#method.into_bytes\">into_bytes</a></li><li><a href=\"#method.into_raw_parts\">into_raw_parts</a></li><li><a href=\"#method.is_empty\">is_empty</a></li><li><a href=\"#method.leak\">leak</a></li><li><a href=\"#method.len\">len</a></li><li><a href=\"#method.new\">new</a></li><li><a href=\"#method.pop\">pop</a></li><li><a href=\"#method.push\">push</a></li><li><a href=\"#method.push_str\">push_str</a></li><li><a href=\"#method.remove\">remove</a></li><li><a href=\"#method.remove_matches\">remove_matches</a></li><li><a href=\"#method.replace_range\">replace_range</a></li><li><a href=\"#method.reserve\">reserve</a></li><li><a href=\"#method.reserve_exact\">reserve_exact</a></li><li><a href=\"#method.retain\">retain</a></li><li><a href=\"#method.shrink_to\">shrink_to</a></li><li><a href=\"#method.shrink_to_fit\">shrink_to_fit</a></li><li><a href=\"#method.split_off\">split_off</a></li><li><a href=\"#method.truncate\">truncate</a></li><li><a href=\"#method.try_reserve\">try_reserve</a></li><li><a href=\"#method.try_reserve_exact\">try_reserve_exact</a></li><li><a href=\"#method.try_with_capacity\">try_with_capacity</a></li><li><a href=\"#method.with_capacity\">with_capacity</a></li></ul><h3><a href=\"#deref-methods-str\">Methods from Deref&lt;Target=str&gt;</a></h3><ul class=\"block deref-methods\"><li><a href=\"#method.as_ascii\">as_ascii</a></li><li><a href=\"#method.as_bytes-1\">as_bytes</a></li><li><a href=\"#method.as_bytes_mut\">as_bytes_mut</a></li><li><a href=\"#method.as_mut_ptr\">as_mut_ptr</a></li><li><a href=\"#method.as_ptr\">as_ptr</a></li><li><a href=\"#method.bytes\">bytes</a></li><li><a href=\"#method.ceil_char_boundary\">ceil_char_boundary</a></li><li><a href=\"#method.char_indices\">char_indices</a></li><li><a href=\"#method.chars\">chars</a></li><li><a href=\"#method.contains\">contains</a></li><li><a href=\"#method.encode_utf16\">encode_utf16</a></li><li><a href=\"#method.ends_with\">ends_with</a></li><li><a href=\"#method.eq_ignore_ascii_case\">eq_ignore_ascii_case</a></li><li><a href=\"#method.escape_debug\">escape_debug</a></li><li><a href=\"#method.escape_default\">escape_default</a></li><li><a href=\"#method.escape_unicode\">escape_unicode</a></li><li><a href=\"#method.find\">find</a></li><li><a href=\"#method.floor_char_boundary\">floor_char_boundary</a></li><li><a href=\"#method.get\">get</a></li><li><a href=\"#method.get_mut\">get_mut</a></li><li><a href=\"#method.get_unchecked\">get_unchecked</a></li><li><a href=\"#method.get_unchecked_mut\">get_unchecked_mut</a></li><li><a href=\"#method.is_ascii\">is_ascii</a></li><li><a href=\"#method.is_char_boundary\">is_char_boundary</a></li><li><a href=\"#method.is_empty-1\">is_empty</a></li><li><a href=\"#method.len-1\">len</a></li><li><a href=\"#method.lines\">lines</a></li><li><a href=\"#method.lines_any\">lines_any</a></li><li><a href=\"#method.make_ascii_lowercase\">make_ascii_lowercase</a></li><li><a href=\"#method.make_ascii_uppercase\">make_ascii_uppercase</a></li><li><a href=\"#method.match_indices\">match_indices</a></li><li><a href=\"#method.matches\">matches</a></li><li><a href=\"#method.parse\">parse</a></li><li><a href=\"#method.repeat\">repeat</a></li><li><a href=\"#method.replace\">replace</a></li><li><a href=\"#method.replacen\">replacen</a></li><li><a href=\"#method.rfind\">rfind</a></li><li><a href=\"#method.rmatch_indices\">rmatch_indices</a></li><li><a href=\"#method.rmatches\">rmatches</a></li><li><a href=\"#method.rsplit\">rsplit</a></li><li><a href=\"#method.rsplit_once\">rsplit_once</a></li><li><a href=\"#method.rsplit_terminator\">rsplit_terminator</a></li><li><a href=\"#method.rsplitn\">rsplitn</a></li><li><a href=\"#method.slice_mut_unchecked\">slice_mut_unchecked</a></li><li><a href=\"#method.slice_unchecked\">slice_unchecked</a></li><li><a href=\"#method.split\">split</a></li><li><a href=\"#method.split_ascii_whitespace\">split_ascii_whitespace</a></li><li><a href=\"#method.split_at\">split_at</a></li><li><a href=\"#method.split_at_checked\">split_at_checked</a></li><li><a href=\"#method.split_at_mut\">split_at_mut</a></li><li><a href=\"#method.split_at_mut_checked\">split_at_mut_checked</a></li><li><a href=\"#method.split_inclusive\">split_inclusive</a></li><li><a href=\"#method.split_once\">split_once</a></li><li><a href=\"#method.split_terminator\">split_terminator</a></li><li><a href=\"#method.split_whitespace\">split_whitespace</a></li><li><a href=\"#method.splitn\">splitn</a></li><li><a href=\"#method.starts_with\">starts_with</a></li><li><a href=\"#method.strip_prefix\">strip_prefix</a></li><li><a href=\"#method.strip_suffix\">strip_suffix</a></li><li><a href=\"#method.to_ascii_lowercase\">to_ascii_lowercase</a></li><li><a href=\"#method.to_ascii_uppercase\">to_ascii_uppercase</a></li><li><a href=\"#method.to_lowercase\">to_lowercase</a></li><li><a href=\"#method.to_uppercase\">to_uppercase</a></li><li><a href=\"#method.trim\">trim</a></li><li><a href=\"#method.trim_ascii\">trim_ascii</a></li><li><a href=\"#method.trim_ascii_end\">trim_ascii_end</a></li><li><a href=\"#method.trim_ascii_start\">trim_ascii_start</a></li><li><a href=\"#method.trim_end\">trim_end</a></li><li><a href=\"#method.trim_end_matches\">trim_end_matches</a></li><li><a href=\"#method.trim_left\">trim_left</a></li><li><a href=\"#method.trim_left_matches\">trim_left_matches</a></li><li><a href=\"#method.trim_matches\">trim_matches</a></li><li><a href=\"#method.trim_right\">trim_right</a></li><li><a href=\"#method.trim_right_matches\">trim_right_matches</a></li><li><a href=\"#method.trim_start\">trim_start</a></li><li><a href=\"#method.trim_start_matches\">trim_start_matches</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-Add%3C%26str%3E-for-String\">Add&lt;&amp;str&gt;</a></li><li><a href=\"#impl-AddAssign%3C%26str%3E-for-String\">AddAssign&lt;&amp;str&gt;</a></li><li><a href=\"#impl-AsMut%3Cstr%3E-for-String\">AsMut&lt;str&gt;</a></li><li><a href=\"#impl-AsRef%3COsStr%3E-for-String\">AsRef&lt;OsStr&gt;</a></li><li><a href=\"#impl-AsRef%3CPath%3E-for-String\">AsRef&lt;Path&gt;</a></li><li><a href=\"#impl-AsRef%3C%5Bu8%5D%3E-for-String\">AsRef&lt;[u8]&gt;</a></li><li><a href=\"#impl-AsRef%3Cstr%3E-for-String\">AsRef&lt;str&gt;</a></li><li><a href=\"#impl-Borrow%3Cstr%3E-for-String\">Borrow&lt;str&gt;</a></li><li><a href=\"#impl-BorrowMut%3Cstr%3E-for-String\">BorrowMut&lt;str&gt;</a></li><li><a href=\"#impl-Clone-for-String\">Clone</a></li><li><a href=\"#impl-Debug-for-String\">Debug</a></li><li><a href=\"#impl-Default-for-String\">Default</a></li><li><a href=\"#impl-Deref-for-String\">Deref</a></li><li><a href=\"#impl-DerefMut-for-String\">DerefMut</a></li><li><a href=\"#impl-DerefPure-for-String\">DerefPure</a></li><li><a href=\"#impl-Display-for-String\">Display</a></li><li><a href=\"#impl-Eq-for-String\">Eq</a></li><li><a href=\"#impl-Extend%3C%26char%3E-for-String\">Extend&lt;&amp;'a char&gt;</a></li><li><a href=\"#impl-Extend%3C%26str%3E-for-String\">Extend&lt;&amp;'a str&gt;</a></li><li><a href=\"#impl-Extend%3CBox%3Cstr,+A%3E%3E-for-String\">Extend&lt;Box&lt;str, A&gt;&gt;</a></li><li><a href=\"#impl-Extend%3CCow%3C'a,+str%3E%3E-for-String\">Extend&lt;Cow&lt;'a, str&gt;&gt;</a></li><li><a href=\"#impl-Extend%3CString%3E-for-String\">Extend&lt;String&gt;</a></li><li><a href=\"#impl-Extend%3Cchar%3E-for-String\">Extend&lt;char&gt;</a></li><li><a href=\"#impl-From%3C%26String%3E-for-Cow%3C'a,+str%3E\">From&lt;&amp;'a String&gt;</a></li><li><a href=\"#impl-From%3C%26String%3E-for-String\">From&lt;&amp;String&gt;</a></li><li><a href=\"#impl-From%3C%26mut+str%3E-for-String\">From&lt;&amp;mut str&gt;</a></li><li><a href=\"#impl-From%3C%26str%3E-for-String\">From&lt;&amp;str&gt;</a></li><li><a href=\"#impl-From%3CBox%3Cstr%3E%3E-for-String\">From&lt;Box&lt;str&gt;&gt;</a></li><li><a href=\"#impl-From%3CCow%3C'a,+str%3E%3E-for-String\">From&lt;Cow&lt;'a, str&gt;&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-Arc%3Cstr%3E\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-Box%3Cdyn+Error%3E\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-Box%3Cdyn+Error+%2B+Send+%2B+Sync%3E\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-Box%3Cstr%3E\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-Cow%3C'a,+str%3E\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-OsString\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-PathBuf\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-Rc%3Cstr%3E\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-Vec%3Cu8%3E\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3Cchar%3E-for-String\">From&lt;char&gt;</a></li><li><a href=\"#impl-FromIterator%3C%26char%3E-for-String\">FromIterator&lt;&amp;'a char&gt;</a></li><li><a href=\"#impl-FromIterator%3C%26str%3E-for-String\">FromIterator&lt;&amp;'a str&gt;</a></li><li><a href=\"#impl-FromIterator%3CBox%3Cstr,+A%3E%3E-for-String\">FromIterator&lt;Box&lt;str, A&gt;&gt;</a></li><li><a href=\"#impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-String\">FromIterator&lt;Cow&lt;'a, str&gt;&gt;</a></li><li><a href=\"#impl-FromIterator%3CString%3E-for-Box%3Cstr%3E\">FromIterator&lt;String&gt;</a></li><li><a href=\"#impl-FromIterator%3CString%3E-for-Cow%3C'a,+str%3E\">FromIterator&lt;String&gt;</a></li><li><a href=\"#impl-FromIterator%3CString%3E-for-String\">FromIterator&lt;String&gt;</a></li><li><a href=\"#impl-FromIterator%3Cchar%3E-for-String\">FromIterator&lt;char&gt;</a></li><li><a href=\"#impl-FromStr-for-String\">FromStr</a></li><li><a href=\"#impl-Hash-for-String\">Hash</a></li><li><a href=\"#impl-Index%3CI%3E-for-String\">Index&lt;I&gt;</a></li><li><a href=\"#impl-IndexMut%3CI%3E-for-String\">IndexMut&lt;I&gt;</a></li><li><a href=\"#impl-Ord-for-String\">Ord</a></li><li><a href=\"#impl-PartialEq-for-String\">PartialEq</a></li><li><a href=\"#impl-PartialEq%3C%26str%3E-for-String\">PartialEq&lt;&amp;'a str&gt;</a></li><li><a href=\"#impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-String\">PartialEq&lt;Cow&lt;'a, str&gt;&gt;</a></li><li><a href=\"#impl-PartialEq%3CString%3E-for-%26str\">PartialEq&lt;String&gt;</a></li><li><a href=\"#impl-PartialEq%3CString%3E-for-Cow%3C'a,+str%3E\">PartialEq&lt;String&gt;</a></li><li><a href=\"#impl-PartialEq%3CString%3E-for-str\">PartialEq&lt;String&gt;</a></li><li><a href=\"#impl-PartialEq%3Cstr%3E-for-String\">PartialEq&lt;str&gt;</a></li><li><a href=\"#impl-PartialOrd-for-String\">PartialOrd</a></li><li><a href=\"#impl-Pattern%3C'a%3E-for-%26String\">Pattern&lt;'a&gt;</a></li><li><a href=\"#impl-StructuralPartialEq-for-String\">StructuralPartialEq</a></li><li><a href=\"#impl-ToSocketAddrs-for-String\">ToSocketAddrs</a></li><li><a href=\"#impl-Write-for-String\">Write</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-String\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-String\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-String\">Send</a></li><li><a href=\"#impl-Sync-for-String\">Sync</a></li><li><a href=\"#impl-Unpin-for-String\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-String\">UnwindSafe</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-ToOwned-for-T\">ToOwned</a></li><li><a href=\"#impl-ToString-for-T\">ToString</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::string</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Drain.html\">Drain</a></li><li><a href=\"struct.FromUtf16Error.html\">FromUtf16Error</a></li><li><a href=\"struct.FromUtf8Error.html\">FromUtf8Error</a></li><li><a href=\"struct.String.html\">String</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.ToString.html\">ToString</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.ParseError.html\">ParseError</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‚ÄòS‚Äô or ‚Äò/‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Struct <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">string</a>::<wbr><a class=\"struct\" href=\"#\">String</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#365\">source</a> ¬∑ <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>‚àí</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub struct String { <span class=\"comment\">/* private fields */</span> }</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A UTF-8‚Äìencoded, growable string.</p>\n<p><code>String</code> is the most common string type. It has ownership over the contents\nof the string, stored in a heap-allocated buffer (see <a href=\"#representation\">Representation</a>).\nIt is closely related to its borrowed counterpart, the primitive <a href=\"../primitive.str.html\" title=\"str\"><code>str</code></a>.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">¬ß</a>Examples</h2>\n<p>You can create a <code>String</code> from <a href=\"../primitive.str.html\" title=\"&amp;str\">a literal string</a> with <a href=\"../convert/trait.From.html#tymethod.from\" title=\"associated function std::convert::From::from\"><code>String::from</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>hello = String::from(<span class=\"string\">\"Hello, world!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+hello+=+String::from(%22Hello,+world!%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>You can append a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> to a <code>String</code> with the <a href=\"struct.String.html#method.push\" title=\"method std::string::String::push\"><code>push</code></a> method, and\nappend a <a href=\"../primitive.str.html\" title=\"&amp;str\"><code>&amp;str</code></a> with the <a href=\"struct.String.html#method.push_str\" title=\"method std::string::String::push_str\"><code>push_str</code></a> method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>hello = String::from(<span class=\"string\">\"Hello, \"</span>);\n\nhello.push(<span class=\"string\">'w'</span>);\nhello.push_str(<span class=\"string\">\"orld!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+hello+=+String::from(%22Hello,+%22);%0A++++%0A++++hello.push('w');%0A++++hello.push_str(%22orld!%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If you have a vector of UTF-8 bytes, you can create a <code>String</code> from it with\nthe <a href=\"struct.String.html#method.from_utf8\" title=\"associated function std::string::String::from_utf8\"><code>from_utf8</code></a> method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some bytes, in a vector\n</span><span class=\"kw\">let </span>sparkle_heart = <span class=\"macro\">vec!</span>[<span class=\"number\">240</span>, <span class=\"number\">159</span>, <span class=\"number\">146</span>, <span class=\"number\">150</span>];\n\n<span class=\"comment\">// We know these bytes are valid, so we'll use `unwrap()`.\n</span><span class=\"kw\">let </span>sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üíñ\"</span>, sparkle_heart);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++//+We+know+these+bytes+are+valid,+so+we'll+use+%60unwrap()%60.%0A++++let+sparkle_heart+=+String::from_utf8(sparkle_heart).unwrap();%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"utf-8\"><a class=\"doc-anchor\" href=\"#utf-8\">¬ß</a>UTF-8</h2>\n<p><code>String</code>s are always valid UTF-8. If you need a non-UTF-8 string, consider\n<a href=\"../../std/ffi/struct.OsString.html\" title=\"ffi::OsString\"><code>OsString</code></a>. It is similar, but without the UTF-8 constraint. Because UTF-8\nis a variable width encoding, <code>String</code>s are typically smaller than an array of\nthe same <code>chars</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem;\n\n<span class=\"comment\">// `s` is ASCII which represents each `char` as one byte\n</span><span class=\"kw\">let </span>s = <span class=\"string\">\"hello\"</span>;\n<span class=\"macro\">assert_eq!</span>(s.len(), <span class=\"number\">5</span>);\n\n<span class=\"comment\">// A `char` array with the same contents would be longer because\n// every `char` is four bytes\n</span><span class=\"kw\">let </span>s = [<span class=\"string\">'h'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>];\n<span class=\"kw\">let </span>size: usize = s.into_iter().map(|c| mem::size_of_val(<span class=\"kw-2\">&amp;</span>c)).sum();\n<span class=\"macro\">assert_eq!</span>(size, <span class=\"number\">20</span>);\n\n<span class=\"comment\">// However, for non-ASCII strings, the difference will be smaller\n// and sometimes they are the same\n</span><span class=\"kw\">let </span>s = <span class=\"string\">\"üíñüíñüíñüíñüíñ\"</span>;\n<span class=\"macro\">assert_eq!</span>(s.len(), <span class=\"number\">20</span>);\n\n<span class=\"kw\">let </span>s = [<span class=\"string\">'üíñ'</span>, <span class=\"string\">'üíñ'</span>, <span class=\"string\">'üíñ'</span>, <span class=\"string\">'üíñ'</span>, <span class=\"string\">'üíñ'</span>];\n<span class=\"kw\">let </span>size: usize = s.into_iter().map(|c| mem::size_of_val(<span class=\"kw-2\">&amp;</span>c)).sum();\n<span class=\"macro\">assert_eq!</span>(size, <span class=\"number\">20</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++//+%60s%60+is+ASCII+which+represents+each+%60char%60+as+one+byte%0A++++let+s+=+%22hello%22;%0A++++assert_eq!(s.len(),+5);%0A++++%0A++++//+A+%60char%60+array+with+the+same+contents+would+be+longer+because%0A++++//+every+%60char%60+is+four+bytes%0A++++let+s+=+%5B'h',+'e',+'l',+'l',+'o'%5D;%0A++++let+size:+usize+=+s.into_iter().map(%7Cc%7C+mem::size_of_val(%26c)).sum();%0A++++assert_eq!(size,+20);%0A++++%0A++++//+However,+for+non-ASCII+strings,+the+difference+will+be+smaller%0A++++//+and+sometimes+they+are+the+same%0A++++let+s+=+%22%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%22;%0A++++assert_eq!(s.len(),+20);%0A++++%0A++++let+s+=+%5B'%F0%9F%92%96',+'%F0%9F%92%96',+'%F0%9F%92%96',+'%F0%9F%92%96',+'%F0%9F%92%96'%5D;%0A++++let+size:+usize+=+s.into_iter().map(%7Cc%7C+mem::size_of_val(%26c)).sum();%0A++++assert_eq!(size,+20);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This raises interesting questions as to how <code>s[i]</code> should work.\nWhat should <code>i</code> be here? Several options include byte indices and\n<code>char</code> indices but, because of UTF-8 encoding, only byte indices\nwould provide constant time indexing. Getting the <code>i</code>th <code>char</code>, for\nexample, is available using <a href=\"../primitive.str.html#method.chars\" title=\"method str::chars\"><code>chars</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"hello\"</span>;\n<span class=\"kw\">let </span>third_character = s.chars().nth(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(third_character, <span class=\"prelude-val\">Some</span>(<span class=\"string\">'l'</span>));\n\n<span class=\"kw\">let </span>s = <span class=\"string\">\"üíñüíñüíñüíñüíñ\"</span>;\n<span class=\"kw\">let </span>third_character = s.chars().nth(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(third_character, <span class=\"prelude-val\">Some</span>(<span class=\"string\">'üíñ'</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22hello%22;%0A++++let+third_character+=+s.chars().nth(2);%0A++++assert_eq!(third_character,+Some('l'));%0A++++%0A++++let+s+=+%22%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%22;%0A++++let+third_character+=+s.chars().nth(2);%0A++++assert_eq!(third_character,+Some('%F0%9F%92%96'));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Next, what should <code>s[i]</code> return? Because indexing returns a reference\nto underlying data it could be <code>&amp;u8</code>, <code>&amp;[u8]</code>, or something else similar.\nSince we‚Äôre only providing one index, <code>&amp;u8</code> makes the most sense but that\nmight not be what the user expects and can be explicitly achieved with\n<a href=\"../primitive.str.html#method.as_bytes\" title=\"method str::as_bytes\"><code>as_bytes()</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// The first byte is 104 - the byte value of `'h'`\n</span><span class=\"kw\">let </span>s = <span class=\"string\">\"hello\"</span>;\n<span class=\"macro\">assert_eq!</span>(s.as_bytes()[<span class=\"number\">0</span>], <span class=\"number\">104</span>);\n<span class=\"comment\">// or\n</span><span class=\"macro\">assert_eq!</span>(s.as_bytes()[<span class=\"number\">0</span>], <span class=\"string\">b'h'</span>);\n\n<span class=\"comment\">// The first byte is 240 which isn't obviously useful\n</span><span class=\"kw\">let </span>s = <span class=\"string\">\"üíñüíñüíñüíñüíñ\"</span>;\n<span class=\"macro\">assert_eq!</span>(s.as_bytes()[<span class=\"number\">0</span>], <span class=\"number\">240</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+The+first+byte+is+104+-+the+byte+value+of+%60'h'%60%0Afn+main()+%7B%0A++++let+s+=+%22hello%22;%0A++++assert_eq!(s.as_bytes()%5B0%5D,+104);%0A++++//+or%0A++++assert_eq!(s.as_bytes()%5B0%5D,+b'h');%0A++++%0A++++//+The+first+byte+is+240+which+isn't+obviously+useful%0A++++let+s+=+%22%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%F0%9F%92%96%22;%0A++++assert_eq!(s.as_bytes()%5B0%5D,+240);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Due to these ambiguities/restrictions, indexing with a <code>usize</code> is simply\nforbidden:</p>\n\n<div class=\"example-wrap compile_fail\"><a href=\"#\" class=\"tooltip\" title=\"This example deliberately fails to compile\">‚ìò</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"hello\"</span>;\n\n<span class=\"comment\">// The following will not compile!\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"The first letter of s is {}\"</span>, s[<span class=\"number\">0</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22hello%22;%0A++++%0A++++//+The+following+will+not+compile!%0A++++println!(%22The+first+letter+of+s+is+%7B%7D%22,+s%5B0%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>It is more clear, however, how <code>&amp;s[i..j]</code> should work (that is,\nindexing with a range). It should accept byte indices (to be constant-time)\nand return a <code>&amp;str</code> which is UTF-8 encoded. This is also called ‚Äústring slicing‚Äù.\nNote this will panic if the byte indices provided are not character\nboundaries - see <a href=\"../primitive.str.html#method.is_char_boundary\" title=\"method str::is_char_boundary\"><code>is_char_boundary</code></a> for more details. See the implementations\nfor <a href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\"><code>SliceIndex&lt;str&gt;</code></a> for more details on string slicing. For a non-panicking\nversion of string slicing, see <a href=\"../primitive.str.html#method.get\" title=\"method str::get\"><code>get</code></a>.</p>\n<p>The <a href=\"../primitive.str.html#method.bytes\" title=\"method str::bytes\"><code>bytes</code></a> and <a href=\"../primitive.str.html#method.chars\" title=\"method str::chars\"><code>chars</code></a> methods return iterators over the bytes and\ncodepoints of the string, respectively. To iterate over codepoints along\nwith byte indices, use <a href=\"../primitive.str.html#method.char_indices\" title=\"method str::char_indices\"><code>char_indices</code></a>.</p>\n<h2 id=\"deref\"><a class=\"doc-anchor\" href=\"#deref\">¬ß</a>Deref</h2>\n<p><code>String</code> implements <code><a href=\"../ops/trait.Deref.html\" title=\"ops::Deref\">Deref</a>&lt;Target = <a href=\"../primitive.str.html\" title=\"str\">str</a>&gt;</code>, and so inherits all of <a href=\"../primitive.str.html\" title=\"str\"><code>str</code></a>‚Äôs\nmethods. In addition, this means that you can pass a <code>String</code> to a\nfunction which takes a <a href=\"../primitive.str.html\" title=\"&amp;str\"><code>&amp;str</code></a> by using an ampersand (<code>&amp;</code>):</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>takes_str(s: <span class=\"kw-2\">&amp;</span>str) { }\n\n<span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"Hello\"</span>);\n\ntakes_str(<span class=\"kw-2\">&amp;</span>s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+takes_str(s:+%26str)+%7B+%7D%0A++++%0A++++let+s+=+String::from(%22Hello%22);%0A++++%0A++++takes_str(%26s);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will create a <a href=\"../primitive.str.html\" title=\"&amp;str\"><code>&amp;str</code></a> from the <code>String</code> and pass it in. This\nconversion is very inexpensive, and so generally, functions will accept\n<a href=\"../primitive.str.html\" title=\"&amp;str\"><code>&amp;str</code></a>s as arguments unless they need a <code>String</code> for some specific\nreason.</p>\n<p>In certain cases Rust doesn‚Äôt have enough information to make this\nconversion, known as <a href=\"../ops/trait.Deref.html\" title=\"ops::Deref\"><code>Deref</code></a> coercion. In the following example a string\nslice <a href=\"../primitive.str.html\" title=\"&amp;str\"><code>&amp;'a str</code></a> implements the trait <code>TraitExample</code>, and the function\n<code>example_func</code> takes anything that implements the trait. In this case Rust\nwould need to make two implicit conversions, which Rust doesn‚Äôt have the\nmeans to do. For that reason, the following example will not compile.</p>\n\n<div class=\"example-wrap compile_fail\"><a href=\"#\" class=\"tooltip\" title=\"This example deliberately fails to compile\">‚ìò</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">trait </span>TraitExample {}\n\n<span class=\"kw\">impl</span>&lt;<span class=\"lifetime\">'a</span>&gt; TraitExample <span class=\"kw\">for </span><span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'a </span>str {}\n\n<span class=\"kw\">fn </span>example_func&lt;A: TraitExample&gt;(example_arg: A) {}\n\n<span class=\"kw\">let </span>example_string = String::from(<span class=\"string\">\"example_string\"</span>);\nexample_func(<span class=\"kw-2\">&amp;</span>example_string);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++trait+TraitExample+%7B%7D%0A++++%0A++++impl%3C'a%3E+TraitExample+for+%26'a+str+%7B%7D%0A++++%0A++++fn+example_func%3CA:+TraitExample%3E(example_arg:+A)+%7B%7D%0A++++%0A++++let+example_string+=+String::from(%22example_string%22);%0A++++example_func(%26example_string);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>There are two options that would work instead. The first would be to\nchange the line <code>example_func(&amp;example_string);</code> to\n<code>example_func(example_string.as_str());</code>, using the method <a href=\"struct.String.html#method.as_str\" title=\"method std::string::String::as_str\"><code>as_str()</code></a>\nto explicitly extract the string slice containing the string. The second\nway changes <code>example_func(&amp;example_string);</code> to\n<code>example_func(&amp;*example_string);</code>. In this case we are dereferencing a\n<code>String</code> to a <a href=\"../primitive.str.html\" title=\"str\"><code>str</code></a>, then referencing the <a href=\"../primitive.str.html\" title=\"str\"><code>str</code></a> back to\n<a href=\"../primitive.str.html\" title=\"&amp;str\"><code>&amp;str</code></a>. The second way is more idiomatic, however both work to do the\nconversion explicitly rather than relying on the implicit conversion.</p>\n<h2 id=\"representation\"><a class=\"doc-anchor\" href=\"#representation\">¬ß</a>Representation</h2>\n<p>A <code>String</code> is made up of three components: a pointer to some bytes, a\nlength, and a capacity. The pointer points to the internal buffer which <code>String</code>\nuses to store its data. The length is the number of bytes currently stored\nin the buffer, and the capacity is the size of the buffer in bytes. As such,\nthe length will always be less than or equal to the capacity.</p>\n<p>This buffer is always stored on the heap.</p>\n<p>You can look at these with the <a href=\"../primitive.str.html#method.as_ptr\" title=\"method str::as_ptr\"><code>as_ptr</code></a>, <a href=\"struct.String.html#method.len\" title=\"method std::string::String::len\"><code>len</code></a>, and <a href=\"struct.String.html#method.capacity\" title=\"method std::string::String::capacity\"><code>capacity</code></a>\nmethods:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem;\n\n<span class=\"kw\">let </span>story = String::from(<span class=\"string\">\"Once upon a time...\"</span>);\n\n<span class=\"comment\">// Prevent automatically dropping the String's data\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>story = mem::ManuallyDrop::new(story);\n\n<span class=\"kw\">let </span>ptr = story.as_mut_ptr();\n<span class=\"kw\">let </span>len = story.len();\n<span class=\"kw\">let </span>capacity = story.capacity();\n\n<span class=\"comment\">// story has nineteen bytes\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"number\">19</span>, len);\n\n<span class=\"comment\">// We can re-build a String out of ptr, len, and capacity. This is all\n// unsafe because we are responsible for making sure the components are\n// valid:\n</span><span class=\"kw\">let </span>s = <span class=\"kw\">unsafe </span>{ String::from_raw_parts(ptr, len, capacity) } ;\n\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"Once upon a time...\"</span>), s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++let+story+=+String::from(%22Once+upon+a+time...%22);%0A++++%0A++++//+Prevent+automatically+dropping+the+String's+data%0A++++let+mut+story+=+mem::ManuallyDrop::new(story);%0A++++%0A++++let+ptr+=+story.as_mut_ptr();%0A++++let+len+=+story.len();%0A++++let+capacity+=+story.capacity();%0A++++%0A++++//+story+has+nineteen+bytes%0A++++assert_eq!(19,+len);%0A++++%0A++++//+We+can+re-build+a+String+out+of+ptr,+len,+and+capacity.+This+is+all%0A++++//+unsafe+because+we+are+responsible+for+making+sure+the+components+are%0A++++//+valid:%0A++++let+s+=+unsafe+%7B+String::from_raw_parts(ptr,+len,+capacity)+%7D+;%0A++++%0A++++assert_eq!(String::from(%22Once+upon+a+time...%22),+s);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If a <code>String</code> has enough capacity, adding elements to it will not\nre-allocate. For example, consider this program:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::new();\n\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, s.capacity());\n\n<span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">5 </span>{\n    s.push_str(<span class=\"string\">\"hello\"</span>);\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, s.capacity());\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::new();%0A++++%0A++++println!(%22%7B%7D%22,+s.capacity());%0A++++%0A++++for+_+in+0..5+%7B%0A++++++++s.push_str(%22hello%22);%0A++++++++println!(%22%7B%7D%22,+s.capacity());%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will output the following:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>0\n8\n16\n16\n32\n32\n</code></pre></div>\n<p>At first, we have no memory allocated at all, but as we append to the\nstring, it increases its capacity appropriately. If we instead use the\n<a href=\"struct.String.html#method.with_capacity\" title=\"associated function std::string::String::with_capacity\"><code>with_capacity</code></a> method to allocate the correct capacity initially:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::with_capacity(<span class=\"number\">25</span>);\n\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, s.capacity());\n\n<span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">5 </span>{\n    s.push_str(<span class=\"string\">\"hello\"</span>);\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, s.capacity());\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(25);%0A++++%0A++++println!(%22%7B%7D%22,+s.capacity());%0A++++%0A++++for+_+in+0..5+%7B%0A++++++++s.push_str(%22hello%22);%0A++++++++println!(%22%7B%7D%22,+s.capacity());%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>We end up with a different output:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>25\n25\n25\n25\n25\n25\n</code></pre></div>\n<p>Here, there‚Äôs no need to allocate more memory inside the loop.</p>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">¬ß</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-String\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#427\">source</a><a href=\"#impl-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.39.0\">1.0.0 (const: 1.39.0)</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#448\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.new\" class=\"fn\">new</a>() -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Creates a new empty <code>String</code>.</p>\n<p>Given that the <code>String</code> is empty, this will not allocate any initial\nbuffer. While that means that this initial operation is very\ninexpensive, it may cause excessive allocation later when you add\ndata. If you have an idea of how much data the <code>String</code> will hold,\nconsider the <a href=\"struct.String.html#method.with_capacity\" title=\"associated function std::string::String::with_capacity\"><code>with_capacity</code></a> method to prevent excessive\nre-allocation.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::new();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::new();%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.with_capacity\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#491\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.with_capacity\" class=\"fn\">with_capacity</a>(capacity: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Creates a new empty <code>String</code> with at least the specified capacity.</p>\n<p><code>String</code>s have an internal buffer to hold their data. The capacity is\nthe length of that buffer, and can be queried with the <a href=\"struct.String.html#method.capacity\" title=\"method std::string::String::capacity\"><code>capacity</code></a>\nmethod. This method creates an empty <code>String</code>, but one with an initial\nbuffer that can hold at least <code>capacity</code> bytes. This is useful when you\nmay be appending a bunch of data to the <code>String</code>, reducing the number of\nreallocations it needs to do.</p>\n<p>If the given capacity is <code>0</code>, no allocation will occur, and this method\nis identical to the <a href=\"struct.String.html#method.new\" title=\"associated function std::string::String::new\"><code>new</code></a> method.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::with_capacity(<span class=\"number\">10</span>);\n\n<span class=\"comment\">// The String contains no chars, even though it has capacity for more\n</span><span class=\"macro\">assert_eq!</span>(s.len(), <span class=\"number\">0</span>);\n\n<span class=\"comment\">// These are all done without reallocating...\n</span><span class=\"kw\">let </span>cap = s.capacity();\n<span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n    s.push(<span class=\"string\">'a'</span>);\n}\n\n<span class=\"macro\">assert_eq!</span>(s.capacity(), cap);\n\n<span class=\"comment\">// ...but this may make the string reallocate\n</span>s.push(<span class=\"string\">'a'</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(10);%0A++++%0A++++//+The+String+contains+no+chars,+even+though+it+has+capacity+for+more%0A++++assert_eq!(s.len(),+0);%0A++++%0A++++//+These+are+all+done+without+reallocating...%0A++++let+cap+=+s.capacity();%0A++++for+_+in+0..10+%7B%0A++++++++s.push('a');%0A++++%7D%0A++++%0A++++assert_eq!(s.capacity(),+cap);%0A++++%0A++++//+...but+this+may+make+the+string+reallocate%0A++++s.push('a');%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_with_capacity\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#504\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_with_capacity\" class=\"fn\">try_with_capacity</a>(capacity: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>, <a class=\"struct\" href=\"../collections/struct.TryReserveError.html\" title=\"struct std::collections::TryReserveError\">TryReserveError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>try_with_capacity</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/91913\">#91913</a>)</span></div></span></summary><div class=\"docblock\"><p>Creates a new empty <code>String</code> with at least the specified capacity.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">¬ß</a>Errors</h5>\n<p>Returns <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> if the capacity exceeds <code>isize::MAX</code> bytes,\nor if the memory allocator reports failure.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_utf8\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#576\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.from_utf8\" class=\"fn\">from_utf8</a>(vec: <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>, <a class=\"struct\" href=\"struct.FromUtf8Error.html\" title=\"struct std::string::FromUtf8Error\">FromUtf8Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a vector of bytes to a <code>String</code>.</p>\n<p>A string (<a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>) is made of bytes (<a href=\"../primitive.u8.html\" title=\"primitive u8\"><code>u8</code></a>), and a vector of bytes\n(<a href=\"../vec/struct.Vec.html\" title=\"Vec\"><code>Vec&lt;u8&gt;</code></a>) is made of bytes, so this function converts between the\ntwo. Not all byte slices are valid <code>String</code>s, however: <code>String</code>\nrequires that it is valid UTF-8. <code>from_utf8()</code> checks to ensure that\nthe bytes are valid UTF-8, and then does the conversion.</p>\n<p>If you are sure that the byte slice is valid UTF-8, and you don‚Äôt want\nto incur the overhead of the validity check, there is an unsafe version\nof this function, <a href=\"struct.String.html#method.from_utf8_unchecked\" title=\"associated function std::string::String::from_utf8_unchecked\"><code>from_utf8_unchecked</code></a>, which has the same behavior\nbut skips the check.</p>\n<p>This method will take care to not copy the vector, for efficiency‚Äôs\nsake.</p>\n<p>If you need a <a href=\"../primitive.str.html\" title=\"&amp;str\"><code>&amp;str</code></a> instead of a <code>String</code>, consider\n<a href=\"../str/fn.from_utf8.html\" title=\"fn std::str::from_utf8\"><code>str::from_utf8</code></a>.</p>\n<p>The inverse of this method is <a href=\"struct.String.html#method.into_bytes\" title=\"method std::string::String::into_bytes\"><code>into_bytes</code></a>.</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">¬ß</a>Errors</h5>\n<p>Returns <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> if the slice is not UTF-8 with a description as to why the\nprovided bytes are not UTF-8. The vector you moved in is also included.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some bytes, in a vector\n</span><span class=\"kw\">let </span>sparkle_heart = <span class=\"macro\">vec!</span>[<span class=\"number\">240</span>, <span class=\"number\">159</span>, <span class=\"number\">146</span>, <span class=\"number\">150</span>];\n\n<span class=\"comment\">// We know these bytes are valid, so we'll use `unwrap()`.\n</span><span class=\"kw\">let </span>sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üíñ\"</span>, sparkle_heart);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++//+We+know+these+bytes+are+valid,+so+we'll+use+%60unwrap()%60.%0A++++let+sparkle_heart+=+String::from_utf8(sparkle_heart).unwrap();%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Incorrect bytes:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some invalid bytes, in a vector\n</span><span class=\"kw\">let </span>sparkle_heart = <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">159</span>, <span class=\"number\">146</span>, <span class=\"number\">150</span>];\n\n<span class=\"macro\">assert!</span>(String::from_utf8(sparkle_heart).is_err());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+invalid+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B0,+159,+146,+150%5D;%0A++++%0A++++assert!(String::from_utf8(sparkle_heart).is_err());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>See the docs for <a href=\"struct.FromUtf8Error.html\" title=\"struct std::string::FromUtf8Error\"><code>FromUtf8Error</code></a> for more details on what you can do\nwith this error.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_utf8_lossy\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#635\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.from_utf8_lossy\" class=\"fn\">from_utf8_lossy</a>(v: &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'_, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a slice of bytes to a string, including invalid characters.</p>\n<p>Strings are made of bytes (<a href=\"../primitive.u8.html\" title=\"primitive u8\"><code>u8</code></a>), and a slice of bytes\n(<a href=\"../primitive.slice.html\" title=\"primitive slice\"><code>&amp;[u8]</code></a>) is made of bytes, so this function converts\nbetween the two. Not all byte slices are valid strings, however: strings\nare required to be valid UTF-8. During this conversion,\n<code>from_utf8_lossy()</code> will replace any invalid UTF-8 sequences with\n<a href=\"../char/constant.REPLACEMENT_CHARACTER.html\" title=\"constant std::char::REPLACEMENT_CHARACTER\"><code>U+FFFD REPLACEMENT CHARACTER</code></a>, which looks like this: ÔøΩ</p>\n<p>If you are sure that the byte slice is valid UTF-8, and you don‚Äôt want\nto incur the overhead of the conversion, there is an unsafe version\nof this function, <a href=\"struct.String.html#method.from_utf8_unchecked\" title=\"associated function std::string::String::from_utf8_unchecked\"><code>from_utf8_unchecked</code></a>, which has the same behavior\nbut skips the checks.</p>\n<p>This function returns a <a href=\"../borrow/enum.Cow.html\" title=\"borrow::Cow\"><code>Cow&lt;'a, str&gt;</code></a>. If our byte slice is invalid\nUTF-8, then we need to insert the replacement characters, which will\nchange the size of the string, and hence, require a <code>String</code>. But if\nit‚Äôs already valid UTF-8, we don‚Äôt need a new allocation. This return\ntype allows us to handle both cases.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some bytes, in a vector\n</span><span class=\"kw\">let </span>sparkle_heart = <span class=\"macro\">vec!</span>[<span class=\"number\">240</span>, <span class=\"number\">159</span>, <span class=\"number\">146</span>, <span class=\"number\">150</span>];\n\n<span class=\"kw\">let </span>sparkle_heart = String::from_utf8_lossy(<span class=\"kw-2\">&amp;</span>sparkle_heart);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üíñ\"</span>, sparkle_heart);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++let+sparkle_heart+=+String::from_utf8_lossy(%26sparkle_heart);%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Incorrect bytes:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some invalid bytes\n</span><span class=\"kw\">let </span>input = <span class=\"string\">b\"Hello \\xF0\\x90\\x80World\"</span>;\n<span class=\"kw\">let </span>output = String::from_utf8_lossy(input);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Hello ÔøΩWorld\"</span>, output);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+invalid+bytes%0Afn+main()+%7B%0A++++let+input+=+b%22Hello+%5CxF0%5Cx90%5Cx80World%22;%0A++++let+output+=+String::from_utf8_lossy(input);%0A++++%0A++++assert_eq!(%22Hello+%EF%BF%BDWorld%22,+output);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_utf16\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#684\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.from_utf16\" class=\"fn\">from_utf16</a>(v: &amp;[<a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>]) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>, <a class=\"struct\" href=\"struct.FromUtf16Error.html\" title=\"struct std::string::FromUtf16Error\">FromUtf16Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Decode a UTF-16‚Äìencoded vector <code>v</code> into a <code>String</code>, returning <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>\nif <code>v</code> contains any invalid data.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// ùÑûmusic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD834</span>, <span class=\"number\">0xDD1E</span>, <span class=\"number\">0x006d</span>, <span class=\"number\">0x0075</span>,\n          <span class=\"number\">0x0073</span>, <span class=\"number\">0x0069</span>, <span class=\"number\">0x0063</span>];\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmusic\"</span>),\n           String::from_utf16(v).unwrap());\n\n<span class=\"comment\">// ùÑûmu&lt;invalid&gt;ic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD834</span>, <span class=\"number\">0xDD1E</span>, <span class=\"number\">0x006d</span>, <span class=\"number\">0x0075</span>,\n          <span class=\"number\">0xD800</span>, <span class=\"number\">0x0069</span>, <span class=\"number\">0x0063</span>];\n<span class=\"macro\">assert!</span>(String::from_utf16(v).is_err());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%F0%9D%84%9Emusic%0Afn+main()+%7B%0A++++let+v+=+%26%5B0xD834,+0xDD1E,+0x006d,+0x0075,%0A++++++++++++++0x0073,+0x0069,+0x0063%5D;%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emusic%22),%0A+++++++++++++++String::from_utf16(v).unwrap());%0A++++%0A++++//+%F0%9D%84%9Emu%3Cinvalid%3Eic%0A++++let+v+=+%26%5B0xD834,+0xDD1E,+0x006d,+0x0075,%0A++++++++++++++0xD800,+0x0069,+0x0063%5D;%0A++++assert!(String::from_utf16(v).is_err());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_utf16_lossy\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#724\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.from_utf16_lossy\" class=\"fn\">from_utf16_lossy</a>(v: &amp;[<a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>]) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Decode a UTF-16‚Äìencoded slice <code>v</code> into a <code>String</code>, replacing\ninvalid data with <a href=\"../char/constant.REPLACEMENT_CHARACTER.html\" title=\"constant std::char::REPLACEMENT_CHARACTER\">the replacement character (<code>U+FFFD</code>)</a>.</p>\n<p>Unlike <a href=\"struct.String.html#method.from_utf8_lossy\" title=\"associated function std::string::String::from_utf8_lossy\"><code>from_utf8_lossy</code></a> which returns a <a href=\"../borrow/enum.Cow.html\" title=\"borrow::Cow\"><code>Cow&lt;'a, str&gt;</code></a>,\n<code>from_utf16_lossy</code> returns a <code>String</code> since the UTF-16 to UTF-8\nconversion requires a memory allocation.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// ùÑûmus&lt;invalid&gt;ic&lt;invalid&gt;\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD834</span>, <span class=\"number\">0xDD1E</span>, <span class=\"number\">0x006d</span>, <span class=\"number\">0x0075</span>,\n          <span class=\"number\">0x0073</span>, <span class=\"number\">0xDD1E</span>, <span class=\"number\">0x0069</span>, <span class=\"number\">0x0063</span>,\n          <span class=\"number\">0xD834</span>];\n\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmus\\u{FFFD}ic\\u{FFFD}\"</span>),\n           String::from_utf16_lossy(v));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%F0%9D%84%9Emus%3Cinvalid%3Eic%3Cinvalid%3E%0Afn+main()+%7B%0A++++let+v+=+%26%5B0xD834,+0xDD1E,+0x006d,+0x0075,%0A++++++++++++++0x0073,+0xDD1E,+0x0069,+0x0063,%0A++++++++++++++0xD834%5D;%0A++++%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emus%5Cu%7BFFFD%7Dic%5Cu%7BFFFD%7D%22),%0A+++++++++++++++String::from_utf16_lossy(v));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_utf16le\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#752\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.from_utf16le\" class=\"fn\">from_utf16le</a>(v: &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>, <a class=\"struct\" href=\"struct.FromUtf16Error.html\" title=\"struct std::string::FromUtf16Error\">FromUtf16Error</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>str_from_utf16_endian</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/116258\">#116258</a>)</span></div></span></summary><div class=\"docblock\"><p>Decode a UTF-16LE‚Äìencoded vector <code>v</code> into a <code>String</code>, returning <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>\nif <code>v</code> contains any invalid data.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(str_from_utf16_endian)]\n</span><span class=\"comment\">// ùÑûmusic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x34</span>, <span class=\"number\">0xD8</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>, <span class=\"number\">0x00</span>,\n          <span class=\"number\">0x73</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>, <span class=\"number\">0x00</span>];\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmusic\"</span>),\n           String::from_utf16le(v).unwrap());\n\n<span class=\"comment\">// ùÑûmu&lt;invalid&gt;ic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x34</span>, <span class=\"number\">0xD8</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>, <span class=\"number\">0x00</span>,\n          <span class=\"number\">0x00</span>, <span class=\"number\">0xD8</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>, <span class=\"number\">0x00</span>];\n<span class=\"macro\">assert!</span>(String::from_utf16le(v).is_err());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(str_from_utf16_endian)%5D%0A//+%F0%9D%84%9Emusic%0Afn+main()+%7B%0A++++let+v+=+%26%5B0x34,+0xD8,+0x1E,+0xDD,+0x6d,+0x00,+0x75,+0x00,%0A++++++++++++++0x73,+0x00,+0x69,+0x00,+0x63,+0x00%5D;%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emusic%22),%0A+++++++++++++++String::from_utf16le(v).unwrap());%0A++++%0A++++//+%F0%9D%84%9Emu%3Cinvalid%3Eic%0A++++let+v+=+%26%5B0x34,+0xD8,+0x1E,+0xDD,+0x6d,+0x00,+0x75,+0x00,%0A++++++++++++++0x00,+0xD8,+0x69,+0x00,+0x63,+0x00%5D;%0A++++assert!(String::from_utf16le(v).is_err());%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_utf16le_lossy\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#791\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.from_utf16le_lossy\" class=\"fn\">from_utf16le_lossy</a>(v: &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>str_from_utf16_endian</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/116258\">#116258</a>)</span></div></span></summary><div class=\"docblock\"><p>Decode a UTF-16LE‚Äìencoded slice <code>v</code> into a <code>String</code>, replacing\ninvalid data with <a href=\"../char/constant.REPLACEMENT_CHARACTER.html\" title=\"constant std::char::REPLACEMENT_CHARACTER\">the replacement character (<code>U+FFFD</code>)</a>.</p>\n<p>Unlike <a href=\"struct.String.html#method.from_utf8_lossy\" title=\"associated function std::string::String::from_utf8_lossy\"><code>from_utf8_lossy</code></a> which returns a <a href=\"../borrow/enum.Cow.html\" title=\"borrow::Cow\"><code>Cow&lt;'a, str&gt;</code></a>,\n<code>from_utf16le_lossy</code> returns a <code>String</code> since the UTF-16 to UTF-8\nconversion requires a memory allocation.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(str_from_utf16_endian)]\n</span><span class=\"comment\">// ùÑûmus&lt;invalid&gt;ic&lt;invalid&gt;\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x34</span>, <span class=\"number\">0xD8</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>, <span class=\"number\">0x00</span>,\n          <span class=\"number\">0x73</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>, <span class=\"number\">0x00</span>,\n          <span class=\"number\">0x34</span>, <span class=\"number\">0xD8</span>];\n\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmus\\u{FFFD}ic\\u{FFFD}\"</span>),\n           String::from_utf16le_lossy(v));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(str_from_utf16_endian)%5D%0A//+%F0%9D%84%9Emus%3Cinvalid%3Eic%3Cinvalid%3E%0Afn+main()+%7B%0A++++let+v+=+%26%5B0x34,+0xD8,+0x1E,+0xDD,+0x6d,+0x00,+0x75,+0x00,%0A++++++++++++++0x73,+0x00,+0x1E,+0xDD,+0x69,+0x00,+0x63,+0x00,%0A++++++++++++++0x34,+0xD8%5D;%0A++++%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emus%5Cu%7BFFFD%7Dic%5Cu%7BFFFD%7D%22),%0A+++++++++++++++String::from_utf16le_lossy(v));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_utf16be\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#827\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.from_utf16be\" class=\"fn\">from_utf16be</a>(v: &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>, <a class=\"struct\" href=\"struct.FromUtf16Error.html\" title=\"struct std::string::FromUtf16Error\">FromUtf16Error</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>str_from_utf16_endian</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/116258\">#116258</a>)</span></div></span></summary><div class=\"docblock\"><p>Decode a UTF-16BE‚Äìencoded vector <code>v</code> into a <code>String</code>, returning <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>\nif <code>v</code> contains any invalid data.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(str_from_utf16_endian)]\n</span><span class=\"comment\">// ùÑûmusic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD8</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>,\n          <span class=\"number\">0x00</span>, <span class=\"number\">0x73</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>];\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmusic\"</span>),\n           String::from_utf16be(v).unwrap());\n\n<span class=\"comment\">// ùÑûmu&lt;invalid&gt;ic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD8</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>,\n          <span class=\"number\">0xD8</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>];\n<span class=\"macro\">assert!</span>(String::from_utf16be(v).is_err());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(str_from_utf16_endian)%5D%0A//+%F0%9D%84%9Emusic%0Afn+main()+%7B%0A++++let+v+=+%26%5B0xD8,+0x34,+0xDD,+0x1E,+0x00,+0x6d,+0x00,+0x75,%0A++++++++++++++0x00,+0x73,+0x00,+0x69,+0x00,+0x63%5D;%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emusic%22),%0A+++++++++++++++String::from_utf16be(v).unwrap());%0A++++%0A++++//+%F0%9D%84%9Emu%3Cinvalid%3Eic%0A++++let+v+=+%26%5B0xD8,+0x34,+0xDD,+0x1E,+0x00,+0x6d,+0x00,+0x75,%0A++++++++++++++0xD8,+0x00,+0x00,+0x69,+0x00,+0x63%5D;%0A++++assert!(String::from_utf16be(v).is_err());%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_utf16be_lossy\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#866\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.from_utf16be_lossy\" class=\"fn\">from_utf16be_lossy</a>(v: &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>str_from_utf16_endian</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/116258\">#116258</a>)</span></div></span></summary><div class=\"docblock\"><p>Decode a UTF-16BE‚Äìencoded slice <code>v</code> into a <code>String</code>, replacing\ninvalid data with <a href=\"../char/constant.REPLACEMENT_CHARACTER.html\" title=\"constant std::char::REPLACEMENT_CHARACTER\">the replacement character (<code>U+FFFD</code>)</a>.</p>\n<p>Unlike <a href=\"struct.String.html#method.from_utf8_lossy\" title=\"associated function std::string::String::from_utf8_lossy\"><code>from_utf8_lossy</code></a> which returns a <a href=\"../borrow/enum.Cow.html\" title=\"borrow::Cow\"><code>Cow&lt;'a, str&gt;</code></a>,\n<code>from_utf16le_lossy</code> returns a <code>String</code> since the UTF-16 to UTF-8\nconversion requires a memory allocation.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(str_from_utf16_endian)]\n</span><span class=\"comment\">// ùÑûmus&lt;invalid&gt;ic&lt;invalid&gt;\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD8</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>,\n          <span class=\"number\">0x00</span>, <span class=\"number\">0x73</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>,\n          <span class=\"number\">0xD8</span>, <span class=\"number\">0x34</span>];\n\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmus\\u{FFFD}ic\\u{FFFD}\"</span>),\n           String::from_utf16be_lossy(v));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(str_from_utf16_endian)%5D%0A//+%F0%9D%84%9Emus%3Cinvalid%3Eic%3Cinvalid%3E%0Afn+main()+%7B%0A++++let+v+=+%26%5B0xD8,+0x34,+0xDD,+0x1E,+0x00,+0x6d,+0x00,+0x75,%0A++++++++++++++0x00,+0x73,+0xDD,+0x1E,+0x00,+0x69,+0x00,+0x63,%0A++++++++++++++0xD8,+0x34%5D;%0A++++%0A++++assert_eq!(String::from(%22%F0%9D%84%9Emus%5Cu%7BFFFD%7Dic%5Cu%7BFFFD%7D%22),%0A+++++++++++++++String::from_utf16be_lossy(v));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_raw_parts\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#908\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.into_raw_parts\" class=\"fn\">into_raw_parts</a>(self) -&gt; (<a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>, <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>vec_into_raw_parts</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/65816\">#65816</a>)</span></div></span></summary><div class=\"docblock\"><p>Decomposes a <code>String</code> into its raw components: <code>(pointer, length, capacity)</code>.</p>\n<p>Returns the raw pointer to the underlying data, the length of\nthe string (in bytes), and the allocated capacity of the data\n(in bytes). These are the same arguments in the same order as\nthe arguments to <a href=\"struct.String.html#method.from_raw_parts\" title=\"associated function std::string::String::from_raw_parts\"><code>from_raw_parts</code></a>.</p>\n<p>After calling this function, the caller is responsible for the\nmemory previously managed by the <code>String</code>. The only way to do\nthis is to convert the raw pointer, length, and capacity back\ninto a <code>String</code> with the <a href=\"struct.String.html#method.from_raw_parts\" title=\"associated function std::string::String::from_raw_parts\"><code>from_raw_parts</code></a> function, allowing\nthe destructor to perform the cleanup.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(vec_into_raw_parts)]\n</span><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n<span class=\"kw\">let </span>(ptr, len, cap) = s.into_raw_parts();\n\n<span class=\"kw\">let </span>rebuilt = <span class=\"kw\">unsafe </span>{ String::from_raw_parts(ptr, len, cap) };\n<span class=\"macro\">assert_eq!</span>(rebuilt, <span class=\"string\">\"hello\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(vec_into_raw_parts)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22hello%22);%0A++++%0A++++let+(ptr,+len,+cap)+=+s.into_raw_parts();%0A++++%0A++++let+rebuilt+=+unsafe+%7B+String::from_raw_parts(ptr,+len,+cap)+%7D;%0A++++assert_eq!(rebuilt,+%22hello%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_raw_parts\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#960\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.from_raw_parts\" class=\"fn\">from_raw_parts</a>(\n    buf: <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>,\n    length: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>,\n    capacity: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Creates a new <code>String</code> from a pointer, a length and a capacity.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">¬ß</a>Safety</h5>\n<p>This is highly unsafe, due to the number of invariants that aren‚Äôt\nchecked:</p>\n<ul>\n<li>The memory at <code>buf</code> needs to have been previously allocated by the\nsame allocator the standard library uses, with a required alignment of exactly 1.</li>\n<li><code>length</code> needs to be less than or equal to <code>capacity</code>.</li>\n<li><code>capacity</code> needs to be the correct value.</li>\n<li>The first <code>length</code> bytes at <code>buf</code> need to be valid UTF-8.</li>\n</ul>\n<p>Violating these may cause problems like corrupting the allocator‚Äôs\ninternal data structures. For example, it is normally <strong>not</strong> safe to\nbuild a <code>String</code> from a pointer to a C <code>char</code> array containing UTF-8\n<em>unless</em> you are certain that array was originally allocated by the\nRust standard library‚Äôs allocator.</p>\n<p>The ownership of <code>buf</code> is effectively transferred to the\n<code>String</code> which may then deallocate, reallocate or change the\ncontents of memory pointed to by the pointer at will. Ensure\nthat nothing else uses the pointer after calling this\nfunction.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem;\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n    <span class=\"comment\">// Prevent automatically dropping the String's data\n    </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = mem::ManuallyDrop::new(s);\n\n    <span class=\"kw\">let </span>ptr = s.as_mut_ptr();\n    <span class=\"kw\">let </span>len = s.len();\n    <span class=\"kw\">let </span>capacity = s.capacity();\n\n    <span class=\"kw\">let </span>s = String::from_raw_parts(ptr, len, capacity);\n\n    <span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"hello\"</span>), s);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++unsafe+%7B%0A++++++++let+s+=+String::from(%22hello%22);%0A++++%0A++++++++//+Prevent+automatically+dropping+the+String's+data%0A++++++++let+mut+s+=+mem::ManuallyDrop::new(s);%0A++++%0A++++++++let+ptr+=+s.as_mut_ptr();%0A++++++++let+len+=+s.len();%0A++++++++let+capacity+=+s.capacity();%0A++++%0A++++++++let+s+=+String::from_raw_parts(ptr,+len,+capacity);%0A++++%0A++++++++assert_eq!(String::from(%22hello%22),+s);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_utf8_unchecked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#993\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.from_utf8_unchecked\" class=\"fn\">from_utf8_unchecked</a>(bytes: <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Converts a vector of bytes to a <code>String</code> without checking that the\nstring contains valid UTF-8.</p>\n<p>See the safe version, <a href=\"struct.String.html#method.from_utf8\" title=\"associated function std::string::String::from_utf8\"><code>from_utf8</code></a>, for more details.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">¬ß</a>Safety</h5>\n<p>This function is unsafe because it does not check that the bytes passed\nto it are valid UTF-8. If this constraint is violated, it may cause\nmemory unsafety issues with future users of the <code>String</code>, as the rest of\nthe standard library assumes that <code>String</code>s are valid UTF-8.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some bytes, in a vector\n</span><span class=\"kw\">let </span>sparkle_heart = <span class=\"macro\">vec!</span>[<span class=\"number\">240</span>, <span class=\"number\">159</span>, <span class=\"number\">146</span>, <span class=\"number\">150</span>];\n\n<span class=\"kw\">let </span>sparkle_heart = <span class=\"kw\">unsafe </span>{\n    String::from_utf8_unchecked(sparkle_heart)\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üíñ\"</span>, sparkle_heart);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+some+bytes,+in+a+vector%0Afn+main()+%7B%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++let+sparkle_heart+=+unsafe+%7B%0A++++++++String::from_utf8_unchecked(sparkle_heart)%0A++++%7D;%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_bytes\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1012\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_bytes\" class=\"fn\">into_bytes</a>(self) -&gt; <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Vec<u8>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Converts a <code>String</code> into a byte vector.</p>\n<p>This consumes the <code>String</code>, so we do not need to copy its contents.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n<span class=\"kw\">let </span>bytes = s.into_bytes();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">104</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>][..], <span class=\"kw-2\">&amp;</span>bytes[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22hello%22);%0A++++let+bytes+=+s.into_bytes();%0A++++%0A++++assert_eq!(%26%5B104,+101,+108,+108,+111%5D%5B..%5D,+%26bytes%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_str\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0\">1.7.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1028\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_str\" class=\"fn\">as_str</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\"><p>Extracts a string slice containing the entire <code>String</code>.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foo\"</span>, s.as_str());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22foo%22);%0A++++%0A++++assert_eq!(%22foo%22,+s.as_str());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_mut_str\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0\">1.7.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1047\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_mut_str\" class=\"fn\">as_mut_str</a>(&amp;mut self) -&gt; &amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\"><p>Converts a <code>String</code> into a mutable string slice.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foobar\"</span>);\n<span class=\"kw\">let </span>s_mut_str = s.as_mut_str();\n\ns_mut_str.make_ascii_uppercase();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"FOOBAR\"</span>, s_mut_str);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foobar%22);%0A++++let+s_mut_str+=+s.as_mut_str();%0A++++%0A++++s_mut_str.make_ascii_uppercase();%0A++++%0A++++assert_eq!(%22FOOBAR%22,+s_mut_str);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.push_str\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1066\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.push_str\" class=\"fn\">push_str</a>(&amp;mut self, string: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>)</h4></section></summary><div class=\"docblock\"><p>Appends a given string slice onto the end of this <code>String</code>.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\ns.push_str(<span class=\"string\">\"bar\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foobar\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foo%22);%0A++++%0A++++s.push_str(%22bar%22);%0A++++%0A++++assert_eq!(%22foobar%22,+s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_from_within\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1094-1096\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.extend_from_within\" class=\"fn\">extend_from_within</a>&lt;R&gt;(&amp;mut self, src: R)<div class=\"where\">where\n    R: <a class=\"trait\" href=\"../ops/trait.RangeBounds.html\" title=\"trait std::ops::RangeBounds\">RangeBounds</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>string_extend_from_within</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/103806\">#103806</a>)</span></div></span></summary><div class=\"docblock\"><p>Copies elements from <code>src</code> range to the end of the string.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">¬ß</a>Panics</h5>\n<p>Panics if the starting point or end point do not lie on a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>\nboundary, or if they‚Äôre out of bounds.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(string_extend_from_within)]\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>string = String::from(<span class=\"string\">\"abcde\"</span>);\n\nstring.extend_from_within(<span class=\"number\">2</span>..);\n<span class=\"macro\">assert_eq!</span>(string, <span class=\"string\">\"abcdecde\"</span>);\n\nstring.extend_from_within(..<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(string, <span class=\"string\">\"abcdecdeab\"</span>);\n\nstring.extend_from_within(<span class=\"number\">4</span>..<span class=\"number\">8</span>);\n<span class=\"macro\">assert_eq!</span>(string, <span class=\"string\">\"abcdecdeabecde\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(string_extend_from_within)%5D%0Afn+main()+%7B%0A++++let+mut+string+=+String::from(%22abcde%22);%0A++++%0A++++string.extend_from_within(2..);%0A++++assert_eq!(string,+%22abcdecde%22);%0A++++%0A++++string.extend_from_within(..2);%0A++++assert_eq!(string,+%22abcdecdeab%22);%0A++++%0A++++string.extend_from_within(4..8);%0A++++assert_eq!(string,+%22abcdecdeabecde%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.capacity\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1118\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.capacity\" class=\"fn\">capacity</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns this <code>String</code>‚Äôs capacity, in bytes.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::with_capacity(<span class=\"number\">10</span>);\n\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::with_capacity(10);%0A++++%0A++++assert!(s.capacity()+%3E=+10);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.reserve\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1165\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.reserve\" class=\"fn\">reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Reserves capacity for at least <code>additional</code> bytes more than the\ncurrent length. The allocator may reserve more space to speculatively\navoid frequent allocations. After calling <code>reserve</code>,\ncapacity will be greater than or equal to <code>self.len() + additional</code>.\nDoes nothing if capacity is already sufficient.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">¬ß</a>Panics</h5>\n<p>Panics if the new capacity overflows <a href=\"../primitive.usize.html\" title=\"primitive usize\"><code>usize</code></a>.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::new();\n\ns.reserve(<span class=\"number\">10</span>);\n\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::new();%0A++++%0A++++s.reserve(10);%0A++++%0A++++assert!(s.capacity()+%3E=+10);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This might not actually increase the capacity:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::with_capacity(<span class=\"number\">10</span>);\ns.push(<span class=\"string\">'a'</span>);\ns.push(<span class=\"string\">'b'</span>);\n\n<span class=\"comment\">// s now has a length of 2 and a capacity of at least 10\n</span><span class=\"kw\">let </span>capacity = s.capacity();\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, s.len());\n<span class=\"macro\">assert!</span>(capacity &gt;= <span class=\"number\">10</span>);\n\n<span class=\"comment\">// Since we already have at least an extra 8 capacity, calling this...\n</span>s.reserve(<span class=\"number\">8</span>);\n\n<span class=\"comment\">// ... doesn't actually increase.\n</span><span class=\"macro\">assert_eq!</span>(capacity, s.capacity());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(10);%0A++++s.push('a');%0A++++s.push('b');%0A++++%0A++++//+s+now+has+a+length+of+2+and+a+capacity+of+at+least+10%0A++++let+capacity+=+s.capacity();%0A++++assert_eq!(2,+s.len());%0A++++assert!(capacity+%3E=+10);%0A++++%0A++++//+Since+we+already+have+at+least+an+extra+8+capacity,+calling+this...%0A++++s.reserve(8);%0A++++%0A++++//+...+doesn't+actually+increase.%0A++++assert_eq!(capacity,+s.capacity());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.reserve_exact\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1215\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.reserve_exact\" class=\"fn\">reserve_exact</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Reserves the minimum capacity for at least <code>additional</code> bytes more than\nthe current length. Unlike <a href=\"struct.String.html#method.reserve\" title=\"method std::string::String::reserve\"><code>reserve</code></a>, this will not\ndeliberately over-allocate to speculatively avoid frequent allocations.\nAfter calling <code>reserve_exact</code>, capacity will be greater than or equal to\n<code>self.len() + additional</code>. Does nothing if the capacity is already\nsufficient.</p>\n<h5 id=\"panics-2\"><a class=\"doc-anchor\" href=\"#panics-2\">¬ß</a>Panics</h5>\n<p>Panics if the new capacity overflows <a href=\"../primitive.usize.html\" title=\"primitive usize\"><code>usize</code></a>.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::new();\n\ns.reserve_exact(<span class=\"number\">10</span>);\n\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::new();%0A++++%0A++++s.reserve_exact(10);%0A++++%0A++++assert!(s.capacity()+%3E=+10);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This might not actually increase the capacity:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::with_capacity(<span class=\"number\">10</span>);\ns.push(<span class=\"string\">'a'</span>);\ns.push(<span class=\"string\">'b'</span>);\n\n<span class=\"comment\">// s now has a length of 2 and a capacity of at least 10\n</span><span class=\"kw\">let </span>capacity = s.capacity();\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, s.len());\n<span class=\"macro\">assert!</span>(capacity &gt;= <span class=\"number\">10</span>);\n\n<span class=\"comment\">// Since we already have at least an extra 8 capacity, calling this...\n</span>s.reserve_exact(<span class=\"number\">8</span>);\n\n<span class=\"comment\">// ... doesn't actually increase.\n</span><span class=\"macro\">assert_eq!</span>(capacity, s.capacity());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(10);%0A++++s.push('a');%0A++++s.push('b');%0A++++%0A++++//+s+now+has+a+length+of+2+and+a+capacity+of+at+least+10%0A++++let+capacity+=+s.capacity();%0A++++assert_eq!(2,+s.len());%0A++++assert!(capacity+%3E=+10);%0A++++%0A++++//+Since+we+already+have+at+least+an+extra+8+capacity,+calling+this...%0A++++s.reserve_exact(8);%0A++++%0A++++//+...+doesn't+actually+increase.%0A++++assert_eq!(capacity,+s.capacity());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_reserve\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.57.0\">1.57.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1250\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.try_reserve\" class=\"fn\">try_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../collections/struct.TryReserveError.html\" title=\"struct std::collections::TryReserveError\">TryReserveError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to reserve capacity for at least <code>additional</code> bytes more than the\ncurrent length. The allocator may reserve more space to speculatively\navoid frequent allocations. After calling <code>try_reserve</code>, capacity will be\ngreater than or equal to <code>self.len() + additional</code> if it returns\n<code>Ok(())</code>. Does nothing if capacity is already sufficient. This method\npreserves the contents even if an error occurs.</p>\n<h5 id=\"errors-2\"><a class=\"doc-anchor\" href=\"#errors-2\">¬ß</a>Errors</h5>\n<p>If the capacity overflows, or the allocator reports a failure, then an error\nis returned.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::TryReserveError;\n\n<span class=\"kw\">fn </span>process_data(data: <span class=\"kw-2\">&amp;</span>str) -&gt; <span class=\"prelude-ty\">Result</span>&lt;String, TryReserveError&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>output = String::new();\n\n    <span class=\"comment\">// Pre-reserve the memory, exiting if we can't\n    </span>output.try_reserve(data.len())<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// Now we know this can't OOM in the middle of our complex work\n    </span>output.push_str(data);\n\n    <span class=\"prelude-val\">Ok</span>(output)\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+process_data(data:+%26str)+-%3E+Result%3CString,+TryReserveError%3E+%7B%0A++++++++let+mut+output+=+String::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can't%0A++++++++output.try_reserve(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can't+OOM+in+the+middle+of+our+complex+work%0A++++++++output.push_str(data);%0A++++%0A++++++++Ok(output)%0A++++%7D%0A++++process_data(%22rust%22).expect(%22why+is+the+test+harness+OOMing+on+4+bytes?%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_reserve_exact\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.57.0\">1.57.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1291\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.try_reserve_exact\" class=\"fn\">try_reserve_exact</a>(\n    &amp;mut self,\n    additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../collections/struct.TryReserveError.html\" title=\"struct std::collections::TryReserveError\">TryReserveError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to reserve the minimum capacity for at least <code>additional</code> bytes\nmore than the current length. Unlike <a href=\"struct.String.html#method.try_reserve\" title=\"method std::string::String::try_reserve\"><code>try_reserve</code></a>, this will not\ndeliberately over-allocate to speculatively avoid frequent allocations.\nAfter calling <code>try_reserve_exact</code>, capacity will be greater than or\nequal to <code>self.len() + additional</code> if it returns <code>Ok(())</code>.\nDoes nothing if the capacity is already sufficient.</p>\n<p>Note that the allocator may give the collection more space than it\nrequests. Therefore, capacity can not be relied upon to be precisely\nminimal. Prefer <a href=\"struct.String.html#method.try_reserve\" title=\"method std::string::String::try_reserve\"><code>try_reserve</code></a> if future insertions are expected.</p>\n<h5 id=\"errors-3\"><a class=\"doc-anchor\" href=\"#errors-3\">¬ß</a>Errors</h5>\n<p>If the capacity overflows, or the allocator reports a failure, then an error\nis returned.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::TryReserveError;\n\n<span class=\"kw\">fn </span>process_data(data: <span class=\"kw-2\">&amp;</span>str) -&gt; <span class=\"prelude-ty\">Result</span>&lt;String, TryReserveError&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>output = String::new();\n\n    <span class=\"comment\">// Pre-reserve the memory, exiting if we can't\n    </span>output.try_reserve_exact(data.len())<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// Now we know this can't OOM in the middle of our complex work\n    </span>output.push_str(data);\n\n    <span class=\"prelude-val\">Ok</span>(output)\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+process_data(data:+%26str)+-%3E+Result%3CString,+TryReserveError%3E+%7B%0A++++++++let+mut+output+=+String::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can't%0A++++++++output.try_reserve_exact(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can't+OOM+in+the+middle+of+our+complex+work%0A++++++++output.push_str(data);%0A++++%0A++++++++Ok(output)%0A++++%7D%0A++++process_data(%22rust%22).expect(%22why+is+the+test+harness+OOMing+on+4+bytes?%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.shrink_to_fit\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1311\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.shrink_to_fit\" class=\"fn\">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Shrinks the capacity of this <code>String</code> to match its length.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\ns.reserve(<span class=\"number\">100</span>);\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">100</span>);\n\ns.shrink_to_fit();\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">3</span>, s.capacity());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foo%22);%0A++++%0A++++s.reserve(100);%0A++++assert!(s.capacity()+%3E=+100);%0A++++%0A++++s.shrink_to_fit();%0A++++assert_eq!(3,+s.capacity());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.shrink_to\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.56.0\">1.56.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1338\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.shrink_to\" class=\"fn\">shrink_to</a>(&amp;mut self, min_capacity: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Shrinks the capacity of this <code>String</code> with a lower bound.</p>\n<p>The capacity will remain at least as large as both the length\nand the supplied value.</p>\n<p>If the current capacity is less than the lower limit, this is a no-op.</p>\n<h5 id=\"examples-25\"><a class=\"doc-anchor\" href=\"#examples-25\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\ns.reserve(<span class=\"number\">100</span>);\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">100</span>);\n\ns.shrink_to(<span class=\"number\">10</span>);\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">10</span>);\ns.shrink_to(<span class=\"number\">0</span>);\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">3</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foo%22);%0A++++%0A++++s.reserve(100);%0A++++assert!(s.capacity()+%3E=+100);%0A++++%0A++++s.shrink_to(10);%0A++++assert!(s.capacity()+%3E=+10);%0A++++s.shrink_to(0);%0A++++assert!(s.capacity()+%3E=+3);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.push\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1358\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.push\" class=\"fn\">push</a>(&amp;mut self, ch: <a class=\"primitive\" href=\"../primitive.char.html\">char</a>)</h4></section></summary><div class=\"docblock\"><p>Appends the given <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> to the end of this <code>String</code>.</p>\n<h5 id=\"examples-26\"><a class=\"doc-anchor\" href=\"#examples-26\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"abc\"</span>);\n\ns.push(<span class=\"string\">'1'</span>);\ns.push(<span class=\"string\">'2'</span>);\ns.push(<span class=\"string\">'3'</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"abc123\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22abc%22);%0A++++%0A++++s.push('1');%0A++++s.push('2');%0A++++s.push('3');%0A++++%0A++++assert_eq!(%22abc123%22,+s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_bytes\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1381\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_bytes\" class=\"fn\">as_bytes</a>(&amp;self) -&gt; &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Returns a byte slice of this <code>String</code>‚Äôs contents.</p>\n<p>The inverse of this method is <a href=\"struct.String.html#method.from_utf8\" title=\"associated function std::string::String::from_utf8\"><code>from_utf8</code></a>.</p>\n<h5 id=\"examples-27\"><a class=\"doc-anchor\" href=\"#examples-27\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">104</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>], s.as_bytes());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22hello%22);%0A++++%0A++++assert_eq!(%26%5B104,+101,+108,+108,+111%5D,+s.as_bytes());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.truncate\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1408\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.truncate\" class=\"fn\">truncate</a>(&amp;mut self, new_len: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Shortens this <code>String</code> to the specified length.</p>\n<p>If <code>new_len</code> is greater than or equal to the string‚Äôs current length, this has no\neffect.</p>\n<p>Note that this method has no effect on the allocated capacity\nof the string</p>\n<h5 id=\"panics-3\"><a class=\"doc-anchor\" href=\"#panics-3\">¬ß</a>Panics</h5>\n<p>Panics if <code>new_len</code> does not lie on a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> boundary.</p>\n<h5 id=\"examples-28\"><a class=\"doc-anchor\" href=\"#examples-28\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\ns.truncate(<span class=\"number\">2</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"he\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22hello%22);%0A++++%0A++++s.truncate(2);%0A++++%0A++++assert_eq!(%22he%22,+s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.pop\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1432\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.pop\" class=\"fn\">pop</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Removes the last character from the string buffer and returns it.</p>\n<p>Returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> if this <code>String</code> is empty.</p>\n<h5 id=\"examples-29\"><a class=\"doc-anchor\" href=\"#examples-29\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"abƒç\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(s.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"string\">'ƒç'</span>));\n<span class=\"macro\">assert_eq!</span>(s.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"string\">'b'</span>));\n<span class=\"macro\">assert_eq!</span>(s.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"string\">'a'</span>));\n\n<span class=\"macro\">assert_eq!</span>(s.pop(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22ab%C4%8D%22);%0A++++%0A++++assert_eq!(s.pop(),+Some('%C4%8D'));%0A++++assert_eq!(s.pop(),+Some('b'));%0A++++assert_eq!(s.pop(),+Some('a'));%0A++++%0A++++assert_eq!(s.pop(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.remove\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1463\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.remove\" class=\"fn\">remove</a>(&amp;mut self, idx: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></summary><div class=\"docblock\"><p>Removes a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> from this <code>String</code> at a byte position and returns it.</p>\n<p>This is an <em>O</em>(<em>n</em>) operation, as it requires copying every element in the\nbuffer.</p>\n<h5 id=\"panics-4\"><a class=\"doc-anchor\" href=\"#panics-4\">¬ß</a>Panics</h5>\n<p>Panics if <code>idx</code> is larger than or equal to the <code>String</code>‚Äôs length,\nor if it does not lie on a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> boundary.</p>\n<h5 id=\"examples-30\"><a class=\"doc-anchor\" href=\"#examples-30\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"ab√ß\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(s.remove(<span class=\"number\">0</span>), <span class=\"string\">'a'</span>);\n<span class=\"macro\">assert_eq!</span>(s.remove(<span class=\"number\">1</span>), <span class=\"string\">'√ß'</span>);\n<span class=\"macro\">assert_eq!</span>(s.remove(<span class=\"number\">0</span>), <span class=\"string\">'b'</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22ab%C3%A7%22);%0A++++%0A++++assert_eq!(s.remove(0),+'a');%0A++++assert_eq!(s.remove(1),+'%C3%A7');%0A++++assert_eq!(s.remove(0),+'b');%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.remove_matches\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1500-1502\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.remove_matches\" class=\"fn\">remove_matches</a>&lt;'a, P&gt;(&amp;'a mut self, pat: P)<div class=\"where\">where\n    P: for&lt;'x&gt; <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'x&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>string_remove_matches</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72826\">#72826</a>)</span></div></span></summary><div class=\"docblock\"><p>Remove all matches of pattern <code>pat</code> in the <code>String</code>.</p>\n<h5 id=\"examples-31\"><a class=\"doc-anchor\" href=\"#examples-31\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(string_remove_matches)]\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"Trees are not green, the sky is not blue.\"</span>);\ns.remove_matches(<span class=\"string\">\"not \"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Trees are green, the sky is blue.\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(string_remove_matches)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Trees+are+not+green,+the+sky+is+not+blue.%22);%0A++++s.remove_matches(%22not+%22);%0A++++assert_eq!(%22Trees+are+green,+the+sky+is+blue.%22,+s);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Matches will be detected and removed iteratively, so in cases where\npatterns overlap, only the first pattern will be removed:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(string_remove_matches)]\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"banana\"</span>);\ns.remove_matches(<span class=\"string\">\"ana\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"bna\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(string_remove_matches)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22banana%22);%0A++++s.remove_matches(%22ana%22);%0A++++assert_eq!(%22bna%22,+s);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.retain\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.26.0\">1.26.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1580-1582\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.retain\" class=\"fn\">retain</a>&lt;F&gt;(&amp;mut self, f: F)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.char.html\">char</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Retains only the characters specified by the predicate.</p>\n<p>In other words, remove all characters <code>c</code> such that <code>f(c)</code> returns <code>false</code>.\nThis method operates in place, visiting each character exactly once in the\noriginal order, and preserves the order of the retained characters.</p>\n<h5 id=\"examples-32\"><a class=\"doc-anchor\" href=\"#examples-32\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"f_o_ob_ar\"</span>);\n\ns.retain(|c| c != <span class=\"string\">'_'</span>);\n\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"foobar\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22f_o_ob_ar%22);%0A++++%0A++++s.retain(%7Cc%7C+c+!=+'_');%0A++++%0A++++assert_eq!(s,+%22foobar%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Because the elements are visited exactly once in the original order,\nexternal state may be used to decide which elements to keep.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"abcde\"</span>);\n<span class=\"kw\">let </span>keep = [<span class=\"bool-val\">false</span>, <span class=\"bool-val\">true</span>, <span class=\"bool-val\">true</span>, <span class=\"bool-val\">false</span>, <span class=\"bool-val\">true</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = keep.iter();\ns.retain(|<span class=\"kw\">_</span>| <span class=\"kw-2\">*</span>iter.next().unwrap());\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"bce\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22abcde%22);%0A++++let+keep+=+%5Bfalse,+true,+true,+false,+true%5D;%0A++++let+mut+iter+=+keep.iter();%0A++++s.retain(%7C_%7C+*iter.next().unwrap());%0A++++assert_eq!(s,+%22bce%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.insert\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1658\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.insert\" class=\"fn\">insert</a>(&amp;mut self, idx: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, ch: <a class=\"primitive\" href=\"../primitive.char.html\">char</a>)</h4></section></summary><div class=\"docblock\"><p>Inserts a character into this <code>String</code> at a byte position.</p>\n<p>This is an <em>O</em>(<em>n</em>) operation as it requires copying every element in the\nbuffer.</p>\n<h5 id=\"panics-5\"><a class=\"doc-anchor\" href=\"#panics-5\">¬ß</a>Panics</h5>\n<p>Panics if <code>idx</code> is larger than the <code>String</code>‚Äôs length, or if it does not\nlie on a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> boundary.</p>\n<h5 id=\"examples-33\"><a class=\"doc-anchor\" href=\"#examples-33\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::with_capacity(<span class=\"number\">3</span>);\n\ns.insert(<span class=\"number\">0</span>, <span class=\"string\">'f'</span>);\ns.insert(<span class=\"number\">1</span>, <span class=\"string\">'o'</span>);\ns.insert(<span class=\"number\">2</span>, <span class=\"string\">'o'</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foo\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::with_capacity(3);%0A++++%0A++++s.insert(0,+'f');%0A++++s.insert(1,+'o');%0A++++s.insert(2,+'o');%0A++++%0A++++assert_eq!(%22foo%22,+s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.insert_str\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1703\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.insert_str\" class=\"fn\">insert_str</a>(&amp;mut self, idx: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, string: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>)</h4></section></summary><div class=\"docblock\"><p>Inserts a string slice into this <code>String</code> at a byte position.</p>\n<p>This is an <em>O</em>(<em>n</em>) operation as it requires copying every element in the\nbuffer.</p>\n<h5 id=\"panics-6\"><a class=\"doc-anchor\" href=\"#panics-6\">¬ß</a>Panics</h5>\n<p>Panics if <code>idx</code> is larger than the <code>String</code>‚Äôs length, or if it does not\nlie on a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> boundary.</p>\n<h5 id=\"examples-34\"><a class=\"doc-anchor\" href=\"#examples-34\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"bar\"</span>);\n\ns.insert_str(<span class=\"number\">0</span>, <span class=\"string\">\"foo\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foobar\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22bar%22);%0A++++%0A++++s.insert_str(0,+%22foo%22);%0A++++%0A++++assert_eq!(%22foobar%22,+s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_mut_vec\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1736\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.as_mut_vec\" class=\"fn\">as_mut_vec</a>(&amp;mut self) -&gt; &amp;mut <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;mut Vec<u8>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to the contents of this <code>String</code>.</p>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">¬ß</a>Safety</h5>\n<p>This function is unsafe because the returned <code>&amp;mut Vec</code> allows writing\nbytes which are not valid UTF-8. If this constraint is violated, using\nthe original <code>String</code> after dropping the <code>&amp;mut Vec</code> may violate memory\nsafety, as the rest of the standard library assumes that <code>String</code>s are\nvalid UTF-8.</p>\n<h5 id=\"examples-35\"><a class=\"doc-anchor\" href=\"#examples-35\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>vec = s.as_mut_vec();\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">104</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>][..], <span class=\"kw-2\">&amp;</span>vec[..]);\n\n    vec.reverse();\n}\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"olleh\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22hello%22);%0A++++%0A++++unsafe+%7B%0A++++++++let+vec+=+s.as_mut_vec();%0A++++++++assert_eq!(%26%5B104,+101,+108,+108,+111%5D%5B..%5D,+%26vec%5B..%5D);%0A++++%0A++++++++vec.reverse();%0A++++%7D%0A++++assert_eq!(s,+%22olleh%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.len\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1758\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.len\" class=\"fn\">len</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the length of this <code>String</code>, in bytes, not <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s or\ngraphemes. In other words, it might not be what a human considers the\nlength of the string.</p>\n<h5 id=\"examples-36\"><a class=\"doc-anchor\" href=\"#examples-36\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = String::from(<span class=\"string\">\"foo\"</span>);\n<span class=\"macro\">assert_eq!</span>(a.len(), <span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>fancy_f = String::from(<span class=\"string\">\"∆íoo\"</span>);\n<span class=\"macro\">assert_eq!</span>(fancy_f.len(), <span class=\"number\">4</span>);\n<span class=\"macro\">assert_eq!</span>(fancy_f.chars().count(), <span class=\"number\">3</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+String::from(%22foo%22);%0A++++assert_eq!(a.len(),+3);%0A++++%0A++++let+fancy_f+=+String::from(%22%C6%92oo%22);%0A++++assert_eq!(fancy_f.len(),+4);%0A++++assert_eq!(fancy_f.chars().count(),+3);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_empty\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1776\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_empty\" class=\"fn\">is_empty</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if this <code>String</code> has a length of zero, and <code>false</code> otherwise.</p>\n<h5 id=\"examples-37\"><a class=\"doc-anchor\" href=\"#examples-37\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = String::new();\n<span class=\"macro\">assert!</span>(v.is_empty());\n\nv.push(<span class=\"string\">'a'</span>);\n<span class=\"macro\">assert!</span>(!v.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::new();%0A++++assert!(v.is_empty());%0A++++%0A++++v.push('a');%0A++++assert!(!v.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_off\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1807\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_off\" class=\"fn\">split_off</a>(&amp;mut self, at: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Splits the string into two at the given byte index.</p>\n<p>Returns a newly allocated <code>String</code>. <code>self</code> contains bytes <code>[0, at)</code>, and\nthe returned <code>String</code> contains bytes <code>[at, len)</code>. <code>at</code> must be on the\nboundary of a UTF-8 code point.</p>\n<p>Note that the capacity of <code>self</code> does not change.</p>\n<h5 id=\"panics-7\"><a class=\"doc-anchor\" href=\"#panics-7\">¬ß</a>Panics</h5>\n<p>Panics if <code>at</code> is not on a <code>UTF-8</code> code point boundary, or if it is beyond the last\ncode point of the string.</p>\n<h5 id=\"examples-38\"><a class=\"doc-anchor\" href=\"#examples-38\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>hello = String::from(<span class=\"string\">\"Hello, World!\"</span>);\n<span class=\"kw\">let </span>world = hello.split_off(<span class=\"number\">7</span>);\n<span class=\"macro\">assert_eq!</span>(hello, <span class=\"string\">\"Hello, \"</span>);\n<span class=\"macro\">assert_eq!</span>(world, <span class=\"string\">\"World!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+mut+hello+=+String::from(%22Hello,+World!%22);%0Alet+world+=+hello.split_off(7);%0Aassert_eq!(hello,+%22Hello,+%22);%0Aassert_eq!(world,+%22World!%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clear\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1831\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.clear\" class=\"fn\">clear</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Truncates this <code>String</code>, removing all contents.</p>\n<p>While this means the <code>String</code> will have a length of zero, it does not\ntouch its capacity.</p>\n<h5 id=\"examples-39\"><a class=\"doc-anchor\" href=\"#examples-39\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\ns.clear();\n\n<span class=\"macro\">assert!</span>(s.is_empty());\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">0</span>, s.len());\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">3</span>, s.capacity());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22foo%22);%0A++++%0A++++s.clear();%0A++++%0A++++assert!(s.is_empty());%0A++++assert_eq!(0,+s.len());%0A++++assert_eq!(3,+s.capacity());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.drain\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1869-1871\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.drain\" class=\"fn\">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class=\"struct\" href=\"struct.Drain.html\" title=\"struct std::string::Drain\">Drain</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Drain<'_>\">‚ìò</a><div class=\"where\">where\n    R: <a class=\"trait\" href=\"../ops/trait.RangeBounds.html\" title=\"trait std::ops::RangeBounds\">RangeBounds</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Removes the specified range from the string in bulk, returning all\nremoved characters as an iterator.</p>\n<p>The returned iterator keeps a mutable borrow on the string to optimize\nits implementation.</p>\n<h5 id=\"panics-8\"><a class=\"doc-anchor\" href=\"#panics-8\">¬ß</a>Panics</h5>\n<p>Panics if the starting point or end point do not lie on a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>\nboundary, or if they‚Äôre out of bounds.</p>\n<h5 id=\"leaking\"><a class=\"doc-anchor\" href=\"#leaking\">¬ß</a>Leaking</h5>\n<p>If the returned iterator goes out of scope without being dropped (due to\n<a href=\"../mem/fn.forget.html\" title=\"fn std::mem::forget\"><code>core::mem::forget</code></a>, for example), the string may still contain a copy\nof any drained characters, or may have lost characters arbitrarily,\nincluding characters outside the range.</p>\n<h5 id=\"examples-40\"><a class=\"doc-anchor\" href=\"#examples-40\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"Œ± is alpha, Œ≤ is beta\"</span>);\n<span class=\"kw\">let </span>beta_offset = s.find(<span class=\"string\">'Œ≤'</span>).unwrap_or(s.len());\n\n<span class=\"comment\">// Remove the range up until the Œ≤ from the string\n</span><span class=\"kw\">let </span>t: String = s.drain(..beta_offset).collect();\n<span class=\"macro\">assert_eq!</span>(t, <span class=\"string\">\"Œ± is alpha, \"</span>);\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"Œ≤ is beta\"</span>);\n\n<span class=\"comment\">// A full range clears the string, like `clear()` does\n</span>s.drain(..);\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22%CE%B1+is+alpha,+%CE%B2+is+beta%22);%0A++++let+beta_offset+=+s.find('%CE%B2').unwrap_or(s.len());%0A++++%0A++++//+Remove+the+range+up+until+the+%CE%B2+from+the+string%0A++++let+t:+String+=+s.drain(..beta_offset).collect();%0A++++assert_eq!(t,+%22%CE%B1+is+alpha,+%22);%0A++++assert_eq!(s,+%22%CE%B2+is+beta%22);%0A++++%0A++++//+A+full+range+clears+the+string,+like+%60clear()%60+does%0A++++s.drain(..);%0A++++assert_eq!(s,+%22%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.replace_range\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1913-1915\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.replace_range\" class=\"fn\">replace_range</a>&lt;R&gt;(&amp;mut self, range: R, replace_with: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>)<div class=\"where\">where\n    R: <a class=\"trait\" href=\"../ops/trait.RangeBounds.html\" title=\"trait std::ops::RangeBounds\">RangeBounds</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Removes the specified range in the string,\nand replaces it with the given string.\nThe given string doesn‚Äôt need to be the same length as the range.</p>\n<h5 id=\"panics-9\"><a class=\"doc-anchor\" href=\"#panics-9\">¬ß</a>Panics</h5>\n<p>Panics if the starting point or end point do not lie on a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>\nboundary, or if they‚Äôre out of bounds.</p>\n<h5 id=\"examples-41\"><a class=\"doc-anchor\" href=\"#examples-41\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"Œ± is alpha, Œ≤ is beta\"</span>);\n<span class=\"kw\">let </span>beta_offset = s.find(<span class=\"string\">'Œ≤'</span>).unwrap_or(s.len());\n\n<span class=\"comment\">// Replace the range up until the Œ≤ from the string\n</span>s.replace_range(..beta_offset, <span class=\"string\">\"Œë is capital alpha; \"</span>);\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"Œë is capital alpha; Œ≤ is beta\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22%CE%B1+is+alpha,+%CE%B2+is+beta%22);%0A++++let+beta_offset+=+s.find('%CE%B2').unwrap_or(s.len());%0A++++%0A++++//+Replace+the+range+up+until+the+%CE%B2+from+the+string%0A++++s.replace_range(..beta_offset,+%22%CE%91+is+capital+alpha;+%22);%0A++++assert_eq!(s,+%22%CE%91+is+capital+alpha;+%CE%B2+is+beta%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_boxed_str\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1962\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_boxed_str\" class=\"fn\">into_boxed_str</a>(self) -&gt; <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts this <code>String</code> into a <code><a href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a href=\"../primitive.str.html\" title=\"str\">str</a>&gt;</code>.</p>\n<p>Before doing the conversion, this method discards excess capacity like <a href=\"struct.String.html#method.shrink_to_fit\" title=\"method std::string::String::shrink_to_fit\"><code>shrink_to_fit</code></a>.\nNote that this call may reallocate and copy the bytes of the string.</p>\n<h5 id=\"examples-42\"><a class=\"doc-anchor\" href=\"#examples-42\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n<span class=\"kw\">let </span>b = s.into_boxed_str();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+String::from(%22hello%22);%0A++++%0A++++let+b+=+s.into_boxed_str();%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.leak\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.72.0\">1.72.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#1990\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.leak\" class=\"fn\">leak</a>&lt;'a&gt;(self) -&gt; &amp;'a mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\"><p>Consumes and leaks the <code>String</code>, returning a mutable reference to the contents,\n<code>&amp;'a mut str</code>.</p>\n<p>The caller has free choice over the returned lifetime, including <code>'static</code>. Indeed,\nthis function is ideally used for data that lives for the remainder of the program‚Äôs life,\nas dropping the returned reference will cause a memory leak.</p>\n<p>It does not reallocate or shrink the <code>String</code>, so the leaked allocation may include unused\ncapacity that is not part of the returned slice. If you want to discard excess capacity,\ncall <a href=\"struct.String.html#method.into_boxed_str\" title=\"method std::string::String::into_boxed_str\"><code>into_boxed_str</code></a>, and then <a href=\"../boxed/struct.Box.html#method.leak\" title=\"associated function std::boxed::Box::leak\"><code>Box::leak</code></a> instead. However, keep in mind that\ntrimming the capacity may result in a reallocation and copy.</p>\n<h5 id=\"examples-43\"><a class=\"doc-anchor\" href=\"#examples-43\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = String::from(<span class=\"string\">\"bucket\"</span>);\n<span class=\"kw\">let </span>static_ref: <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'static </span><span class=\"kw-2\">mut </span>str = x.leak();\n<span class=\"macro\">assert_eq!</span>(static_ref, <span class=\"string\">\"bucket\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+String::from(%22bucket%22);%0A++++let+static_ref:+%26'static+mut+str+=+x.leak();%0A++++assert_eq!(static_ref,+%22bucket%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details></div><h2 id=\"deref-methods-str\" class=\"section-header\"><span>Methods from <a class=\"trait\" href=\"../ops/trait.Deref.html\" title=\"trait std::ops::Deref\">Deref</a>&lt;Target = <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</span><a href=\"#deref-methods-str\" class=\"anchor\">¬ß</a></h2><div id=\"deref-methods-str-1\" class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.len-1\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#160\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.len-1\" class=\"fn\">len</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the length of <code>self</code>.</p>\n<p>This length is in bytes, not <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s or graphemes. In other words,\nit might not be what a human considers the length of the string.</p>\n<h5 id=\"examples-44\"><a class=\"doc-anchor\" href=\"#examples-44\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>len = <span class=\"string\">\"foo\"</span>.len();\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">3</span>, len);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"∆íoo\"</span>.len(), <span class=\"number\">4</span>); <span class=\"comment\">// fancy f!\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"∆íoo\"</span>.chars().count(), <span class=\"number\">3</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+len+=+%22foo%22.len();%0A++++assert_eq!(3,+len);%0A++++%0A++++assert_eq!(%22%C6%92oo%22.len(),+4);+//+fancy+f!%0A++++assert_eq!(%22%C6%92oo%22.chars().count(),+3);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_empty-1\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#179\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_empty-1\" class=\"fn\">is_empty</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>\n<h5 id=\"examples-45\"><a class=\"doc-anchor\" href=\"#examples-45\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"\"</span>;\n<span class=\"macro\">assert!</span>(s.is_empty());\n\n<span class=\"kw\">let </span>s = <span class=\"string\">\"not empty\"</span>;\n<span class=\"macro\">assert!</span>(!s.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%22;%0A++++assert!(s.is_empty());%0A++++%0A++++let+s+=+%22not+empty%22;%0A++++assert!(!s.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_char_boundary\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.9.0\">1.9.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#209\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_char_boundary\" class=\"fn\">is_char_boundary</a>(&amp;self, index: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point\nsequence or the end of the string.</p>\n<p>The start and end of the string (when <code>index == self.len()</code>) are\nconsidered to be boundaries.</p>\n<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>\n<h5 id=\"examples-46\"><a class=\"doc-anchor\" href=\"#examples-46\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"L√∂we ËÄÅËôé L√©opard\"</span>;\n<span class=\"macro\">assert!</span>(s.is_char_boundary(<span class=\"number\">0</span>));\n<span class=\"comment\">// start of `ËÄÅ`\n</span><span class=\"macro\">assert!</span>(s.is_char_boundary(<span class=\"number\">6</span>));\n<span class=\"macro\">assert!</span>(s.is_char_boundary(s.len()));\n\n<span class=\"comment\">// second byte of `√∂`\n</span><span class=\"macro\">assert!</span>(!s.is_char_boundary(<span class=\"number\">2</span>));\n\n<span class=\"comment\">// third byte of `ËÄÅ`\n</span><span class=\"macro\">assert!</span>(!s.is_char_boundary(<span class=\"number\">8</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++assert!(s.is_char_boundary(0));%0A++++//+start+of+%60%E8%80%81%60%0A++++assert!(s.is_char_boundary(6));%0A++++assert!(s.is_char_boundary(s.len()));%0A++++%0A++++//+second+byte+of+%60%C3%B6%60%0A++++assert!(!s.is_char_boundary(2));%0A++++%0A++++//+third+byte+of+%60%E8%80%81%60%0A++++assert!(!s.is_char_boundary(8));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.floor_char_boundary\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#256\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.floor_char_boundary\" class=\"fn\">floor_char_boundary</a>(&amp;self, index: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/93743\">#93743</a>)</span></div></span></summary><div class=\"docblock\"><p>Finds the closest <code>x</code> not exceeding <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>\n<p>This method can help you truncate a string so that it‚Äôs still valid UTF-8, but doesn‚Äôt\nexceed a given number of bytes. Note that this is done purely at the character level\nand can still visually split graphemes, even though the underlying characters aren‚Äôt\nsplit. For example, the emoji üßë‚Äçüî¨ (scientist) could be split so that the string only\nincludes üßë (person) instead.</p>\n<h5 id=\"examples-47\"><a class=\"doc-anchor\" href=\"#examples-47\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(round_char_boundary)]\n</span><span class=\"kw\">let </span>s = <span class=\"string\">\"‚ù§Ô∏èüß°üíõüíöüíôüíú\"</span>;\n<span class=\"macro\">assert_eq!</span>(s.len(), <span class=\"number\">26</span>);\n<span class=\"macro\">assert!</span>(!s.is_char_boundary(<span class=\"number\">13</span>));\n\n<span class=\"kw\">let </span>closest = s.floor_char_boundary(<span class=\"number\">13</span>);\n<span class=\"macro\">assert_eq!</span>(closest, <span class=\"number\">10</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>s[..closest], <span class=\"string\">\"‚ù§Ô∏èüß°\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(round_char_boundary)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22;%0A++++assert_eq!(s.len(),+26);%0A++++assert!(!s.is_char_boundary(13));%0A++++%0A++++let+closest+=+s.floor_char_boundary(13);%0A++++assert_eq!(closest,+10);%0A++++assert_eq!(%26s%5B..closest%5D,+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ceil_char_boundary\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#294\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.ceil_char_boundary\" class=\"fn\">ceil_char_boundary</a>(&amp;self, index: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/93743\">#93743</a>)</span></div></span></summary><div class=\"docblock\"><p>Finds the closest <code>x</code> not below <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>\n<p>If <code>index</code> is greater than the length of the string, this returns the length of the string.</p>\n<p>This method is the natural complement to <a href=\"../primitive.str.html#method.floor_char_boundary\" title=\"method str::floor_char_boundary\"><code>floor_char_boundary</code></a>. See that method\nfor more details.</p>\n<h5 id=\"examples-48\"><a class=\"doc-anchor\" href=\"#examples-48\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(round_char_boundary)]\n</span><span class=\"kw\">let </span>s = <span class=\"string\">\"‚ù§Ô∏èüß°üíõüíöüíôüíú\"</span>;\n<span class=\"macro\">assert_eq!</span>(s.len(), <span class=\"number\">26</span>);\n<span class=\"macro\">assert!</span>(!s.is_char_boundary(<span class=\"number\">13</span>));\n\n<span class=\"kw\">let </span>closest = s.ceil_char_boundary(<span class=\"number\">13</span>);\n<span class=\"macro\">assert_eq!</span>(closest, <span class=\"number\">14</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>s[..closest], <span class=\"string\">\"‚ù§Ô∏èüß°üíõ\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(round_char_boundary)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22;%0A++++assert_eq!(s.len(),+26);%0A++++assert!(!s.is_char_boundary(13));%0A++++%0A++++let+closest+=+s.ceil_char_boundary(13);%0A++++assert_eq!(closest,+14);%0A++++assert_eq!(%26s%5B..closest%5D,+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_bytes-1\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#320\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_bytes-1\" class=\"fn\">as_bytes</a>(&amp;self) -&gt; &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Converts a string slice to a byte slice. To convert the byte slice back\ninto a string slice, use the <a href=\"../str/fn.from_utf8.html\" title=\"fn std::str::from_utf8\"><code>from_utf8</code></a> function.</p>\n<h5 id=\"examples-49\"><a class=\"doc-anchor\" href=\"#examples-49\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>bytes = <span class=\"string\">\"bors\"</span>.as_bytes();\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"bors\"</span>, bytes);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+%22bors%22.as_bytes();%0A++++assert_eq!(b%22bors%22,+bytes);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_bytes_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#364\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.as_bytes_mut\" class=\"fn\">as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;mut [u8]\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Converts a mutable string slice to a mutable byte slice.</p>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">¬ß</a>Safety</h5>\n<p>The caller must ensure that the content of the slice is valid UTF-8\nbefore the borrow ends and the underlying <code>str</code> is used.</p>\n<p>Use of a <code>str</code> whose contents are not valid UTF-8 is undefined behavior.</p>\n<h5 id=\"examples-50\"><a class=\"doc-anchor\" href=\"#examples-50\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"Hello\"</span>);\n<span class=\"kw\">let </span>bytes = <span class=\"kw\">unsafe </span>{ s.as_bytes_mut() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"Hello\"</span>, bytes);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Hello%22);%0A++++let+bytes+=+unsafe+%7B+s.as_bytes_mut()+%7D;%0A++++%0A++++assert_eq!(b%22Hello%22,+bytes);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Mutability:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"üóª‚ààüåè\"</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>bytes = s.as_bytes_mut();\n\n    bytes[<span class=\"number\">0</span>] = <span class=\"number\">0xF0</span>;\n    bytes[<span class=\"number\">1</span>] = <span class=\"number\">0x9F</span>;\n    bytes[<span class=\"number\">2</span>] = <span class=\"number\">0x8D</span>;\n    bytes[<span class=\"number\">3</span>] = <span class=\"number\">0x94</span>;\n}\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üçî‚ààüåè\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++%0A++++unsafe+%7B%0A++++++++let+bytes+=+s.as_bytes_mut();%0A++++%0A++++++++bytes%5B0%5D+=+0xF0;%0A++++++++bytes%5B1%5D+=+0x9F;%0A++++++++bytes%5B2%5D+=+0x8D;%0A++++++++bytes%5B3%5D+=+0x94;%0A++++%7D%0A++++%0A++++assert_eq!(%22%F0%9F%8D%94%E2%88%88%F0%9F%8C%8F%22,+s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#394\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_ptr\" class=\"fn\">as_ptr</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*const </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a></h4></section></summary><div class=\"docblock\"><p>Converts a string slice to a raw pointer.</p>\n<p>As string slices are a slice of bytes, the raw pointer points to a\n<a href=\"../primitive.u8.html\" title=\"primitive u8\"><code>u8</code></a>. This pointer will be pointing to the first byte of the string\nslice.</p>\n<p>The caller must ensure that the returned pointer is never written to.\nIf you need to mutate the contents of the string slice, use <a href=\"../primitive.str.html#method.as_mut_ptr\" title=\"method str::as_mut_ptr\"><code>as_mut_ptr</code></a>.</p>\n<h5 id=\"examples-51\"><a class=\"doc-anchor\" href=\"#examples-51\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"Hello\"</span>;\n<span class=\"kw\">let </span>ptr = s.as_ptr();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Hello%22;%0A++++let+ptr+=+s.as_ptr();%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_mut_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0\">1.36.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#410\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_mut_ptr\" class=\"fn\">as_mut_ptr</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a></h4></section></summary><div class=\"docblock\"><p>Converts a mutable string slice to a raw pointer.</p>\n<p>As string slices are a slice of bytes, the raw pointer points to a\n<a href=\"../primitive.u8.html\" title=\"primitive u8\"><code>u8</code></a>. This pointer will be pointing to the first byte of the string\nslice.</p>\n<p>It is your responsibility to make sure that the string slice only gets\nmodified in a way that it remains valid UTF-8.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#435\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.get\" class=\"fn\">get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;&lt;I as <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt;::<a class=\"associatedtype\" href=\"../slice/trait.SliceIndex.html#associatedtype.Output\" title=\"type std::slice::SliceIndex::Output\">Output</a>&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a subslice of <code>str</code>.</p>\n<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns\n<a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> whenever equivalent indexing operation would panic.</p>\n<h5 id=\"examples-52\"><a class=\"doc-anchor\" href=\"#examples-52\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = String::from(<span class=\"string\">\"üóª‚ààüåè\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"üóª\"</span>), v.get(<span class=\"number\">0</span>..<span class=\"number\">4</span>));\n\n<span class=\"comment\">// indices not on UTF-8 sequence boundaries\n</span><span class=\"macro\">assert!</span>(v.get(<span class=\"number\">1</span>..).is_none());\n<span class=\"macro\">assert!</span>(v.get(..<span class=\"number\">8</span>).is_none());\n\n<span class=\"comment\">// out of bounds\n</span><span class=\"macro\">assert!</span>(v.get(..<span class=\"number\">42</span>).is_none());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++%0A++++assert_eq!(Some(%22%F0%9F%97%BB%22),+v.get(0..4));%0A++++%0A++++//+indices+not+on+UTF-8+sequence+boundaries%0A++++assert!(v.get(1..).is_none());%0A++++assert!(v.get(..8).is_none());%0A++++%0A++++//+out+of+bounds%0A++++assert!(v.get(..42).is_none());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#467\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.get_mut\" class=\"fn\">get_mut</a>&lt;I&gt;(\n    &amp;mut self,\n    i: I,\n) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;mut &lt;I as <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt;::<a class=\"associatedtype\" href=\"../slice/trait.SliceIndex.html#associatedtype.Output\" title=\"type std::slice::SliceIndex::Output\">Output</a>&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a mutable subslice of <code>str</code>.</p>\n<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns\n<a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> whenever equivalent indexing operation would panic.</p>\n<h5 id=\"examples-53\"><a class=\"doc-anchor\" href=\"#examples-53\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = String::from(<span class=\"string\">\"hello\"</span>);\n<span class=\"comment\">// correct length\n</span><span class=\"macro\">assert!</span>(v.get_mut(<span class=\"number\">0</span>..<span class=\"number\">5</span>).is_some());\n<span class=\"comment\">// out of bounds\n</span><span class=\"macro\">assert!</span>(v.get_mut(..<span class=\"number\">42</span>).is_none());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"he\"</span>), v.get_mut(<span class=\"number\">0</span>..<span class=\"number\">2</span>).map(|v| <span class=\"kw-2\">&amp;*</span>v));\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"hello\"</span>, v);\n{\n    <span class=\"kw\">let </span>s = v.get_mut(<span class=\"number\">0</span>..<span class=\"number\">2</span>);\n    <span class=\"kw\">let </span>s = s.map(|s| {\n        s.make_ascii_uppercase();\n        <span class=\"kw-2\">&amp;*</span>s\n    });\n    <span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"HE\"</span>), s);\n}\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"HEllo\"</span>, v);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::from(%22hello%22);%0A++++//+correct+length%0A++++assert!(v.get_mut(0..5).is_some());%0A++++//+out+of+bounds%0A++++assert!(v.get_mut(..42).is_none());%0A++++assert_eq!(Some(%22he%22),+v.get_mut(0..2).map(%7Cv%7C+%26*v));%0A++++%0A++++assert_eq!(%22hello%22,+v);%0A++++%7B%0A++++++++let+s+=+v.get_mut(0..2);%0A++++++++let+s+=+s.map(%7Cs%7C+%7B%0A++++++++++++s.make_ascii_uppercase();%0A++++++++++++%26*s%0A++++++++%7D);%0A++++++++assert_eq!(Some(%22HE%22),+s);%0A++++%7D%0A++++assert_eq!(%22HEllo%22,+v);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_unchecked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#499\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.get_unchecked\" class=\"fn\">get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt;::<a class=\"associatedtype\" href=\"../slice/trait.SliceIndex.html#associatedtype.Output\" title=\"type std::slice::SliceIndex::Output\">Output</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns an unchecked subslice of <code>str</code>.</p>\n<p>This is the unchecked alternative to indexing the <code>str</code>.</p>\n<h5 id=\"safety-4\"><a class=\"doc-anchor\" href=\"#safety-4\">¬ß</a>Safety</h5>\n<p>Callers of this function are responsible that these preconditions are\nsatisfied:</p>\n<ul>\n<li>The starting index must not exceed the ending index;</li>\n<li>Indexes must be within bounds of the original slice;</li>\n<li>Indexes must lie on UTF-8 sequence boundaries.</li>\n</ul>\n<p>Failing that, the returned string slice may reference invalid memory or\nviolate the invariants communicated by the <code>str</code> type.</p>\n<h5 id=\"examples-54\"><a class=\"doc-anchor\" href=\"#examples-54\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"string\">\"üóª‚ààüåè\"</span>;\n<span class=\"kw\">unsafe </span>{\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üóª\"</span>, v.get_unchecked(<span class=\"number\">0</span>..<span class=\"number\">4</span>));\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"‚àà\"</span>, v.get_unchecked(<span class=\"number\">4</span>..<span class=\"number\">7</span>));\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üåè\"</span>, v.get_unchecked(<span class=\"number\">7</span>..<span class=\"number\">11</span>));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22;%0A++++unsafe+%7B%0A++++++++assert_eq!(%22%F0%9F%97%BB%22,+v.get_unchecked(0..4));%0A++++++++assert_eq!(%22%E2%88%88%22,+v.get_unchecked(4..7));%0A++++++++assert_eq!(%22%F0%9F%8C%8F%22,+v.get_unchecked(7..11));%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_unchecked_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#534\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.get_unchecked_mut\" class=\"fn\">get_unchecked_mut</a>&lt;I&gt;(\n    &amp;mut self,\n    i: I,\n) -&gt; &amp;mut &lt;I as <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt;::<a class=\"associatedtype\" href=\"../slice/trait.SliceIndex.html#associatedtype.Output\" title=\"type std::slice::SliceIndex::Output\">Output</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a mutable, unchecked subslice of <code>str</code>.</p>\n<p>This is the unchecked alternative to indexing the <code>str</code>.</p>\n<h5 id=\"safety-5\"><a class=\"doc-anchor\" href=\"#safety-5\">¬ß</a>Safety</h5>\n<p>Callers of this function are responsible that these preconditions are\nsatisfied:</p>\n<ul>\n<li>The starting index must not exceed the ending index;</li>\n<li>Indexes must be within bounds of the original slice;</li>\n<li>Indexes must lie on UTF-8 sequence boundaries.</li>\n</ul>\n<p>Failing that, the returned string slice may reference invalid memory or\nviolate the invariants communicated by the <code>str</code> type.</p>\n<h5 id=\"examples-55\"><a class=\"doc-anchor\" href=\"#examples-55\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = String::from(<span class=\"string\">\"üóª‚ààüåè\"</span>);\n<span class=\"kw\">unsafe </span>{\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üóª\"</span>, v.get_unchecked_mut(<span class=\"number\">0</span>..<span class=\"number\">4</span>));\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"‚àà\"</span>, v.get_unchecked_mut(<span class=\"number\">4</span>..<span class=\"number\">7</span>));\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üåè\"</span>, v.get_unchecked_mut(<span class=\"number\">7</span>..<span class=\"number\">11</span>));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++unsafe+%7B%0A++++++++assert_eq!(%22%F0%9F%97%BB%22,+v.get_unchecked_mut(0..4));%0A++++++++assert_eq!(%22%E2%88%88%22,+v.get_unchecked_mut(4..7));%0A++++++++assert_eq!(%22%F0%9F%8C%8F%22,+v.get_unchecked_mut(7..11));%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.slice_unchecked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#585\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.slice_unchecked\" class=\"fn\">slice_unchecked</a>(&amp;self, begin: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, end: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">üëé</span><span>Deprecated since 1.29.0: use <code>get_unchecked(begin..end)</code> instead</span></div></span></summary><div class=\"docblock\"><p>Creates a string slice from another string slice, bypassing safety\nchecks.</p>\n<p>This is generally not recommended, use with caution! For a safe\nalternative see <a href=\"../primitive.str.html\" title=\"primitive str\"><code>str</code></a> and <a href=\"../ops/trait.Index.html\" title=\"trait std::ops::Index\"><code>Index</code></a>.</p>\n<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but\nexcluding <code>end</code>.</p>\n<p>To get a mutable string slice instead, see the\n<a href=\"../primitive.str.html#method.slice_mut_unchecked\" title=\"method str::slice_mut_unchecked\"><code>slice_mut_unchecked</code></a> method.</p>\n<h5 id=\"safety-6\"><a class=\"doc-anchor\" href=\"#safety-6\">¬ß</a>Safety</h5>\n<p>Callers of this function are responsible that three preconditions are\nsatisfied:</p>\n<ul>\n<li><code>begin</code> must not exceed <code>end</code>.</li>\n<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>\n<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>\n</ul>\n<h5 id=\"examples-56\"><a class=\"doc-anchor\" href=\"#examples-56\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"L√∂we ËÄÅËôé L√©opard\"</span>;\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"L√∂we ËÄÅËôé L√©opard\"</span>, s.slice_unchecked(<span class=\"number\">0</span>, <span class=\"number\">21</span>));\n}\n\n<span class=\"kw\">let </span>s = <span class=\"string\">\"Hello, world!\"</span>;\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"world\"</span>, s.slice_unchecked(<span class=\"number\">7</span>, <span class=\"number\">12</span>));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22,+s.slice_unchecked(0,+21));%0A++++%7D%0A++++%0A++++let+s+=+%22Hello,+world!%22;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(%22world%22,+s.slice_unchecked(7,+12));%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.slice_mut_unchecked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#618\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.slice_mut_unchecked\" class=\"fn\">slice_mut_unchecked</a>(\n    &amp;mut self,\n    begin: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>,\n    end: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>,\n) -&gt; &amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">üëé</span><span>Deprecated since 1.29.0: use <code>get_unchecked_mut(begin..end)</code> instead</span></div></span></summary><div class=\"docblock\"><p>Creates a string slice from another string slice, bypassing safety\nchecks.\nThis is generally not recommended, use with caution! For a safe\nalternative see <a href=\"../primitive.str.html\" title=\"primitive str\"><code>str</code></a> and <a href=\"../ops/trait.IndexMut.html\" title=\"trait std::ops::IndexMut\"><code>IndexMut</code></a>.</p>\n<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but\nexcluding <code>end</code>.</p>\n<p>To get an immutable string slice instead, see the\n<a href=\"../primitive.str.html#method.slice_unchecked\" title=\"method str::slice_unchecked\"><code>slice_unchecked</code></a> method.</p>\n<h5 id=\"safety-7\"><a class=\"doc-anchor\" href=\"#safety-7\">¬ß</a>Safety</h5>\n<p>Callers of this function are responsible that three preconditions are\nsatisfied:</p>\n<ul>\n<li><code>begin</code> must not exceed <code>end</code>.</li>\n<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>\n<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_at\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#657\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_at\" class=\"fn\">split_at</a>(&amp;self, mid: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; (&amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>, &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>)</h4></section></summary><div class=\"docblock\"><p>Divide one string slice into two at an index.</p>\n<p>The argument, <code>mid</code>, should be a byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point.</p>\n<p>The two slices returned go from the start of the string slice to <code>mid</code>,\nand from <code>mid</code> to the end of the string slice.</p>\n<p>To get mutable string slices instead, see the <a href=\"../primitive.str.html#method.split_at_mut\" title=\"method str::split_at_mut\"><code>split_at_mut</code></a>\nmethod.</p>\n<h5 id=\"panics-10\"><a class=\"doc-anchor\" href=\"#panics-10\">¬ß</a>Panics</h5>\n<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past\nthe end of the last code point of the string slice.  For a non-panicking\nalternative see <a href=\"../primitive.str.html#method.split_at_checked\" title=\"method str::split_at_checked\"><code>split_at_checked</code></a>.</p>\n<h5 id=\"examples-57\"><a class=\"doc-anchor\" href=\"#examples-57\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"Per Martin-L√∂f\"</span>;\n\n<span class=\"kw\">let </span>(first, last) = s.split_at(<span class=\"number\">3</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Per\"</span>, first);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\" Martin-L√∂f\"</span>, last);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Per+Martin-L%C3%B6f%22;%0A++++%0A++++let+(first,+last)+=+s.split_at(3);%0A++++%0A++++assert_eq!(%22Per%22,+first);%0A++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_at_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#697\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_at_mut\" class=\"fn\">split_at_mut</a>(&amp;mut self, mid: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; (&amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a>, &amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a>)</h4></section></summary><div class=\"docblock\"><p>Divide one mutable string slice into two at an index.</p>\n<p>The argument, <code>mid</code>, should be a byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point.</p>\n<p>The two slices returned go from the start of the string slice to <code>mid</code>,\nand from <code>mid</code> to the end of the string slice.</p>\n<p>To get immutable string slices instead, see the <a href=\"../primitive.str.html#method.split_at\" title=\"method str::split_at\"><code>split_at</code></a> method.</p>\n<h5 id=\"panics-11\"><a class=\"doc-anchor\" href=\"#panics-11\">¬ß</a>Panics</h5>\n<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past\nthe end of the last code point of the string slice.  For a non-panicking\nalternative see <a href=\"../primitive.str.html#method.split_at_mut_checked\" title=\"method str::split_at_mut_checked\"><code>split_at_mut_checked</code></a>.</p>\n<h5 id=\"examples-58\"><a class=\"doc-anchor\" href=\"#examples-58\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = <span class=\"string\">\"Per Martin-L√∂f\"</span>.to_string();\n{\n    <span class=\"kw\">let </span>(first, last) = s.split_at_mut(<span class=\"number\">3</span>);\n    first.make_ascii_uppercase();\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"PER\"</span>, first);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\" Martin-L√∂f\"</span>, last);\n}\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"PER Martin-L√∂f\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%22Per+Martin-L%C3%B6f%22.to_string();%0A++++%7B%0A++++++++let+(first,+last)+=+s.split_at_mut(3);%0A++++++++first.make_ascii_uppercase();%0A++++++++assert_eq!(%22PER%22,+first);%0A++++++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%7D%0A++++assert_eq!(%22PER+Martin-L%C3%B6f%22,+s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_at_checked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#736\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_at_checked\" class=\"fn\">split_at_checked</a>(&amp;self, mid: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;(&amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>, &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Divide one string slice into two at an index.</p>\n<p>The argument, <code>mid</code>, should be a valid byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point. The\nmethod returns <code>None</code> if that‚Äôs not the case.</p>\n<p>The two slices returned go from the start of the string slice to <code>mid</code>,\nand from <code>mid</code> to the end of the string slice.</p>\n<p>To get mutable string slices instead, see the <a href=\"../primitive.str.html#method.split_at_mut_checked\" title=\"method str::split_at_mut_checked\"><code>split_at_mut_checked</code></a>\nmethod.</p>\n<h5 id=\"examples-59\"><a class=\"doc-anchor\" href=\"#examples-59\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"Per Martin-L√∂f\"</span>;\n\n<span class=\"kw\">let </span>(first, last) = s.split_at_checked(<span class=\"number\">3</span>).unwrap();\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Per\"</span>, first);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\" Martin-L√∂f\"</span>, last);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, s.split_at_checked(<span class=\"number\">13</span>));  <span class=\"comment\">// Inside ‚Äú√∂‚Äù\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, s.split_at_checked(<span class=\"number\">16</span>));  <span class=\"comment\">// Beyond the string length</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Per+Martin-L%C3%B6f%22;%0A++++%0A++++let+(first,+last)+=+s.split_at_checked(3).unwrap();%0A++++assert_eq!(%22Per%22,+first);%0A++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%0A++++assert_eq!(None,+s.split_at_checked(13));++//+Inside+%E2%80%9C%C3%B6%E2%80%9D%0A++++assert_eq!(None,+s.split_at_checked(16));++//+Beyond+the+string+length%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_at_mut_checked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#776\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_at_mut_checked\" class=\"fn\">split_at_mut_checked</a>(\n    &amp;mut self,\n    mid: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;(&amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a>, &amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Divide one mutable string slice into two at an index.</p>\n<p>The argument, <code>mid</code>, should be a valid byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point. The\nmethod returns <code>None</code> if that‚Äôs not the case.</p>\n<p>The two slices returned go from the start of the string slice to <code>mid</code>,\nand from <code>mid</code> to the end of the string slice.</p>\n<p>To get immutable string slices instead, see the <a href=\"../primitive.str.html#method.split_at_checked\" title=\"method str::split_at_checked\"><code>split_at_checked</code></a> method.</p>\n<h5 id=\"examples-60\"><a class=\"doc-anchor\" href=\"#examples-60\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = <span class=\"string\">\"Per Martin-L√∂f\"</span>.to_string();\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((first, last)) = s.split_at_mut_checked(<span class=\"number\">3</span>) {\n    first.make_ascii_uppercase();\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"PER\"</span>, first);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\" Martin-L√∂f\"</span>, last);\n}\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"PER Martin-L√∂f\"</span>, s);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, s.split_at_mut_checked(<span class=\"number\">13</span>));  <span class=\"comment\">// Inside ‚Äú√∂‚Äù\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, s.split_at_mut_checked(<span class=\"number\">16</span>));  <span class=\"comment\">// Beyond the string length</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%22Per+Martin-L%C3%B6f%22.to_string();%0A++++if+let+Some((first,+last))+=+s.split_at_mut_checked(3)+%7B%0A++++++++first.make_ascii_uppercase();%0A++++++++assert_eq!(%22PER%22,+first);%0A++++++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%7D%0A++++assert_eq!(%22PER+Martin-L%C3%B6f%22,+s);%0A++++%0A++++assert_eq!(None,+s.split_at_mut_checked(13));++//+Inside+%E2%80%9C%C3%B6%E2%80%9D%0A++++assert_eq!(None,+s.split_at_mut_checked(16));++//+Beyond+the+string+length%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.chars\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#853\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.chars\" class=\"fn\">chars</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.Chars.html\" title=\"struct std::str::Chars\">Chars</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Chars<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over the <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s of a string slice.</p>\n<p>As a string slice consists of valid UTF-8, we can iterate through a\nstring slice by <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>. This method returns such an iterator.</p>\n<p>It‚Äôs important to remember that <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> represents a Unicode Scalar\nValue, and might not match your idea of what a ‚Äòcharacter‚Äô is. Iteration\nover grapheme clusters may be what you actually want. This functionality\nis not provided by Rust‚Äôs standard library, check crates.io instead.</p>\n<h5 id=\"examples-61\"><a class=\"doc-anchor\" href=\"#examples-61\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>word = <span class=\"string\">\"goodbye\"</span>;\n\n<span class=\"kw\">let </span>count = word.chars().count();\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">7</span>, count);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>chars = word.chars();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'g'</span>), chars.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'o'</span>), chars.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'o'</span>), chars.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'d'</span>), chars.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'b'</span>), chars.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'y'</span>), chars.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'e'</span>), chars.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, chars.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+word+=+%22goodbye%22;%0A++++%0A++++let+count+=+word.chars().count();%0A++++assert_eq!(7,+count);%0A++++%0A++++let+mut+chars+=+word.chars();%0A++++%0A++++assert_eq!(Some('g'),+chars.next());%0A++++assert_eq!(Some('o'),+chars.next());%0A++++assert_eq!(Some('o'),+chars.next());%0A++++assert_eq!(Some('d'),+chars.next());%0A++++assert_eq!(Some('b'),+chars.next());%0A++++assert_eq!(Some('y'),+chars.next());%0A++++assert_eq!(Some('e'),+chars.next());%0A++++%0A++++assert_eq!(None,+chars.next());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Remember, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s might not match your intuition about characters:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>y = <span class=\"string\">\"yÃÜ\"</span>;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>chars = y.chars();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'y'</span>), chars.next()); <span class=\"comment\">// not 'yÃÜ'\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'\\u{0306}'</span>), chars.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, chars.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+y+=+%22y%CC%86%22;%0A++++%0A++++let+mut+chars+=+y.chars();%0A++++%0A++++assert_eq!(Some('y'),+chars.next());+//+not+'y%CC%86'%0A++++assert_eq!(Some('%5Cu%7B0306%7D'),+chars.next());%0A++++%0A++++assert_eq!(None,+chars.next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.char_indices\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#910\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.char_indices\" class=\"fn\">char_indices</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.CharIndices.html\" title=\"struct std::str::CharIndices\">CharIndices</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"CharIndices<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over the <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s of a string slice, and their\npositions.</p>\n<p>As a string slice consists of valid UTF-8, we can iterate through a\nstring slice by <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>. This method returns an iterator of both\nthese <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, as well as their byte positions.</p>\n<p>The iterator yields tuples. The position is first, the <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> is\nsecond.</p>\n<h5 id=\"examples-62\"><a class=\"doc-anchor\" href=\"#examples-62\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>word = <span class=\"string\">\"goodbye\"</span>;\n\n<span class=\"kw\">let </span>count = word.char_indices().count();\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">7</span>, count);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>char_indices = word.char_indices();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">0</span>, <span class=\"string\">'g'</span>)), char_indices.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">1</span>, <span class=\"string\">'o'</span>)), char_indices.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">2</span>, <span class=\"string\">'o'</span>)), char_indices.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">3</span>, <span class=\"string\">'d'</span>)), char_indices.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">4</span>, <span class=\"string\">'b'</span>)), char_indices.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">5</span>, <span class=\"string\">'y'</span>)), char_indices.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">6</span>, <span class=\"string\">'e'</span>)), char_indices.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, char_indices.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+word+=+%22goodbye%22;%0A++++%0A++++let+count+=+word.char_indices().count();%0A++++assert_eq!(7,+count);%0A++++%0A++++let+mut+char_indices+=+word.char_indices();%0A++++%0A++++assert_eq!(Some((0,+'g')),+char_indices.next());%0A++++assert_eq!(Some((1,+'o')),+char_indices.next());%0A++++assert_eq!(Some((2,+'o')),+char_indices.next());%0A++++assert_eq!(Some((3,+'d')),+char_indices.next());%0A++++assert_eq!(Some((4,+'b')),+char_indices.next());%0A++++assert_eq!(Some((5,+'y')),+char_indices.next());%0A++++assert_eq!(Some((6,+'e')),+char_indices.next());%0A++++%0A++++assert_eq!(None,+char_indices.next());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Remember, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s might not match your intuition about characters:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>yes = <span class=\"string\">\"yÃÜes\"</span>;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>char_indices = yes.char_indices();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">0</span>, <span class=\"string\">'y'</span>)), char_indices.next()); <span class=\"comment\">// not (0, 'yÃÜ')\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">1</span>, <span class=\"string\">'\\u{0306}'</span>)), char_indices.next());\n\n<span class=\"comment\">// note the 3 here - the previous character took up two bytes\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">3</span>, <span class=\"string\">'e'</span>)), char_indices.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"number\">4</span>, <span class=\"string\">'s'</span>)), char_indices.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, char_indices.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+yes+=+%22y%CC%86es%22;%0A++++%0A++++let+mut+char_indices+=+yes.char_indices();%0A++++%0A++++assert_eq!(Some((0,+'y')),+char_indices.next());+//+not+(0,+'y%CC%86')%0A++++assert_eq!(Some((1,+'%5Cu%7B0306%7D')),+char_indices.next());%0A++++%0A++++//+note+the+3+here+-+the+previous+character+took+up+two+bytes%0A++++assert_eq!(Some((3,+'e')),+char_indices.next());%0A++++assert_eq!(Some((4,+'s')),+char_indices.next());%0A++++%0A++++assert_eq!(None,+char_indices.next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bytes\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#933\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.bytes\" class=\"fn\">bytes</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.Bytes.html\" title=\"struct std::str::Bytes\">Bytes</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Bytes<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>An iterator over the bytes of a string slice.</p>\n<p>As a string slice consists of a sequence of bytes, we can iterate\nthrough a string slice by byte. This method returns such an iterator.</p>\n<h5 id=\"examples-63\"><a class=\"doc-anchor\" href=\"#examples-63\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>bytes = <span class=\"string\">\"bors\"</span>.bytes();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">b'b'</span>), bytes.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">b'o'</span>), bytes.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">b'r'</span>), bytes.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">b's'</span>), bytes.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, bytes.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+bytes+=+%22bors%22.bytes();%0A++++%0A++++assert_eq!(Some(b'b'),+bytes.next());%0A++++assert_eq!(Some(b'o'),+bytes.next());%0A++++assert_eq!(Some(b'r'),+bytes.next());%0A++++assert_eq!(Some(b's'),+bytes.next());%0A++++%0A++++assert_eq!(None,+bytes.next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_whitespace\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.1.0\">1.1.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#985\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_whitespace\" class=\"fn\">split_whitespace</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.SplitWhitespace.html\" title=\"struct std::str::SplitWhitespace\">SplitWhitespace</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"SplitWhitespace<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Splits a string slice by whitespace.</p>\n<p>The iterator returned will return string slices that are sub-slices of\nthe original string slice, separated by any amount of whitespace.</p>\n<p>‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived\nCore Property <code>White_Space</code>. If you only want to split on ASCII whitespace\ninstead, use <a href=\"../primitive.str.html#method.split_ascii_whitespace\" title=\"method str::split_ascii_whitespace\"><code>split_ascii_whitespace</code></a>.</p>\n<h5 id=\"examples-64\"><a class=\"doc-anchor\" href=\"#examples-64\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = <span class=\"string\">\"A few words\"</span>.split_whitespace();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"A\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"few\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"words\"</span>), iter.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, iter.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22A+few+words%22.split_whitespace();%0A++++%0A++++assert_eq!(Some(%22A%22),+iter.next());%0A++++assert_eq!(Some(%22few%22),+iter.next());%0A++++assert_eq!(Some(%22words%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>All kinds of whitespace are considered:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = <span class=\"string\">\" Mary   had\\ta\\u{2009}little  \\n\\t lamb\"</span>.split_whitespace();\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"Mary\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"had\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"a\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"little\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"lamb\"</span>), iter.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, iter.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22+Mary+++had%5Cta%5Cu%7B2009%7Dlittle++%5Cn%5Ct+lamb%22.split_whitespace();%0A++++assert_eq!(Some(%22Mary%22),+iter.next());%0A++++assert_eq!(Some(%22had%22),+iter.next());%0A++++assert_eq!(Some(%22a%22),+iter.next());%0A++++assert_eq!(Some(%22little%22),+iter.next());%0A++++assert_eq!(Some(%22lamb%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If the string is empty or all whitespace, the iterator yields no string slices:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"\"</span>.split_whitespace().next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"   \"</span>.split_whitespace().next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%22.split_whitespace().next(),+None);%0A++++assert_eq!(%22+++%22.split_whitespace().next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_ascii_whitespace\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1034\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_ascii_whitespace\" class=\"fn\">split_ascii_whitespace</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.SplitAsciiWhitespace.html\" title=\"struct std::str::SplitAsciiWhitespace\">SplitAsciiWhitespace</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"SplitAsciiWhitespace<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Splits a string slice by ASCII whitespace.</p>\n<p>The iterator returned will return string slices that are sub-slices of\nthe original string slice, separated by any amount of ASCII whitespace.</p>\n<p>To split by Unicode <code>Whitespace</code> instead, use <a href=\"../primitive.str.html#method.split_whitespace\" title=\"method str::split_whitespace\"><code>split_whitespace</code></a>.</p>\n<h5 id=\"examples-65\"><a class=\"doc-anchor\" href=\"#examples-65\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = <span class=\"string\">\"A few words\"</span>.split_ascii_whitespace();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"A\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"few\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"words\"</span>), iter.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, iter.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22A+few+words%22.split_ascii_whitespace();%0A++++%0A++++assert_eq!(Some(%22A%22),+iter.next());%0A++++assert_eq!(Some(%22few%22),+iter.next());%0A++++assert_eq!(Some(%22words%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>All kinds of ASCII whitespace are considered:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = <span class=\"string\">\" Mary   had\\ta little  \\n\\t lamb\"</span>.split_ascii_whitespace();\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"Mary\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"had\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"a\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"little\"</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"lamb\"</span>), iter.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, iter.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22+Mary+++had%5Cta+little++%5Cn%5Ct+lamb%22.split_ascii_whitespace();%0A++++assert_eq!(Some(%22Mary%22),+iter.next());%0A++++assert_eq!(Some(%22had%22),+iter.next());%0A++++assert_eq!(Some(%22a%22),+iter.next());%0A++++assert_eq!(Some(%22little%22),+iter.next());%0A++++assert_eq!(Some(%22lamb%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If the string is empty or all ASCII whitespace, the iterator yields no string slices:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"\"</span>.split_ascii_whitespace().next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"   \"</span>.split_ascii_whitespace().next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%22.split_ascii_whitespace().next(),+None);%0A++++assert_eq!(%22+++%22.split_ascii_whitespace().next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lines\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1092\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.lines\" class=\"fn\">lines</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.Lines.html\" title=\"struct std::str::Lines\">Lines</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Lines<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>An iterator over the lines of a string, as string slices.</p>\n<p>Lines are split at line endings that are either newlines (<code>\\n</code>) or\nsequences of a carriage return followed by a line feed (<code>\\r\\n</code>).</p>\n<p>Line terminators are not included in the lines returned by the iterator.</p>\n<p>Note that any carriage return (<code>\\r</code>) not immediately followed by a\nline feed (<code>\\n</code>) does not split a line. These carriage returns are\nthereby included in the produced lines.</p>\n<p>The final line ending is optional. A string that ends with a final line\nending will return the same lines as an otherwise identical string\nwithout a final line ending.</p>\n<h5 id=\"examples-66\"><a class=\"doc-anchor\" href=\"#examples-66\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>text = <span class=\"string\">\"foo\\r\\nbar\\n\\nbaz\\r\"</span>;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>lines = text.lines();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"foo\"</span>), lines.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"bar\"</span>), lines.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"\"</span>), lines.next());\n<span class=\"comment\">// Trailing carriage return is included in the last line\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"baz\\r\"</span>), lines.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, lines.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22foo%5Cr%5Cnbar%5Cn%5Cnbaz%5Cr%22;%0A++++let+mut+lines+=+text.lines();%0A++++%0A++++assert_eq!(Some(%22foo%22),+lines.next());%0A++++assert_eq!(Some(%22bar%22),+lines.next());%0A++++assert_eq!(Some(%22%22),+lines.next());%0A++++//+Trailing+carriage+return+is+included+in+the+last+line%0A++++assert_eq!(Some(%22baz%5Cr%22),+lines.next());%0A++++%0A++++assert_eq!(None,+lines.next());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The final line does not require any ending:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>text = <span class=\"string\">\"foo\\nbar\\n\\r\\nbaz\"</span>;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>lines = text.lines();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"foo\"</span>), lines.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"bar\"</span>), lines.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"\"</span>), lines.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"baz\"</span>), lines.next());\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, lines.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22foo%5Cnbar%5Cn%5Cr%5Cnbaz%22;%0A++++let+mut+lines+=+text.lines();%0A++++%0A++++assert_eq!(Some(%22foo%22),+lines.next());%0A++++assert_eq!(Some(%22bar%22),+lines.next());%0A++++assert_eq!(Some(%22%22),+lines.next());%0A++++assert_eq!(Some(%22baz%22),+lines.next());%0A++++%0A++++assert_eq!(None,+lines.next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lines_any\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1105\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.lines_any\" class=\"fn\">lines_any</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.LinesAny.html\" title=\"struct std::str::LinesAny\">LinesAny</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"LinesAny<'_>\">‚ìò</a></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">üëé</span><span>Deprecated since 1.4.0: use lines() instead now</span></div></span></summary><div class=\"docblock\"><p>An iterator over the lines of a string.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.encode_utf16\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.8.0\">1.8.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1124\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.encode_utf16\" class=\"fn\">encode_utf16</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.EncodeUtf16.html\" title=\"struct std::str::EncodeUtf16\">EncodeUtf16</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"EncodeUtf16<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>\n<h5 id=\"examples-67\"><a class=\"doc-anchor\" href=\"#examples-67\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>text = <span class=\"string\">\"Za≈º√≥≈Çƒá gƒô≈õlƒÖ ja≈∫≈Ñ\"</span>;\n\n<span class=\"kw\">let </span>utf8_len = text.len();\n<span class=\"kw\">let </span>utf16_len = text.encode_utf16().count();\n\n<span class=\"macro\">assert!</span>(utf16_len &lt;= utf8_len);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22Za%C5%BC%C3%B3%C5%82%C4%87+g%C4%99%C5%9Bl%C4%85+ja%C5%BA%C5%84%22;%0A++++%0A++++let+utf8_len+=+text.len();%0A++++let+utf16_len+=+text.encode_utf16().count();%0A++++%0A++++assert!(utf16_len+%3C=+utf8_len);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.contains\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1149\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.contains\" class=\"fn\">contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the given pattern matches a sub-slice of\nthis string slice.</p>\n<p>Returns <code>false</code> if it does not.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"examples-68\"><a class=\"doc-anchor\" href=\"#examples-68\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>bananas = <span class=\"string\">\"bananas\"</span>;\n\n<span class=\"macro\">assert!</span>(bananas.contains(<span class=\"string\">\"nana\"</span>));\n<span class=\"macro\">assert!</span>(!bananas.contains(<span class=\"string\">\"apples\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.contains(%22nana%22));%0A++++assert!(!bananas.contains(%22apples%22));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.starts_with\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1186\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.starts_with\" class=\"fn\">starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the given pattern matches a prefix of this\nstring slice.</p>\n<p>Returns <code>false</code> if it does not.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, in which case this function will return true if\nthe <code>&amp;str</code> is a prefix of this string slice.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can also be a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.\nThese will only be checked against the first character of this string slice.\nLook at the second example below regarding behavior for slices of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s.</p>\n<h5 id=\"examples-69\"><a class=\"doc-anchor\" href=\"#examples-69\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>bananas = <span class=\"string\">\"bananas\"</span>;\n\n<span class=\"macro\">assert!</span>(bananas.starts_with(<span class=\"string\">\"bana\"</span>));\n<span class=\"macro\">assert!</span>(!bananas.starts_with(<span class=\"string\">\"nana\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.starts_with(%22bana%22));%0A++++assert!(!bananas.starts_with(%22nana%22));%0A%7D&amp;edition=2021\">Run</a></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>bananas = <span class=\"string\">\"bananas\"</span>;\n\n<span class=\"comment\">// Note that both of these assert successfully.\n</span><span class=\"macro\">assert!</span>(bananas.starts_with(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">'b'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'n'</span>, <span class=\"string\">'a'</span>]));\n<span class=\"macro\">assert!</span>(bananas.starts_with(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++//+Note+that+both+of+these+assert+successfully.%0A++++assert!(bananas.starts_with(%26%5B'b',+'a',+'n',+'a'%5D));%0A++++assert!(bananas.starts_with(%26%5B'a',+'b',+'c',+'d'%5D));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ends_with\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1210-1212\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.ends_with\" class=\"fn\">ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the given pattern matches a suffix of this\nstring slice.</p>\n<p>Returns <code>false</code> if it does not.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"examples-70\"><a class=\"doc-anchor\" href=\"#examples-70\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>bananas = <span class=\"string\">\"bananas\"</span>;\n\n<span class=\"macro\">assert!</span>(bananas.ends_with(<span class=\"string\">\"anas\"</span>));\n<span class=\"macro\">assert!</span>(!bananas.ends_with(<span class=\"string\">\"nana\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.ends_with(%22anas%22));%0A++++assert!(!bananas.ends_with(%22nana%22));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.find\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1261\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.find\" class=\"fn\">find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns the byte index of the first character of this string slice that\nmatches the pattern.</p>\n<p>Returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> if the pattern doesn‚Äôt match.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"examples-71\"><a class=\"doc-anchor\" href=\"#examples-71\">¬ß</a>Examples</h5>\n<p>Simple patterns:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"L√∂we ËÄÅËôé L√©opard Gepardi\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(s.find(<span class=\"string\">'L'</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">0</span>));\n<span class=\"macro\">assert_eq!</span>(s.find(<span class=\"string\">'√©'</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">14</span>));\n<span class=\"macro\">assert_eq!</span>(s.find(<span class=\"string\">\"pard\"</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">17</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard+Gepardi%22;%0A++++%0A++++assert_eq!(s.find('L'),+Some(0));%0A++++assert_eq!(s.find('%C3%A9'),+Some(14));%0A++++assert_eq!(s.find(%22pard%22),+Some(17));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>More complex patterns using point-free style and closures:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"L√∂we ËÄÅËôé L√©opard\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(s.find(char::is_whitespace), <span class=\"prelude-val\">Some</span>(<span class=\"number\">5</span>));\n<span class=\"macro\">assert_eq!</span>(s.find(char::is_lowercase), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(s.find(|c: char| (c &lt; <span class=\"string\">'o'</span>) &amp;&amp; (c &gt; <span class=\"string\">'a'</span>)), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++assert_eq!(s.find(char::is_whitespace),+Some(5));%0A++++assert_eq!(s.find(char::is_lowercase),+Some(1));%0A++++assert_eq!(s.find(%7Cc:+char%7C+c.is_whitespace()+%7C%7C+c.is_lowercase()),+Some(1));%0A++++assert_eq!(s.find(%7Cc:+char%7C+(c+%3C+'o')+%26%26+(c+%3E+'a')),+Some(4));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Not finding the pattern:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"L√∂we ËÄÅËôé L√©opard\"</span>;\n<span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>];\n\n<span class=\"macro\">assert_eq!</span>(s.find(x), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++%0A++++assert_eq!(s.find(x),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rfind\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1307-1309\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.rfind\" class=\"fn\">rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns the byte index for the first character of the last match of the pattern in\nthis string slice.</p>\n<p>Returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> if the pattern doesn‚Äôt match.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"examples-72\"><a class=\"doc-anchor\" href=\"#examples-72\">¬ß</a>Examples</h5>\n<p>Simple patterns:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"L√∂we ËÄÅËôé L√©opard Gepardi\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(s.rfind(<span class=\"string\">'L'</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">13</span>));\n<span class=\"macro\">assert_eq!</span>(s.rfind(<span class=\"string\">'√©'</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">14</span>));\n<span class=\"macro\">assert_eq!</span>(s.rfind(<span class=\"string\">\"pard\"</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">24</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard+Gepardi%22;%0A++++%0A++++assert_eq!(s.rfind('L'),+Some(13));%0A++++assert_eq!(s.rfind('%C3%A9'),+Some(14));%0A++++assert_eq!(s.rfind(%22pard%22),+Some(24));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>More complex patterns with closures:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"L√∂we ËÄÅËôé L√©opard\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(s.rfind(char::is_whitespace), <span class=\"prelude-val\">Some</span>(<span class=\"number\">12</span>));\n<span class=\"macro\">assert_eq!</span>(s.rfind(char::is_lowercase), <span class=\"prelude-val\">Some</span>(<span class=\"number\">20</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++assert_eq!(s.rfind(char::is_whitespace),+Some(12));%0A++++assert_eq!(s.rfind(char::is_lowercase),+Some(20));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Not finding the pattern:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"L√∂we ËÄÅËôé L√©opard\"</span>;\n<span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>];\n\n<span class=\"macro\">assert_eq!</span>(s.rfind(x), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++%0A++++assert_eq!(s.rfind(x),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1429\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split\" class=\"fn\">split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.Split.html\" title=\"struct std::str::Split\">Split</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Split<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over substrings of this string slice, separated by\ncharacters matched by a pattern.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"iterator-behavior\"><a class=\"doc-anchor\" href=\"#iterator-behavior\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator will be a <a href=\"../iter/trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\"><code>DoubleEndedIterator</code></a> if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, but not for <code>&amp;str</code>.</p>\n<p>If the pattern allows a reverse search but its results might differ\nfrom a forward search, the <a href=\"../primitive.str.html#method.rsplit\" title=\"method str::rsplit\"><code>rsplit</code></a> method can be used.</p>\n<h5 id=\"examples-73\"><a class=\"doc-anchor\" href=\"#examples-73\">¬ß</a>Examples</h5>\n<p>Simple patterns:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"Mary had a little lamb\"</span>.split(<span class=\"string\">' '</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"Mary\"</span>, <span class=\"string\">\"had\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"little\"</span>, <span class=\"string\">\"lamb\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"\"</span>.split(<span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"lionXXtigerXleopard\"</span>.split(<span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"lion\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"tiger\"</span>, <span class=\"string\">\"leopard\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"lion::tiger::leopard\"</span>.split(<span class=\"string\">\"::\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"lion\"</span>, <span class=\"string\">\"tiger\"</span>, <span class=\"string\">\"leopard\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"abc1def2ghi\"</span>.split(char::is_numeric).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"abc\"</span>, <span class=\"string\">\"def\"</span>, <span class=\"string\">\"ghi\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"lionXtigerXleopard\"</span>.split(char::is_uppercase).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"lion\"</span>, <span class=\"string\">\"tiger\"</span>, <span class=\"string\">\"leopard\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.split('+').collect();%0A++++assert_eq!(v,+%5B%22Mary%22,+%22had%22,+%22a%22,+%22little%22,+%22lamb%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.split('X').collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.split('X').collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22%22,+%22tiger%22,+%22leopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.split(%22::%22).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22tiger%22,+%22leopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1def2ghi%22.split(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22def%22,+%22ghi%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXtigerXleopard%22.split(char::is_uppercase).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22tiger%22,+%22leopard%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"2020-11-03 23:59\"</span>.split(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">'-'</span>, <span class=\"string\">' '</span>, <span class=\"string\">':'</span>, <span class=\"string\">'@'</span>][..]).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"2020\"</span>, <span class=\"string\">\"11\"</span>, <span class=\"string\">\"03\"</span>, <span class=\"string\">\"23\"</span>, <span class=\"string\">\"59\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%222020-11-03+23:59%22.split(%26%5B'-',+'+',+':',+'%40'%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%222020%22,+%2211%22,+%2203%22,+%2223%22,+%2259%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A more complex pattern, using a closure:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"abc1defXghi\"</span>.split(|c| c == <span class=\"string\">'1' </span>|| c == <span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"abc\"</span>, <span class=\"string\">\"def\"</span>, <span class=\"string\">\"ghi\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.split(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22def%22,+%22ghi%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If a string contains multiple contiguous separators, you will end up\nwith empty strings in the output:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"string\">\"||||a||b|c\"</span>.to_string();\n<span class=\"kw\">let </span>d: Vec&lt;<span class=\"kw\">_</span>&gt; = x.split(<span class=\"string\">'|'</span>).collect();\n\n<span class=\"macro\">assert_eq!</span>(d, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22%7C%7C%7C%7Ca%7C%7Cb%7Cc%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split('%7C').collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22%22,+%22%22,+%22%22,+%22%22,+%22a%22,+%22%22,+%22b%22,+%22c%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Contiguous separators are separated by the empty string.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"string\">\"(///)\"</span>.to_string();\n<span class=\"kw\">let </span>d: Vec&lt;<span class=\"kw\">_</span>&gt; = x.split(<span class=\"string\">'/'</span>).collect();\n\n<span class=\"macro\">assert_eq!</span>(d, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">\"(\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\")\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22(///)%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split('/').collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22(%22,+%22%22,+%22%22,+%22)%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Separators at the start or end of a string are neighbored\nby empty strings.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>d: Vec&lt;<span class=\"kw\">_</span>&gt; = <span class=\"string\">\"010\"</span>.split(<span class=\"string\">\"0\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(d, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">\"\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\"\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+d:+Vec%3C_%3E+=+%22010%22.split(%220%22).collect();%0A++++assert_eq!(d,+%26%5B%22%22,+%221%22,+%22%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>When the empty string is used as a separator, it separates\nevery character in the string, along with the beginning\nand end of the string.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f: Vec&lt;<span class=\"kw\">_</span>&gt; = <span class=\"string\">\"rust\"</span>.split(<span class=\"string\">\"\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(f, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">\"\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"string\">\"u\"</span>, <span class=\"string\">\"s\"</span>, <span class=\"string\">\"t\"</span>, <span class=\"string\">\"\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f:+Vec%3C_%3E+=+%22rust%22.split(%22%22).collect();%0A++++assert_eq!(f,+%26%5B%22%22,+%22r%22,+%22u%22,+%22s%22,+%22t%22,+%22%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Contiguous separators can lead to possibly surprising behavior\nwhen whitespace is used as the separator. This code is correct:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"string\">\"    a  b c\"</span>.to_string();\n<span class=\"kw\">let </span>d: Vec&lt;<span class=\"kw\">_</span>&gt; = x.split(<span class=\"string\">' '</span>).collect();\n\n<span class=\"macro\">assert_eq!</span>(d, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22++++a++b+c%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split('+').collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22%22,+%22%22,+%22%22,+%22%22,+%22a%22,+%22%22,+%22b%22,+%22c%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>It does <em>not</em> give you:</p>\n\n<div class=\"example-wrap ignore\"><a href=\"#\" class=\"tooltip\" title=\"This example is not tested\">‚ìò</a><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(d, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(d,+%26%5B%22a%22,+%22b%22,+%22c%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Use <a href=\"../primitive.str.html#method.split_whitespace\" title=\"method str::split_whitespace\"><code>split_whitespace</code></a> for this behavior.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_inclusive\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1469\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_inclusive\" class=\"fn\">split_inclusive</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.SplitInclusive.html\" title=\"struct std::str::SplitInclusive\">SplitInclusive</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"SplitInclusive<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over substrings of this string slice, separated by\ncharacters matched by a pattern. Differs from the iterator produced by\n<code>split</code> in that <code>split_inclusive</code> leaves the matched part as the\nterminator of the substring.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"examples-74\"><a class=\"doc-anchor\" href=\"#examples-74\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\"\n    </span>.split_inclusive(<span class=\"string\">'\\n'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"Mary had a little lamb\\n\"</span>, <span class=\"string\">\"little lamb\\n\"</span>, <span class=\"string\">\"little lamb.\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%5Cnlittle+lamb%5Cnlittle+lamb.%22%0A++++++++.split_inclusive('%5Cn').collect();%0A++++assert_eq!(v,+%5B%22Mary+had+a+little+lamb%5Cn%22,+%22little+lamb%5Cn%22,+%22little+lamb.%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If the last element of the string is matched,\nthat element will be considered the terminator of the preceding substring.\nThat substring will be the last item returned by the iterator.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\\n\"\n    </span>.split_inclusive(<span class=\"string\">'\\n'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"Mary had a little lamb\\n\"</span>, <span class=\"string\">\"little lamb\\n\"</span>, <span class=\"string\">\"little lamb.\\n\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%5Cnlittle+lamb%5Cnlittle+lamb.%5Cn%22%0A++++++++.split_inclusive('%5Cn').collect();%0A++++assert_eq!(v,+%5B%22Mary+had+a+little+lamb%5Cn%22,+%22little+lamb%5Cn%22,+%22little+lamb.%5Cn%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rsplit\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1524-1526\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.rsplit\" class=\"fn\">rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.RSplit.html\" title=\"struct std::str::RSplit\">RSplit</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"RSplit<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over substrings of the given string slice, separated by\ncharacters matched by a pattern and yielded in reverse order.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"iterator-behavior-1\"><a class=\"doc-anchor\" href=\"#iterator-behavior-1\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator requires that the pattern supports a reverse\nsearch, and it will be a <a href=\"../iter/trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\"><code>DoubleEndedIterator</code></a> if a forward/reverse\nsearch yields the same elements.</p>\n<p>For iterating from the front, the <a href=\"../primitive.str.html#method.split\" title=\"method str::split\"><code>split</code></a> method can be used.</p>\n<h5 id=\"examples-75\"><a class=\"doc-anchor\" href=\"#examples-75\">¬ß</a>Examples</h5>\n<p>Simple patterns:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"Mary had a little lamb\"</span>.rsplit(<span class=\"string\">' '</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"lamb\"</span>, <span class=\"string\">\"little\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"had\"</span>, <span class=\"string\">\"Mary\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"\"</span>.rsplit(<span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"lionXXtigerXleopard\"</span>.rsplit(<span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"leopard\"</span>, <span class=\"string\">\"tiger\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"lion\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"lion::tiger::leopard\"</span>.rsplit(<span class=\"string\">\"::\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"leopard\"</span>, <span class=\"string\">\"tiger\"</span>, <span class=\"string\">\"lion\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.rsplit('+').collect();%0A++++assert_eq!(v,+%5B%22lamb%22,+%22little%22,+%22a%22,+%22had%22,+%22Mary%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.rsplit('X').collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.rsplit('X').collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22%22,+%22lion%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.rsplit(%22::%22).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22lion%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A more complex pattern, using a closure:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"abc1defXghi\"</span>.rsplit(|c| c == <span class=\"string\">'1' </span>|| c == <span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"ghi\"</span>, <span class=\"string\">\"def\"</span>, <span class=\"string\">\"abc\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.rsplit(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22ghi%22,+%22def%22,+%22abc%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_terminator\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1573\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_terminator\" class=\"fn\">split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.SplitTerminator.html\" title=\"struct std::str::SplitTerminator\">SplitTerminator</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"SplitTerminator<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over substrings of the given string slice, separated by\ncharacters matched by a pattern.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<p>Equivalent to <a href=\"../primitive.str.html#method.split\" title=\"method str::split\"><code>split</code></a>, except that the trailing substring\nis skipped if empty.</p>\n<p>This method can be used for string data that is <em>terminated</em>,\nrather than <em>separated</em> by a pattern.</p>\n<h5 id=\"iterator-behavior-2\"><a class=\"doc-anchor\" href=\"#iterator-behavior-2\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator will be a <a href=\"../iter/trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\"><code>DoubleEndedIterator</code></a> if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, but not for <code>&amp;str</code>.</p>\n<p>If the pattern allows a reverse search but its results might differ\nfrom a forward search, the <a href=\"../primitive.str.html#method.rsplit_terminator\" title=\"method str::rsplit_terminator\"><code>rsplit_terminator</code></a> method can be used.</p>\n<h5 id=\"examples-76\"><a class=\"doc-anchor\" href=\"#examples-76\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"A.B.\"</span>.split_terminator(<span class=\"string\">'.'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"A..B..\"</span>.split_terminator(<span class=\"string\">\".\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"A\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"A.B:C.D\"</span>.split_terminator(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">'.'</span>, <span class=\"string\">':'</span>][..]).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B.%22.split_terminator('.').collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22B%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A..B..%22.split_terminator(%22.%22).collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22%22,+%22B%22,+%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B:C.D%22.split_terminator(%26%5B'.',+':'%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22B%22,+%22C%22,+%22D%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rsplit_terminator\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1619-1621\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.rsplit_terminator\" class=\"fn\">rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.RSplitTerminator.html\" title=\"struct std::str::RSplitTerminator\">RSplitTerminator</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"RSplitTerminator<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over substrings of <code>self</code>, separated by characters\nmatched by a pattern and yielded in reverse order.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<p>Equivalent to <a href=\"../primitive.str.html#method.split\" title=\"method str::split\"><code>split</code></a>, except that the trailing substring is\nskipped if empty.</p>\n<p>This method can be used for string data that is <em>terminated</em>,\nrather than <em>separated</em> by a pattern.</p>\n<h5 id=\"iterator-behavior-3\"><a class=\"doc-anchor\" href=\"#iterator-behavior-3\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator requires that the pattern supports a\nreverse search, and it will be double ended if a forward/reverse\nsearch yields the same elements.</p>\n<p>For iterating from the front, the <a href=\"../primitive.str.html#method.split_terminator\" title=\"method str::split_terminator\"><code>split_terminator</code></a> method can be\nused.</p>\n<h5 id=\"examples-77\"><a class=\"doc-anchor\" href=\"#examples-77\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"A.B.\"</span>.rsplit_terminator(<span class=\"string\">'.'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"B\"</span>, <span class=\"string\">\"A\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"A..B..\"</span>.rsplit_terminator(<span class=\"string\">\".\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"A\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"A.B:C.D\"</span>.rsplit_terminator(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">'.'</span>, <span class=\"string\">':'</span>][..]).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"D\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"A\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B.%22.rsplit_terminator('.').collect();%0A++++assert_eq!(v,+%5B%22B%22,+%22A%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A..B..%22.rsplit_terminator(%22.%22).collect();%0A++++assert_eq!(v,+%5B%22%22,+%22B%22,+%22%22,+%22A%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B:C.D%22.rsplit_terminator(%26%5B'.',+':'%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%22D%22,+%22C%22,+%22B%22,+%22A%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.splitn\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1674\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.splitn\" class=\"fn\">splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.SplitN.html\" title=\"struct std::str::SplitN\">SplitN</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"SplitN<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over substrings of the given string slice, separated by a\npattern, restricted to returning at most <code>n</code> items.</p>\n<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)\nwill contain the remainder of the string.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"iterator-behavior-4\"><a class=\"doc-anchor\" href=\"#iterator-behavior-4\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator will not be double ended, because it is\nnot efficient to support.</p>\n<p>If the pattern allows a reverse search, the <a href=\"../primitive.str.html#method.rsplitn\" title=\"method str::rsplitn\"><code>rsplitn</code></a> method can be\nused.</p>\n<h5 id=\"examples-78\"><a class=\"doc-anchor\" href=\"#examples-78\">¬ß</a>Examples</h5>\n<p>Simple patterns:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"Mary had a little lambda\"</span>.splitn(<span class=\"number\">3</span>, <span class=\"string\">' '</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"Mary\"</span>, <span class=\"string\">\"had\"</span>, <span class=\"string\">\"a little lambda\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"lionXXtigerXleopard\"</span>.splitn(<span class=\"number\">3</span>, <span class=\"string\">\"X\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"lion\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"tigerXleopard\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"abcXdef\"</span>.splitn(<span class=\"number\">1</span>, <span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"abcXdef\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"\"</span>.splitn(<span class=\"number\">1</span>, <span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lambda%22.splitn(3,+'+').collect();%0A++++assert_eq!(v,+%5B%22Mary%22,+%22had%22,+%22a+little+lambda%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.splitn(3,+%22X%22).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22%22,+%22tigerXleopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXdef%22.splitn(1,+'X').collect();%0A++++assert_eq!(v,+%5B%22abcXdef%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.splitn(1,+'X').collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A more complex pattern, using a closure:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"abc1defXghi\"</span>.splitn(<span class=\"number\">2</span>, |c| c == <span class=\"string\">'1' </span>|| c == <span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"abc\"</span>, <span class=\"string\">\"defXghi\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.splitn(2,+%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22defXghi%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rsplitn\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1723-1725\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.rsplitn\" class=\"fn\">rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.RSplitN.html\" title=\"struct std::str::RSplitN\">RSplitN</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"RSplitN<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over substrings of this string slice, separated by a\npattern, starting from the end of the string, restricted to returning\nat most <code>n</code> items.</p>\n<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)\nwill contain the remainder of the string.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"iterator-behavior-5\"><a class=\"doc-anchor\" href=\"#iterator-behavior-5\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator will not be double ended, because it is not\nefficient to support.</p>\n<p>For splitting from the front, the <a href=\"../primitive.str.html#method.splitn\" title=\"method str::splitn\"><code>splitn</code></a> method can be used.</p>\n<h5 id=\"examples-79\"><a class=\"doc-anchor\" href=\"#examples-79\">¬ß</a>Examples</h5>\n<p>Simple patterns:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"Mary had a little lamb\"</span>.rsplitn(<span class=\"number\">3</span>, <span class=\"string\">' '</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"lamb\"</span>, <span class=\"string\">\"little\"</span>, <span class=\"string\">\"Mary had a\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"lionXXtigerXleopard\"</span>.rsplitn(<span class=\"number\">3</span>, <span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"leopard\"</span>, <span class=\"string\">\"tiger\"</span>, <span class=\"string\">\"lionX\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"lion::tiger::leopard\"</span>.rsplitn(<span class=\"number\">2</span>, <span class=\"string\">\"::\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"leopard\"</span>, <span class=\"string\">\"lion::tiger\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.rsplitn(3,+'+').collect();%0A++++assert_eq!(v,+%5B%22lamb%22,+%22little%22,+%22Mary+had+a%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.rsplitn(3,+'X').collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22lionX%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.rsplitn(2,+%22::%22).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22lion::tiger%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A more complex pattern, using a closure:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"abc1defXghi\"</span>.rsplitn(<span class=\"number\">2</span>, |c| c == <span class=\"string\">'1' </span>|| c == <span class=\"string\">'X'</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"ghi\"</span>, <span class=\"string\">\"abc1def\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.rsplitn(2,+%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22ghi%22,+%22abc1def%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_once\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.52.0\">1.52.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1743\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_once\" class=\"fn\">split_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;(&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>, &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>)&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Splits the string on the first occurrence of the specified delimiter and\nreturns prefix before delimiter and suffix after delimiter.</p>\n<h5 id=\"examples-80\"><a class=\"doc-anchor\" href=\"#examples-80\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"cfg\"</span>.split_once(<span class=\"string\">'='</span>), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"cfg=\"</span>.split_once(<span class=\"string\">'='</span>), <span class=\"prelude-val\">Some</span>((<span class=\"string\">\"cfg\"</span>, <span class=\"string\">\"\"</span>)));\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"cfg=foo\"</span>.split_once(<span class=\"string\">'='</span>), <span class=\"prelude-val\">Some</span>((<span class=\"string\">\"cfg\"</span>, <span class=\"string\">\"foo\"</span>)));\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"cfg=foo=bar\"</span>.split_once(<span class=\"string\">'='</span>), <span class=\"prelude-val\">Some</span>((<span class=\"string\">\"cfg\"</span>, <span class=\"string\">\"foo=bar\"</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22cfg%22.split_once('='),+None);%0A++++assert_eq!(%22cfg=%22.split_once('='),+Some((%22cfg%22,+%22%22)));%0A++++assert_eq!(%22cfg=foo%22.split_once('='),+Some((%22cfg%22,+%22foo%22)));%0A++++assert_eq!(%22cfg=foo=bar%22.split_once('='),+Some((%22cfg%22,+%22foo=bar%22)));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rsplit_once\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.52.0\">1.52.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1761-1763\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.rsplit_once\" class=\"fn\">rsplit_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;(&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>, &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>)&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Splits the string on the last occurrence of the specified delimiter and\nreturns prefix before delimiter and suffix after delimiter.</p>\n<h5 id=\"examples-81\"><a class=\"doc-anchor\" href=\"#examples-81\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"cfg\"</span>.rsplit_once(<span class=\"string\">'='</span>), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"cfg=foo\"</span>.rsplit_once(<span class=\"string\">'='</span>), <span class=\"prelude-val\">Some</span>((<span class=\"string\">\"cfg\"</span>, <span class=\"string\">\"foo\"</span>)));\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"cfg=foo=bar\"</span>.rsplit_once(<span class=\"string\">'='</span>), <span class=\"prelude-val\">Some</span>((<span class=\"string\">\"cfg=foo\"</span>, <span class=\"string\">\"bar\"</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22cfg%22.rsplit_once('='),+None);%0A++++assert_eq!(%22cfg=foo%22.rsplit_once('='),+Some((%22cfg%22,+%22foo%22)));%0A++++assert_eq!(%22cfg=foo=bar%22.rsplit_once('='),+Some((%22cfg=foo%22,+%22bar%22)));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.matches\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1801\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.matches\" class=\"fn\">matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.Matches.html\" title=\"struct std::str::Matches\">Matches</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Matches<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over the disjoint matches of a pattern within the given string\nslice.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"iterator-behavior-6\"><a class=\"doc-anchor\" href=\"#iterator-behavior-6\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator will be a <a href=\"../iter/trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\"><code>DoubleEndedIterator</code></a> if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, but not for <code>&amp;str</code>.</p>\n<p>If the pattern allows a reverse search but its results might differ\nfrom a forward search, the <a href=\"../primitive.str.html#method.rmatches\" title=\"method str::rmatches\"><code>rmatches</code></a> method can be used.</p>\n<h5 id=\"examples-82\"><a class=\"doc-anchor\" href=\"#examples-82\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"abcXXXabcYYYabc\"</span>.matches(<span class=\"string\">\"abc\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"abc\"</span>, <span class=\"string\">\"abc\"</span>, <span class=\"string\">\"abc\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"1abc2abc3\"</span>.matches(char::is_numeric).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXXXabcYYYabc%22.matches(%22abc%22).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22abc%22,+%22abc%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%221abc2abc3%22.matches(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%221%22,+%222%22,+%223%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rmatches\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1835-1837\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.rmatches\" class=\"fn\">rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.RMatches.html\" title=\"struct std::str::RMatches\">RMatches</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"RMatches<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over the disjoint matches of a pattern within this string slice,\nyielded in reverse order.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"iterator-behavior-7\"><a class=\"doc-anchor\" href=\"#iterator-behavior-7\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator requires that the pattern supports a reverse\nsearch, and it will be a <a href=\"../iter/trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\"><code>DoubleEndedIterator</code></a> if a forward/reverse\nsearch yields the same elements.</p>\n<p>For iterating from the front, the <a href=\"../primitive.str.html#method.matches\" title=\"method str::matches\"><code>matches</code></a> method can be used.</p>\n<h5 id=\"examples-83\"><a class=\"doc-anchor\" href=\"#examples-83\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"abcXXXabcYYYabc\"</span>.rmatches(<span class=\"string\">\"abc\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"abc\"</span>, <span class=\"string\">\"abc\"</span>, <span class=\"string\">\"abc\"</span>]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = <span class=\"string\">\"1abc2abc3\"</span>.rmatches(char::is_numeric).collect();\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"string\">\"3\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"1\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXXXabcYYYabc%22.rmatches(%22abc%22).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22abc%22,+%22abc%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%221abc2abc3%22.rmatches(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%223%22,+%222%22,+%221%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.match_indices\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1879\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.match_indices\" class=\"fn\">match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.MatchIndices.html\" title=\"struct std::str::MatchIndices\">MatchIndices</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"MatchIndices<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over the disjoint matches of a pattern within this string\nslice as well as the index that the match starts at.</p>\n<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices\ncorresponding to the first match are returned.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"iterator-behavior-8\"><a class=\"doc-anchor\" href=\"#iterator-behavior-8\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator will be a <a href=\"../iter/trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\"><code>DoubleEndedIterator</code></a> if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, but not for <code>&amp;str</code>.</p>\n<p>If the pattern allows a reverse search but its results might differ\nfrom a forward search, the <a href=\"../primitive.str.html#method.rmatch_indices\" title=\"method str::rmatch_indices\"><code>rmatch_indices</code></a> method can be used.</p>\n<h5 id=\"examples-84\"><a class=\"doc-anchor\" href=\"#examples-84\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw\">_</span>&gt; = <span class=\"string\">\"abcXXXabcYYYabc\"</span>.match_indices(<span class=\"string\">\"abc\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [(<span class=\"number\">0</span>, <span class=\"string\">\"abc\"</span>), (<span class=\"number\">6</span>, <span class=\"string\">\"abc\"</span>), (<span class=\"number\">12</span>, <span class=\"string\">\"abc\"</span>)]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw\">_</span>&gt; = <span class=\"string\">\"1abcabc2\"</span>.match_indices(<span class=\"string\">\"abc\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [(<span class=\"number\">1</span>, <span class=\"string\">\"abc\"</span>), (<span class=\"number\">4</span>, <span class=\"string\">\"abc\"</span>)]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw\">_</span>&gt; = <span class=\"string\">\"ababa\"</span>.match_indices(<span class=\"string\">\"aba\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [(<span class=\"number\">0</span>, <span class=\"string\">\"aba\"</span>)]); <span class=\"comment\">// only the first `aba`</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C_%3E+=+%22abcXXXabcYYYabc%22.match_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(0,+%22abc%22),+(6,+%22abc%22),+(12,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%221abcabc2%22.match_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(1,+%22abc%22),+(4,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%22ababa%22.match_indices(%22aba%22).collect();%0A++++assert_eq!(v,+%5B(0,+%22aba%22)%5D);+//+only+the+first+%60aba%60%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rmatch_indices\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1919-1921\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.rmatch_indices\" class=\"fn\">rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class=\"struct\" href=\"../str/struct.RMatchIndices.html\" title=\"struct std::str::RMatchIndices\">RMatchIndices</a>&lt;'a, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"RMatchIndices<'a, P>\">‚ìò</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator over the disjoint matches of a pattern within <code>self</code>,\nyielded in reverse order along with the index of the match.</p>\n<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices\ncorresponding to the last match are returned.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"iterator-behavior-9\"><a class=\"doc-anchor\" href=\"#iterator-behavior-9\">¬ß</a>Iterator behavior</h5>\n<p>The returned iterator requires that the pattern supports a reverse\nsearch, and it will be a <a href=\"../iter/trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\"><code>DoubleEndedIterator</code></a> if a forward/reverse\nsearch yields the same elements.</p>\n<p>For iterating from the front, the <a href=\"../primitive.str.html#method.match_indices\" title=\"method str::match_indices\"><code>match_indices</code></a> method can be used.</p>\n<h5 id=\"examples-85\"><a class=\"doc-anchor\" href=\"#examples-85\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw\">_</span>&gt; = <span class=\"string\">\"abcXXXabcYYYabc\"</span>.rmatch_indices(<span class=\"string\">\"abc\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [(<span class=\"number\">12</span>, <span class=\"string\">\"abc\"</span>), (<span class=\"number\">6</span>, <span class=\"string\">\"abc\"</span>), (<span class=\"number\">0</span>, <span class=\"string\">\"abc\"</span>)]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw\">_</span>&gt; = <span class=\"string\">\"1abcabc2\"</span>.rmatch_indices(<span class=\"string\">\"abc\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [(<span class=\"number\">4</span>, <span class=\"string\">\"abc\"</span>), (<span class=\"number\">1</span>, <span class=\"string\">\"abc\"</span>)]);\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw\">_</span>&gt; = <span class=\"string\">\"ababa\"</span>.rmatch_indices(<span class=\"string\">\"aba\"</span>).collect();\n<span class=\"macro\">assert_eq!</span>(v, [(<span class=\"number\">2</span>, <span class=\"string\">\"aba\"</span>)]); <span class=\"comment\">// only the last `aba`</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C_%3E+=+%22abcXXXabcYYYabc%22.rmatch_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(12,+%22abc%22),+(6,+%22abc%22),+(0,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%221abcabc2%22.rmatch_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(4,+%22abc%22),+(1,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%22ababa%22.rmatch_indices(%22aba%22).collect();%0A++++assert_eq!(v,+%5B(2,+%22aba%22)%5D);+//+only+the+last+%60aba%60%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1943\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim\" class=\"fn\">trim</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with leading and trailing whitespace removed.</p>\n<p>‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived\nCore Property <code>White_Space</code>, which includes newlines.</p>\n<h5 id=\"examples-86\"><a class=\"doc-anchor\" href=\"#examples-86\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"\\n Hello\\tworld\\t\\n\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Hello\\tworld\"</span>, s.trim());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++%0A++++assert_eq!(%22Hello%5Ctworld%22,+s.trim());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_start\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.30.0\">1.30.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#1982\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_start\" class=\"fn\">trim_start</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with leading whitespace removed.</p>\n<p>‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived\nCore Property <code>White_Space</code>, which includes newlines.</p>\n<h5 id=\"text-directionality\"><a class=\"doc-anchor\" href=\"#text-directionality\">¬ß</a>Text directionality</h5>\n<p>A string is a sequence of bytes. <code>start</code> in this context means the first\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be left side, and for right-to-left languages like\nArabic or Hebrew, this will be the right side.</p>\n<h5 id=\"examples-87\"><a class=\"doc-anchor\" href=\"#examples-87\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"\\n Hello\\tworld\\t\\n\"</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Hello\\tworld\\t\\n\"</span>, s.trim_start());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++assert_eq!(%22Hello%5Ctworld%5Ct%5Cn%22,+s.trim_start());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Directionality:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"  English  \"</span>;\n<span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'E'</span>) == s.trim_start().chars().next());\n\n<span class=\"kw\">let </span>s = <span class=\"string\">\"  ◊¢◊ë◊®◊ô◊™  \"</span>;\n<span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'◊¢'</span>) == s.trim_start().chars().next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English++%22;%0A++++assert!(Some('E')+==+s.trim_start().chars().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some('%D7%A2')+==+s.trim_start().chars().next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_end\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.30.0\">1.30.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2021\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_end\" class=\"fn\">trim_end</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with trailing whitespace removed.</p>\n<p>‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived\nCore Property <code>White_Space</code>, which includes newlines.</p>\n<h5 id=\"text-directionality-1\"><a class=\"doc-anchor\" href=\"#text-directionality-1\">¬ß</a>Text directionality</h5>\n<p>A string is a sequence of bytes. <code>end</code> in this context means the last\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be right side, and for right-to-left languages like\nArabic or Hebrew, this will be the left side.</p>\n<h5 id=\"examples-88\"><a class=\"doc-anchor\" href=\"#examples-88\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"\\n Hello\\tworld\\t\\n\"</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"\\n Hello\\tworld\"</span>, s.trim_end());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++assert_eq!(%22%5Cn+Hello%5Ctworld%22,+s.trim_end());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Directionality:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"  English  \"</span>;\n<span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'h'</span>) == s.trim_end().chars().rev().next());\n\n<span class=\"kw\">let </span>s = <span class=\"string\">\"  ◊¢◊ë◊®◊ô◊™  \"</span>;\n<span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'◊™'</span>) == s.trim_end().chars().rev().next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English++%22;%0A++++assert!(Some('h')+==+s.trim_end().chars().rev().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some('%D7%AA')+==+s.trim_end().chars().rev().next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_left\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2061\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_left\" class=\"fn\">trim_left</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">üëé</span><span>Deprecated since 1.33.0: superseded by <code>trim_start</code></span></div></span></summary><div class=\"docblock\"><p>Returns a string slice with leading whitespace removed.</p>\n<p>‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived\nCore Property <code>White_Space</code>.</p>\n<h5 id=\"text-directionality-2\"><a class=\"doc-anchor\" href=\"#text-directionality-2\">¬ß</a>Text directionality</h5>\n<p>A string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be\nthe <em>right</em> side, not the left.</p>\n<h5 id=\"examples-89\"><a class=\"doc-anchor\" href=\"#examples-89\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\" Hello\\tworld\\t\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Hello\\tworld\\t\"</span>, s.trim_left());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22+Hello%5Ctworld%5Ct%22;%0A++++%0A++++assert_eq!(%22Hello%5Ctworld%5Ct%22,+s.trim_left());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Directionality:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"  English\"</span>;\n<span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'E'</span>) == s.trim_left().chars().next());\n\n<span class=\"kw\">let </span>s = <span class=\"string\">\"  ◊¢◊ë◊®◊ô◊™\"</span>;\n<span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'◊¢'</span>) == s.trim_left().chars().next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English%22;%0A++++assert!(Some('E')+==+s.trim_left().chars().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA%22;%0A++++assert!(Some('%D7%A2')+==+s.trim_left().chars().next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_right\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2101\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_right\" class=\"fn\">trim_right</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">üëé</span><span>Deprecated since 1.33.0: superseded by <code>trim_end</code></span></div></span></summary><div class=\"docblock\"><p>Returns a string slice with trailing whitespace removed.</p>\n<p>‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived\nCore Property <code>White_Space</code>.</p>\n<h5 id=\"text-directionality-3\"><a class=\"doc-anchor\" href=\"#text-directionality-3\">¬ß</a>Text directionality</h5>\n<p>A string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be\nthe <em>left</em> side, not the right.</p>\n<h5 id=\"examples-90\"><a class=\"doc-anchor\" href=\"#examples-90\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\" Hello\\tworld\\t\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\" Hello\\tworld\"</span>, s.trim_right());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22+Hello%5Ctworld%5Ct%22;%0A++++%0A++++assert_eq!(%22+Hello%5Ctworld%22,+s.trim_right());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Directionality:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"English  \"</span>;\n<span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'h'</span>) == s.trim_right().chars().rev().next());\n\n<span class=\"kw\">let </span>s = <span class=\"string\">\"◊¢◊ë◊®◊ô◊™  \"</span>;\n<span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">'◊™'</span>) == s.trim_right().chars().rev().next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22English++%22;%0A++++assert!(Some('h')+==+s.trim_right().chars().rev().next());%0A++++%0A++++let+s+=+%22%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some('%D7%AA')+==+s.trim_right().chars().rev().next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_matches\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2134-2136\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_matches\" class=\"fn\">trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.DoubleEndedSearcher.html\" title=\"trait std::str::pattern::DoubleEndedSearcher\">DoubleEndedSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with all prefixes and suffixes that match a\npattern repeatedly removed.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a function\nor closure that determines if a character matches.</p>\n<h5 id=\"examples-91\"><a class=\"doc-anchor\" href=\"#examples-91\">¬ß</a>Examples</h5>\n<p>Simple patterns:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"11foo1bar11\"</span>.trim_matches(<span class=\"string\">'1'</span>), <span class=\"string\">\"foo1bar\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"123foo1bar123\"</span>.trim_matches(char::is_numeric), <span class=\"string\">\"foo1bar\"</span>);\n\n<span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"12foo1bar12\"</span>.trim_matches(x), <span class=\"string\">\"foo1bar\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_matches('1'),+%22foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_matches(char::is_numeric),+%22foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_matches(x),+%22foo1bar%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A more complex pattern, using a closure:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"1foo1barXX\"</span>.trim_matches(|c| c == <span class=\"string\">'1' </span>|| c == <span class=\"string\">'X'</span>), <span class=\"string\">\"foo1bar\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221foo1barXX%22.trim_matches(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X'),+%22foo1bar%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_start_matches\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.30.0\">1.30.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2181\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_start_matches\" class=\"fn\">trim_start_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with all prefixes that match a pattern\nrepeatedly removed.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"text-directionality-4\"><a class=\"doc-anchor\" href=\"#text-directionality-4\">¬ß</a>Text directionality</h5>\n<p>A string is a sequence of bytes. <code>start</code> in this context means the first\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be left side, and for right-to-left languages like\nArabic or Hebrew, this will be the right side.</p>\n<h5 id=\"examples-92\"><a class=\"doc-anchor\" href=\"#examples-92\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"11foo1bar11\"</span>.trim_start_matches(<span class=\"string\">'1'</span>), <span class=\"string\">\"foo1bar11\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"123foo1bar123\"</span>.trim_start_matches(char::is_numeric), <span class=\"string\">\"foo1bar123\"</span>);\n\n<span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"12foo1bar12\"</span>.trim_start_matches(x), <span class=\"string\">\"foo1bar12\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_start_matches('1'),+%22foo1bar11%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_start_matches(char::is_numeric),+%22foo1bar123%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_start_matches(x),+%22foo1bar12%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.strip_prefix\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.45.0\">1.45.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2214\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.strip_prefix\" class=\"fn\">strip_prefix</a>&lt;'a, P&gt;(&amp;'a self, prefix: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with the prefix removed.</p>\n<p>If the string starts with the pattern <code>prefix</code>, returns the substring after the prefix,\nwrapped in <code>Some</code>. Unlike <code>trim_start_matches</code>, this method removes the prefix exactly once.</p>\n<p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"examples-93\"><a class=\"doc-anchor\" href=\"#examples-93\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foo:bar\"</span>.strip_prefix(<span class=\"string\">\"foo:\"</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">\"bar\"</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foo:bar\"</span>.strip_prefix(<span class=\"string\">\"bar\"</span>), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foofoo\"</span>.strip_prefix(<span class=\"string\">\"foo\"</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">\"foo\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22foo:bar%22.strip_prefix(%22foo:%22),+Some(%22bar%22));%0A++++assert_eq!(%22foo:bar%22.strip_prefix(%22bar%22),+None);%0A++++assert_eq!(%22foofoo%22.strip_prefix(%22foo%22),+Some(%22foo%22));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.strip_suffix\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.45.0\">1.45.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2241-2244\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.strip_suffix\" class=\"fn\">strip_suffix</a>&lt;'a, P&gt;(&amp;'a self, suffix: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with the suffix removed.</p>\n<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix,\nwrapped in <code>Some</code>.  Unlike <code>trim_end_matches</code>, this method removes the suffix exactly once.</p>\n<p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"examples-94\"><a class=\"doc-anchor\" href=\"#examples-94\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"bar:foo\"</span>.strip_suffix(<span class=\"string\">\":foo\"</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">\"bar\"</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"bar:foo\"</span>.strip_suffix(<span class=\"string\">\"bar\"</span>), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foofoo\"</span>.strip_suffix(<span class=\"string\">\"foo\"</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">\"foo\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22bar:foo%22.strip_suffix(%22:foo%22),+Some(%22bar%22));%0A++++assert_eq!(%22bar:foo%22.strip_suffix(%22bar%22),+None);%0A++++assert_eq!(%22foofoo%22.strip_suffix(%22foo%22),+Some(%22foo%22));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_end_matches\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.30.0\">1.30.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2285-2287\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_end_matches\" class=\"fn\">trim_end_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with all suffixes that match a pattern\nrepeatedly removed.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"text-directionality-5\"><a class=\"doc-anchor\" href=\"#text-directionality-5\">¬ß</a>Text directionality</h5>\n<p>A string is a sequence of bytes. <code>end</code> in this context means the last\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be right side, and for right-to-left languages like\nArabic or Hebrew, this will be the left side.</p>\n<h5 id=\"examples-95\"><a class=\"doc-anchor\" href=\"#examples-95\">¬ß</a>Examples</h5>\n<p>Simple patterns:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"11foo1bar11\"</span>.trim_end_matches(<span class=\"string\">'1'</span>), <span class=\"string\">\"11foo1bar\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"123foo1bar123\"</span>.trim_end_matches(char::is_numeric), <span class=\"string\">\"123foo1bar\"</span>);\n\n<span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"12foo1bar12\"</span>.trim_end_matches(x), <span class=\"string\">\"12foo1bar\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_end_matches('1'),+%2211foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_end_matches(char::is_numeric),+%22123foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_end_matches(x),+%2212foo1bar%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A more complex pattern, using a closure:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"1fooX\"</span>.trim_end_matches(|c| c == <span class=\"string\">'1' </span>|| c == <span class=\"string\">'X'</span>), <span class=\"string\">\"1foo\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221fooX%22.trim_end_matches(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X'),+%221foo%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_left_matches\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2329\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_left_matches\" class=\"fn\">trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">üëé</span><span>Deprecated since 1.33.0: superseded by <code>trim_start_matches</code></span></div></span></summary><div class=\"docblock\"><p>Returns a string slice with all prefixes that match a pattern\nrepeatedly removed.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"text-directionality-6\"><a class=\"doc-anchor\" href=\"#text-directionality-6\">¬ß</a>Text directionality</h5>\n<p>A string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be\nthe <em>right</em> side, not the left.</p>\n<h5 id=\"examples-96\"><a class=\"doc-anchor\" href=\"#examples-96\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"11foo1bar11\"</span>.trim_left_matches(<span class=\"string\">'1'</span>), <span class=\"string\">\"foo1bar11\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"123foo1bar123\"</span>.trim_left_matches(char::is_numeric), <span class=\"string\">\"foo1bar123\"</span>);\n\n<span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"12foo1bar12\"</span>.trim_left_matches(x), <span class=\"string\">\"foo1bar12\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_left_matches('1'),+%22foo1bar11%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_left_matches(char::is_numeric),+%22foo1bar123%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_left_matches(x),+%22foo1bar12%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_right_matches\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2372-2374\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_right_matches\" class=\"fn\">trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">üëé</span><span>Deprecated since 1.33.0: superseded by <code>trim_end_matches</code></span></div></span></summary><div class=\"docblock\"><p>Returns a string slice with all suffixes that match a pattern\nrepeatedly removed.</p>\n<p>The <a href=\"../str/pattern/index.html\" title=\"mod std::str::pattern\">pattern</a> can be a <code>&amp;str</code>, <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>, a slice of <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h5 id=\"text-directionality-7\"><a class=\"doc-anchor\" href=\"#text-directionality-7\">¬ß</a>Text directionality</h5>\n<p>A string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be\nthe <em>left</em> side, not the right.</p>\n<h5 id=\"examples-97\"><a class=\"doc-anchor\" href=\"#examples-97\">¬ß</a>Examples</h5>\n<p>Simple patterns:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"11foo1bar11\"</span>.trim_right_matches(<span class=\"string\">'1'</span>), <span class=\"string\">\"11foo1bar\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"123foo1bar123\"</span>.trim_right_matches(char::is_numeric), <span class=\"string\">\"123foo1bar\"</span>);\n\n<span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"12foo1bar12\"</span>.trim_right_matches(x), <span class=\"string\">\"12foo1bar\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_right_matches('1'),+%2211foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_right_matches(char::is_numeric),+%22123foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_right_matches(x),+%2212foo1bar%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A more complex pattern, using a closure:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"1fooX\"</span>.trim_right_matches(|c| c == <span class=\"string\">'1' </span>|| c == <span class=\"string\">'X'</span>), <span class=\"string\">\"1foo\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221fooX%22.trim_right_matches(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X'),+%221foo%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.parse\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2424\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.parse\" class=\"fn\">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;F, &lt;F as <a class=\"trait\" href=\"../str/trait.FromStr.html\" title=\"trait std::str::FromStr\">FromStr</a>&gt;::<a class=\"associatedtype\" href=\"../str/trait.FromStr.html#associatedtype.Err\" title=\"type std::str::FromStr::Err\">Err</a>&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../str/trait.FromStr.html\" title=\"trait std::str::FromStr\">FromStr</a>,</div></h4></section></summary><div class=\"docblock\"><p>Parses this string slice into another type.</p>\n<p>Because <code>parse</code> is so general, it can cause problems with type\ninference. As such, <code>parse</code> is one of the few times you‚Äôll see\nthe syntax affectionately known as the ‚Äòturbofish‚Äô: <code>::&lt;&gt;</code>. This\nhelps the inference algorithm understand specifically which type\nyou‚Äôre trying to parse into.</p>\n<p><code>parse</code> can parse into any type that implements the <a href=\"../str/trait.FromStr.html\" title=\"trait std::str::FromStr\"><code>FromStr</code></a> trait.</p>\n<h5 id=\"errors-4\"><a class=\"doc-anchor\" href=\"#errors-4\">¬ß</a>Errors</h5>\n<p>Will return <a href=\"../str/trait.FromStr.html#associatedtype.Err\" title=\"associated type std::str::FromStr::Err\"><code>Err</code></a> if it‚Äôs not possible to parse this string slice into\nthe desired type.</p>\n<h5 id=\"examples-98\"><a class=\"doc-anchor\" href=\"#examples-98\">¬ß</a>Examples</h5>\n<p>Basic usage</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>four: u32 = <span class=\"string\">\"4\"</span>.parse().unwrap();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">4</span>, four);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+four:+u32+=+%224%22.parse().unwrap();%0A++++%0A++++assert_eq!(4,+four);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using the ‚Äòturbofish‚Äô instead of annotating <code>four</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>four = <span class=\"string\">\"4\"</span>.parse::&lt;u32&gt;();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Ok</span>(<span class=\"number\">4</span>), four);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+four+=+%224%22.parse::%3Cu32%3E();%0A++++%0A++++assert_eq!(Ok(4),+four);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Failing to parse:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>nope = <span class=\"string\">\"j\"</span>.parse::&lt;u32&gt;();\n\n<span class=\"macro\">assert!</span>(nope.is_err());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+nope+=+%22j%22.parse::%3Cu32%3E();%0A++++%0A++++assert!(nope.is_err());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_ascii\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0\">1.23.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2443\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_ascii\" class=\"fn\">is_ascii</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks if all characters in this string are within the ASCII range.</p>\n<h5 id=\"examples-99\"><a class=\"doc-anchor\" href=\"#examples-99\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>ascii = <span class=\"string\">\"hello!\\n\"</span>;\n<span class=\"kw\">let </span>non_ascii = <span class=\"string\">\"Gr√º√üe, J√ºrgen ‚ù§\"</span>;\n\n<span class=\"macro\">assert!</span>(ascii.is_ascii());\n<span class=\"macro\">assert!</span>(!non_ascii.is_ascii());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ascii+=+%22hello!%5Cn%22;%0A++++let+non_ascii+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert!(ascii.is_ascii());%0A++++assert!(!non_ascii.is_ascii());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ascii\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2455\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.as_ascii\" class=\"fn\">as_ascii</a>(&amp;self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;[<a class=\"enum\" href=\"../ascii/enum.Char.html\" title=\"enum std::ascii::Char\">AsciiChar</a>]&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/110998\">#110998</a>)</span></div></span></summary><div class=\"docblock\"><p>If this string slice <a href=\"../primitive.str.html#method.is_ascii\" title=\"method str::is_ascii\"><code>is_ascii</code></a>, returns it as a slice\nof <a href=\"../ascii/enum.Char.html\" title=\"enum std::ascii::Char\">ASCII characters</a>, otherwise returns <code>None</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq_ignore_ascii_case\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0\">1.23.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2475\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.eq_ignore_ascii_case\" class=\"fn\">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks that two strings are an ASCII case-insensitive match.</p>\n<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,\nbut without allocating and copying temporaries.</p>\n<h5 id=\"examples-100\"><a class=\"doc-anchor\" href=\"#examples-100\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert!</span>(<span class=\"string\">\"Ferris\"</span>.eq_ignore_ascii_case(<span class=\"string\">\"FERRIS\"</span>));\n<span class=\"macro\">assert!</span>(<span class=\"string\">\"Ferr√∂s\"</span>.eq_ignore_ascii_case(<span class=\"string\">\"FERR√∂S\"</span>));\n<span class=\"macro\">assert!</span>(!<span class=\"string\">\"Ferr√∂s\"</span>.eq_ignore_ascii_case(<span class=\"string\">\"FERR√ñS\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!(%22Ferris%22.eq_ignore_ascii_case(%22FERRIS%22));%0A++++assert!(%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%B6S%22));%0A++++assert!(!%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%96S%22));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.make_ascii_uppercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0\">1.23.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2500\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.make_ascii_uppercase\" class=\"fn\">make_ascii_uppercase</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Converts this string to its ASCII upper case equivalent in-place.</p>\n<p>ASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô,\nbut non-ASCII letters are unchanged.</p>\n<p>To return a new uppercased value without modifying the existing one, use\n<a href=\"#method.to_ascii_uppercase\"><code>to_ascii_uppercase()</code></a>.</p>\n<h5 id=\"examples-101\"><a class=\"doc-anchor\" href=\"#examples-101\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"Gr√º√üe, J√ºrgen ‚ù§\"</span>);\n\ns.make_ascii_uppercase();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"GR√º√üE, J√ºRGEN ‚ù§\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22);%0A++++%0A++++s.make_ascii_uppercase();%0A++++%0A++++assert_eq!(%22GR%C3%BC%C3%9FE,+J%C3%BCRGEN+%E2%9D%A4%22,+s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.make_ascii_lowercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0\">1.23.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2527\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.make_ascii_lowercase\" class=\"fn\">make_ascii_lowercase</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Converts this string to its ASCII lower case equivalent in-place.</p>\n<p>ASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô,\nbut non-ASCII letters are unchanged.</p>\n<p>To return a new lowercased value without modifying the existing one, use\n<a href=\"#method.to_ascii_lowercase\"><code>to_ascii_lowercase()</code></a>.</p>\n<h5 id=\"examples-102\"><a class=\"doc-anchor\" href=\"#examples-102\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"GR√ú√üE, J√úRGEN ‚ù§\"</span>);\n\ns.make_ascii_lowercase();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"gr√ú√üe, j√úrgen ‚ù§\"</span>, s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22GR%C3%9C%C3%9FE,+J%C3%9CRGEN+%E2%9D%A4%22);%0A++++%0A++++s.make_ascii_lowercase();%0A++++%0A++++assert_eq!(%22gr%C3%9C%C3%9Fe,+j%C3%9Crgen+%E2%9D%A4%22,+s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_ascii_start\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2552\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_ascii_start\" class=\"fn\">trim_ascii_start</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with leading ASCII whitespace removed.</p>\n<p>‚ÄòWhitespace‚Äô refers to the definition used by\n<a href=\"../primitive.u8.html#method.is_ascii_whitespace\" title=\"method u8::is_ascii_whitespace\"><code>u8::is_ascii_whitespace</code></a>.</p>\n<h5 id=\"examples-103\"><a class=\"doc-anchor\" href=\"#examples-103\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\" \\t \\u{3000}hello world\\n\"</span>.trim_ascii_start(), <span class=\"string\">\"\\u{3000}hello world\\n\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"  \"</span>.trim_ascii_start(), <span class=\"string\">\"\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"\"</span>.trim_ascii_start(), <span class=\"string\">\"\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22+%5Ct+%5Cu%7B3000%7Dhello+world%5Cn%22.trim_ascii_start(),+%22%5Cu%7B3000%7Dhello+world%5Cn%22);%0A++++assert_eq!(%22++%22.trim_ascii_start(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii_start(),+%22%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_ascii_end\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2577\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_ascii_end\" class=\"fn\">trim_ascii_end</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with trailing ASCII whitespace removed.</p>\n<p>‚ÄòWhitespace‚Äô refers to the definition used by\n<a href=\"../primitive.u8.html#method.is_ascii_whitespace\" title=\"method u8::is_ascii_whitespace\"><code>u8::is_ascii_whitespace</code></a>.</p>\n<h5 id=\"examples-104\"><a class=\"doc-anchor\" href=\"#examples-104\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"\\r hello world\\u{3000}\\n \"</span>.trim_ascii_end(), <span class=\"string\">\"\\r hello world\\u{3000}\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"  \"</span>.trim_ascii_end(), <span class=\"string\">\"\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"\"</span>.trim_ascii_end(), <span class=\"string\">\"\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%5Cr+hello+world%5Cu%7B3000%7D%5Cn+%22.trim_ascii_end(),+%22%5Cr+hello+world%5Cu%7B3000%7D%22);%0A++++assert_eq!(%22++%22.trim_ascii_end(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii_end(),+%22%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trim_ascii\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2603\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trim_ascii\" class=\"fn\">trim_ascii</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\"><p>Returns a string slice with leading and trailing ASCII whitespace\nremoved.</p>\n<p>‚ÄòWhitespace‚Äô refers to the definition used by\n<a href=\"../primitive.u8.html#method.is_ascii_whitespace\" title=\"method u8::is_ascii_whitespace\"><code>u8::is_ascii_whitespace</code></a>.</p>\n<h5 id=\"examples-105\"><a class=\"doc-anchor\" href=\"#examples-105\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"\\r hello world\\n \"</span>.trim_ascii(), <span class=\"string\">\"hello world\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"  \"</span>.trim_ascii(), <span class=\"string\">\"\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"\"</span>.trim_ascii(), <span class=\"string\">\"\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%5Cr+hello+world%5Cn+%22.trim_ascii(),+%22hello+world%22);%0A++++assert_eq!(%22++%22.trim_ascii(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii(),+%22%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.escape_debug\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2646\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.escape_debug\" class=\"fn\">escape_debug</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.EscapeDebug.html\" title=\"struct std::str::EscapeDebug\">EscapeDebug</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"EscapeDebug<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Return an iterator that escapes each char in <code>self</code> with <a href=\"../primitive.char.html#method.escape_debug\" title=\"method char::escape_debug\"><code>char::escape_debug</code></a>.</p>\n<p>Note: only extended grapheme codepoints that begin the string will be\nescaped.</p>\n<h5 id=\"examples-106\"><a class=\"doc-anchor\" href=\"#examples-106\">¬ß</a>Examples</h5>\n<p>As an iterator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">for </span>c <span class=\"kw\">in </span><span class=\"string\">\"‚ù§\\n!\"</span>.escape_debug() {\n    <span class=\"macro\">print!</span>(<span class=\"string\">\"{c}\"</span>);\n}\n<span class=\"macro\">println!</span>();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_debug()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using <code>println!</code> directly:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"string\">\"‚ù§\\n!\"</span>.escape_debug());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_debug());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Both are equivalent to:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">println!</span>(<span class=\"string\">\"‚ù§\\\\n!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%E2%9D%A4%5C%5Cn!%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using <code>to_string</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"‚ù§\\n!\"</span>.escape_debug().to_string(), <span class=\"string\">\"‚ù§\\\\n!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_debug().to_string(),+%22%E2%9D%A4%5C%5Cn!%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.escape_default\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2697\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.escape_default\" class=\"fn\">escape_default</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.EscapeDefault.html\" title=\"struct std::str::EscapeDefault\">EscapeDefault</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"EscapeDefault<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Return an iterator that escapes each char in <code>self</code> with <a href=\"../primitive.char.html#method.escape_default\" title=\"method char::escape_default\"><code>char::escape_default</code></a>.</p>\n<h5 id=\"examples-107\"><a class=\"doc-anchor\" href=\"#examples-107\">¬ß</a>Examples</h5>\n<p>As an iterator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">for </span>c <span class=\"kw\">in </span><span class=\"string\">\"‚ù§\\n!\"</span>.escape_default() {\n    <span class=\"macro\">print!</span>(<span class=\"string\">\"{c}\"</span>);\n}\n<span class=\"macro\">println!</span>();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_default()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using <code>println!</code> directly:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"string\">\"‚ù§\\n!\"</span>.escape_default());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_default());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Both are equivalent to:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">println!</span>(<span class=\"string\">\"\\\\u{{2764}}\\\\n!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cn!%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using <code>to_string</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"‚ù§\\n!\"</span>.escape_default().to_string(), <span class=\"string\">\"\\\\u{2764}\\\\n!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_default().to_string(),+%22%5C%5Cu%7B2764%7D%5C%5Cn!%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.escape_unicode\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/mod.rs.html#2735\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.escape_unicode\" class=\"fn\">escape_unicode</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../str/struct.EscapeUnicode.html\" title=\"struct std::str::EscapeUnicode\">EscapeUnicode</a>&lt;'_&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"EscapeUnicode<'_>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Return an iterator that escapes each char in <code>self</code> with <a href=\"../primitive.char.html#method.escape_unicode\" title=\"method char::escape_unicode\"><code>char::escape_unicode</code></a>.</p>\n<h5 id=\"examples-108\"><a class=\"doc-anchor\" href=\"#examples-108\">¬ß</a>Examples</h5>\n<p>As an iterator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">for </span>c <span class=\"kw\">in </span><span class=\"string\">\"‚ù§\\n!\"</span>.escape_unicode() {\n    <span class=\"macro\">print!</span>(<span class=\"string\">\"{c}\"</span>);\n}\n<span class=\"macro\">println!</span>();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_unicode()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using <code>println!</code> directly:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"string\">\"‚ù§\\n!\"</span>.escape_unicode());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_unicode());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Both are equivalent to:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">println!</span>(<span class=\"string\">\"\\\\u{{2764}}\\\\u{{a}}\\\\u{{21}}\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cu%7B%7Ba%7D%7D%5C%5Cu%7B%7B21%7D%7D%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using <code>to_string</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"‚ù§\\n!\"</span>.escape_unicode().to_string(), <span class=\"string\">\"\\\\u{2764}\\\\u{a}\\\\u{21}\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_unicode().to_string(),+%22%5C%5Cu%7B2764%7D%5C%5Cu%7Ba%7D%5C%5Cu%7B21%7D%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.replace\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#271\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.replace\" class=\"fn\">replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Replaces all matches of a pattern with another string.</p>\n<p><code>replace</code> creates a new <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>, and copies the data from this string slice into it.\nWhile doing so, it attempts to find matches of a pattern. If it finds any, it\nreplaces them with the replacement string slice.</p>\n<h5 id=\"examples-109\"><a class=\"doc-anchor\" href=\"#examples-109\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"this is old\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"this is new\"</span>, s.replace(<span class=\"string\">\"old\"</span>, <span class=\"string\">\"new\"</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"than an old\"</span>, s.replace(<span class=\"string\">\"is\"</span>, <span class=\"string\">\"an\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+old%22;%0A++++%0A++++assert_eq!(%22this+is+new%22,+s.replace(%22old%22,+%22new%22));%0A++++assert_eq!(%22than+an+old%22,+s.replace(%22is%22,+%22an%22));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>When the pattern doesn‚Äôt match, it returns this string slice as <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"this is old\"</span>;\n<span class=\"macro\">assert_eq!</span>(s, s.replace(<span class=\"string\">\"cookie monster\"</span>, <span class=\"string\">\"little lamb\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+old%22;%0A++++assert_eq!(s,+s.replace(%22cookie+monster%22,+%22little+lamb%22));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.replacen\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#311\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.replacen\" class=\"fn\">replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>, count: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Replaces first N matches of a pattern with another string.</p>\n<p><code>replacen</code> creates a new <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>, and copies the data from this string slice into it.\nWhile doing so, it attempts to find matches of a pattern. If it finds any, it\nreplaces them with the replacement string slice at most <code>count</code> times.</p>\n<h5 id=\"examples-110\"><a class=\"doc-anchor\" href=\"#examples-110\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"foo foo 123 foo\"</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"new new 123 foo\"</span>, s.replacen(<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"new\"</span>, <span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"faa fao 123 foo\"</span>, s.replacen(<span class=\"string\">'o'</span>, <span class=\"string\">\"a\"</span>, <span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foo foo new23 foo\"</span>, s.replacen(char::is_numeric, <span class=\"string\">\"new\"</span>, <span class=\"number\">1</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22foo+foo+123+foo%22;%0A++++assert_eq!(%22new+new+123+foo%22,+s.replacen(%22foo%22,+%22new%22,+2));%0A++++assert_eq!(%22faa+fao+123+foo%22,+s.replacen('o',+%22a%22,+3));%0A++++assert_eq!(%22foo+foo+new23+foo%22,+s.replacen(char::is_numeric,+%22new%22,+1));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>When the pattern doesn‚Äôt match, it returns this string slice as <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"this is old\"</span>;\n<span class=\"macro\">assert_eq!</span>(s, s.replacen(<span class=\"string\">\"cookie monster\"</span>, <span class=\"string\">\"little lamb\"</span>, <span class=\"number\">10</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+old%22;%0A++++assert_eq!(s,+s.replacen(%22cookie+monster%22,+%22little+lamb%22,+10));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_lowercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#368\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_lowercase\" class=\"fn\">to_lowercase</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Returns the lowercase equivalent of this string slice, as a new <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>.</p>\n<p>‚ÄòLowercase‚Äô is defined according to the terms of the Unicode Derived Core Property\n<code>Lowercase</code>.</p>\n<p>Since some characters can expand into multiple characters when changing\nthe case, this function returns a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> instead of modifying the\nparameter in-place.</p>\n<h5 id=\"examples-111\"><a class=\"doc-anchor\" href=\"#examples-111\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"HELLO\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"hello\"</span>, s.to_lowercase());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22HELLO%22;%0A++++%0A++++assert_eq!(%22hello%22,+s.to_lowercase());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A tricky example, with sigma:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>sigma = <span class=\"string\">\"Œ£\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"œÉ\"</span>, sigma.to_lowercase());\n\n<span class=\"comment\">// but at the end of a word, it's œÇ, not œÉ:\n</span><span class=\"kw\">let </span>odysseus = <span class=\"string\">\"·ΩàŒîŒ•Œ£Œ£ŒïŒéŒ£\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"·ΩÄŒ¥œÖœÉœÉŒµœçœÇ\"</span>, odysseus.to_lowercase());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+sigma+=+%22%CE%A3%22;%0A++++%0A++++assert_eq!(%22%CF%83%22,+sigma.to_lowercase());%0A++++%0A++++//+but+at+the+end+of+a+word,+it's+%CF%82,+not+%CF%83:%0A++++let+odysseus+=+%22%E1%BD%88%CE%94%CE%A5%CE%A3%CE%A3%CE%95%CE%8E%CE%A3%22;%0A++++%0A++++assert_eq!(%22%E1%BD%80%CE%B4%CF%85%CF%83%CF%83%CE%B5%CF%8D%CF%82%22,+odysseus.to_lowercase());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Languages without case are not changed:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>new_year = <span class=\"string\">\"ÂÜúÂéÜÊñ∞Âπ¥\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(new_year, new_year.to_lowercase());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+new_year+=+%22%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%22;%0A++++%0A++++assert_eq!(new_year,+new_year.to_lowercase());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_uppercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#461\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_uppercase\" class=\"fn\">to_uppercase</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Returns the uppercase equivalent of this string slice, as a new <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>.</p>\n<p>‚ÄòUppercase‚Äô is defined according to the terms of the Unicode Derived Core Property\n<code>Uppercase</code>.</p>\n<p>Since some characters can expand into multiple characters when changing\nthe case, this function returns a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> instead of modifying the\nparameter in-place.</p>\n<h5 id=\"examples-112\"><a class=\"doc-anchor\" href=\"#examples-112\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"hello\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"HELLO\"</span>, s.to_uppercase());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22hello%22;%0A++++%0A++++assert_eq!(%22HELLO%22,+s.to_uppercase());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Scripts without case are not changed:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>new_year = <span class=\"string\">\"ÂÜúÂéÜÊñ∞Âπ¥\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(new_year, new_year.to_uppercase());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+new_year+=+%22%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%22;%0A++++%0A++++assert_eq!(new_year,+new_year.to_uppercase());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>One character can become multiple:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"tsch√º√ü\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"TSCH√úSS\"</span>, s.to_uppercase());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22tsch%C3%BC%C3%9F%22;%0A++++%0A++++assert_eq!(%22TSCH%C3%9CSS%22,+s.to_uppercase());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.repeat\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#531\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.repeat\" class=\"fn\">repeat</a>(&amp;self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Creates a new <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> by repeating a string <code>n</code> times.</p>\n<h5 id=\"panics-12\"><a class=\"doc-anchor\" href=\"#panics-12\">¬ß</a>Panics</h5>\n<p>This function will panic if the capacity would overflow.</p>\n<h5 id=\"examples-113\"><a class=\"doc-anchor\" href=\"#examples-113\">¬ß</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"abc\"</span>.repeat(<span class=\"number\">4</span>), String::from(<span class=\"string\">\"abcabcabcabc\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22abc%22.repeat(4),+String::from(%22abcabcabcabc%22));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A panic upon overflow:</p>\n\n<div class=\"example-wrap should_panic\"><a href=\"#\" class=\"tooltip\" title=\"This example panics\">‚ìò</a><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// this will panic at runtime\n</span><span class=\"kw\">let </span>huge = <span class=\"string\">\"0123456789abcdef\"</span>.repeat(usize::MAX);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+this+will+panic+at+runtime%0Afn+main()+%7B%0A++++let+huge+=+%220123456789abcdef%22.repeat(usize::MAX);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_ascii_uppercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0\">1.23.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#561\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_ascii_uppercase\" class=\"fn\">to_ascii_uppercase</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Returns a copy of this string where each character is mapped to its\nASCII upper case equivalent.</p>\n<p>ASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô,\nbut non-ASCII letters are unchanged.</p>\n<p>To uppercase the value in-place, use <a href=\"../primitive.str.html#method.make_ascii_uppercase\" title=\"method str::make_ascii_uppercase\"><code>make_ascii_uppercase</code></a>.</p>\n<p>To uppercase ASCII characters in addition to non-ASCII characters, use\n<a href=\"#method.to_uppercase\"><code>to_uppercase</code></a>.</p>\n<h5 id=\"examples-114\"><a class=\"doc-anchor\" href=\"#examples-114\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"Gr√º√üe, J√ºrgen ‚ù§\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"GR√º√üE, J√ºRGEN ‚ù§\"</span>, s.to_ascii_uppercase());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert_eq!(%22GR%C3%BC%C3%9FE,+J%C3%BCRGEN+%E2%9D%A4%22,+s.to_ascii_uppercase());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_ascii_lowercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0\">1.23.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#593\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_ascii_lowercase\" class=\"fn\">to_ascii_lowercase</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Returns a copy of this string where each character is mapped to its\nASCII lower case equivalent.</p>\n<p>ASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô,\nbut non-ASCII letters are unchanged.</p>\n<p>To lowercase the value in-place, use <a href=\"../primitive.str.html#method.make_ascii_lowercase\" title=\"method str::make_ascii_lowercase\"><code>make_ascii_lowercase</code></a>.</p>\n<p>To lowercase ASCII characters in addition to non-ASCII characters, use\n<a href=\"#method.to_lowercase\"><code>to_lowercase</code></a>.</p>\n<h5 id=\"examples-115\"><a class=\"doc-anchor\" href=\"#examples-115\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"Gr√º√üe, J√ºrgen ‚ù§\"</span>;\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"gr√º√üe, j√ºrgen ‚ù§\"</span>, s.to_ascii_lowercase());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert_eq!(%22gr%C3%BC%C3%9Fe,+j%C3%BCrgen+%E2%9D%A4%22,+s.to_ascii_lowercase());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">¬ß</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Add%3C%26str%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2432\">source</a></span><a href=\"#impl-Add%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&lt;&amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"docblock\"><p>Implements the <code>+</code> operator for concatenating two strings.</p>\n<p>This consumes the <code>String</code> on the left-hand side and re-uses its buffer (growing it if\nnecessary). This is done to avoid allocating a new <code>String</code> and copying the entire contents on\nevery operation, which would lead to <em>O</em>(<em>n</em>^2) running time when building an <em>n</em>-byte string by\nrepeated concatenation.</p>\n<p>The string on the right-hand side is only borrowed; its contents are copied into the returned\n<code>String</code>.</p>\n<h4 id=\"examples-116\"><a class=\"doc-anchor\" href=\"#examples-116\">¬ß</a>Examples</h4>\n<p>Concatenating two <code>String</code>s takes the first by value and borrows the second:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = String::from(<span class=\"string\">\"hello\"</span>);\n<span class=\"kw\">let </span>b = String::from(<span class=\"string\">\" world\"</span>);\n<span class=\"kw\">let </span>c = a + <span class=\"kw-2\">&amp;</span>b;\n<span class=\"comment\">// `a` is moved and can no longer be used here.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+String::from(%22hello%22);%0A++++let+b+=+String::from(%22+world%22);%0A++++let+c+=+a+%2B+%26b;%0A++++//+%60a%60+is+moved+and+can+no+longer+be+used+here.%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If you want to keep using the first <code>String</code>, you can clone it and append to the clone instead:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = String::from(<span class=\"string\">\"hello\"</span>);\n<span class=\"kw\">let </span>b = String::from(<span class=\"string\">\" world\"</span>);\n<span class=\"kw\">let </span>c = a.clone() + <span class=\"kw-2\">&amp;</span>b;\n<span class=\"comment\">// `a` is still valid here.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+String::from(%22hello%22);%0A++++let+b+=+String::from(%22+world%22);%0A++++let+c+=+a.clone()+%2B+%26b;%0A++++//+%60a%60+is+still+valid+here.%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Concatenating <code>&amp;str</code> slices can be done by converting the first to a <code>String</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = <span class=\"string\">\"hello\"</span>;\n<span class=\"kw\">let </span>b = <span class=\"string\">\" world\"</span>;\n<span class=\"kw\">let </span>c = a.to_string() + b;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%22hello%22;%0A++++let+b+=+%22+world%22;%0A++++let+c+=+a.to_string()+%2B+b;%0A%7D&amp;edition=2021\">Run</a></div>\n</div><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"../ops/trait.Add.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>+</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.add\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2436\">source</a><a href=\"#method.add\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.Add.html#tymethod.add\" class=\"fn\">add</a>(self, other: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\">Performs the <code>+</code> operation. <a href=\"../ops/trait.Add.html#tymethod.add\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AddAssign%3C%26str%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0\">1.12.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2447\">source</a></span><a href=\"#impl-AddAssign%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.AddAssign.html\" title=\"trait std::ops::AddAssign\">AddAssign</a>&lt;&amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"docblock\"><p>Implements the <code>+=</code> operator for appending to a <code>String</code>.</p>\n<p>This has the same behavior as the <a href=\"struct.String.html#method.push_str\" title=\"method std::string::String::push_str\"><code>push_str</code></a> method.</p>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.add_assign\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2449\">source</a><a href=\"#method.add_assign\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.AddAssign.html#tymethod.add_assign\" class=\"fn\">add_assign</a>(&amp;mut self, other: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>+=</code> operation. <a href=\"../ops/trait.AddAssign.html#tymethod.add_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsMut%3Cstr%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2692\">source</a></span><a href=\"#impl-AsMut%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2694\">source</a><a href=\"#method.as_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.AsMut.html#tymethod.as_mut\" class=\"fn\">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\">Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsRef%3C%5Bu8%5D%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2700\">source</a></span><a href=\"#impl-AsRef%3C%5Bu8%5D%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ref-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2702\">source</a><a href=\"#method.as_ref-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.AsRef.html#tymethod.as_ref\" class=\"fn\">as_ref</a>(&amp;self) -&gt; &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">‚ìò</a></h4></section></summary><div class=\"docblock\">Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsRef%3COsStr%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"../../src/std/ffi/os_str.rs.html#1584-1589\">source</a></span><a href=\"#impl-AsRef%3COsStr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ref-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/ffi/os_str.rs.html#1586-1588\">source</a><a href=\"#method.as_ref-3\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.AsRef.html#tymethod.as_ref\" class=\"fn\">as_ref</a>(&amp;self) -&gt; &amp;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a></h4></section></summary><div class=\"docblock\">Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsRef%3CPath%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"../../src/std/path.rs.html#3182-3187\">source</a></span><a href=\"#impl-AsRef%3CPath%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ref-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/path.rs.html#3184-3186\">source</a><a href=\"#method.as_ref-2\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.AsRef.html#tymethod.as_ref\" class=\"fn\">as_ref</a>(&amp;self) -&gt; &amp;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a></h4></section></summary><div class=\"docblock\">Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsRef%3Cstr%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2684\">source</a></span><a href=\"#impl-AsRef%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ref\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2686\">source</a><a href=\"#method.as_ref\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.AsRef.html#tymethod.as_ref\" class=\"fn\">as_ref</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\">Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Borrow%3Cstr%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#190\">source</a></span><a href=\"#impl-Borrow%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#192\">source</a><a href=\"#method.borrow\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BorrowMut%3Cstr%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0\">1.36.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#198\">source</a></span><a href=\"#impl-BorrowMut%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#200\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Clone-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2097\">source</a></span><a href=\"#impl-Clone-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2106\">source</a><a href=\"#method.clone_from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>)</h4></section></summary><div class=\"docblock\"><p>Clones the contents of <code>source</code> into <code>self</code>.</p>\n<p>This method is preferred over simply assigning <code>source.clone()</code> to <code>self</code>,\nas it avoids reallocation if possible.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2098\">source</a><a href=\"#method.clone\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\">Returns a copy of the value. <a href=\"../clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2378\">source</a></span><a href=\"#impl-Debug-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2380\">source</a><a href=\"#method.fmt-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2361\">source</a></span><a href=\"#impl-Default-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2364\">source</a><a href=\"#method.default\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Creates an empty <code>String</code>.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Deref-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2479\">source</a></span><a href=\"#impl-Deref-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.Deref.html\" title=\"trait std::ops::Deref\">Deref</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Target\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Target\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"../ops/trait.Deref.html#associatedtype.Target\" class=\"associatedtype\">Target</a> = <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\">The resulting type after dereferencing.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.deref\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2483\">source</a><a href=\"#method.deref\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.Deref.html#tymethod.deref\" class=\"fn\">deref</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\">Dereferences the value.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-DerefMut-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2492\">source</a></span><a href=\"#impl-DerefMut-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.DerefMut.html\" title=\"trait std::ops::DerefMut\">DerefMut</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.deref_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2494\">source</a><a href=\"#method.deref_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.DerefMut.html#tymethod.deref_mut\" class=\"fn\">deref_mut</a>(&amp;mut self) -&gt; &amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><div class=\"docblock\">Mutably dereferences the value.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Display-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2370\">source</a></span><a href=\"#impl-Display-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2372\">source</a><a href=\"#method.fmt\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Display.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Display.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3C%26char%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2213\">source</a></span><a href=\"#impl-Extend%3C%26char%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;&amp;'a <a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2214\">source</a><a href=\"#method.extend-4\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = &amp;'a <a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2219\">source</a><a href=\"#method.extend_one-4\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, _: &amp;'a <a class=\"primitive\" href=\"../primitive.char.html\">char</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2224\">source</a><a href=\"#method.extend_reserve-4\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3C%26str%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2231\">source</a></span><a href=\"#impl-Extend%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2232\">source</a><a href=\"#method.extend-5\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2237\">source</a><a href=\"#method.extend_one-5\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, s: &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461\">source</a><a href=\"#method.extend_reserve-5\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3CBox%3Cstr,+A%3E%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.45.0\">1.45.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2244\">source</a></span><a href=\"#impl-Extend%3CBox%3Cstr,+A%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"trait\" href=\"../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;<a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>, A&gt;&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2245\">source</a><a href=\"#method.extend-2\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>, A&gt;&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#453\">source</a><a href=\"#method.extend_one-2\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461\">source</a><a href=\"#method.extend_reserve-2\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3CCow%3C'a,+str%3E%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.19.0\">1.19.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2265\">source</a></span><a href=\"#impl-Extend%3CCow%3C'a,+str%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;<a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2266\">source</a><a href=\"#method.extend\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2271\">source</a><a href=\"#method.extend_one\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, s: <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461\">source</a><a href=\"#method.extend_reserve\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3CString%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2252\">source</a></span><a href=\"#impl-Extend%3CString%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2253\">source</a><a href=\"#method.extend-3\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2258\">source</a><a href=\"#method.extend_one-3\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, s: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461\">source</a><a href=\"#method.extend_reserve-3\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3Cchar%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2192\">source</a></span><a href=\"#impl-Extend%3Cchar%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;<a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2193\">source</a><a href=\"#method.extend-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2201\">source</a><a href=\"#method.extend_one-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, c: <a class=\"primitive\" href=\"../primitive.char.html\">char</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2206\">source</a><a href=\"#method.extend_reserve-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26String%3E-for-Cow%3C'a,+str%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2853\">source</a></span><a href=\"#impl-From%3C%26String%3E-for-Cow%3C'a,+str%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;'a <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-7\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2868\">source</a><a href=\"#method.from-7\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;'a <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> reference into a <a href=\"../borrow/enum.Cow.html#variant.Borrowed\" title=\"borrow::Cow::Borrowed\"><code>Borrowed</code></a> variant.\nNo heap allocation is performed, and the string\nis not copied.</p>\n<h5 id=\"example-2\"><a class=\"doc-anchor\" href=\"#example-2\">¬ß</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"eggplant\"</span>.to_string();\n<span class=\"macro\">assert_eq!</span>(Cow::from(<span class=\"kw-2\">&amp;</span>s), Cow::Borrowed(<span class=\"string\">\"eggplant\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Cow;%0A++++let+s+=+%22eggplant%22.to_string();%0A++++assert_eq!(Cow::from(%26s),+Cow::Borrowed(%22eggplant%22));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26String%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.35.0\">1.35.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2733\">source</a></span><a href=\"#impl-From%3C%26String%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2738\">source</a><a href=\"#method.from-5\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Converts a <code>&amp;String</code> into a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>.</p>\n<p>This clones <code>s</code> and returns the clone.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26mut+str%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.44.0\">1.44.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2721\">source</a></span><a href=\"#impl-From%3C%26mut+str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2726\">source</a><a href=\"#method.from-2\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;mut <a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Converts a <code>&amp;mut str</code> into a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>.</p>\n<p>The result is allocated on the heap.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26str%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2709\">source</a></span><a href=\"#impl-From%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-13\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2714\">source</a><a href=\"#method.from-13\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Converts a <code>&amp;str</code> into a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>.</p>\n<p>The result is allocated on the heap.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CBox%3Cstr%3E%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.18.0\">1.18.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2746\">source</a></span><a href=\"#impl-From%3CBox%3Cstr%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-6\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2759\">source</a><a href=\"#method.from-6\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Converts the given boxed <code>str</code> slice to a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>.\nIt is notable that the <code>str</code> slice is owned.</p>\n<h5 id=\"examples-119\"><a class=\"doc-anchor\" href=\"#examples-119\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s1: String = String::from(<span class=\"string\">\"hello world\"</span>);\n<span class=\"kw\">let </span>s2: Box&lt;str&gt; = s1.into_boxed_str();\n<span class=\"kw\">let </span>s3: String = String::from(s2);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"hello world\"</span>, s3)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1:+String+=+String::from(%22hello+world%22);%0A++++let+s2:+Box%3Cstr%3E+=+s1.into_boxed_str();%0A++++let+s3:+String+=+String::from(s2);%0A++++%0A++++assert_eq!(%22hello+world%22,+s3)%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CCow%3C'a,+str%3E%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.14.0\">1.14.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2785\">source</a></span><a href=\"#impl-From%3CCow%3C'a,+str%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-11\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2802\">source</a><a href=\"#method.from-11\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Converts a clone-on-write string to an owned\ninstance of <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>.</p>\n<p>This extracts the owned string,\nclones the string if it is not already owned.</p>\n<h5 id=\"example-5\"><a class=\"doc-anchor\" href=\"#example-5\">¬ß</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// If the string is not owned...\n</span><span class=\"kw\">let </span>cow: Cow&lt;<span class=\"lifetime\">'_</span>, str&gt; = Cow::Borrowed(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"comment\">// It will allocate on the heap and copy the string.\n</span><span class=\"kw\">let </span>owned: String = String::from(cow);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>owned[..], <span class=\"string\">\"eggplant\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Cow;%0A++++//+If+the+string+is+not+owned...%0A++++let+cow:+Cow%3C'_,+str%3E+=+Cow::Borrowed(%22eggplant%22);%0A++++//+It+will+allocate+on+the+heap+and+copy+the+string.%0A++++let+owned:+String+=+String::from(cow);%0A++++assert_eq!(%26owned%5B..%5D,+%22eggplant%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-Arc%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3558\">source</a></span><a href=\"#impl-From%3CString%3E-for-Arc%3Cstr%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"../sync/struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-10\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3570\">source</a><a href=\"#method.from-10\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"../sync/struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted <code>str</code> and copy <code>v</code> into it.</p>\n<h5 id=\"example-4\"><a class=\"doc-anchor\" href=\"#example-4\">¬ß</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>unique: String = <span class=\"string\">\"eggplant\"</span>.to_owned();\n<span class=\"kw\">let </span>shared: Arc&lt;str&gt; = Arc::from(unique);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+unique:+String+=+%22eggplant%22.to_owned();%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(unique);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-Box%3Cdyn+Error%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2513\">source</a></span><a href=\"#impl-From%3CString%3E-for-Box%3Cdyn+Error%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;dyn <a class=\"trait\" href=\"../error/trait.Error.html\" title=\"trait std::error::Error\">Error</a> + 'a&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-12\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2526\">source</a><a href=\"#method.from-12\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(str_err: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;dyn <a class=\"trait\" href=\"../error/trait.Error.html\" title=\"trait std::error::Error\">Error</a> + 'a&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> into a box of dyn <a href=\"../error/trait.Error.html\" title=\"trait std::error::Error\"><code>Error</code></a>.</p>\n<h5 id=\"examples-121\"><a class=\"doc-anchor\" href=\"#examples-121\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::error::Error;\n<span class=\"kw\">use </span>std::mem;\n\n<span class=\"kw\">let </span>a_string_error = <span class=\"string\">\"a string error\"</span>.to_string();\n<span class=\"kw\">let </span>a_boxed_error = Box::&lt;<span class=\"kw\">dyn </span>Error&gt;::from(a_string_error);\n<span class=\"macro\">assert!</span>(mem::size_of::&lt;Box&lt;<span class=\"kw\">dyn </span>Error&gt;&gt;() == mem::size_of_val(<span class=\"kw-2\">&amp;</span>a_boxed_error))</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::error::Error;%0A++++use+std::mem;%0A++++%0A++++let+a_string_error+=+%22a+string+error%22.to_string();%0A++++let+a_boxed_error+=+Box::%3Cdyn+Error%3E::from(a_string_error);%0A++++assert!(mem::size_of::%3CBox%3Cdyn+Error%3E%3E()+==+mem::size_of_val(%26a_boxed_error))%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-Box%3Cdyn+Error+%2B+Send+%2B+Sync%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2469\">source</a></span><a href=\"#impl-From%3CString%3E-for-Box%3Cdyn+Error+%2B+Send+%2B+Sync%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;dyn <a class=\"trait\" href=\"../error/trait.Error.html\" title=\"trait std::error::Error\">Error</a> + <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + 'a&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-8\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2484\">source</a><a href=\"#method.from-8\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(err: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;dyn <a class=\"trait\" href=\"../error/trait.Error.html\" title=\"trait std::error::Error\">Error</a> + <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + 'a&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> into a box of dyn <a href=\"../error/trait.Error.html\" title=\"trait std::error::Error\"><code>Error</code></a> + <a href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\"><code>Send</code></a> + <a href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\"><code>Sync</code></a>.</p>\n<h5 id=\"examples-120\"><a class=\"doc-anchor\" href=\"#examples-120\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::error::Error;\n<span class=\"kw\">use </span>std::mem;\n\n<span class=\"kw\">let </span>a_string_error = <span class=\"string\">\"a string error\"</span>.to_string();\n<span class=\"kw\">let </span>a_boxed_error = Box::&lt;<span class=\"kw\">dyn </span>Error + Send + Sync&gt;::from(a_string_error);\n<span class=\"macro\">assert!</span>(\n    mem::size_of::&lt;Box&lt;<span class=\"kw\">dyn </span>Error + Send + Sync&gt;&gt;() == mem::size_of_val(<span class=\"kw-2\">&amp;</span>a_boxed_error))</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::error::Error;%0A++++use+std::mem;%0A++++%0A++++let+a_string_error+=+%22a+string+error%22.to_string();%0A++++let+a_boxed_error+=+Box::%3Cdyn+Error+%2B+Send+%2B+Sync%3E::from(a_string_error);%0A++++assert!(%0A++++++++mem::size_of::%3CBox%3Cdyn+Error+%2B+Send+%2B+Sync%3E%3E()+==+mem::size_of_val(%26a_boxed_error))%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-Box%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2766\">source</a></span><a href=\"#impl-From%3CString%3E-for-Box%3Cstr%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2778\">source</a><a href=\"#method.from-3\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts the given <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> to a boxed <code>str</code> slice that is owned.</p>\n<h5 id=\"examples-118\"><a class=\"doc-anchor\" href=\"#examples-118\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s1: String = String::from(<span class=\"string\">\"hello world\"</span>);\n<span class=\"kw\">let </span>s2: Box&lt;str&gt; = Box::from(s1);\n<span class=\"kw\">let </span>s3: String = String::from(s2);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"hello world\"</span>, s3)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1:+String+=+String::from(%22hello+world%22);%0A++++let+s2:+Box%3Cstr%3E+=+Box::from(s1);%0A++++let+s3:+String+=+String::from(s2);%0A++++%0A++++assert_eq!(%22hello+world%22,+s3)%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-Cow%3C'a,+str%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2830\">source</a></span><a href=\"#impl-From%3CString%3E-for-Cow%3C'a,+str%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2846\">source</a><a href=\"#method.from-4\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> into an <a href=\"../borrow/enum.Cow.html#variant.Owned\" title=\"borrow::Cow::Owned\"><code>Owned</code></a> variant.\nNo heap allocation is performed, and the string\nis not copied.</p>\n<h5 id=\"example-1\"><a class=\"doc-anchor\" href=\"#example-1\">¬ß</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = <span class=\"string\">\"eggplant\"</span>.to_string();\n<span class=\"kw\">let </span>s2 = <span class=\"string\">\"eggplant\"</span>.to_string();\n<span class=\"macro\">assert_eq!</span>(Cow::from(s), Cow::&lt;<span class=\"lifetime\">'static</span>, str&gt;::Owned(s2));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Cow;%0A++++let+s+=+%22eggplant%22.to_string();%0A++++let+s2+=+%22eggplant%22.to_string();%0A++++assert_eq!(Cow::from(s),+Cow::%3C'static,+str%3E::Owned(s2));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-OsString\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"../../src/std/ffi/os_str.rs.html#544-552\">source</a></span><a href=\"#impl-From%3CString%3E-for-OsString\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-14\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/ffi/os_str.rs.html#549-551\">source</a><a href=\"#method.from-14\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a></h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> into an <a href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a>.</p>\n<p>This conversion does not allocate or copy memory.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-PathBuf\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"../../src/std/path.rs.html#1739-1747\">source</a></span><a href=\"#impl-From%3CString%3E-for-PathBuf\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\">PathBuf</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-15\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/path.rs.html#1744-1746\">source</a><a href=\"#method.from-15\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\">PathBuf</a></h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> into a <a href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\"><code>PathBuf</code></a></p>\n<p>This conversion does not allocate or copy memory.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-Rc%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2599\">source</a></span><a href=\"#impl-From%3CString%3E-for-Rc%3Cstr%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"../rc/struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-9\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2611\">source</a><a href=\"#method.from-9\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"../rc/struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted string slice and copy <code>v</code> into it.</p>\n<h5 id=\"example-3\"><a class=\"doc-anchor\" href=\"#example-3\">¬ß</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>original: String = <span class=\"string\">\"statue\"</span>.to_owned();\n<span class=\"kw\">let </span>shared: Rc&lt;str&gt; = Rc::from(original);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"statue\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+String+=+%22statue%22.to_owned();%0A++++let+shared:+Rc%3Cstr%3E+=+Rc::from(original);%0A++++assert_eq!(%22statue%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-Vec%3Cu8%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.14.0\">1.14.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2898\">source</a></span><a href=\"#impl-From%3CString%3E-for-Vec%3Cu8%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2911\">source</a><a href=\"#method.from-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(string: <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Vec<u8>\">‚ìò</a></h4></section></summary><div class=\"docblock\"><p>Converts the given <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> to a vector <a href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\"><code>Vec</code></a> that holds values of type <a href=\"../primitive.u8.html\" title=\"primitive u8\"><code>u8</code></a>.</p>\n<h5 id=\"examples-117\"><a class=\"doc-anchor\" href=\"#examples-117\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s1 = String::from(<span class=\"string\">\"hello world\"</span>);\n<span class=\"kw\">let </span>v1 = Vec::from(s1);\n\n<span class=\"kw\">for </span>b <span class=\"kw\">in </span>v1 {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{b}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1+=+String::from(%22hello+world%22);%0A++++let+v1+=+Vec::from(s1);%0A++++%0A++++for+b+in+v1+%7B%0A++++++++println!(%22%7Bb%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3Cchar%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.46.0\">1.46.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#3041\">source</a></span><a href=\"#impl-From%3Cchar%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#3051\">source</a><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(c: <a class=\"primitive\" href=\"../primitive.char.html\">char</a>) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\"><p>Allocates an owned <a href=\"struct.String.html\" title=\"struct std::string::String\"><code>String</code></a> from a single character.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">¬ß</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>c: char = <span class=\"string\">'a'</span>;\n<span class=\"kw\">let </span>s: String = String::from(c);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"a\"</span>, <span class=\"kw-2\">&amp;</span>s[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+c:+char+=+'a';%0A++++let+s:+String+=+String::from(c);%0A++++assert_eq!(%22a%22,+%26s%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3C%26char%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2123\">source</a></span><a href=\"#impl-FromIterator%3C%26char%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;&amp;'a <a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2124\">source</a><a href=\"#method.from_iter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = &amp;'a <a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3C%26str%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2133\">source</a></span><a href=\"#impl-FromIterator%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2134\">source</a><a href=\"#method.from_iter-2\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3CBox%3Cstr,+A%3E%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.45.0\">1.45.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2162\">source</a></span><a href=\"#impl-FromIterator%3CBox%3Cstr,+A%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;<a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>, A&gt;&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter-6\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2163\">source</a><a href=\"#method.from_iter-6\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>, A&gt;&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.19.0\">1.19.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2172\">source</a></span><a href=\"#impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;<a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2173\">source</a><a href=\"#method.from_iter-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3CString%3E-for-Box%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2195\">source</a></span><a href=\"#impl-FromIterator%3CString%3E-for-Box%3Cstr%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2196\">source</a><a href=\"#method.from_iter-4\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;T&gt;(iter: T) -&gt; <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3CString%3E-for-Cow%3C'a,+str%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0\">1.12.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2891\">source</a></span><a href=\"#impl-FromIterator%3CString%3E-for-Cow%3C'a,+str%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2892\">source</a><a href=\"#method.from_iter-3\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(it: I) -&gt; <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3CString%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2143\">source</a></span><a href=\"#impl-FromIterator%3CString%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter-7\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2144\">source</a><a href=\"#method.from_iter-7\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3Cchar%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2113\">source</a></span><a href=\"#impl-FromIterator%3Cchar%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;<a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2114\">source</a><a href=\"#method.from_iter-5\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.char.html\">char</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromStr-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2509\">source</a></span><a href=\"#impl-FromStr-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../str/trait.FromStr.html\" title=\"trait std::str::FromStr\">FromStr</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Err\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Err\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"../str/trait.FromStr.html#associatedtype.Err\" class=\"associatedtype\">Err</a> = <a class=\"enum\" href=\"../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The associated error which can be returned from parsing.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_str\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2512\">source</a><a href=\"#method.from_str\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../str/trait.FromStr.html#tymethod.from_str\" class=\"fn\">from_str</a>(s: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>, &lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a> as <a class=\"trait\" href=\"../str/trait.FromStr.html\" title=\"trait std::str::FromStr\">FromStr</a>&gt;::<a class=\"associatedtype\" href=\"../str/trait.FromStr.html#associatedtype.Err\" title=\"type std::str::FromStr::Err\">Err</a>&gt;</h4></section></summary><div class=\"docblock\">Parses a string <code>s</code> to return a value of this type. <a href=\"../str/trait.FromStr.html#tymethod.from_str\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Hash-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2386\">source</a></span><a href=\"#impl-Hash-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2388\">source</a><a href=\"#method.hash\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../hash/trait.Hash.html#tymethod.hash\" class=\"fn\">hash</a>&lt;H&gt;(&amp;self, hasher: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,</div></h4></section></summary><div class=\"docblock\">Feeds this value into the given <a href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../hash/trait.Hash.html#tymethod.hash\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/hash/mod.rs.html#238-240\">source</a></span><a href=\"#method.hash_slice\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../hash/trait.Hash.html#method.hash_slice\" class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[Self]</a>, state: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Feeds a slice of this type into the given <a href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../hash/trait.Hash.html#method.hash_slice\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Index%3CI%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2455-2457\">source</a></span><a href=\"#impl-Index%3CI%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"../ops/trait.Index.html\" title=\"trait std::ops::Index\">Index</a>&lt;I&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"../ops/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;I as <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt;::<a class=\"associatedtype\" href=\"../slice/trait.SliceIndex.html#associatedtype.Output\" title=\"type std::slice::SliceIndex::Output\">Output</a></h4></section></summary><div class=\"docblock\">The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.index\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2462\">source</a><a href=\"#method.index\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: I) -&gt; &amp;&lt;I as <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt;::<a class=\"associatedtype\" href=\"../slice/trait.SliceIndex.html#associatedtype.Output\" title=\"type std::slice::SliceIndex::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the indexing (<code>container[index]</code>) operation. <a href=\"../ops/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-IndexMut%3CI%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2468-2470\">source</a></span><a href=\"#impl-IndexMut%3CI%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"../ops/trait.IndexMut.html\" title=\"trait std::ops::IndexMut\">IndexMut</a>&lt;I&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2473\">source</a><a href=\"#method.index_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: I) -&gt; &amp;mut &lt;I as <a class=\"trait\" href=\"../slice/trait.SliceIndex.html\" title=\"trait std::slice::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt;::<a class=\"associatedtype\" href=\"../slice/trait.SliceIndex.html#associatedtype.Output\" title=\"type std::slice::SliceIndex::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"../ops/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Ord-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362\">source</a></span><a href=\"#impl-Ord-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362\">source</a><a href=\"#method.cmp\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#tymethod.cmp\" class=\"fn\">cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></h4></section></summary><div class=\"docblock\">This method returns an <a href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href=\"../cmp/trait.Ord.html#tymethod.cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#856-858\">source</a></span><a href=\"#method.max\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.max\" class=\"fn\">max</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the maximum of two values. <a href=\"../cmp/trait.Ord.html#method.max\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#877-879\">source</a></span><a href=\"#method.min\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.min\" class=\"fn\">min</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the minimum of two values. <a href=\"../cmp/trait.Ord.html#method.min\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clamp\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.50.0\">1.50.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#903-906\">source</a></span><a href=\"#method.clamp\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.clamp\" class=\"fn\">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section></summary><div class=\"docblock\">Restrict a value to a certain interval. <a href=\"../cmp/trait.Ord.html#method.clamp\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq%3C%26str%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352\">source</a></span><a href=\"#impl-PartialEq%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352\">source</a><a href=\"#method.eq\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352\">source</a><a href=\"#method.ne\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358\">source</a></span><a href=\"#impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358\">source</a><a href=\"#method.eq-3\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358\">source</a><a href=\"#method.ne-3\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq%3CString%3E-for-%26str\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352\">source</a></span><a href=\"#impl-PartialEq%3CString%3E-for-%26str\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352\">source</a><a href=\"#method.eq-5\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2352\">source</a><a href=\"#method.ne-5\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq%3CString%3E-for-Cow%3C'a,+str%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358\">source</a></span><a href=\"#impl-PartialEq%3CString%3E-for-Cow%3C'a,+str%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358\">source</a><a href=\"#method.eq-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2358\">source</a><a href=\"#method.ne-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq%3CString%3E-for-str\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351\">source</a></span><a href=\"#impl-PartialEq%3CString%3E-for-str\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351\">source</a><a href=\"#method.eq-2\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351\">source</a><a href=\"#method.ne-2\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq%3Cstr%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351\">source</a></span><a href=\"#impl-PartialEq%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq-6\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351\">source</a><a href=\"#method.eq-6\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne-6\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2351\">source</a><a href=\"#method.ne-6\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362\">source</a></span><a href=\"#impl-PartialEq-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362\">source</a><a href=\"#method.eq-4\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne-4\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263\">source</a></span><a href=\"#method.ne-4\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialOrd-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362\">source</a></span><a href=\"#impl-PartialOrd-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362\">source</a><a href=\"#method.partial_cmp\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class=\"docblock\">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180\">source</a></span><a href=\"#method.lt\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"../cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198\">source</a></span><a href=\"#method.le\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>\noperator. <a href=\"../cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215\">source</a></span><a href=\"#method.gt\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href=\"../cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233\">source</a></span><a href=\"#method.ge\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>\noperator. <a href=\"../cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Pattern%3C'a%3E-for-%26String\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2288\">source</a><a href=\"#impl-Pattern%3C'a%3E-for-%26String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt; for &amp;'b <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"docblock\"><p>A convenience impl that delegates to the impl for <code>&amp;str</code>.</p>\n<h4 id=\"examples-122\"><a class=\"doc-anchor\" href=\"#examples-122\">¬ß</a>Examples</h4>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"Hello world\"</span>).find(<span class=\"string\">\"world\"</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">6</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(String::from(%22Hello+world%22).find(%22world%22),+Some(6));%0A%7D&amp;edition=2021\">Run</a></div>\n</div><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Searcher\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Searcher\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" class=\"associatedtype\">Searcher</a> = &lt;&amp;'b <a class=\"primitive\" href=\"../primitive.str.html\">str</a> as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Associated searcher for this pattern</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_searcher\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2291\">source</a><a href=\"#method.into_searcher\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../str/pattern/trait.Pattern.html#tymethod.into_searcher\" class=\"fn\">into_searcher</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; &lt;&amp;'b <a class=\"primitive\" href=\"../primitive.str.html\">str</a> as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Constructs the associated searcher from\n<code>self</code> and the <code>haystack</code> to search in.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_contained_in\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2296\">source</a><a href=\"#method.is_contained_in\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../str/pattern/trait.Pattern.html#method.is_contained_in\" class=\"fn\">is_contained_in</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Checks whether the pattern matches anywhere in the haystack</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_prefix_of\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2301\">source</a><a href=\"#method.is_prefix_of\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../str/pattern/trait.Pattern.html#method.is_prefix_of\" class=\"fn\">is_prefix_of</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Checks whether the pattern matches at the front of the haystack</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.strip_prefix_of\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2306\">source</a><a href=\"#method.strip_prefix_of\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../str/pattern/trait.Pattern.html#method.strip_prefix_of\" class=\"fn\">strip_prefix_of</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Removes the pattern from the front of haystack, if it matches.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_suffix_of\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2311\">source</a><a href=\"#method.is_suffix_of\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../str/pattern/trait.Pattern.html#method.is_suffix_of\" class=\"fn\">is_suffix_of</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Checks whether the pattern matches at the back of the haystack</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.strip_suffix_of\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2316\">source</a><a href=\"#method.strip_suffix_of\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../str/pattern/trait.Pattern.html#method.strip_suffix_of\" class=\"fn\">strip_suffix_of</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Removes the pattern from the back of haystack, if it matches.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-ToSocketAddrs-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> ¬∑ <a class=\"src\" href=\"../../src/std/net/socket_addr.rs.html#310-315\">source</a></span><a href=\"#impl-ToSocketAddrs-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../net/trait.ToSocketAddrs.html\" title=\"trait std::net::ToSocketAddrs\">ToSocketAddrs</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Iter\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Iter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"../net/trait.ToSocketAddrs.html#associatedtype.Iter\" class=\"associatedtype\">Iter</a> = <a class=\"struct\" href=\"../vec/struct.IntoIter.html\" title=\"struct std::vec::IntoIter\">IntoIter</a>&lt;<a class=\"enum\" href=\"../net/enum.SocketAddr.html\" title=\"enum std::net::SocketAddr\">SocketAddr</a>&gt;</h4></section></summary><div class=\"docblock\">Returned iterator over socket addresses which this type may correspond\nto.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_socket_addrs\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/net/socket_addr.rs.html#312-314\">source</a><a href=\"#method.to_socket_addrs\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs\" class=\"fn\">to_socket_addrs</a>(&amp;self) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"struct\" href=\"../vec/struct.IntoIter.html\" title=\"struct std::vec::IntoIter\">IntoIter</a>&lt;<a class=\"enum\" href=\"../net/enum.SocketAddr.html\" title=\"enum std::net::SocketAddr\">SocketAddr</a>&gt;&gt;</h4></section></summary><div class=\"docblock\">Converts this object to an iterator of resolved <a href=\"../net/enum.SocketAddr.html\" title=\"enum std::net::SocketAddr\"><code>SocketAddr</code></a>s. <a href=\"../net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Write-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2918\">source</a></span><a href=\"#impl-Write-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../fmt/trait.Write.html\" title=\"trait std::fmt::Write\">Write</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_str\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2920\">source</a><a href=\"#method.write_str\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Write.html#tymethod.write_str\" class=\"fn\">write_str</a>(&amp;mut self, s: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Writes a string slice into this writer, returning whether the write\nsucceeded. <a href=\"../fmt/trait.Write.html#tymethod.write_str\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_char\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2926\">source</a><a href=\"#method.write_char\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Write.html#method.write_char\" class=\"fn\">write_char</a>(&amp;mut self, c: <a class=\"primitive\" href=\"../primitive.char.html\">char</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Writes a <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a> into this writer, returning whether the write succeeded. <a href=\"../fmt/trait.Write.html#method.write_char\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_fmt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/fmt/mod.rs.html#206\">source</a></span><a href=\"#method.write_fmt\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Write.html#method.write_fmt\" class=\"fn\">write_fmt</a>(&amp;mut self, args: <a class=\"struct\" href=\"../fmt/struct.Arguments.html\" title=\"struct std::fmt::Arguments\">Arguments</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Glue for usage of the <a href=\"../macro.write.html\" title=\"macro std::write\"><code>write!</code></a> macro with implementors of this trait. <a href=\"../fmt/trait.Write.html#method.write_fmt\">Read more</a></div></details></div></details><section id=\"impl-DerefPure-for-String\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2489\">source</a><a href=\"#impl-DerefPure-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.DerefPure.html\" title=\"trait std::ops::DerefPure\">DerefPure</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section><section id=\"impl-Eq-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362\">source</a></span><a href=\"#impl-Eq-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section><section id=\"impl-StructuralPartialEq-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> ¬∑ <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#362\">source</a></span><a href=\"#impl-StructuralPartialEq-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.StructuralPartialEq.html\" title=\"trait std::marker::StructuralPartialEq\">StructuralPartialEq</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">¬ß</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-String\" class=\"impl\"><a href=\"#impl-Freeze-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section><section id=\"impl-RefUnwindSafe-for-String\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section><section id=\"impl-Send-for-String\" class=\"impl\"><a href=\"#impl-Send-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section><section id=\"impl-Sync-for-String\" class=\"impl\"><a href=\"#impl-Sync-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section><section id=\"impl-Unpin-for-String\" class=\"impl\"><a href=\"#impl-Unpin-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section><section id=\"impl-UnwindSafe-for-String\" class=\"impl\"><a href=\"#impl-UnwindSafe-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">¬ß</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-16\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from-16\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToOwned-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85\">source</a><a href=\"#impl-ToOwned-for-T\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Owned\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"../borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88\">source</a><a href=\"#method.to_owned\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\">Creates owned data from borrowed data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92\">source</a><a href=\"#method.clone_into\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>)</h4></section></summary><div class=\"docblock\">Uses borrowed data to replace owned data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToString-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2552\">source</a><a href=\"#impl-ToString-for-T\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ToString.html\" title=\"trait std::string::ToString\">ToString</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_string\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2558\">source</a><a href=\"#method.to_string\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">default fn <a href=\"trait.ToString.html#tymethod.to_string\" class=\"fn\">to_string</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\">Converts the given value to a <code>String</code>. <a href=\"trait.ToString.html#tymethod.to_string\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div><script type=\"text/json\" id=\"notable-traits-data\">{\"&[u8]\":\"<h3>Notable traits for <code>&amp;[<a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>]</code></h3><pre><code><div class=\\\"where\\\">impl <a class=\\\"trait\\\" href=\\\"../io/trait.Read.html\\\" title=\\\"trait std::io::Read\\\">Read</a> for &amp;[<a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>]</div>\",\"&mut Vec<u8>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../vec/struct.Vec.html\\\" title=\\\"struct std::vec::Vec\\\">Vec</a>&lt;<a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;A: <a class=\\\"trait\\\" href=\\\"../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a>&gt; <a class=\\\"trait\\\" href=\\\"../io/trait.Write.html\\\" title=\\\"trait std::io::Write\\\">Write</a> for <a class=\\\"struct\\\" href=\\\"../vec/struct.Vec.html\\\" title=\\\"struct std::vec::Vec\\\">Vec</a>&lt;<a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>, A&gt;</div>\",\"&mut [u8]\":\"<h3>Notable traits for <code>&amp;mut [<a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>]</code></h3><pre><code><div class=\\\"where\\\">impl <a class=\\\"trait\\\" href=\\\"../io/trait.Write.html\\\" title=\\\"trait std::io::Write\\\">Write</a> for &amp;mut [<a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>]</div>\",\"Bytes<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.Bytes.html\\\" title=\\\"struct std::str::Bytes\\\">Bytes</a>&lt;'_&gt;</code></h3><pre><code><div class=\\\"where\\\">impl <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.Bytes.html\\\" title=\\\"struct std::str::Bytes\\\">Bytes</a>&lt;'_&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>;</div>\",\"CharIndices<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.CharIndices.html\\\" title=\\\"struct std::str::CharIndices\\\">CharIndices</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.CharIndices.html\\\" title=\\\"struct std::str::CharIndices\\\">CharIndices</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../primitive.usize.html\\\">usize</a>, <a class=\\\"primitive\\\" href=\\\"../primitive.char.html\\\">char</a>);</div>\",\"Chars<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.Chars.html\\\" title=\\\"struct std::str::Chars\\\">Chars</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.Chars.html\\\" title=\\\"struct std::str::Chars\\\">Chars</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../primitive.char.html\\\">char</a>;</div>\",\"Drain<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Drain.html\\\" title=\\\"struct std::string::Drain\\\">Drain</a>&lt;'_&gt;</code></h3><pre><code><div class=\\\"where\\\">impl <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Drain.html\\\" title=\\\"struct std::string::Drain\\\">Drain</a>&lt;'_&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../primitive.char.html\\\">char</a>;</div>\",\"EncodeUtf16<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.EncodeUtf16.html\\\" title=\\\"struct std::str::EncodeUtf16\\\">EncodeUtf16</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.EncodeUtf16.html\\\" title=\\\"struct std::str::EncodeUtf16\\\">EncodeUtf16</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../primitive.u16.html\\\">u16</a>;</div>\",\"EscapeDebug<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.EscapeDebug.html\\\" title=\\\"struct std::str::EscapeDebug\\\">EscapeDebug</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.EscapeDebug.html\\\" title=\\\"struct std::str::EscapeDebug\\\">EscapeDebug</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../primitive.char.html\\\">char</a>;</div>\",\"EscapeDefault<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.EscapeDefault.html\\\" title=\\\"struct std::str::EscapeDefault\\\">EscapeDefault</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.EscapeDefault.html\\\" title=\\\"struct std::str::EscapeDefault\\\">EscapeDefault</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../primitive.char.html\\\">char</a>;</div>\",\"EscapeUnicode<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.EscapeUnicode.html\\\" title=\\\"struct std::str::EscapeUnicode\\\">EscapeUnicode</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.EscapeUnicode.html\\\" title=\\\"struct std::str::EscapeUnicode\\\">EscapeUnicode</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../primitive.char.html\\\">char</a>;</div>\",\"Lines<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.Lines.html\\\" title=\\\"struct std::str::Lines\\\">Lines</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.Lines.html\\\" title=\\\"struct std::str::Lines\\\">Lines</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"LinesAny<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.LinesAny.html\\\" title=\\\"struct std::str::LinesAny\\\">LinesAny</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.LinesAny.html\\\" title=\\\"struct std::str::LinesAny\\\">LinesAny</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"MatchIndices<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.MatchIndices.html\\\" title=\\\"struct std::str::MatchIndices\\\">MatchIndices</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.MatchIndices.html\\\" title=\\\"struct std::str::MatchIndices\\\">MatchIndices</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../primitive.usize.html\\\">usize</a>, &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>);</div>\",\"Matches<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.Matches.html\\\" title=\\\"struct std::str::Matches\\\">Matches</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.Matches.html\\\" title=\\\"struct std::str::Matches\\\">Matches</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"RMatchIndices<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.RMatchIndices.html\\\" title=\\\"struct std::str::RMatchIndices\\\">RMatchIndices</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.RMatchIndices.html\\\" title=\\\"struct std::str::RMatchIndices\\\">RMatchIndices</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,\\n    &lt;P as <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;&gt;::<a class=\\\"associatedtype\\\" href=\\\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\\\" title=\\\"type std::str::pattern::Pattern::Searcher\\\">Searcher</a>: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.ReverseSearcher.html\\\" title=\\\"trait std::str::pattern::ReverseSearcher\\\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../primitive.usize.html\\\">usize</a>, &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>);</div>\",\"RMatches<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.RMatches.html\\\" title=\\\"struct std::str::RMatches\\\">RMatches</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.RMatches.html\\\" title=\\\"struct std::str::RMatches\\\">RMatches</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,\\n    &lt;P as <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;&gt;::<a class=\\\"associatedtype\\\" href=\\\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\\\" title=\\\"type std::str::pattern::Pattern::Searcher\\\">Searcher</a>: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.ReverseSearcher.html\\\" title=\\\"trait std::str::pattern::ReverseSearcher\\\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"RSplit<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.RSplit.html\\\" title=\\\"struct std::str::RSplit\\\">RSplit</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.RSplit.html\\\" title=\\\"struct std::str::RSplit\\\">RSplit</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,\\n    &lt;P as <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;&gt;::<a class=\\\"associatedtype\\\" href=\\\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\\\" title=\\\"type std::str::pattern::Pattern::Searcher\\\">Searcher</a>: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.ReverseSearcher.html\\\" title=\\\"trait std::str::pattern::ReverseSearcher\\\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"RSplitN<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.RSplitN.html\\\" title=\\\"struct std::str::RSplitN\\\">RSplitN</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.RSplitN.html\\\" title=\\\"struct std::str::RSplitN\\\">RSplitN</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,\\n    &lt;P as <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;&gt;::<a class=\\\"associatedtype\\\" href=\\\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\\\" title=\\\"type std::str::pattern::Pattern::Searcher\\\">Searcher</a>: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.ReverseSearcher.html\\\" title=\\\"trait std::str::pattern::ReverseSearcher\\\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"RSplitTerminator<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.RSplitTerminator.html\\\" title=\\\"struct std::str::RSplitTerminator\\\">RSplitTerminator</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.RSplitTerminator.html\\\" title=\\\"struct std::str::RSplitTerminator\\\">RSplitTerminator</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,\\n    &lt;P as <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;&gt;::<a class=\\\"associatedtype\\\" href=\\\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\\\" title=\\\"type std::str::pattern::Pattern::Searcher\\\">Searcher</a>: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.ReverseSearcher.html\\\" title=\\\"trait std::str::pattern::ReverseSearcher\\\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"Split<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.Split.html\\\" title=\\\"struct std::str::Split\\\">Split</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.Split.html\\\" title=\\\"struct std::str::Split\\\">Split</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"SplitAsciiWhitespace<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.SplitAsciiWhitespace.html\\\" title=\\\"struct std::str::SplitAsciiWhitespace\\\">SplitAsciiWhitespace</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.SplitAsciiWhitespace.html\\\" title=\\\"struct std::str::SplitAsciiWhitespace\\\">SplitAsciiWhitespace</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"SplitInclusive<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.SplitInclusive.html\\\" title=\\\"struct std::str::SplitInclusive\\\">SplitInclusive</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.SplitInclusive.html\\\" title=\\\"struct std::str::SplitInclusive\\\">SplitInclusive</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"SplitN<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.SplitN.html\\\" title=\\\"struct std::str::SplitN\\\">SplitN</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.SplitN.html\\\" title=\\\"struct std::str::SplitN\\\">SplitN</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"SplitTerminator<'a, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.SplitTerminator.html\\\" title=\\\"struct std::str::SplitTerminator\\\">SplitTerminator</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, P&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.SplitTerminator.html\\\" title=\\\"struct std::str::SplitTerminator\\\">SplitTerminator</a>&lt;'a, P&gt;<div class=\\\"where\\\">where\\n    P: <a class=\\\"trait\\\" href=\\\"../str/pattern/trait.Pattern.html\\\" title=\\\"trait std::str::pattern::Pattern\\\">Pattern</a>&lt;'a&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"SplitWhitespace<'_>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../str/struct.SplitWhitespace.html\\\" title=\\\"struct std::str::SplitWhitespace\\\">SplitWhitespace</a>&lt;'a&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../str/struct.SplitWhitespace.html\\\" title=\\\"struct std::str::SplitWhitespace\\\">SplitWhitespace</a>&lt;'a&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &amp;'a <a class=\\\"primitive\\\" href=\\\"../primitive.str.html\\\">str</a>;</div>\",\"Vec<u8>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../vec/struct.Vec.html\\\" title=\\\"struct std::vec::Vec\\\">Vec</a>&lt;<a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;A: <a class=\\\"trait\\\" href=\\\"../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a>&gt; <a class=\\\"trait\\\" href=\\\"../io/trait.Write.html\\\" title=\\\"trait std::io::Write\\\">Write</a> for <a class=\\\"struct\\\" href=\\\"../vec/struct.Vec.html\\\" title=\\\"struct std::vec::Vec\\\">Vec</a>&lt;<a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>, A&gt;</div>\"}</script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:08:39.685Z"
}