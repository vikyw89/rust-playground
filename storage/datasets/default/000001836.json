{
	"title": "Patterns - The Rust Reference",
	"url": "https://doc.rust-lang.org/reference/patterns.html#wildcard-pattern",
	"markdown": "# Patterns - The Rust Reference\n\n> **Syntax**  \n> _Pattern_ :  \n>       `|`? _PatternNoTopAlt_ ( `|` _PatternNoTopAlt_ )\\*\n> \n> _PatternNoTopAlt_ :  \n>       _PatternWithoutRange_  \n>    | [_RangePattern_](#range-patterns)\n> \n> _PatternWithoutRange_ :  \n>       [_LiteralPattern_](#literal-patterns)  \n>    | [_IdentifierPattern_](#identifier-patterns)  \n>    | [_WildcardPattern_](#wildcard-pattern)  \n>    | [_RestPattern_](#rest-patterns)  \n>    | [_ReferencePattern_](#reference-patterns)  \n>    | [_StructPattern_](#struct-patterns)  \n>    | [_TupleStructPattern_](#tuple-struct-patterns)  \n>    | [_TuplePattern_](#tuple-patterns)  \n>    | [_GroupedPattern_](#grouped-patterns)  \n>    | [_SlicePattern_](#slice-patterns)  \n>    | [_PathPattern_](#path-patterns)  \n>    | [_MacroInvocation_](about:blank/macros.html#macro-invocation)\n\nPatterns are used to match values against structures and to, optionally, bind variables to values inside these structures. They are also used in variable declarations and parameters for functions and closures.\n\nThe pattern in the following example does four things:\n\n-   Tests if `person` has the `car` field filled with something.\n-   Tests if the person's `age` field is between 13 and 19, and binds its value to the `person_age` variable.\n-   Binds a reference to the `name` field to the variable `person_name`.\n-   Ignores the rest of the fields of `person`. The remaining fields can have any value and are not bound to any variables.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Car;\nstruct Computer;\nstruct Person {\n    name: String,\n    car: Option<Car>,\n    computer: Option<Computer>,\n    age: u8,\n}\nlet person = Person {\n    name: String::from(\"John\"),\n    car: Some(Car),\n    computer: None,\n    age: 15,\n};\nif let\n    Person {\n        car: Some(_),\n        age: person_age @ 13..=19,\n        name: ref person_name,\n        ..\n    } = person\n{\n    println!(\"{} has a car and is {} years old.\", person_name, person_age);\n}\n}\n```\n\nPatterns are used in:\n\n-   [`let` declarations](about:blank/statements.html#let-statements)\n-   [Function](items/functions.html) and [closure](expressions/closure-expr.html) parameters\n-   [`match` expressions](expressions/match-expr.html)\n-   [`if let` expressions](expressions/if-expr.html)\n-   [`while let` expressions](about:blank/expressions/loop-expr.html#predicate-pattern-loops)\n-   [`for` expressions](about:blank/expressions/loop-expr.html#iterator-loops)\n\n## [Destructuring](#destructuring)\n\nPatterns can be used to _destructure_ [structs](items/structs.html), [enums](items/enumerations.html), and [tuples](types/tuple.html). Destructuring breaks up a value into its component pieces. The syntax used is almost the same as when creating such values. In a pattern whose [scrutinee](about:blank/glossary.html#scrutinee) expression has a `struct`, `enum` or `tuple` type, a placeholder (`_`) stands in for a _single_ data field, whereas a wildcard `..` stands in for _all_ the remaining fields of a particular variant. When destructuring a data structure with named (but not numbered) fields, it is allowed to write `fieldname` as a shorthand for `fieldname: fieldname`.\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Message {\n    Quit,\n    WriteString(String),\n    Move { x: i32, y: i32 },\n    ChangeColor(u8, u8, u8),\n}\nlet message = Message::Quit;\nmatch message {\n    Message::Quit => println!(\"Quit\"),\n    Message::WriteString(write) => println!(\"{}\", &write),\n    Message::Move{ x, y: 0 } => println!(\"move {} horizontally\", x),\n    Message::Move{ .. } => println!(\"other move\"),\n    Message::ChangeColor { 0: red, 1: green, 2: _ } => {\n        println!(\"color change, red: {}, green: {}\", red, green);\n    }\n};\n}\n```\n\n## [Refutability](#refutability)\n\nA pattern is said to be _refutable_ when it has the possibility of not being matched by the value it is being matched against. _Irrefutable_ patterns, on the other hand, always match the value they are being matched against. Examples:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet (x, y) = (1, 2);               // \"(x, y)\" is an irrefutable pattern\n\nif let (a, 3) = (1, 2) {           // \"(a, 3)\" is refutable, and will not match\n    panic!(\"Shouldn't reach here\");\n} else if let (a, 4) = (3, 4) {    // \"(a, 4)\" is refutable, and will match\n    println!(\"Matched ({}, 4)\", a);\n}\n}\n```\n\n## [Literal patterns](#literal-patterns)\n\n> **Syntax**  \n> _LiteralPattern_ :  \n>       `true` | `false`  \n>    | [CHAR\\_LITERAL](about:blank/tokens.html#character-literals)  \n>    | [BYTE\\_LITERAL](about:blank/tokens.html#byte-literals)  \n>    | [STRING\\_LITERAL](about:blank/tokens.html#string-literals)  \n>    | [RAW\\_STRING\\_LITERAL](about:blank/tokens.html#raw-string-literals)  \n>    | [BYTE\\_STRING\\_LITERAL](about:blank/tokens.html#byte-string-literals)  \n>    | [RAW\\_BYTE\\_STRING\\_LITERAL](about:blank/tokens.html#raw-byte-string-literals)  \n>    | [C\\_STRING\\_LITERAL](about:blank/tokens.html#c-string-literals)  \n>    | [RAW\\_C\\_STRING\\_LITERAL](about:blank/tokens.html#raw-c-string-literals)  \n>    | `-`? [INTEGER\\_LITERAL](about:blank/tokens.html#integer-literals)  \n>    | `-`? [FLOAT\\_LITERAL](about:blank/tokens.html#floating-point-literals)\n\n_Literal patterns_ match exactly the same value as what is created by the literal. Since negative numbers are not [literals](expressions/literal-expr.html), literal patterns also accept an optional minus sign before the literal, which acts like the negation operator.\n\nC string and raw C string literals are accepted in literal patterns, but `&CStr` doesn't implement structural equality (`#[derive(Eq, PartialEq)]`) and therefore any such `match` on a `&CStr` will be rejected with a type error.\n\nLiteral patterns are always refutable.\n\nExamples:\n\n```rust\n#![allow(unused)]\nfn main() {\nfor i in -2..5 {\n    match i {\n        -1 => println!(\"It's minus one\"),\n        1 => println!(\"It's a one\"),\n        2|4 => println!(\"It's either a two or a four\"),\n        _ => println!(\"Matched none of the arms\"),\n    }\n}\n}\n```\n\n## [Identifier patterns](#identifier-patterns)\n\n> **Syntax**  \n> _IdentifierPattern_ :  \n>       `ref`? `mut`? [IDENTIFIER](identifiers.html) (`@` [_PatternNoTopAlt_](#patterns) ) ?\n\nIdentifier patterns bind the value they match to a variable. The identifier must be unique within the pattern. The variable will shadow any variables of the same name in scope. The [scope](names/scopes.html) of the new binding depends on the context of where the pattern is used (such as a `let` binding or a `match` arm).\n\nPatterns that consist of only an identifier, possibly with a `mut`, match any value and bind it to that identifier. This is the most commonly used pattern in variable declarations and parameters for functions and closures.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut variable = 10;\nfn sum(x: i32, y: i32) -> i32 {\n   x + y\n}\n}\n```\n\nTo bind the matched value of a pattern to a variable, use the syntax `variable @ subpattern`. For example, the following binds the value 2 to `e` (not the entire range: the range here is a range subpattern).\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = 2;\n\nmatch x {\n    e @ 1 ..= 5 => println!(\"got a range element {}\", e),\n    _ => println!(\"anything\"),\n}\n}\n```\n\nBy default, identifier patterns bind a variable to a copy of or move from the matched value depending on whether the matched value implements [`Copy`](about:blank/special-types-and-traits.html#copy). This can be changed to bind to a reference by using the `ref` keyword, or to a mutable reference using `ref mut`. For example:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet a = Some(10);\nmatch a {\n    None => (),\n    Some(value) => (),\n}\n\nmatch a {\n    None => (),\n    Some(ref value) => (),\n}\n}\n```\n\nIn the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the `&` operator can't be applied to the value's fields. For example, the following is not valid:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Person {\n   name: String,\n   age: u8,\n}\nlet value = Person { name: String::from(\"John\"), age: 23 };\nif let Person { name: &person_name, age: 18..=150 } = value { }\n}\n```\n\nTo make it valid, write the following:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Person {\n   name: String,\n   age: u8,\n}\nlet value = Person { name: String::from(\"John\"), age: 23 };\nif let Person {name: ref person_name, age: 18..=150 } = value { }\n}\n```\n\nThus, `ref` is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.\n\n[Path patterns](#path-patterns) take precedence over identifier patterns. It is an error if `ref` or `ref mut` is specified and the identifier shadows a constant.\n\nIdentifier patterns are irrefutable if the `@` subpattern is irrefutable or the subpattern is not specified.\n\n### [Binding modes](#binding-modes)\n\nTo service better ergonomics, patterns operate in different _binding modes_ in order to make it easier to bind references to values. When a reference value is matched by a non-reference pattern, it will be automatically treated as a `ref` or `ref mut` binding. Example:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x: &Option<i32> = &Some(3);\nif let Some(y) = x {\n    // y was converted to `ref y` and its type is &i32\n}\n}\n```\n\n_Non-reference patterns_ include all patterns except bindings, [wildcard patterns](#wildcard-pattern) (`_`), [`const` patterns](#path-patterns) of reference types, and [reference patterns](#reference-patterns).\n\nIf a binding pattern does not explicitly have `ref`, `ref mut`, or `mut`, then it uses the _default binding mode_ to determine how the variable is bound. The default binding mode starts in \"move\" mode which uses move semantics. When matching a pattern, the compiler starts from the outside of the pattern and works inwards. Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. References will set the default binding mode to `ref`. Mutable references will set the mode to `ref mut` unless the mode is already `ref` in which case it remains `ref`. If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.\n\nMove bindings and reference bindings can be mixed together in the same pattern. Doing so will result in partial move of the object bound to and the object cannot be used afterwards. This applies only if the type cannot be copied.\n\nIn the example below, `name` is moved out of `person`. Trying to use `person` as a whole or `person.name` would result in an error because of _partial move_.\n\nExample:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Person {\n   name: String,\n   age: u8,\n}\nlet person = Person{ name: String::from(\"John\"), age: 23 };\n// `name` is moved from person and `age` referenced\nlet Person { name, ref age } = person;\n}\n```\n\n## [Wildcard pattern](#wildcard-pattern)\n\n> **Syntax**  \n> _WildcardPattern_ :  \n>    `_`\n\nThe _wildcard pattern_ (an underscore symbol) matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the `..` which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.\n\nExamples:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = 20;\nlet (a, _) = (10, x);   // the x is always matched by _\nassert_eq!(a, 10);\n\n// ignore a function/closure param\nlet real_part = |a: f64, _: f64| { a };\n\n// ignore a field from a struct\nstruct RGBA {\n   r: f32,\n   g: f32,\n   b: f32,\n   a: f32,\n}\nlet color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};\nlet RGBA{r: red, g: green, b: blue, a: _} = color;\nassert_eq!(color.r, red);\nassert_eq!(color.g, green);\nassert_eq!(color.b, blue);\n\n// accept any Some, with any value\nlet x = Some(10);\nif let Some(_) = x {}\n}\n```\n\nThe wildcard pattern is always irrefutable.\n\n## [Rest patterns](#rest-patterns)\n\n> **Syntax**  \n> _RestPattern_ :  \n>    `..`\n\nThe _rest pattern_ (the `..` token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after. It may only be used in [tuple](#tuple-patterns), [tuple struct](#tuple-struct-patterns), and [slice](#slice-patterns) patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an [identifier pattern](#identifier-patterns) for [slice patterns](#slice-patterns) only.\n\nThe rest pattern is always irrefutable.\n\nExamples:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet words = vec![\"a\", \"b\", \"c\"];\nlet slice = &words[..];\nmatch slice {\n    [] => println!(\"slice is empty\"),\n    [one] => println!(\"single element {}\", one),\n    [head, tail @ ..] => println!(\"head={} tail={:?}\", head, tail),\n}\n\nmatch slice {\n    // Ignore everything but the last element, which must be \"!\".\n    [.., \"!\"] => println!(\"!!!\"),\n\n    // `start` is a slice of everything except the last element, which must be \"z\".\n    [start @ .., \"z\"] => println!(\"starts with: {:?}\", start),\n\n    // `end` is a slice of everything but the first element, which must be \"a\".\n    [\"a\", end @ ..] => println!(\"ends with: {:?}\", end),\n\n    // 'whole' is the entire slice and `last` is the final element\n    whole @ [.., last] => println!(\"the last element of {:?} is {}\", whole, last),\n\n    rest => println!(\"{:?}\", rest),\n}\n\nif let [.., penultimate, _] = slice {\n    println!(\"next to last is {}\", penultimate);\n}\n\nlet tuple = (1, 2, 3, 4, 5);\n// Rest patterns may also be used in tuple and tuple struct patterns.\nmatch tuple {\n    (1, .., y, z) => println!(\"y={} z={}\", y, z),\n    (.., 5) => println!(\"tail must be 5\"),\n    (..) => println!(\"matches everything else\"),\n}\n}\n```\n\n## [Range patterns](#range-patterns)\n\n> **Syntax**  \n> _RangePattern_ :  \n>       _RangeInclusivePattern_  \n>    | _RangeFromPattern_  \n>    | _RangeToInclusivePattern_  \n>    | _ObsoleteRangePattern_\n> \n> _RangeExclusivePattern_ :  \n>       _RangePatternBound_ `..` _RangePatternBound_\n> \n> _RangeInclusivePattern_ :  \n>       _RangePatternBound_ `..=` _RangePatternBound_\n> \n> _RangeFromPattern_ :  \n>       _RangePatternBound_ `..`\n> \n> _RangeToInclusivePattern_ :  \n>       `..=` _RangePatternBound_\n> \n> _ObsoleteRangePattern_ :  \n>    _RangePatternBound_ `...` _RangePatternBound_\n> \n> _RangePatternBound_ :  \n>       [CHAR\\_LITERAL](about:blank/tokens.html#character-literals)  \n>    | [BYTE\\_LITERAL](about:blank/tokens.html#byte-literals)  \n>    | `-`? [INTEGER\\_LITERAL](about:blank/tokens.html#integer-literals)  \n>    | `-`? [FLOAT\\_LITERAL](about:blank/tokens.html#floating-point-literals)  \n>    | [_PathExpression_](expressions/path-expr.html)\n\n_Range patterns_ match scalar values within the range defined by their bounds. They comprise a _sigil_ (one of `..`, `..=`, or `...`) and a bound on one or both sides. A bound on the left of the sigil is a _lower bound_. A bound on the right is an _upper bound_.\n\nA range pattern with both a lower and upper bound will match all values between and including both of its bounds. It is written as its lower bound, followed by `..` for end-exclusive or `..=` for end-inclusive, followed by its upper bound. The type of the range pattern is the type unification of its upper and lower bounds.\n\nFor example, a pattern `'m'..='p'` will match only the values `'m'`, `'n'`, `'o'`, and `'p'`. Similarly, `'m'..'p'` will match only `'m'`, `'n'` and `'o'`, specifically **not** including `'p'`.\n\nThe lower bound cannot be greater than the upper bound. That is, in `a..=b`, a ≤ b must be the case. For example, it is an error to have a range pattern `10..=0`.\n\nA range pattern with only a lower bound will match any value greater than or equal to the lower bound. It is written as its lower bound followed by `..`, and has the same type as its lower bound. For example, `1..` will match 1, 9, or 9001, or 9007199254740991 (if it is of an appropriate size), but not 0, and not negative numbers for signed integers.\n\nA range pattern with only an upper bound matches any value less than or equal to the upper bound. It is written as `..=` followed by its upper bound, and has the same type as its upper bound. For example, `..=10` will match 10, 1, 0, and for signed integer types, all negative values.\n\nRange patterns with only one bound cannot be used as the top-level pattern for subpatterns in [slice patterns](#slice-patterns).\n\nThe bounds is written as one of:\n\n-   A character, byte, integer, or float literal.\n-   A `-` followed by an integer or float literal.\n-   A [path](expressions/path-expr.html)\n\nIf the bounds is written as a path, after macro resolution, the path must resolve to a constant item of the type `char`, an integer type, or a float type.\n\nThe type and value of the bounds is dependent upon how it is written out. If the bounds is a [path](expressions/path-expr.html), the pattern has the type and value of the [constant](items/constant-items.html) the path resolves to. For float range patterns, the constant may not be a `NaN`. If it is a literal, it has the type and value of the corresponding [literal expression](expressions/literal-expr.html). If is a literal preceded by a `-`, it has the same type as the corresponding [literal expression](expressions/literal-expr.html) and the value of [negating](about:blank/expressions/operator-expr.html#negation-operators) the value of the corresponding literal expression.\n\nExamples:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet c = 'f';\nlet valid_variable = match c {\n    'a'..='z' => true,\n    'A'..='Z' => true,\n    'α'..='ω' => true,\n    _ => false,\n};\n\nlet ph = 10;\nprintln!(\"{}\", match ph {\n    0..7 => \"acid\",\n    7 => \"neutral\",\n    8..=14 => \"base\",\n    _ => unreachable!(),\n});\n\nlet uint: u32 = 5;\nmatch uint {\n    0 => \"zero!\",\n    1.. => \"positive number!\",\n};\n\n// using paths to constants:\nconst TROPOSPHERE_MIN : u8 = 6;\nconst TROPOSPHERE_MAX : u8 = 20;\n\nconst STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;\nconst STRATOSPHERE_MAX : u8 = 50;\n\nconst MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;\nconst MESOSPHERE_MAX : u8 = 85;\n\nlet altitude = 70;\n\nprintln!(\"{}\", match altitude {\n    TROPOSPHERE_MIN..=TROPOSPHERE_MAX => \"troposphere\",\n    STRATOSPHERE_MIN..=STRATOSPHERE_MAX => \"stratosphere\",\n    MESOSPHERE_MIN..=MESOSPHERE_MAX => \"mesosphere\",\n    _ => \"outer space, maybe\",\n});\n\npub mod binary {\n    pub const MEGA : u64 = 1024*1024;\n    pub const GIGA : u64 = 1024*1024*1024;\n}\nlet n_items = 20_832_425;\nlet bytes_per_item = 12;\nif let size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item {\n    println!(\"It fits and occupies {} bytes\", size);\n}\n\ntrait MaxValue {\n    const MAX: u64;\n}\nimpl MaxValue for u8 {\n    const MAX: u64 = (1 << 8) - 1;\n}\nimpl MaxValue for u16 {\n    const MAX: u64 = (1 << 16) - 1;\n}\nimpl MaxValue for u32 {\n    const MAX: u64 = (1 << 32) - 1;\n}\n// using qualified paths:\nprintln!(\"{}\", match 0xfacade {\n    0 ..= <u8 as MaxValue>::MAX => \"fits in a u8\",\n    0 ..= <u16 as MaxValue>::MAX => \"fits in a u16\",\n    0 ..= <u32 as MaxValue>::MAX => \"fits in a u32\",\n    _ => \"too big\",\n});\n}\n```\n\nRange patterns for fix-width integer and `char` types are irrefutable when they span the entire set of possible values of a type. For example, `0u8..=255u8` is irrefutable. The range of values for an integer type is the closed range from its minimum to maximum value. The range of values for a `char` type are precisely those ranges containing all Unicode Scalar Values: `'\\u{0000}'..='\\u{D7FF}'` and `'\\u{E000}'..='\\u{10FFFF}'`.\n\n> **Edition Differences**: Before the 2021 edition, range patterns with both a lower and upper bound may also be written using `...` in place of `..=`, with the same meaning.\n\n## [Reference patterns](#reference-patterns)\n\n> **Syntax**  \n> _ReferencePattern_ :  \n>    (`&`|`&&`) `mut`? [_PatternWithoutRange_](#patterns)\n\nReference patterns dereference the pointers that are being matched and, thus, borrow them.\n\nFor example, these two matches on `x: &i32` are equivalent:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet int_reference = &3;\n\nlet a = match *int_reference { 0 => \"zero\", _ => \"some\" };\nlet b = match int_reference { &0 => \"zero\", _ => \"some\" };\n\nassert_eq!(a, b);\n}\n```\n\nThe grammar production for reference patterns has to match the token `&&` to match a reference to a reference because it is a token by itself, not two `&` tokens.\n\nAdding the `mut` keyword dereferences a mutable reference. The mutability must match the mutability of the reference.\n\nReference patterns are always irrefutable.\n\n## [Struct patterns](#struct-patterns)\n\n> **Syntax**  \n> _StructPattern_ :  \n>    [_PathInExpression_](about:blank/paths.html#paths-in-expressions) `{`  \n>       _StructPatternElements_ ?  \n>    `}`\n> \n> _StructPatternElements_ :  \n>       _StructPatternFields_ (`,` | `,` _StructPatternEtCetera_)?  \n>    | _StructPatternEtCetera_\n> \n> _StructPatternFields_ :  \n>    _StructPatternField_ (`,` _StructPatternField_) \\*\n> \n> _StructPatternField_ :  \n>    [_OuterAttribute_](attributes.html) \\*  \n>    (  \n>          [TUPLE\\_INDEX](about:blank/tokens.html#tuple-index) `:` [_Pattern_](#patterns)  \n>       | [IDENTIFIER](identifiers.html) `:` [_Pattern_](#patterns)  \n>       | `ref`? `mut`? [IDENTIFIER](identifiers.html)  \n>    )\n> \n> _StructPatternEtCetera_ :  \n>    [_OuterAttribute_](attributes.html) \\*  \n>    `..`\n\nStruct patterns match struct, enum, and union values that match all criteria defined by its subpatterns. They are also used to [destructure](#destructuring) a struct, enum, or union value.\n\nOn a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of `..`:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Point {\n    x: u32,\n    y: u32,\n}\nlet s = Point {x: 1, y: 1};\n\nmatch s {\n    Point {x: 10, y: 20} => (),\n    Point {y: 10, x: 20} => (),    // order doesn't matter\n    Point {x: 10, ..} => (),\n    Point {..} => (),\n}\n\nstruct PointTuple (\n    u32,\n    u32,\n);\nlet t = PointTuple(1, 2);\n\nmatch t {\n    PointTuple {0: 10, 1: 20} => (),\n    PointTuple {1: 10, 0: 20} => (),   // order doesn't matter\n    PointTuple {0: 10, ..} => (),\n    PointTuple {..} => (),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n}\nlet m = Message::Quit;\n\nmatch m {\n    Message::Quit => (),\n    Message::Move {x: 10, y: 20} => (),\n    Message::Move {..} => (),\n}\n}\n```\n\nIf `..` is not used, a struct pattern used to match a struct is required to specify all fields:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Struct {\n   a: i32,\n   b: char,\n   c: bool,\n}\nlet mut struct_value = Struct{a: 10, b: 'X', c: false};\n\nmatch struct_value {\n    Struct{a: 10, b: 'X', c: false} => (),\n    Struct{a: 10, b: 'X', ref c} => (),\n    Struct{a: 10, b: 'X', ref mut c} => (),\n    Struct{a: 10, b: 'X', c: _} => (),\n    Struct{a: _, b: _, c: _} => (),\n}\n}\n```\n\nA struct pattern used to match a union must specify exactly one field (see [Pattern matching on unions](about:blank/items/unions.html#pattern-matching-on-unions)).\n\nThe `ref` and/or `mut` _IDENTIFIER_ syntax matches any value and binds it to a variable with the same name as the given field.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Struct {\n   a: i32,\n   b: char,\n   c: bool,\n}\nlet struct_value = Struct{a: 10, b: 'X', c: false};\n\nlet Struct{a: x, b: y, c: z} = struct_value;          // destructure all fields\n}\n```\n\nA struct pattern is refutable if the _PathInExpression_ resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable.\n\n## [Tuple struct patterns](#tuple-struct-patterns)\n\n> **Syntax**  \n> _TupleStructPattern_ :  \n>    [_PathInExpression_](about:blank/paths.html#paths-in-expressions) `(` _TupleStructItems_? `)`\n> \n> _TupleStructItems_ :  \n>    [_Pattern_](#patterns) ( `,` [_Pattern_](#patterns) )\\* `,`?\n\nTuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to [destructure](#destructuring) a tuple struct or enum value.\n\nA tuple struct pattern is refutable if the _PathInExpression_ resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable.\n\n## [Tuple patterns](#tuple-patterns)\n\n> **Syntax**  \n> _TuplePattern_ :  \n>    `(` _TuplePatternItems_? `)`\n> \n> _TuplePatternItems_ :  \n>       [_Pattern_](#patterns) `,`  \n>    | [_RestPattern_](#rest-patterns)  \n>    | [_Pattern_](#patterns) (`,` [_Pattern_](#patterns))+ `,`?\n\nTuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to [destructure](#destructuring) a tuple.\n\nThe form `(..)` with a single [_RestPattern_](#rest-patterns) is a special form that does not require a comma, and matches a tuple of any size.\n\nThe tuple pattern is refutable when one of its subpatterns is refutable.\n\nAn example of using tuple patterns:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet pair = (10, \"ten\");\nlet (a, b) = pair;\n\nassert_eq!(a, 10);\nassert_eq!(b, \"ten\");\n}\n```\n\n## [Grouped patterns](#grouped-patterns)\n\n> **Syntax**  \n> _GroupedPattern_ :  \n>    `(` [_Pattern_](#patterns) `)`\n\nEnclosing a pattern in parentheses can be used to explicitly control the precedence of compound patterns. For example, a reference pattern next to a range pattern such as `&0..=5` is ambiguous and is not allowed, but can be expressed with parentheses.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet int_reference = &3;\nmatch int_reference {\n    &(0..=5) => (),\n    _ => (),\n}\n}\n```\n\n## [Slice patterns](#slice-patterns)\n\n> **Syntax**  \n> _SlicePattern_ :  \n>    `[` _SlicePatternItems_? `]`\n> \n> _SlicePatternItems_ :  \n>    [_Pattern_](#patterns) (`,` [_Pattern_](#patterns))\\* `,`?\n\nSlice patterns can match both arrays of fixed size and slices of dynamic size.\n\n```rust\n#![allow(unused)]\nfn main() {\n// Fixed size\nlet arr = [1, 2, 3];\nmatch arr {\n    [1, _, _] => \"starts with one\",\n    [a, b, c] => \"starts with something else\",\n};\n}\n```\n\n```rust\n#![allow(unused)]\nfn main() {\n// Dynamic size\nlet v = vec![1, 2, 3];\nmatch v[..] {\n    [a, b] => { /* this arm will not apply because the length doesn't match */ }\n    [a, b, c] => { /* this arm will apply */ }\n    _ => { /* this wildcard is required, since the length is not known statically */ }\n};\n}\n```\n\nSlice patterns are irrefutable when matching an array as long as each element is irrefutable. When matching a slice, it is irrefutable only in the form with a single `..` [rest pattern](#rest-patterns) or [identifier pattern](#identifier-patterns) with the `..` rest pattern as a subpattern.\n\nWithin a slice, a range pattern without both lower and upper bound must be enclosed in parentheses, as in `(a..)`, to clarify it is intended to match against a single slice element. A range pattern with both lower and upper bound, like `a..=b`, is not required to be enclosed in parentheses.\n\n## [Path patterns](#path-patterns)\n\n> **Syntax**  \n> _PathPattern_ :  \n>       [_PathExpression_](expressions/path-expr.html)\n\n_Path patterns_ are patterns that refer either to constant values or to structs or enum variants that have no fields.\n\nUnqualified path patterns can refer to:\n\n-   enum variants\n-   structs\n-   constants\n-   associated constants\n\nQualified path patterns can only refer to associated constants.\n\nPath patterns are irrefutable when they refer to structs or an enum variant when the enum has only one variant or a constant whose type is irrefutable. They are refutable when they refer to refutable constants or enum variants for enums with multiple variants.\n\n### [Constant patterns](#constant-patterns)\n\nWhen a constant `C` of type `T` is used as a pattern, we first check that `T: PartialEq`. Furthermore we require that the value of `C` _has (recursive) structural equality_, which is defined recursively as follows:\n\n-   Integers as well as `str`, `bool` and `char` values always have structural equality.\n-   Tuples, arrays, and slices have structural equality if all their fields/elements have structural equality. (In particular, `()` and `[]` always have structural equality.)\n-   References have structural equality if the value they point to has structural equality.\n-   A value of `struct` or `enum` type has structural equality if its `PartialEq` instance is derived via `#[derive(PartialEq)]`, and all fields (for enums: of the active variant) have structural equality.\n-   A raw pointer has structural equality if it was defined as a constant integer (and then cast/transmuted).\n-   A float value has structural equality if it is not a `NaN`.\n-   Nothing else has structural equality.\n\nIn particular, the value of `C` must be known at pattern-building time (which is pre-monomorphization). This means that associated consts that involve generic parameters cannot be used as patterns.\n\nAfter ensuring all conditions are met, the constant value is translated into a pattern, and now behaves exactly as-if that pattern had been written directly. In particular, it fully participates in exhaustiveness checking. (For raw pointers, constants are the only way to write such patterns. Only `_` is ever considered exhaustive for these types.)\n\n## [Or-patterns](#or-patterns)\n\n_Or-patterns_ are patterns that match on one of two or more sub-patterns (for example `A | B | C`). They can nest arbitrarily. Syntactically, or-patterns are allowed in any of the places where other patterns are allowed (represented by the _Pattern_ production), with the exceptions of `let`\\-bindings and function and closure arguments (represented by the _PatternNoTopAlt_ production).\n\n### [Static semantics](#static-semantics)\n\n1.  Given a pattern `p | q` at some depth for some arbitrary patterns `p` and `q`, the pattern is considered ill-formed if:\n    \n    -   the type inferred for `p` does not unify with the type inferred for `q`, or\n    -   the same set of bindings are not introduced in `p` and `q`, or\n    -   the type of any two bindings with the same name in `p` and `q` do not unify with respect to types or binding modes.\n    \n    Unification of types is in all instances aforementioned exact and implicit [type coercions](type-coercions.html) do not apply.\n    \n2.  When type checking an expression `match e_s { a_1 => e_1, ... a_n => e_n }`, for each match arm `a_i` which contains a pattern of form `p_i | q_i`, the pattern `p_i | q_i` is considered ill formed if, at the depth `d` where it exists the fragment of `e_s` at depth `d`, the type of the expression fragment does not unify with `p_i | q_i`.\n    \n3.  With respect to exhaustiveness checking, a pattern `p | q` is considered to cover `p` as well as `q`. For some constructor `c(x, ..)` the distributive law applies such that `c(p | q, ..rest)` covers the same set of value as `c(p, ..rest) | c(q, ..rest)` does. This can be applied recursively until there are no more nested patterns of form `p | q` other than those that exist at the top level.\n    \n    Note that by _\"constructor\"_ we do not refer to tuple struct patterns, but rather we refer to a pattern for any product type. This includes enum variants, tuple structs, structs with named fields, arrays, tuples, and slices.\n    \n\n### [Dynamic semantics](#dynamic-semantics)\n\n1.  The dynamic semantics of pattern matching a scrutinee expression `e_s` against a pattern `c(p | q, ..rest)` at depth `d` where `c` is some constructor, `p` and `q` are arbitrary patterns, and `rest` is optionally any remaining potential factors in `c`, is defined as being the same as that of `c(p, ..rest) | c(q, ..rest)`.\n\n### [Precedence with other undelimited patterns](#precedence-with-other-undelimited-patterns)\n\nAs shown elsewhere in this chapter, there are several types of patterns that are syntactically undelimited, including identifier patterns, reference patterns, and or-patterns. Or-patterns always have the lowest-precedence. This allows us to reserve syntactic space for a possible future type ascription feature and also to reduce ambiguity. For example, `x @ A(..) | B(..)` will result in an error that `x` is not bound in all patterns. `&A(x) | B(x)` will result in a type mismatch between `x` in the different subpatterns.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Patterns - The Rust Reference</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/reference.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"notation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Notation</a></li><li class=\"chapter-item expanded \"><a href=\"lexical-structure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Lexical structure</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"input-format.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Input format</a></li><li class=\"chapter-item expanded \"><a href=\"keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"identifiers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Identifiers</a></li><li class=\"chapter-item expanded \"><a href=\"comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"whitespace.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Whitespace</a></li><li class=\"chapter-item expanded \"><a href=\"tokens.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Tokens</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Macros</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macros-by-example.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Macros By Example</a></li><li class=\"chapter-item expanded \"><a href=\"procedural-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Procedural Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"crates-and-source-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Crates and source files</a></li><li class=\"chapter-item expanded \"><a href=\"conditional-compilation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Conditional compilation</a></li><li class=\"chapter-item expanded \"><a href=\"items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Items</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"items/modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Modules</a></li><li class=\"chapter-item expanded \"><a href=\"items/extern-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Extern crates</a></li><li class=\"chapter-item expanded \"><a href=\"items/use-declarations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Use declarations</a></li><li class=\"chapter-item expanded \"><a href=\"items/functions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.4.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"items/type-aliases.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.5.</strong> Type aliases</a></li><li class=\"chapter-item expanded \"><a href=\"items/structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.6.</strong> Structs</a></li><li class=\"chapter-item expanded \"><a href=\"items/enumerations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.7.</strong> Enumerations</a></li><li class=\"chapter-item expanded \"><a href=\"items/unions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.8.</strong> Unions</a></li><li class=\"chapter-item expanded \"><a href=\"items/constant-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.9.</strong> Constant items</a></li><li class=\"chapter-item expanded \"><a href=\"items/static-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.10.</strong> Static items</a></li><li class=\"chapter-item expanded \"><a href=\"items/traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.11.</strong> Traits</a></li><li class=\"chapter-item expanded \"><a href=\"items/implementations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.12.</strong> Implementations</a></li><li class=\"chapter-item expanded \"><a href=\"items/external-blocks.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.13.</strong> External blocks</a></li><li class=\"chapter-item expanded \"><a href=\"items/generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.14.</strong> Generic parameters</a></li><li class=\"chapter-item expanded \"><a href=\"items/associated-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.15.</strong> Associated Items</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"attributes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Attributes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"attributes/testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Testing</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/derive.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Derive</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/diagnostics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Diagnostics</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/codegen.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Code generation</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/limits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Limits</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/type_system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.6.</strong> Type System</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/debugger.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.7.</strong> Debugger</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"statements-and-expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Statements and expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"statements.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Statements</a></li><li class=\"chapter-item expanded \"><a href=\"expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"expressions/literal-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.1.</strong> Literal expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/path-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.2.</strong> Path expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/block-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.3.</strong> Block expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/operator-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.4.</strong> Operator expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/grouped-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.5.</strong> Grouped expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/array-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.6.</strong> Array and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/tuple-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.7.</strong> Tuple and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/struct-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.8.</strong> Struct expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.9.</strong> Call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/method-call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.10.</strong> Method call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/field-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.11.</strong> Field access expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/closure-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.12.</strong> Closure expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/loop-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.13.</strong> Loop expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/range-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.14.</strong> Range expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/if-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.15.</strong> If and if let expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/match-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.16.</strong> Match expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/return-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.17.</strong> Return expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/await-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.18.</strong> Await expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/underscore-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.19.</strong> Underscore expressions</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"patterns.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Patterns</a></li><li class=\"chapter-item expanded \"><a href=\"type-system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Type system</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Types</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types/boolean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Boolean type</a></li><li class=\"chapter-item expanded \"><a href=\"types/numeric.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Numeric types</a></li><li class=\"chapter-item expanded \"><a href=\"types/textual.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Textual types</a></li><li class=\"chapter-item expanded \"><a href=\"types/never.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Never type</a></li><li class=\"chapter-item expanded \"><a href=\"types/tuple.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Tuple types</a></li><li class=\"chapter-item expanded \"><a href=\"types/array.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.6.</strong> Array types</a></li><li class=\"chapter-item expanded \"><a href=\"types/slice.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.7.</strong> Slice types</a></li><li class=\"chapter-item expanded \"><a href=\"types/struct.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.8.</strong> Struct types</a></li><li class=\"chapter-item expanded \"><a href=\"types/enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.9.</strong> Enumerated types</a></li><li class=\"chapter-item expanded \"><a href=\"types/union.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.10.</strong> Union types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-item.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.11.</strong> Function item types</a></li><li class=\"chapter-item expanded \"><a href=\"types/closure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.12.</strong> Closure types</a></li><li class=\"chapter-item expanded \"><a href=\"types/pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.13.</strong> Pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.14.</strong> Function pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/trait-object.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.15.</strong> Trait object types</a></li><li class=\"chapter-item expanded \"><a href=\"types/impl-trait.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.16.</strong> Impl trait type</a></li><li class=\"chapter-item expanded \"><a href=\"types/parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.17.</strong> Type parameters</a></li><li class=\"chapter-item expanded \"><a href=\"types/inferred.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.18.</strong> Inferred type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"dynamically-sized-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Dynamically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"type-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Type layout</a></li><li class=\"chapter-item expanded \"><a href=\"interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.4.</strong> Interior mutability</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.5.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"trait-bounds.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.6.</strong> Trait and lifetime bounds</a></li><li class=\"chapter-item expanded \"><a href=\"type-coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.7.</strong> Type coercions</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.8.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.9.</strong> Lifetime elision</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"special-types-and-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Special types and traits</a></li><li class=\"chapter-item expanded \"><a href=\"names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Names</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"names/namespaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Namespaces</a></li><li class=\"chapter-item expanded \"><a href=\"names/scopes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Scopes</a></li><li class=\"chapter-item expanded \"><a href=\"names/preludes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Preludes</a></li><li class=\"chapter-item expanded \"><a href=\"paths.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Paths</a></li><li class=\"chapter-item expanded \"><a href=\"names/name-resolution.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Name resolution</a></li><li class=\"chapter-item expanded \"><a href=\"visibility-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Visibility and privacy</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"memory-model.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Memory model</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"memory-allocation-and-lifetime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Memory allocation and lifetime</a></li><li class=\"chapter-item expanded \"><a href=\"variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Variables</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"linkage.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> Linkage</a></li><li class=\"chapter-item expanded \"><a href=\"inline-assembly.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Inline assembly</a></li><li class=\"chapter-item expanded \"><a href=\"unsafety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Unsafety</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"unsafe-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> The unsafe keyword</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-considered-undefined.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Behavior considered undefined</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-not-considered-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Behavior not considered unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"const_eval.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Constant Evaluation</a></li><li class=\"chapter-item expanded \"><a href=\"abi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Application Binary Interface</a></li><li class=\"chapter-item expanded \"><a href=\"runtime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> The Rust runtime</a></li><li class=\"chapter-item expanded \"><a href=\"appendices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Appendices</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macro-ambiguity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class=\"chapter-item expanded \"><a href=\"influences.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Influences</a></li><li class=\"chapter-item expanded \"><a href=\"glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Glossary</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar bordered\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Reference</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/edit/master/src/patterns.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"patterns\"><a class=\"header\" href=\"#patterns\">Patterns</a></h1>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>Pattern</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <code class=\"hljs\">|</code><sup>?</sup> <em>PatternNoTopAlt</em>  ( <code class=\"hljs\">|</code> <em>PatternNoTopAlt</em> )<sup>*</sup></p>\n<p><em>PatternNoTopAlt</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <em>PatternWithoutRange</em><br>\n&nbsp;&nbsp; | <a href=\"#range-patterns\"><em>RangePattern</em></a></p>\n<p><em>PatternWithoutRange</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"#literal-patterns\"><em>LiteralPattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#identifier-patterns\"><em>IdentifierPattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#wildcard-pattern\"><em>WildcardPattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#rest-patterns\"><em>RestPattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#reference-patterns\"><em>ReferencePattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#struct-patterns\"><em>StructPattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#tuple-struct-patterns\"><em>TupleStructPattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#tuple-patterns\"><em>TuplePattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#grouped-patterns\"><em>GroupedPattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#slice-patterns\"><em>SlicePattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#path-patterns\"><em>PathPattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"macros.html#macro-invocation\"><em>MacroInvocation</em></a></p>\n</blockquote>\n<p>Patterns are used to match values against structures and to, optionally, bind variables to values inside these structures.\nThey are also used in variable declarations and parameters for functions and closures.</p>\n<p>The pattern in the following example does four things:</p>\n<ul>\n<li>Tests if <code class=\"hljs\">person</code> has the <code class=\"hljs\">car</code> field filled with something.</li>\n<li>Tests if the person's <code class=\"hljs\">age</code> field is between 13 and 19, and binds its value to the <code class=\"hljs\">person_age</code> variable.</li>\n<li>Binds a reference to the <code class=\"hljs\">name</code> field to the variable <code class=\"hljs\">person_name</code>.</li>\n<li>Ignores the rest of the fields of <code class=\"hljs\">person</code>.\nThe remaining fields can have any value and are not bound to any variables.</li>\n</ul>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Car</span></span>;\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Computer</span></span>;\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Person</span></span> {\n</span><span class=\"boring\">    name: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    car: <span class=\"hljs-built_in\">Option</span>&lt;Car&gt;,\n</span><span class=\"boring\">    computer: <span class=\"hljs-built_in\">Option</span>&lt;Computer&gt;,\n</span><span class=\"boring\">    age: <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> person = Person {\n</span><span class=\"boring\">    name: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"John\"</span>),\n</span><span class=\"boring\">    car: <span class=\"hljs-literal\">Some</span>(Car),\n</span><span class=\"boring\">    computer: <span class=\"hljs-literal\">None</span>,\n</span><span class=\"boring\">    age: <span class=\"hljs-number\">15</span>,\n</span><span class=\"boring\">};\n</span><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span>\n    Person {\n        car: <span class=\"hljs-literal\">Some</span>(_),\n        age: person_age @ <span class=\"hljs-number\">13</span>..=<span class=\"hljs-number\">19</span>,\n        name: <span class=\"hljs-keyword\">ref</span> person_name,\n        ..\n    } = person\n{\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{} has a car and is {} years old.\"</span>, person_name, person_age);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Patterns are used in:</p>\n<ul>\n<li><a href=\"statements.html#let-statements\"><code class=\"hljs\">let</code> declarations</a></li>\n<li><a href=\"items/functions.html\">Function</a> and <a href=\"expressions/closure-expr.html\">closure</a> parameters</li>\n<li><a href=\"expressions/match-expr.html\"><code class=\"hljs\">match</code> expressions</a></li>\n<li><a href=\"expressions/if-expr.html\"><code class=\"hljs\">if let</code> expressions</a></li>\n<li><a href=\"expressions/loop-expr.html#predicate-pattern-loops\"><code class=\"hljs\">while let</code> expressions</a></li>\n<li><a href=\"expressions/loop-expr.html#iterator-loops\"><code class=\"hljs\">for</code> expressions</a></li>\n</ul>\n<h2 id=\"destructuring\"><a class=\"header\" href=\"#destructuring\">Destructuring</a></h2>\n<p>Patterns can be used to <em>destructure</em> <a href=\"items/structs.html\">structs</a>, <a href=\"items/enumerations.html\">enums</a>, and <a href=\"types/tuple.html\">tuples</a>.\nDestructuring breaks up a value into its component pieces.\nThe syntax used is almost the same as when creating such values.\nIn a pattern whose <a href=\"glossary.html#scrutinee\">scrutinee</a> expression has a <code class=\"hljs\">struct</code>, <code class=\"hljs\">enum</code> or <code class=\"hljs\">tuple</code> type, a placeholder (<code class=\"hljs\">_</code>) stands in for a <em>single</em> data field, whereas a wildcard <code class=\"hljs\">..</code>  stands in for <em>all</em> the remaining fields of a particular variant.\nWhen destructuring a data structure with named (but not numbered) fields, it is allowed to write <code class=\"hljs\">fieldname</code> as a shorthand for <code class=\"hljs\">fieldname: fieldname</code>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Message</span></span> {\n</span><span class=\"boring\">    Quit,\n</span><span class=\"boring\">    WriteString(<span class=\"hljs-built_in\">String</span>),\n</span><span class=\"boring\">    Move { x: <span class=\"hljs-built_in\">i32</span>, y: <span class=\"hljs-built_in\">i32</span> },\n</span><span class=\"boring\">    ChangeColor(<span class=\"hljs-built_in\">u8</span>, <span class=\"hljs-built_in\">u8</span>, <span class=\"hljs-built_in\">u8</span>),\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> message = Message::Quit;\n</span><span class=\"hljs-keyword\">match</span> message {\n    Message::Quit =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Quit\"</span>),\n    Message::WriteString(write) =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, &amp;write),\n    Message::Move{ x, y: <span class=\"hljs-number\">0</span> } =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"move {} horizontally\"</span>, x),\n    Message::Move{ .. } =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"other move\"</span>),\n    Message::ChangeColor { <span class=\"hljs-number\">0</span>: red, <span class=\"hljs-number\">1</span>: green, <span class=\"hljs-number\">2</span>: _ } =&gt; {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"color change, red: {}, green: {}\"</span>, red, green);\n    }\n};\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"refutability\"><a class=\"header\" href=\"#refutability\">Refutability</a></h2>\n<p>A pattern is said to be <em>refutable</em> when it has the possibility of not being matched by the value it is being matched against.\n<em>Irrefutable</em> patterns, on the other hand, always match the value they are being matched against.\nExamples:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> (x, y) = (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);               <span class=\"hljs-comment\">// \"(x, y)\" is an irrefutable pattern</span>\n\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> (a, <span class=\"hljs-number\">3</span>) = (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>) {           <span class=\"hljs-comment\">// \"(a, 3)\" is refutable, and will not match</span>\n    <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"Shouldn't reach here\"</span>);\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> (a, <span class=\"hljs-number\">4</span>) = (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>) {    <span class=\"hljs-comment\">// \"(a, 4)\" is refutable, and will match</span>\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Matched ({}, 4)\"</span>, a);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"literal-patterns\"><a class=\"header\" href=\"#literal-patterns\">Literal patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>LiteralPattern</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <code class=\"hljs\">true</code> | <code class=\"hljs\">false</code><br>\n&nbsp;&nbsp; | <a href=\"tokens.html#character-literals\">CHAR_LITERAL</a><br>\n&nbsp;&nbsp; | <a href=\"tokens.html#byte-literals\">BYTE_LITERAL</a><br>\n&nbsp;&nbsp; | <a href=\"tokens.html#string-literals\">STRING_LITERAL</a><br>\n&nbsp;&nbsp; | <a href=\"tokens.html#raw-string-literals\">RAW_STRING_LITERAL</a><br>\n&nbsp;&nbsp; | <a href=\"tokens.html#byte-string-literals\">BYTE_STRING_LITERAL</a><br>\n&nbsp;&nbsp; | <a href=\"tokens.html#raw-byte-string-literals\">RAW_BYTE_STRING_LITERAL</a><br>\n&nbsp;&nbsp; | <a href=\"tokens.html#c-string-literals\">C_STRING_LITERAL</a><br>\n&nbsp;&nbsp; | <a href=\"tokens.html#raw-c-string-literals\">RAW_C_STRING_LITERAL</a><br>\n&nbsp;&nbsp; | <code class=\"hljs\">-</code><sup>?</sup> <a href=\"tokens.html#integer-literals\">INTEGER_LITERAL</a><br>\n&nbsp;&nbsp; | <code class=\"hljs\">-</code><sup>?</sup> <a href=\"tokens.html#floating-point-literals\">FLOAT_LITERAL</a></p>\n</blockquote>\n<p><em>Literal patterns</em> match exactly the same value as what is created by the literal.\nSince negative numbers are not <a href=\"expressions/literal-expr.html\">literals</a>, literal patterns also accept an optional minus sign before the literal, which acts like the negation operator.</p>\n<div class=\"warning\">\n<p>C string and raw C string literals are accepted in literal patterns, but <code class=\"hljs\">&amp;CStr</code>\ndoesn't implement structural equality (<code class=\"hljs\">#[derive(Eq, PartialEq)]</code>) and therefore\nany such <code class=\"hljs\">match</code> on a <code class=\"hljs\">&amp;CStr</code> will be rejected with a type error.</p>\n</div>\n<p>Literal patterns are always refutable.</p>\n<p>Examples:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> -<span class=\"hljs-number\">2</span>..<span class=\"hljs-number\">5</span> {\n    <span class=\"hljs-keyword\">match</span> i {\n        -<span class=\"hljs-number\">1</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"It's minus one\"</span>),\n        <span class=\"hljs-number\">1</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"It's a one\"</span>),\n        <span class=\"hljs-number\">2</span>|<span class=\"hljs-number\">4</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"It's either a two or a four\"</span>),\n        _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Matched none of the arms\"</span>),\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"identifier-patterns\"><a class=\"header\" href=\"#identifier-patterns\">Identifier patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>IdentifierPattern</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <code class=\"hljs\">ref</code><sup>?</sup> <code class=\"hljs\">mut</code><sup>?</sup> <a href=\"identifiers.html\">IDENTIFIER</a> (<code class=\"hljs\">@</code> <a href=\"#patterns\"><em>PatternNoTopAlt</em></a> ) <sup>?</sup></p>\n</blockquote>\n<p>Identifier patterns bind the value they match to a variable.\nThe identifier must be unique within the pattern.\nThe variable will shadow any variables of the same name in scope.\nThe <a href=\"names/scopes.html\">scope</a> of the new binding depends on the context of where the pattern is used (such as a <code class=\"hljs\">let</code> binding or a <code class=\"hljs\">match</code> arm).</p>\n<p>Patterns that consist of only an identifier, possibly with a <code class=\"hljs\">mut</code>, match any value and bind it to that identifier.\nThis is the most commonly used pattern in variable declarations and parameters for functions and closures.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> variable = <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">sum</span></span>(x: <span class=\"hljs-built_in\">i32</span>, y: <span class=\"hljs-built_in\">i32</span>) -&gt; <span class=\"hljs-built_in\">i32</span> {\n<span class=\"boring\">   x + y\n</span><span class=\"boring\">}\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p>To bind the matched value of a pattern to a variable, use the syntax <code class=\"hljs\">variable @ subpattern</code>.\nFor example, the following binds the value 2 to <code class=\"hljs\">e</code> (not the entire range: the range here is a range subpattern).</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-keyword\">match</span> x {\n    e @ <span class=\"hljs-number\">1</span> ..= <span class=\"hljs-number\">5</span> =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"got a range element {}\"</span>, e),\n    _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"anything\"</span>),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>By default, identifier patterns bind a variable to a copy of or move from the matched value depending on whether the matched value implements <a href=\"special-types-and-traits.html#copy\"><code class=\"hljs\">Copy</code></a>.\nThis can be changed to bind to a reference by using the <code class=\"hljs\">ref</code> keyword, or to a mutable reference using <code class=\"hljs\">ref mut</code>. For example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">10</span>);\n</span><span class=\"hljs-keyword\">match</span> a {\n    <span class=\"hljs-literal\">None</span> =&gt; (),\n    <span class=\"hljs-literal\">Some</span>(value) =&gt; (),\n}\n\n<span class=\"hljs-keyword\">match</span> a {\n    <span class=\"hljs-literal\">None</span> =&gt; (),\n    <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-keyword\">ref</span> value) =&gt; (),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In the first match expression, the value is copied (or moved).\nIn the second match, a reference to the same memory location is bound to the variable value.\nThis syntax is needed because in destructuring subpatterns the <code class=\"hljs\">&amp;</code> operator can't be applied to the value's fields.\nFor example, the following is not valid:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Person</span></span> {\n</span><span class=\"boring\">   name: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">   age: <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> value = Person { name: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"John\"</span>), age: <span class=\"hljs-number\">23</span> };\n</span><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> Person { name: &amp;person_name, age: <span class=\"hljs-number\">18</span>..=<span class=\"hljs-number\">150</span> } = value { }\n<span class=\"boring\">}</span></code></pre></pre>\n<p>To make it valid, write the following:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Person</span></span> {\n</span><span class=\"boring\">   name: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">   age: <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> value = Person { name: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"John\"</span>), age: <span class=\"hljs-number\">23</span> };\n</span><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> Person {name: <span class=\"hljs-keyword\">ref</span> person_name, age: <span class=\"hljs-number\">18</span>..=<span class=\"hljs-number\">150</span> } = value { }\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Thus, <code class=\"hljs\">ref</code> is not something that is being matched against.\nIts objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</p>\n<p><a href=\"#path-patterns\">Path patterns</a> take precedence over identifier patterns.\nIt is an error if <code class=\"hljs\">ref</code> or <code class=\"hljs\">ref mut</code> is specified and the identifier shadows a constant.</p>\n<p>Identifier patterns are irrefutable if the <code class=\"hljs\">@</code> subpattern is irrefutable or the subpattern is not specified.</p>\n<h3 id=\"binding-modes\"><a class=\"header\" href=\"#binding-modes\">Binding modes</a></h3>\n<p>To service better ergonomics, patterns operate in different <em>binding modes</em> in order to make it easier to bind references to values.\nWhen a reference value is matched by a non-reference pattern, it will be automatically treated as a <code class=\"hljs\">ref</code> or <code class=\"hljs\">ref mut</code> binding.\nExample:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x: &amp;<span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; = &amp;<span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(y) = x {\n    <span class=\"hljs-comment\">// y was converted to `ref y` and its type is &amp;i32</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p><em>Non-reference patterns</em> include all patterns except bindings, <a href=\"#wildcard-pattern\">wildcard patterns</a> (<code class=\"hljs\">_</code>), <a href=\"#path-patterns\"><code class=\"hljs\">const</code> patterns</a> of reference types, and <a href=\"#reference-patterns\">reference patterns</a>.</p>\n<p>If a binding pattern does not explicitly have <code class=\"hljs\">ref</code>, <code class=\"hljs\">ref mut</code>, or <code class=\"hljs\">mut</code>, then it uses the <em>default binding mode</em> to determine how the variable is bound.\nThe default binding mode starts in \"move\" mode which uses move semantics.\nWhen matching a pattern, the compiler starts from the outside of the pattern and works inwards.\nEach time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode.\nReferences will set the default binding mode to <code class=\"hljs\">ref</code>.\nMutable references will set the mode to <code class=\"hljs\">ref mut</code> unless the mode is already <code class=\"hljs\">ref</code> in which case it remains <code class=\"hljs\">ref</code>.\nIf the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</p>\n<p>Move bindings and reference bindings can be mixed together in the same pattern.\nDoing so will result in partial move of the object bound to and the object cannot be used afterwards.\nThis applies only if the type cannot be copied.</p>\n<p>In the example below, <code class=\"hljs\">name</code> is moved out of <code class=\"hljs\">person</code>.\nTrying to use <code class=\"hljs\">person</code> as a whole or <code class=\"hljs\">person.name</code> would result in an error because of <em>partial move</em>.</p>\n<p>Example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Person</span></span> {\n</span><span class=\"boring\">   name: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">   age: <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> person = Person{ name: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"John\"</span>), age: <span class=\"hljs-number\">23</span> };\n</span><span class=\"hljs-comment\">// `name` is moved from person and `age` referenced</span>\n<span class=\"hljs-keyword\">let</span> Person { name, <span class=\"hljs-keyword\">ref</span> age } = person;\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"wildcard-pattern\"><a class=\"header\" href=\"#wildcard-pattern\">Wildcard pattern</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>WildcardPattern</em> :<br>\n&nbsp;&nbsp; <code class=\"hljs\">_</code></p>\n</blockquote>\n<p>The <em>wildcard pattern</em> (an underscore symbol) matches any value.\nIt is used to ignore values when they don't matter.\nInside other patterns it matches a single data field (as opposed to the <code class=\"hljs\">..</code> which matches the remaining fields).\nUnlike identifier patterns, it does not copy, move or borrow the value it matches.</p>\n<p>Examples:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">20</span>;\n</span><span class=\"hljs-keyword\">let</span> (a, _) = (<span class=\"hljs-number\">10</span>, x);   <span class=\"hljs-comment\">// the x is always matched by _</span>\n<span class=\"boring\"><span class=\"hljs-built_in\">assert_eq!</span>(a, <span class=\"hljs-number\">10</span>);\n</span>\n<span class=\"hljs-comment\">// ignore a function/closure param</span>\n<span class=\"hljs-keyword\">let</span> real_part = |a: <span class=\"hljs-built_in\">f64</span>, _: <span class=\"hljs-built_in\">f64</span>| { a };\n\n<span class=\"hljs-comment\">// ignore a field from a struct</span>\n<span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RGBA</span></span> {\n</span><span class=\"boring\">   r: <span class=\"hljs-built_in\">f32</span>,\n</span><span class=\"boring\">   g: <span class=\"hljs-built_in\">f32</span>,\n</span><span class=\"boring\">   b: <span class=\"hljs-built_in\">f32</span>,\n</span><span class=\"boring\">   a: <span class=\"hljs-built_in\">f32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> color = RGBA{r: <span class=\"hljs-number\">0.4</span>, g: <span class=\"hljs-number\">0.1</span>, b: <span class=\"hljs-number\">0.9</span>, a: <span class=\"hljs-number\">0.5</span>};\n</span><span class=\"hljs-keyword\">let</span> RGBA{r: red, g: green, b: blue, a: _} = color;\n<span class=\"boring\"><span class=\"hljs-built_in\">assert_eq!</span>(color.r, red);\n</span><span class=\"boring\"><span class=\"hljs-built_in\">assert_eq!</span>(color.g, green);\n</span><span class=\"boring\"><span class=\"hljs-built_in\">assert_eq!</span>(color.b, blue);\n</span>\n<span class=\"hljs-comment\">// accept any Some, with any value</span>\n<span class=\"boring\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">10</span>);\n</span><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(_) = x {}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The wildcard pattern is always irrefutable.</p>\n<h2 id=\"rest-patterns\"><a class=\"header\" href=\"#rest-patterns\">Rest patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>RestPattern</em> :<br>\n&nbsp;&nbsp; <code class=\"hljs\">..</code></p>\n</blockquote>\n<p>The <em>rest pattern</em> (the <code class=\"hljs\">..</code> token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after.\nIt may only be used in <a href=\"#tuple-patterns\">tuple</a>, <a href=\"#tuple-struct-patterns\">tuple struct</a>, and <a href=\"#slice-patterns\">slice</a> patterns, and may only appear once as one of the elements in those patterns.\nIt is also allowed in an <a href=\"#identifier-patterns\">identifier pattern</a> for <a href=\"#slice-patterns\">slice patterns</a> only.</p>\n<p>The rest pattern is always irrefutable.</p>\n<p>Examples:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> words = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"c\"</span>];\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> slice = &amp;words[..];\n</span><span class=\"hljs-keyword\">match</span> slice {\n    [] =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"slice is empty\"</span>),\n    [one] =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"single element {}\"</span>, one),\n    [head, tail @ ..] =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"head={} tail={:?}\"</span>, head, tail),\n}\n\n<span class=\"hljs-keyword\">match</span> slice {\n    <span class=\"hljs-comment\">// Ignore everything but the last element, which must be \"!\".</span>\n    [.., <span class=\"hljs-string\">\"!\"</span>] =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"!!!\"</span>),\n\n    <span class=\"hljs-comment\">// `start` is a slice of everything except the last element, which must be \"z\".</span>\n    [start @ .., <span class=\"hljs-string\">\"z\"</span>] =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"starts with: {:?}\"</span>, start),\n\n    <span class=\"hljs-comment\">// `end` is a slice of everything but the first element, which must be \"a\".</span>\n    [<span class=\"hljs-string\">\"a\"</span>, end @ ..] =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"ends with: {:?}\"</span>, end),\n\n    <span class=\"hljs-comment\">// 'whole' is the entire slice and `last` is the final element</span>\n    whole @ [.., last] =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"the last element of {:?} is {}\"</span>, whole, last),\n\n    rest =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{:?}\"</span>, rest),\n}\n\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> [.., penultimate, _] = slice {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"next to last is {}\"</span>, penultimate);\n}\n\n<span class=\"boring\"><span class=\"hljs-keyword\">let</span> tuple = (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>);\n</span><span class=\"hljs-comment\">// Rest patterns may also be used in tuple and tuple struct patterns.</span>\n<span class=\"hljs-keyword\">match</span> tuple {\n    (<span class=\"hljs-number\">1</span>, .., y, z) =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"y={} z={}\"</span>, y, z),\n    (.., <span class=\"hljs-number\">5</span>) =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"tail must be 5\"</span>),\n    (..) =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"matches everything else\"</span>),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"range-patterns\"><a class=\"header\" href=\"#range-patterns\">Range patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>RangePattern</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <em>RangeInclusivePattern</em><br>\n&nbsp;&nbsp; | <em>RangeFromPattern</em><br>\n&nbsp;&nbsp; | <em>RangeToInclusivePattern</em><br>\n&nbsp;&nbsp; | <em>ObsoleteRangePattern</em></p>\n<p><em>RangeExclusivePattern</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <em>RangePatternBound</em> <code class=\"hljs\">..</code> <em>RangePatternBound</em></p>\n<p><em>RangeInclusivePattern</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <em>RangePatternBound</em> <code class=\"hljs\">..=</code> <em>RangePatternBound</em></p>\n<p><em>RangeFromPattern</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <em>RangePatternBound</em> <code class=\"hljs\">..</code></p>\n<p><em>RangeToInclusivePattern</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <code class=\"hljs\">..=</code> <em>RangePatternBound</em></p>\n<p><em>ObsoleteRangePattern</em> :<br>\n&nbsp;&nbsp; <em>RangePatternBound</em> <code class=\"hljs\">...</code> <em>RangePatternBound</em></p>\n<p><em>RangePatternBound</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"tokens.html#character-literals\">CHAR_LITERAL</a><br>\n&nbsp;&nbsp; | <a href=\"tokens.html#byte-literals\">BYTE_LITERAL</a><br>\n&nbsp;&nbsp; | <code class=\"hljs\">-</code><sup>?</sup> <a href=\"tokens.html#integer-literals\">INTEGER_LITERAL</a><br>\n&nbsp;&nbsp; | <code class=\"hljs\">-</code><sup>?</sup> <a href=\"tokens.html#floating-point-literals\">FLOAT_LITERAL</a><br>\n&nbsp;&nbsp; | <a href=\"expressions/path-expr.html\"><em>PathExpression</em></a></p>\n</blockquote>\n<p><em>Range patterns</em> match scalar values within the range defined by their bounds.\nThey comprise a <em>sigil</em> (one of <code class=\"hljs\">..</code>, <code class=\"hljs\">..=</code>, or <code class=\"hljs\">...</code>) and a bound on one or both sides.\nA bound on the left of the sigil is a <em>lower bound</em>.\nA bound on the right is an <em>upper bound</em>.</p>\n<p>A range pattern with both a lower and upper bound will match all values between and including both of its bounds.\nIt is written as its lower bound, followed by <code class=\"hljs\">..</code> for end-exclusive or <code class=\"hljs\">..=</code> for end-inclusive, followed by its upper bound.\nThe type of the range pattern is the type unification of its upper and lower bounds.</p>\n<p>For example, a pattern <code class=\"hljs\">'m'..='p'</code> will match only the values <code class=\"hljs\">'m'</code>, <code class=\"hljs\">'n'</code>, <code class=\"hljs\">'o'</code>, and <code class=\"hljs\">'p'</code>.\nSimilarly, <code class=\"hljs\">'m'..'p'</code> will match only <code class=\"hljs\">'m'</code>, <code class=\"hljs\">'n'</code> and <code class=\"hljs\">'o'</code>, specifically <strong>not</strong> including <code class=\"hljs\">'p'</code>.</p>\n<p>The lower bound cannot be greater than the upper bound.\nThat is, in <code class=\"hljs\">a..=b</code>, a ≤ b must be the case.\nFor example, it is an error to have a range pattern <code class=\"hljs\">10..=0</code>.</p>\n<p>A range pattern with only a lower bound will match any value greater than or equal to the lower bound.\nIt is written as its lower bound followed by <code class=\"hljs\">..</code>, and has the same type as its lower bound.\nFor example, <code class=\"hljs\">1..</code> will match 1, 9, or 9001, or 9007199254740991 (if it is of an appropriate size), but not 0, and not negative numbers for signed integers.</p>\n<p>A range pattern with only an upper bound matches any value less than or equal to the upper bound.\nIt is written as <code class=\"hljs\">..=</code> followed by its upper bound, and has the same type as its upper bound.\nFor example, <code class=\"hljs\">..=10</code> will match 10, 1, 0, and for signed integer types, all negative values.</p>\n<p>Range patterns with only one bound cannot be used as the top-level pattern for subpatterns in <a href=\"#slice-patterns\">slice patterns</a>.</p>\n<p>The bounds is written as one of:</p>\n<ul>\n<li>A character, byte, integer, or float literal.</li>\n<li>A <code class=\"hljs\">-</code> followed by an integer or float literal.</li>\n<li>A <a href=\"expressions/path-expr.html\">path</a></li>\n</ul>\n<p>If the bounds is written as a path, after macro resolution, the path must resolve to a constant item of the type <code class=\"hljs\">char</code>, an integer type, or a float type.</p>\n<p>The type and value of the bounds is dependent upon how it is written out.\nIf the bounds is a <a href=\"expressions/path-expr.html\">path</a>, the pattern has the type and value of the <a href=\"items/constant-items.html\">constant</a> the path resolves to.\nFor float range patterns, the constant may not be a <code class=\"hljs\">NaN</code>.\nIf it is a literal, it has the type and value of the corresponding <a href=\"expressions/literal-expr.html\">literal expression</a>.\nIf is a literal preceded by a <code class=\"hljs\">-</code>, it has the same type as the corresponding <a href=\"expressions/literal-expr.html\">literal expression</a> and the value of <a href=\"expressions/operator-expr.html#negation-operators\">negating</a> the value of the corresponding literal expression.</p>\n<p>Examples:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-string\">'f'</span>;\n</span><span class=\"hljs-keyword\">let</span> valid_variable = <span class=\"hljs-keyword\">match</span> c {\n    <span class=\"hljs-string\">'a'</span>..=<span class=\"hljs-string\">'z'</span> =&gt; <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">'A'</span>..=<span class=\"hljs-string\">'Z'</span> =&gt; <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">'α'</span>..=<span class=\"hljs-string\">'ω'</span> =&gt; <span class=\"hljs-literal\">true</span>,\n    _ =&gt; <span class=\"hljs-literal\">false</span>,\n};\n\n<span class=\"boring\"><span class=\"hljs-keyword\">let</span> ph = <span class=\"hljs-number\">10</span>;\n</span><span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-keyword\">match</span> ph {\n    <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">7</span> =&gt; <span class=\"hljs-string\">\"acid\"</span>,\n    <span class=\"hljs-number\">7</span> =&gt; <span class=\"hljs-string\">\"neutral\"</span>,\n    <span class=\"hljs-number\">8</span>..=<span class=\"hljs-number\">14</span> =&gt; <span class=\"hljs-string\">\"base\"</span>,\n    _ =&gt; <span class=\"hljs-built_in\">unreachable!</span>(),\n});\n\n<span class=\"boring\"><span class=\"hljs-keyword\">let</span> uint: <span class=\"hljs-built_in\">u32</span> = <span class=\"hljs-number\">5</span>;\n</span><span class=\"hljs-keyword\">match</span> uint {\n    <span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-string\">\"zero!\"</span>,\n    <span class=\"hljs-number\">1</span>.. =&gt; <span class=\"hljs-string\">\"positive number!\"</span>,\n};\n\n<span class=\"hljs-comment\">// using paths to constants:</span>\n<span class=\"boring\"><span class=\"hljs-keyword\">const</span> TROPOSPHERE_MIN : <span class=\"hljs-built_in\">u8</span> = <span class=\"hljs-number\">6</span>;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">const</span> TROPOSPHERE_MAX : <span class=\"hljs-built_in\">u8</span> = <span class=\"hljs-number\">20</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">const</span> STRATOSPHERE_MIN : <span class=\"hljs-built_in\">u8</span> = TROPOSPHERE_MAX + <span class=\"hljs-number\">1</span>;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">const</span> STRATOSPHERE_MAX : <span class=\"hljs-built_in\">u8</span> = <span class=\"hljs-number\">50</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">const</span> MESOSPHERE_MIN : <span class=\"hljs-built_in\">u8</span> = STRATOSPHERE_MAX + <span class=\"hljs-number\">1</span>;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">const</span> MESOSPHERE_MAX : <span class=\"hljs-built_in\">u8</span> = <span class=\"hljs-number\">85</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> altitude = <span class=\"hljs-number\">70</span>;\n</span><span class=\"boring\">\n</span><span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-keyword\">match</span> altitude {\n    TROPOSPHERE_MIN..=TROPOSPHERE_MAX =&gt; <span class=\"hljs-string\">\"troposphere\"</span>,\n    STRATOSPHERE_MIN..=STRATOSPHERE_MAX =&gt; <span class=\"hljs-string\">\"stratosphere\"</span>,\n    MESOSPHERE_MIN..=MESOSPHERE_MAX =&gt; <span class=\"hljs-string\">\"mesosphere\"</span>,\n    _ =&gt; <span class=\"hljs-string\">\"outer space, maybe\"</span>,\n});\n\n<span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">mod</span> binary {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">const</span> MEGA : <span class=\"hljs-built_in\">u64</span> = <span class=\"hljs-number\">1024</span>*<span class=\"hljs-number\">1024</span>;\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">const</span> GIGA : <span class=\"hljs-built_in\">u64</span> = <span class=\"hljs-number\">1024</span>*<span class=\"hljs-number\">1024</span>*<span class=\"hljs-number\">1024</span>;\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> n_items = <span class=\"hljs-number\">20_832_425</span>;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> bytes_per_item = <span class=\"hljs-number\">12</span>;\n</span><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"It fits and occupies {} bytes\"</span>, size);\n}\n\n<span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">MaxValue</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">const</span> MAX: <span class=\"hljs-built_in\">u64</span>;\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> MaxValue <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">u8</span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">const</span> MAX: <span class=\"hljs-built_in\">u64</span> = (<span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">8</span>) - <span class=\"hljs-number\">1</span>;\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> MaxValue <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">u16</span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">const</span> MAX: <span class=\"hljs-built_in\">u64</span> = (<span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">16</span>) - <span class=\"hljs-number\">1</span>;\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> MaxValue <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">u32</span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">const</span> MAX: <span class=\"hljs-built_in\">u64</span> = (<span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">32</span>) - <span class=\"hljs-number\">1</span>;\n</span><span class=\"boring\">}\n</span><span class=\"hljs-comment\">// using qualified paths:</span>\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-keyword\">match</span> <span class=\"hljs-number\">0xfacade</span> {\n    <span class=\"hljs-number\">0</span> ..= &lt;<span class=\"hljs-built_in\">u8</span> <span class=\"hljs-keyword\">as</span> MaxValue&gt;::MAX =&gt; <span class=\"hljs-string\">\"fits in a u8\"</span>,\n    <span class=\"hljs-number\">0</span> ..= &lt;<span class=\"hljs-built_in\">u16</span> <span class=\"hljs-keyword\">as</span> MaxValue&gt;::MAX =&gt; <span class=\"hljs-string\">\"fits in a u16\"</span>,\n    <span class=\"hljs-number\">0</span> ..= &lt;<span class=\"hljs-built_in\">u32</span> <span class=\"hljs-keyword\">as</span> MaxValue&gt;::MAX =&gt; <span class=\"hljs-string\">\"fits in a u32\"</span>,\n    _ =&gt; <span class=\"hljs-string\">\"too big\"</span>,\n});\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Range patterns for fix-width integer and <code class=\"hljs\">char</code> types are irrefutable when they span the entire set of possible values of a type.\nFor example, <code class=\"hljs\">0u8..=255u8</code> is irrefutable.\nThe range of values for an integer type is the closed range from its minimum to maximum value.\nThe range of values for a <code class=\"hljs\">char</code> type are precisely those ranges containing all Unicode Scalar Values: <code class=\"hljs\">'\\u{0000}'..='\\u{D7FF}'</code> and <code class=\"hljs\">'\\u{E000}'..='\\u{10FFFF}'</code>.</p>\n<blockquote>\n<p><strong>Edition Differences</strong>: Before the 2021 edition, range patterns with both a lower and upper bound may also be written using <code class=\"hljs\">...</code> in place of <code class=\"hljs\">..=</code>, with the same meaning.</p>\n</blockquote>\n<h2 id=\"reference-patterns\"><a class=\"header\" href=\"#reference-patterns\">Reference patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>ReferencePattern</em> :<br>\n&nbsp;&nbsp; (<code class=\"hljs\">&amp;</code>|<code class=\"hljs\">&amp;&amp;</code>) <code class=\"hljs\">mut</code><sup>?</sup> <a href=\"#patterns\"><em>PatternWithoutRange</em></a></p>\n</blockquote>\n<p>Reference patterns dereference the pointers that are being matched and, thus, borrow them.</p>\n<p>For example, these two matches on <code class=\"hljs\">x: &amp;i32</code> are equivalent:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> int_reference = &amp;<span class=\"hljs-number\">3</span>;\n\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-keyword\">match</span> *int_reference { <span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-string\">\"zero\"</span>, _ =&gt; <span class=\"hljs-string\">\"some\"</span> };\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">match</span> int_reference { &amp;<span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-string\">\"zero\"</span>, _ =&gt; <span class=\"hljs-string\">\"some\"</span> };\n\n<span class=\"hljs-built_in\">assert_eq!</span>(a, b);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The grammar production for reference patterns has to match the token <code class=\"hljs\">&amp;&amp;</code> to match a reference to a reference because it is a token by itself, not two <code class=\"hljs\">&amp;</code> tokens.</p>\n<p>Adding the <code class=\"hljs\">mut</code> keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</p>\n<p>Reference patterns are always irrefutable.</p>\n<h2 id=\"struct-patterns\"><a class=\"header\" href=\"#struct-patterns\">Struct patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>StructPattern</em> :<br>\n&nbsp;&nbsp; <a href=\"paths.html#paths-in-expressions\"><em>PathInExpression</em></a> <code class=\"hljs\">{</code><br>\n&nbsp;&nbsp; &nbsp;&nbsp; <em>StructPatternElements</em> <sup>?</sup><br>\n&nbsp;&nbsp; <code class=\"hljs\">}</code></p>\n<p><em>StructPatternElements</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <em>StructPatternFields</em> (<code class=\"hljs\">,</code> | <code class=\"hljs\">,</code> <em>StructPatternEtCetera</em>)<sup>?</sup><br>\n&nbsp;&nbsp; | <em>StructPatternEtCetera</em></p>\n<p><em>StructPatternFields</em> :<br>\n&nbsp;&nbsp; <em>StructPatternField</em> (<code class=\"hljs\">,</code> <em>StructPatternField</em>) <sup>*</sup></p>\n<p><em>StructPatternField</em> :<br>\n&nbsp;&nbsp; <a href=\"attributes.html\"><em>OuterAttribute</em></a> <sup>*</sup><br>\n&nbsp;&nbsp; (<br>\n&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <a href=\"tokens.html#tuple-index\">TUPLE_INDEX</a> <code class=\"hljs\">:</code> <a href=\"#patterns\"><em>Pattern</em></a><br>\n&nbsp;&nbsp; &nbsp;&nbsp; | <a href=\"identifiers.html\">IDENTIFIER</a> <code class=\"hljs\">:</code> <a href=\"#patterns\"><em>Pattern</em></a><br>\n&nbsp;&nbsp; &nbsp;&nbsp; | <code class=\"hljs\">ref</code><sup>?</sup> <code class=\"hljs\">mut</code><sup>?</sup> <a href=\"identifiers.html\">IDENTIFIER</a><br>\n&nbsp;&nbsp; )</p>\n<p><em>StructPatternEtCetera</em> :<br>\n&nbsp;&nbsp; <a href=\"attributes.html\"><em>OuterAttribute</em></a> <sup>*</sup><br>\n&nbsp;&nbsp; <code class=\"hljs\">..</code></p>\n</blockquote>\n<p>Struct patterns match struct, enum, and union values that match all criteria defined by its subpatterns.\nThey are also used to <a href=\"#destructuring\">destructure</a> a struct, enum, or union value.</p>\n<p>On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of <code class=\"hljs\">..</code>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n</span><span class=\"boring\">    x: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    y: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> s = Point {x: <span class=\"hljs-number\">1</span>, y: <span class=\"hljs-number\">1</span>};\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">match</span> s {\n    Point {x: <span class=\"hljs-number\">10</span>, y: <span class=\"hljs-number\">20</span>} =&gt; (),\n    Point {y: <span class=\"hljs-number\">10</span>, x: <span class=\"hljs-number\">20</span>} =&gt; (),    <span class=\"hljs-comment\">// order doesn't matter</span>\n    Point {x: <span class=\"hljs-number\">10</span>, ..} =&gt; (),\n    Point {..} =&gt; (),\n}\n\n<span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PointTuple</span></span> (\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">);\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> t = PointTuple(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">match</span> t {\n    PointTuple {<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1</span>: <span class=\"hljs-number\">20</span>} =&gt; (),\n    PointTuple {<span class=\"hljs-number\">1</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">20</span>} =&gt; (),   <span class=\"hljs-comment\">// order doesn't matter</span>\n    PointTuple {<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">10</span>, ..} =&gt; (),\n    PointTuple {..} =&gt; (),\n}\n\n<span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Message</span></span> {\n</span><span class=\"boring\">    Quit,\n</span><span class=\"boring\">    Move { x: <span class=\"hljs-built_in\">i32</span>, y: <span class=\"hljs-built_in\">i32</span> },\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> m = Message::Quit;\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">match</span> m {\n    Message::Quit =&gt; (),\n    Message::Move {x: <span class=\"hljs-number\">10</span>, y: <span class=\"hljs-number\">20</span>} =&gt; (),\n    Message::Move {..} =&gt; (),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>If <code class=\"hljs\">..</code> is not used, a struct pattern used to match a struct is required to specify all fields:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Struct</span></span> {\n</span><span class=\"boring\">   a: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">   b: <span class=\"hljs-built_in\">char</span>,\n</span><span class=\"boring\">   c: <span class=\"hljs-built_in\">bool</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> struct_value = Struct{a: <span class=\"hljs-number\">10</span>, b: <span class=\"hljs-string\">'X'</span>, c: <span class=\"hljs-literal\">false</span>};\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">match</span> struct_value {\n    Struct{a: <span class=\"hljs-number\">10</span>, b: <span class=\"hljs-string\">'X'</span>, c: <span class=\"hljs-literal\">false</span>} =&gt; (),\n    Struct{a: <span class=\"hljs-number\">10</span>, b: <span class=\"hljs-string\">'X'</span>, <span class=\"hljs-keyword\">ref</span> c} =&gt; (),\n    Struct{a: <span class=\"hljs-number\">10</span>, b: <span class=\"hljs-string\">'X'</span>, <span class=\"hljs-keyword\">ref</span> <span class=\"hljs-keyword\">mut</span> c} =&gt; (),\n    Struct{a: <span class=\"hljs-number\">10</span>, b: <span class=\"hljs-string\">'X'</span>, c: _} =&gt; (),\n    Struct{a: _, b: _, c: _} =&gt; (),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>A struct pattern used to match a union must specify exactly one field (see <a href=\"items/unions.html#pattern-matching-on-unions\">Pattern matching on unions</a>).</p>\n<p>The <code class=\"hljs\">ref</code> and/or <code class=\"hljs\">mut</code> <em>IDENTIFIER</em> syntax matches any value and binds it to a variable with the same name as the given field.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Struct</span></span> {\n</span><span class=\"boring\">   a: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">   b: <span class=\"hljs-built_in\">char</span>,\n</span><span class=\"boring\">   c: <span class=\"hljs-built_in\">bool</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> struct_value = Struct{a: <span class=\"hljs-number\">10</span>, b: <span class=\"hljs-string\">'X'</span>, c: <span class=\"hljs-literal\">false</span>};\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">let</span> Struct{a: x, b: y, c: z} = struct_value;          <span class=\"hljs-comment\">// destructure all fields</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p>A struct pattern is refutable if the <em>PathInExpression</em> resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable.</p>\n<h2 id=\"tuple-struct-patterns\"><a class=\"header\" href=\"#tuple-struct-patterns\">Tuple struct patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>TupleStructPattern</em> :<br>\n&nbsp;&nbsp; <a href=\"paths.html#paths-in-expressions\"><em>PathInExpression</em></a> <code class=\"hljs\">(</code> <em>TupleStructItems</em><sup>?</sup> <code class=\"hljs\">)</code></p>\n<p><em>TupleStructItems</em> :<br>\n&nbsp;&nbsp; <a href=\"#patterns\"><em>Pattern</em></a>&nbsp;( <code class=\"hljs\">,</code> <a href=\"#patterns\"><em>Pattern</em></a> )<sup>*</sup> <code class=\"hljs\">,</code><sup>?</sup></p>\n</blockquote>\n<p>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns.\nThey are also used to <a href=\"#destructuring\">destructure</a> a tuple struct or enum value.</p>\n<p>A tuple struct pattern is refutable if the <em>PathInExpression</em> resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable.</p>\n<h2 id=\"tuple-patterns\"><a class=\"header\" href=\"#tuple-patterns\">Tuple patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>TuplePattern</em> :<br>\n&nbsp;&nbsp; <code class=\"hljs\">(</code> <em>TuplePatternItems</em><sup>?</sup> <code class=\"hljs\">)</code></p>\n<p><em>TuplePatternItems</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"#patterns\"><em>Pattern</em></a> <code class=\"hljs\">,</code><br>\n&nbsp;&nbsp; | <a href=\"#rest-patterns\"><em>RestPattern</em></a><br>\n&nbsp;&nbsp; | <a href=\"#patterns\"><em>Pattern</em></a>&nbsp;(<code class=\"hljs\">,</code> <a href=\"#patterns\"><em>Pattern</em></a>)<sup>+</sup> <code class=\"hljs\">,</code><sup>?</sup></p>\n</blockquote>\n<p>Tuple patterns match tuple values that match all criteria defined by its subpatterns.\nThey are also used to <a href=\"#destructuring\">destructure</a> a tuple.</p>\n<p>The form <code class=\"hljs\">(..)</code> with a single <a href=\"#rest-patterns\"><em>RestPattern</em></a> is a special form that does not require a comma, and matches a tuple of any size.</p>\n<p>The tuple pattern is refutable when one of its subpatterns is refutable.</p>\n<p>An example of using tuple patterns:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> pair = (<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">\"ten\"</span>);\n<span class=\"hljs-keyword\">let</span> (a, b) = pair;\n\n<span class=\"hljs-built_in\">assert_eq!</span>(a, <span class=\"hljs-number\">10</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(b, <span class=\"hljs-string\">\"ten\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"grouped-patterns\"><a class=\"header\" href=\"#grouped-patterns\">Grouped patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>GroupedPattern</em> :<br>\n&nbsp;&nbsp; <code class=\"hljs\">(</code> <a href=\"#patterns\"><em>Pattern</em></a> <code class=\"hljs\">)</code></p>\n</blockquote>\n<p>Enclosing a pattern in parentheses can be used to explicitly control the precedence of compound patterns.\nFor example, a reference pattern next to a range pattern such as <code class=\"hljs\">&amp;0..=5</code> is ambiguous and is not allowed, but can be expressed with parentheses.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> int_reference = &amp;<span class=\"hljs-number\">3</span>;\n<span class=\"hljs-keyword\">match</span> int_reference {\n    &amp;(<span class=\"hljs-number\">0</span>..=<span class=\"hljs-number\">5</span>) =&gt; (),\n    _ =&gt; (),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"slice-patterns\"><a class=\"header\" href=\"#slice-patterns\">Slice patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>SlicePattern</em> :<br>\n&nbsp;&nbsp; <code class=\"hljs\">[</code> <em>SlicePatternItems</em><sup>?</sup> <code class=\"hljs\">]</code></p>\n<p><em>SlicePatternItems</em> :<br>\n&nbsp;&nbsp; <a href=\"#patterns\"><em>Pattern</em></a> (<code class=\"hljs\">,</code> <a href=\"#patterns\"><em>Pattern</em></a>)<sup>*</sup> <code class=\"hljs\">,</code><sup>?</sup></p>\n</blockquote>\n<p>Slice patterns can match both arrays of fixed size and slices of dynamic size.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// Fixed size</span>\n<span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">match</span> arr {\n    [<span class=\"hljs-number\">1</span>, _, _] =&gt; <span class=\"hljs-string\">\"starts with one\"</span>,\n    [a, b, c] =&gt; <span class=\"hljs-string\">\"starts with something else\"</span>,\n};\n<span class=\"boring\">}</span></code></pre></pre>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// Dynamic size</span>\n<span class=\"hljs-keyword\">let</span> v = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">match</span> v[..] {\n    [a, b] =&gt; { <span class=\"hljs-comment\">/* this arm will not apply because the length doesn't match */</span> }\n    [a, b, c] =&gt; { <span class=\"hljs-comment\">/* this arm will apply */</span> }\n    _ =&gt; { <span class=\"hljs-comment\">/* this wildcard is required, since the length is not known statically */</span> }\n};\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Slice patterns are irrefutable when matching an array as long as each element is irrefutable.\nWhen matching a slice, it is irrefutable only in the form with a single <code class=\"hljs\">..</code> <a href=\"#rest-patterns\">rest pattern</a> or <a href=\"#identifier-patterns\">identifier pattern</a> with the <code class=\"hljs\">..</code> rest pattern as a subpattern.</p>\n<p>Within a slice, a range pattern without both lower and upper bound must be enclosed in parentheses, as in <code class=\"hljs\">(a..)</code>, to clarify it is intended to match against a single slice element.\nA range pattern with both lower and upper bound, like <code class=\"hljs\">a..=b</code>, is not required to be enclosed in parentheses.</p>\n<h2 id=\"path-patterns\"><a class=\"header\" href=\"#path-patterns\">Path patterns</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>PathPattern</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"expressions/path-expr.html\"><em>PathExpression</em></a></p>\n</blockquote>\n<p><em>Path patterns</em> are patterns that refer either to constant values or\nto structs or enum variants that have no fields.</p>\n<p>Unqualified path patterns can refer to:</p>\n<ul>\n<li>enum variants</li>\n<li>structs</li>\n<li>constants</li>\n<li>associated constants</li>\n</ul>\n<p>Qualified path patterns can only refer to associated constants.</p>\n<p>Path patterns are irrefutable when they refer to structs or an enum variant when the enum has only one variant or a constant whose type is irrefutable.\nThey are refutable when they refer to refutable constants or enum variants for enums with multiple variants.</p>\n<h3 id=\"constant-patterns\"><a class=\"header\" href=\"#constant-patterns\">Constant patterns</a></h3>\n<p>When a constant <code class=\"hljs\">C</code> of type <code class=\"hljs\">T</code> is used as a pattern, we first check that <code class=\"hljs\">T: PartialEq</code>.\nFurthermore we require that the value of <code class=\"hljs\">C</code> <em>has (recursive) structural equality</em>, which is defined recursively as follows:</p>\n<ul>\n<li>Integers as well as <code class=\"hljs\">str</code>, <code class=\"hljs\">bool</code> and <code class=\"hljs\">char</code> values always have structural equality.</li>\n<li>Tuples, arrays, and slices have structural equality if all their fields/elements have structural equality.\n(In particular, <code class=\"hljs\">()</code> and <code class=\"hljs\">[]</code> always have structural equality.)</li>\n<li>References have structural equality if the value they point to has structural equality.</li>\n<li>A value of <code class=\"hljs\">struct</code> or <code class=\"hljs\">enum</code> type has structural equality if its <code class=\"hljs\">PartialEq</code> instance is derived via <code class=\"hljs\">#[derive(PartialEq)]</code>,\nand all fields (for enums: of the active variant) have structural equality.</li>\n<li>A raw pointer has structural equality if it was defined as a constant integer (and then cast/transmuted).</li>\n<li>A float value has structural equality if it is not a <code class=\"hljs\">NaN</code>.</li>\n<li>Nothing else has structural equality.</li>\n</ul>\n<p>In particular, the value of <code class=\"hljs\">C</code> must be known at pattern-building time (which is pre-monomorphization).\nThis means that associated consts that involve generic parameters cannot be used as patterns.</p>\n<p>After ensuring all conditions are met, the constant value is translated into a pattern, and now behaves exactly as-if that pattern had been written directly.\nIn particular, it fully participates in exhaustiveness checking.\n(For raw pointers, constants are the only way to write such patterns. Only <code class=\"hljs\">_</code> is ever considered exhaustive for these types.)</p>\n<h2 id=\"or-patterns\"><a class=\"header\" href=\"#or-patterns\">Or-patterns</a></h2>\n<p><em>Or-patterns</em> are patterns that match on one of two or more sub-patterns (for example <code class=\"hljs\">A | B | C</code>).\nThey can nest arbitrarily.\nSyntactically, or-patterns are allowed in any of the places where other patterns are allowed (represented by the <em>Pattern</em> production), with the exceptions of <code class=\"hljs\">let</code>-bindings and function and closure arguments (represented by the <em>PatternNoTopAlt</em> production).</p>\n<h3 id=\"static-semantics\"><a class=\"header\" href=\"#static-semantics\">Static semantics</a></h3>\n<ol>\n<li>\n<p>Given a pattern <code class=\"hljs\">p | q</code> at some depth for some arbitrary patterns <code class=\"hljs\">p</code> and <code class=\"hljs\">q</code>, the pattern is considered ill-formed if:</p>\n<ul>\n<li>the type inferred for <code class=\"hljs\">p</code> does not unify with the type inferred for <code class=\"hljs\">q</code>, or</li>\n<li>the same set of bindings are not introduced in <code class=\"hljs\">p</code> and <code class=\"hljs\">q</code>, or</li>\n<li>the type of any two bindings with the same name in <code class=\"hljs\">p</code> and <code class=\"hljs\">q</code> do not unify with respect to types or binding modes.</li>\n</ul>\n<p>Unification of types is in all instances aforementioned exact and implicit <a href=\"type-coercions.html\">type coercions</a> do not apply.</p>\n</li>\n<li>\n<p>When type checking an expression <code class=\"hljs\">match e_s { a_1 =&gt; e_1, ... a_n =&gt; e_n }</code>,\nfor each match arm <code class=\"hljs\">a_i</code> which contains a pattern of form <code class=\"hljs\">p_i | q_i</code>,\nthe pattern <code class=\"hljs\">p_i | q_i</code> is considered ill formed if,\nat the depth <code class=\"hljs\">d</code> where it exists the fragment of <code class=\"hljs\">e_s</code> at depth <code class=\"hljs\">d</code>,\nthe type of the expression fragment does not unify with <code class=\"hljs\">p_i | q_i</code>.</p>\n</li>\n<li>\n<p>With respect to exhaustiveness checking, a pattern <code class=\"hljs\">p | q</code> is considered to cover <code class=\"hljs\">p</code> as well as <code class=\"hljs\">q</code>.\nFor some constructor <code class=\"hljs\">c(x, ..)</code> the distributive law applies such that <code class=\"hljs\">c(p | q, ..rest)</code> covers the same set of value as <code class=\"hljs\">c(p, ..rest) | c(q, ..rest)</code> does.\nThis can be applied recursively until there are no more nested patterns of form <code class=\"hljs\">p | q</code> other than those that exist at the top level.</p>\n<p>Note that by <em>\"constructor\"</em> we do not refer to tuple struct patterns, but rather we refer to a pattern for any product type.\nThis includes enum variants, tuple structs, structs with named fields, arrays, tuples, and slices.</p>\n</li>\n</ol>\n<h3 id=\"dynamic-semantics\"><a class=\"header\" href=\"#dynamic-semantics\">Dynamic semantics</a></h3>\n<ol>\n<li>The dynamic semantics of pattern matching a scrutinee expression <code class=\"hljs\">e_s</code> against a pattern <code class=\"hljs\">c(p | q, ..rest)</code> at depth <code class=\"hljs\">d</code> where <code class=\"hljs\">c</code> is some constructor,\n<code class=\"hljs\">p</code> and <code class=\"hljs\">q</code> are arbitrary patterns,\nand <code class=\"hljs\">rest</code> is optionally any remaining potential factors in <code class=\"hljs\">c</code>,\nis defined as being the same as that of <code class=\"hljs\">c(p, ..rest) | c(q, ..rest)</code>.</li>\n</ol>\n<h3 id=\"precedence-with-other-undelimited-patterns\"><a class=\"header\" href=\"#precedence-with-other-undelimited-patterns\">Precedence with other undelimited patterns</a></h3>\n<p>As shown elsewhere in this chapter, there are several types of patterns that are syntactically undelimited, including identifier patterns, reference patterns, and or-patterns.\nOr-patterns always have the lowest-precedence.\nThis allows us to reserve syntactic space for a possible future type ascription feature and also to reduce ambiguity.\nFor example, <code class=\"hljs\">x @ A(..) | B(..)</code> will result in an error that <code class=\"hljs\">x</code> is not bound in all patterns.\n<code class=\"hljs\">&amp;A(x) | B(x)</code> will result in a type mismatch between <code class=\"hljs\">x</code> in the different subpatterns.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"expressions/underscore-expr.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"type-system.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"expressions/underscore-expr.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"type-system.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:20:43.195Z"
}