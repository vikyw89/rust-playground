{
	"title": "Closures: Anonymous Functions that Capture Their Environment - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch13-01-closures.html",
	"markdown": "# Closures: Anonymous Functions that Capture Their Environment\n\nRust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they’re defined. We’ll demonstrate how these closure features allow for code reuse and behavior customization.\n\n### [Capturing the Environment with Closures](#capturing-the-environment-with-closures)\n\nWe’ll first examine how we can use closures to capture values from the environment they’re defined in for later use. Here’s the scenario: Every so often, our t-shirt company gives away an exclusive, limited-edition shirt to someone on our mailing list as a promotion. People on the mailing list can optionally add their favorite color to their profile. If the person chosen for a free shirt has their favorite color set, they get that color shirt. If the person hasn’t specified a favorite color, they get whatever color the company currently has the most of.\n\nThere are many ways to implement this. For this example, we’re going to use an enum called `ShirtColor` that has the variants `Red` and `Blue` (limiting the number of colors available for simplicity). We represent the company’s inventory with an `Inventory` struct that has a field named `shirts` that contains a `Vec<ShirtColor>` representing the shirt colors currently in stock. The method `giveaway` defined on `Inventory` gets the optional shirt color preference of the free shirt winner, and returns the shirt color the person will get. This setup is shown in Listing 13-1:\n\nFilename: src/main.rs\n\n```rust\n#[derive(Debug, PartialEq, Copy, Clone)]\nenum ShirtColor {\n    Red,\n    Blue,\n}\n\nstruct Inventory {\n    shirts: Vec<ShirtColor>,\n}\n\nimpl Inventory {\n    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {\n        user_preference.unwrap_or_else(|| self.most_stocked())\n    }\n\n    fn most_stocked(&self) -> ShirtColor {\n        let mut num_red = 0;\n        let mut num_blue = 0;\n\n        for color in &self.shirts {\n            match color {\n                ShirtColor::Red => num_red += 1,\n                ShirtColor::Blue => num_blue += 1,\n            }\n        }\n        if num_red > num_blue {\n            ShirtColor::Red\n        } else {\n            ShirtColor::Blue\n        }\n    }\n}\n\nfn main() {\n    let store = Inventory {\n        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],\n    };\n\n    let user_pref1 = Some(ShirtColor::Red);\n    let giveaway1 = store.giveaway(user_pref1);\n    println!(\n        \"The user with preference {:?} gets {:?}\",\n        user_pref1, giveaway1\n    );\n\n    let user_pref2 = None;\n    let giveaway2 = store.giveaway(user_pref2);\n    println!(\n        \"The user with preference {:?} gets {:?}\",\n        user_pref2, giveaway2\n    );\n}\n```\n\nListing 13-1: Shirt company giveaway situation\n\nThe `store` defined in `main` has two blue shirts and one red shirt remaining to distribute for this limited-edition promotion. We call the `giveaway` method for a user with a preference for a red shirt and a user without any preference.\n\nAgain, this code could be implemented in many ways, and here, to focus on closures, we’ve stuck to concepts you’ve already learned except for the body of the `giveaway` method that uses a closure. In the `giveaway` method, we get the user preference as a parameter of type `Option<ShirtColor>` and call the `unwrap_or_else` method on `user_preference`. The [`unwrap_or_else` method on `Option<T>`](about:blank/std/option/enum.Option.html#method.unwrap_or_else) is defined by the standard library. It takes one argument: a closure without any arguments that returns a value `T` (the same type stored in the `Some` variant of the `Option<T>`, in this case `ShirtColor`). If the `Option<T>` is the `Some` variant, `unwrap_or_else` returns the value from within the `Some`. If the `Option<T>` is the `None` variant, `unwrap_or_else` calls the closure and returns the value returned by the closure.\n\nWe specify the closure expression `|| self.most_stocked()` as the argument to `unwrap_or_else`. This is a closure that takes no parameters itself (if the closure had parameters, they would appear between the two vertical bars). The body of the closure calls `self.most_stocked()`. We’re defining the closure here, and the implementation of `unwrap_or_else` will evaluate the closure later if the result is needed.\n\nRunning this code prints:\n\n```console\n$ cargo run\n   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n     Running `target/debug/shirt-company`\nThe user with preference Some(Red) gets Red\nThe user with preference None gets Blue\n\n```\n\nOne interesting aspect here is that we’ve passed a closure that calls `self.most_stocked()` on the current `Inventory` instance. The standard library didn’t need to know anything about the `Inventory` or `ShirtColor` types we defined, or the logic we want to use in this scenario. The closure captures an immutable reference to the `self` `Inventory` instance and passes it with the code we specify to the `unwrap_or_else` method. Functions, on the other hand, are not able to capture their environment in this way.\n\n### [Closure Type Inference and Annotation](#closure-type-inference-and-annotation)\n\nThere are more differences between functions and closures. Closures don’t usually require you to annotate the types of the parameters or the return value like `fn` functions do. Type annotations are required on functions because the types are part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. Closures, on the other hand, aren’t used in an exposed interface like this: they’re stored in variables and used without naming them and exposing them to users of our library.\n\nClosures are typically short and relevant only within a narrow context rather than in any arbitrary scenario. Within these limited contexts, the compiler can infer the types of the parameters and the return type, similar to how it’s able to infer the types of most variables (there are rare cases where the compiler needs closure type annotations too).\n\nAs with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for a closure would look like the definition shown in Listing 13-2. In this example, we’re defining a closure and storing it in a variable rather than defining the closure in the spot we pass it as an argument as we did in Listing 13-1.\n\nFilename: src/main.rs\n\n```rust\nuse std::thread;\nuse std::time::Duration;\n\nfn generate_workout(intensity: u32, random_number: u32) {\n    let expensive_closure = |num: u32| -> u32 {\n        println!(\"calculating slowly...\");\n        thread::sleep(Duration::from_secs(2));\n        num\n    };\n\n    if intensity < 25 {\n        println!(\"Today, do {} pushups!\", expensive_closure(intensity));\n        println!(\"Next, do {} situps!\", expensive_closure(intensity));\n    } else {\n        if random_number == 3 {\n            println!(\"Take a break today! Remember to stay hydrated!\");\n        } else {\n            println!(\n                \"Today, run for {} minutes!\",\n                expensive_closure(intensity)\n            );\n        }\n    }\n}\n\nfn main() {\n    let simulated_user_specified_value = 10;\n    let simulated_random_number = 7;\n\n    generate_workout(simulated_user_specified_value, simulated_random_number);\n}\n```\n\nListing 13-2: Adding optional type annotations of the parameter and return value types in the closure\n\nWith type annotations added, the syntax of closures looks more similar to the syntax of functions. Here we define a function that adds 1 to its parameter and a closure that has the same behavior, for comparison. We’ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:\n\n```rust\nfn  add_one_v1   (x: u32) -> u32 { x + 1 }\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n```\n\nThe first line shows a function definition, and the second line shows a fully annotated closure definition. In the third line, we remove the type annotations from the closure definition. In the fourth line, we remove the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they’re called. The `add_one_v3` and `add_one_v4` lines require the closures to be evaluated to be able to compile because the types will be inferred from their usage. This is similar to `let v = Vec::new();` needing either type annotations or values of some type to be inserted into the `Vec` for Rust to be able to infer the type.\n\nFor closure definitions, the compiler will infer one concrete type for each of their parameters and for their return value. For instance, Listing 13-3 shows the definition of a short closure that just returns the value it receives as a parameter. This closure isn’t very useful except for the purposes of this example. Note that we haven’t added any type annotations to the definition. Because there are no type annotations, we can call the closure with any type, which we’ve done here with `String` the first time. If we then try to call `example_closure` with an integer, we’ll get an error.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let example_closure = |x| x;\n\n    let s = example_closure(String::from(\"hello\"));\n    let n = example_closure(5);\n}\n```\n\nListing 13-3: Attempting to call a closure whose types are inferred with two different types\n\nThe compiler gives us this error:\n\n```console\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\nerror[E0308]: mismatched types\n --> src/main.rs:5:29\n  |\n5 |     let n = example_closure(5);\n  |             --------------- ^- help: try using a conversion method: `.to_string()`\n  |             |               |\n  |             |               expected `String`, found integer\n  |             arguments to this function are incorrect\n  |\nnote: expected because the closure was earlier called with an argument of type `String`\n --> src/main.rs:4:29\n  |\n4 |     let s = example_closure(String::from(\"hello\"));\n  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`\n  |             |\n  |             in this closure call\nnote: closure parameter defined here\n --> src/main.rs:2:28\n  |\n2 |     let example_closure = |x| x;\n  |                            ^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `closure-example` (bin \"closure-example\") due to 1 previous error\n\n```\n\nThe first time we call `example_closure` with the `String` value, the compiler infers the type of `x` and the return type of the closure to be `String`. Those types are then locked into the closure in `example_closure`, and we get a type error when we next try to use a different type with the same closure.\n\n### [Capturing References or Moving Ownership](#capturing-references-or-moving-ownership)\n\nClosures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: borrowing immutably, borrowing mutably, and taking ownership. The closure will decide which of these to use based on what the body of the function does with the captured values.\n\nIn Listing 13-4, we define a closure that captures an immutable reference to the vector named `list` because it only needs an immutable reference to print the value:\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {list:?}\");\n\n    let only_borrows = || println!(\"From closure: {list:?}\");\n\n    println!(\"Before calling closure: {list:?}\");\n    only_borrows();\n    println!(\"After calling closure: {list:?}\");\n}\n```\n\nListing 13-4: Defining and calling a closure that captures an immutable reference\n\nThis example also illustrates that a variable can bind to a closure definition, and we can later call the closure by using the variable name and parentheses as if the variable name were a function name.\n\nBecause we can have multiple immutable references to `list` at the same time, `list` is still accessible from the code before the closure definition, after the closure definition but before the closure is called, and after the closure is called. This code compiles, runs, and prints:\n\n```console\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/closure-example`\nBefore defining closure: [1, 2, 3]\nBefore calling closure: [1, 2, 3]\nFrom closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3]\n\n```\n\nNext, in Listing 13-5, we change the closure body so that it adds an element to the `list` vector. The closure now captures a mutable reference:\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Before defining closure: {list:?}\");\n\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!(\"After calling closure: {list:?}\");\n}\n```\n\nListing 13-5: Defining and calling a closure that captures a mutable reference\n\nThis code compiles, runs, and prints:\n\n```console\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/closure-example`\nBefore defining closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3, 7]\n\n```\n\nNote that there’s no longer a `println!` between the definition and the call of the `borrows_mutably` closure: when `borrows_mutably` is defined, it captures a mutable reference to `list`. We don’t use the closure again after the closure is called, so the mutable borrow ends. Between the closure definition and the closure call, an immutable borrow to print isn’t allowed because no other borrows are allowed when there’s a mutable borrow. Try adding a `println!` there to see what error message you get!\n\nIf you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesn’t strictly need ownership, you can use the `move` keyword before the parameter list.\n\nThis technique is mostly useful when passing a closure to a new thread to move the data so that it’s owned by the new thread. We’ll discuss threads and why you would want to use them in detail in Chapter 16 when we talk about concurrency, but for now, let’s briefly explore spawning a new thread using a closure that needs the `move` keyword. Listing 13-6 shows Listing 13-4 modified to print the vector in a new thread rather than in the main thread:\n\nFilename: src/main.rs\n\n```rust\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {list:?}\");\n\n    thread::spawn(move || println!(\"From thread: {list:?}\"))\n        .join()\n        .unwrap();\n}\n```\n\nListing 13-6: Using `move` to force the closure for the thread to take ownership of `list`\n\nWe spawn a new thread, giving the thread a closure to run as an argument. The closure body prints out the list. In Listing 13-4, the closure only captured `list` using an immutable reference because that’s the least amount of access to `list` needed to print it. In this example, even though the closure body still only needs an immutable reference, we need to specify that `list` should be moved into the closure by putting the `move` keyword at the beginning of the closure definition. The new thread might finish before the rest of the main thread finishes, or the main thread might finish first. If the main thread maintained ownership of `list` but ended before the new thread did and dropped `list`, the immutable reference in the thread would be invalid. Therefore, the compiler requires that `list` be moved into the closure given to the new thread so the reference will be valid. Try removing the `move` keyword or using `list` in the main thread after the closure is defined to see what compiler errors you get!\n\n### [Moving Captured Values Out of Closures and the `Fn` Traits](#moving-captured-values-out-of-closures-and-the-fn-traits)\n\nOnce a closure has captured a reference or captured ownership of a value from the environment where the closure is defined (thus affecting what, if anything, is moved _into_ the closure), the code in the body of the closure defines what happens to the references or values when the closure is evaluated later (thus affecting what, if anything, is moved _out of_ the closure). A closure body can do any of the following: move a captured value out of the closure, mutate the captured value, neither move nor mutate the value, or capture nothing from the environment to begin with.\n\nThe way a closure captures and handles values from the environment affects which traits the closure implements, and traits are how functions and structs can specify what kinds of closures they can use. Closures will automatically implement one, two, or all three of these `Fn` traits, in an additive fashion, depending on how the closure’s body handles the values:\n\n1.  `FnOnce` applies to closures that can be called once. All closures implement at least this trait, because all closures can be called. A closure that moves captured values out of its body will only implement `FnOnce` and none of the other `Fn` traits, because it can only be called once.\n2.  `FnMut` applies to closures that don’t move captured values out of their body, but that might mutate the captured values. These closures can be called more than once.\n3.  `Fn` applies to closures that don’t move captured values out of their body and that don’t mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently.\n\nLet’s look at the definition of the `unwrap_or_else` method on `Option<T>` that we used in Listing 13-1:\n\n```rust\nimpl<T> Option<T> {\n    pub fn unwrap_or_else<F>(self, f: F) -> T\n    where\n        F: FnOnce() -> T\n    {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n}\n```\n\nRecall that `T` is the generic type representing the type of the value in the `Some` variant of an `Option`. That type `T` is also the return type of the `unwrap_or_else` function: code that calls `unwrap_or_else` on an `Option<String>`, for example, will get a `String`.\n\nNext, notice that the `unwrap_or_else` function has the additional generic type parameter `F`. The `F` type is the type of the parameter named `f`, which is the closure we provide when calling `unwrap_or_else`.\n\nThe trait bound specified on the generic type `F` is `FnOnce() -> T`, which means `F` must be able to be called once, take no arguments, and return a `T`. Using `FnOnce` in the trait bound expresses the constraint that `unwrap_or_else` is only going to call `f` at most one time. In the body of `unwrap_or_else`, we can see that if the `Option` is `Some`, `f` won’t be called. If the `Option` is `None`, `f` will be called once. Because all closures implement `FnOnce`, `unwrap_or_else` accepts all three kinds of closures and is as flexible as it can be.\n\nNote: Functions can implement all three of the `Fn` traits too. If what we want to do doesn’t require capturing a value from the environment, we can use the name of a function rather than a closure where we need something that implements one of the `Fn` traits. For example, on an `Option<Vec<T>>` value, we could call `unwrap_or_else(Vec::new)` to get a new, empty vector if the value is `None`.\n\nNow let’s look at the standard library method `sort_by_key` defined on slices, to see how that differs from `unwrap_or_else` and why `sort_by_key` uses `FnMut` instead of `FnOnce` for the trait bound. The closure gets one argument in the form of a reference to the current item in the slice being considered, and returns a value of type `K` that can be ordered. This function is useful when you want to sort a slice by a particular attribute of each item. In Listing 13-7, we have a list of `Rectangle` instances and we use `sort_by_key` to order them by their `width` attribute from low to high:\n\nFilename: src/main.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    list.sort_by_key(|r| r.width);\n    println!(\"{list:#?}\");\n}\n```\n\nListing 13-7: Using `sort_by_key` to order rectangles by width\n\nThis code prints:\n\n```console\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s\n     Running `target/debug/rectangles`\n[\n    Rectangle {\n        width: 3,\n        height: 5,\n    },\n    Rectangle {\n        width: 7,\n        height: 12,\n    },\n    Rectangle {\n        width: 10,\n        height: 1,\n    },\n]\n\n```\n\nThe reason `sort_by_key` is defined to take an `FnMut` closure is that it calls the closure multiple times: once for each item in the slice. The closure `|r| r.width` doesn’t capture, mutate, or move out anything from its environment, so it meets the trait bound requirements.\n\nIn contrast, Listing 13-8 shows an example of a closure that implements just the `FnOnce` trait, because it moves a value out of the environment. The compiler won’t let us use this closure with `sort_by_key`:\n\nFilename: src/main.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut sort_operations = vec![];\n    let value = String::from(\"closure called\");\n\n    list.sort_by_key(|r| {\n        sort_operations.push(value);\n        r.width\n    });\n    println!(\"{list:#?}\");\n}\n```\n\nListing 13-8: Attempting to use an `FnOnce` closure with `sort_by_key`\n\nThis is a contrived, convoluted way (that doesn’t work) to try and count the number of times `sort_by_key` calls the closure when sorting `list`. This code attempts to do this counting by pushing `value`—a `String` from the closure’s environment—into the `sort_operations` vector. The closure captures `value` then moves `value` out of the closure by transferring ownership of `value` to the `sort_operations` vector. This closure can be called once; trying to call it a second time wouldn’t work because `value` would no longer be in the environment to be pushed into `sort_operations` again! Therefore, this closure only implements `FnOnce`. When we try to compile this code, we get this error that `value` can’t be moved out of the closure because the closure must implement `FnMut`:\n\n```console\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\nerror[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure\n  --> src/main.rs:18:30\n   |\n15 |     let value = String::from(\"closure called\");\n   |         ----- captured outer variable\n16 |\n17 |     list.sort_by_key(|r| {\n   |                      --- captured by this `FnMut` closure\n18 |         sort_operations.push(value);\n   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait\n\nFor more information about this error, try `rustc --explain E0507`.\nerror: could not compile `rectangles` (bin \"rectangles\") due to 1 previous error\n\n```\n\nThe error points to the line in the closure body that moves `value` out of the environment. To fix this, we need to change the closure body so that it doesn’t move values out of the environment. To count the number of times the closure is called, keeping a counter in the environment and incrementing its value in the closure body is a more straightforward way to calculate that. The closure in Listing 13-9 works with `sort_by_key` because it is only capturing a mutable reference to the `num_sort_operations` counter and can therefore be called more than once:\n\nFilename: src/main.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut num_sort_operations = 0;\n    list.sort_by_key(|r| {\n        num_sort_operations += 1;\n        r.width\n    });\n    println!(\"{list:#?}, sorted in {num_sort_operations} operations\");\n}\n```\n\nListing 13-9: Using an `FnMut` closure with `sort_by_key` is allowed\n\nThe `Fn` traits are important when defining or using functions or types that make use of closures. In the next section, we’ll discuss iterators. Many iterator methods take closure arguments, so keep these closure details in mind as we continue!",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Closures: Anonymous Functions that Capture Their Environment - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <!-- Old heading. Do not remove or links may break. -->\n<p><a id=\"closures-anonymous-functions-that-can-capture-their-environment\"></a></p>\n<h2 id=\"closures-anonymous-functions-that-capture-their-environment\"><a class=\"header\" href=\"#closures-anonymous-functions-that-capture-their-environment\">Closures: Anonymous Functions that Capture Their Environment</a></h2>\n<p>Rust’s closures are anonymous functions you can save in a variable or pass as\narguments to other functions. You can create the closure in one place and then\ncall the closure elsewhere to evaluate it in a different context. Unlike\nfunctions, closures can capture values from the scope in which they’re defined.\nWe’ll demonstrate how these closure features allow for code reuse and behavior\ncustomization.</p>\n<!-- Old headings. Do not remove or links may break. -->\n<p><a id=\"creating-an-abstraction-of-behavior-with-closures\"></a>\n<a id=\"refactoring-using-functions\"></a>\n<a id=\"refactoring-with-closures-to-store-code\"></a></p>\n<h3 id=\"capturing-the-environment-with-closures\"><a class=\"header\" href=\"#capturing-the-environment-with-closures\">Capturing the Environment with Closures</a></h3>\n<p>We’ll first examine how we can use closures to capture values from the\nenvironment they’re defined in for later use. Here’s the scenario: Every so\noften, our t-shirt company gives away an exclusive, limited-edition shirt to\nsomeone on our mailing list as a promotion. People on the mailing list can\noptionally add their favorite color to their profile. If the person chosen for\na free shirt has their favorite color set, they get that color shirt. If the\nperson hasn’t specified a favorite color, they get whatever color the company\ncurrently has the most of.</p>\n<p>There are many ways to implement this. For this example, we’re going to use an\nenum called <code class=\"hljs\">ShirtColor</code> that has the variants <code class=\"hljs\">Red</code> and <code class=\"hljs\">Blue</code> (limiting the\nnumber of colors available for simplicity). We represent the company’s\ninventory with an <code class=\"hljs\">Inventory</code> struct that has a field named <code class=\"hljs\">shirts</code> that\ncontains a <code class=\"hljs\">Vec&lt;ShirtColor&gt;</code> representing the shirt colors currently in stock.\nThe method <code class=\"hljs\">giveaway</code> defined on <code class=\"hljs\">Inventory</code> gets the optional shirt\ncolor preference of the free shirt winner, and returns the shirt color the\nperson will get. This setup is shown in Listing 13-1:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-meta\">#[derive(Debug, PartialEq, Copy, Clone)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">ShirtColor</span></span> {\n    Red,\n    Blue,\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inventory</span></span> {\n    shirts: <span class=\"hljs-built_in\">Vec</span>&lt;ShirtColor&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span> Inventory {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">giveaway</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, user_preference: <span class=\"hljs-built_in\">Option</span>&lt;ShirtColor&gt;) -&gt; ShirtColor {\n        user_preference.unwrap_or_else(|| <span class=\"hljs-keyword\">self</span>.most_stocked())\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">most_stocked</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; ShirtColor {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> num_red = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> num_blue = <span class=\"hljs-number\">0</span>;\n\n        <span class=\"hljs-keyword\">for</span> color <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">self</span>.shirts {\n            <span class=\"hljs-keyword\">match</span> color {\n                ShirtColor::Red =&gt; num_red += <span class=\"hljs-number\">1</span>,\n                ShirtColor::Blue =&gt; num_blue += <span class=\"hljs-number\">1</span>,\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> num_red &gt; num_blue {\n            ShirtColor::Red\n        } <span class=\"hljs-keyword\">else</span> {\n            ShirtColor::Blue\n        }\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> store = Inventory {\n        shirts: <span class=\"hljs-built_in\">vec!</span>[ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],\n    };\n\n    <span class=\"hljs-keyword\">let</span> user_pref1 = <span class=\"hljs-literal\">Some</span>(ShirtColor::Red);\n    <span class=\"hljs-keyword\">let</span> giveaway1 = store.giveaway(user_pref1);\n    <span class=\"hljs-built_in\">println!</span>(\n        <span class=\"hljs-string\">\"The user with preference {:?} gets {:?}\"</span>,\n        user_pref1, giveaway1\n    );\n\n    <span class=\"hljs-keyword\">let</span> user_pref2 = <span class=\"hljs-literal\">None</span>;\n    <span class=\"hljs-keyword\">let</span> giveaway2 = store.giveaway(user_pref2);\n    <span class=\"hljs-built_in\">println!</span>(\n        <span class=\"hljs-string\">\"The user with preference {:?} gets {:?}\"</span>,\n        user_pref2, giveaway2\n    );\n}</code></pre>\n<p><span class=\"caption\">Listing 13-1: Shirt company giveaway situation</span></p>\n<p>The <code class=\"hljs\">store</code> defined in <code class=\"hljs\">main</code> has two blue shirts and one red shirt remaining\nto distribute for this limited-edition promotion. We call the <code class=\"hljs\">giveaway</code> method\nfor a user with a preference for a red shirt and a user without any preference.</p>\n<p>Again, this code could be implemented in many ways, and here, to focus on\nclosures, we’ve stuck to concepts you’ve already learned except for the body of\nthe <code class=\"hljs\">giveaway</code> method that uses a closure. In the <code class=\"hljs\">giveaway</code> method, we get the\nuser preference as a parameter of type <code class=\"hljs\">Option&lt;ShirtColor&gt;</code> and call the\n<code class=\"hljs\">unwrap_or_else</code> method on <code class=\"hljs\">user_preference</code>. The <a href=\"../std/option/enum.Option.html#method.unwrap_or_else\"><code class=\"hljs\">unwrap_or_else</code> method on\n<code class=\"hljs\">Option&lt;T&gt;</code></a><!-- ignore --> is defined by the standard library.\nIt takes one argument: a closure without any arguments that returns a value <code class=\"hljs\">T</code>\n(the same type stored in the <code class=\"hljs\">Some</code> variant of the <code class=\"hljs\">Option&lt;T&gt;</code>, in this case\n<code class=\"hljs\">ShirtColor</code>). If the <code class=\"hljs\">Option&lt;T&gt;</code> is the <code class=\"hljs\">Some</code> variant, <code class=\"hljs\">unwrap_or_else</code>\nreturns the value from within the <code class=\"hljs\">Some</code>. If the <code class=\"hljs\">Option&lt;T&gt;</code> is the <code class=\"hljs\">None</code>\nvariant, <code class=\"hljs\">unwrap_or_else</code> calls the closure and returns the value returned by\nthe closure.</p>\n<p>We specify the closure expression <code class=\"hljs\">|| self.most_stocked()</code> as the argument to\n<code class=\"hljs\">unwrap_or_else</code>. This is a closure that takes no parameters itself (if the\nclosure had parameters, they would appear between the two vertical bars). The\nbody of the closure calls <code class=\"hljs\">self.most_stocked()</code>. We’re defining the closure\nhere, and the implementation of <code class=\"hljs\">unwrap_or_else</code> will evaluate the closure\nlater if the result is needed.</p>\n<p>Running this code prints:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n     Running `target/debug/shirt-company`\nThe user with preference Some(Red) gets Red\nThe user with preference None gets Blue\n</code></pre>\n<p>One interesting aspect here is that we’ve passed a closure that calls\n<code class=\"hljs\">self.most_stocked()</code> on the current <code class=\"hljs\">Inventory</code> instance. The standard library\ndidn’t need to know anything about the <code class=\"hljs\">Inventory</code> or <code class=\"hljs\">ShirtColor</code> types we\ndefined, or the logic we want to use in this scenario. The closure captures an\nimmutable reference to the <code class=\"hljs\">self</code> <code class=\"hljs\">Inventory</code> instance and passes it with the\ncode we specify to the <code class=\"hljs\">unwrap_or_else</code> method. Functions, on the other hand,\nare not able to capture their environment in this way.</p>\n<h3 id=\"closure-type-inference-and-annotation\"><a class=\"header\" href=\"#closure-type-inference-and-annotation\">Closure Type Inference and Annotation</a></h3>\n<p>There are more differences between functions and closures. Closures don’t\nusually require you to annotate the types of the parameters or the return value\nlike <code class=\"hljs\">fn</code> functions do. Type annotations are required on functions because the\ntypes are part of an explicit interface exposed to your users. Defining this\ninterface rigidly is important for ensuring that everyone agrees on what types\nof values a function uses and returns. Closures, on the other hand, aren’t used\nin an exposed interface like this: they’re stored in variables and used without\nnaming them and exposing them to users of our library.</p>\n<p>Closures are typically short and relevant only within a narrow context rather\nthan in any arbitrary scenario. Within these limited contexts, the compiler can\ninfer the types of the parameters and the return type, similar to how it’s able\nto infer the types of most variables (there are rare cases where the compiler\nneeds closure type annotations too).</p>\n<p>As with variables, we can add type annotations if we want to increase\nexplicitness and clarity at the cost of being more verbose than is strictly\nnecessary. Annotating the types for a closure would look like the definition\nshown in Listing 13-2. In this example, we’re defining a closure and storing it\nin a variable rather than defining the closure in the spot we pass it as an\nargument as we did in Listing 13-1.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::thread;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::time::Duration;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">generate_workout</span></span>(intensity: <span class=\"hljs-built_in\">u32</span>, random_number: <span class=\"hljs-built_in\">u32</span>) {\n</span>    <span class=\"hljs-keyword\">let</span> expensive_closure = |num: <span class=\"hljs-built_in\">u32</span>| -&gt; <span class=\"hljs-built_in\">u32</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"calculating slowly...\"</span>);\n        thread::sleep(Duration::from_secs(<span class=\"hljs-number\">2</span>));\n        num\n    };\n<span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">if</span> intensity &lt; <span class=\"hljs-number\">25</span> {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Today, do {} pushups!\"</span>, expensive_closure(intensity));\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Next, do {} situps!\"</span>, expensive_closure(intensity));\n</span><span class=\"boring\">    } <span class=\"hljs-keyword\">else</span> {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> random_number == <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Take a break today! Remember to stay hydrated!\"</span>);\n</span><span class=\"boring\">        } <span class=\"hljs-keyword\">else</span> {\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(\n</span><span class=\"boring\">                <span class=\"hljs-string\">\"Today, run for {} minutes!\"</span>,\n</span><span class=\"boring\">                expensive_closure(intensity)\n</span><span class=\"boring\">            );\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> simulated_user_specified_value = <span class=\"hljs-number\">10</span>;\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> simulated_random_number = <span class=\"hljs-number\">7</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    generate_workout(simulated_user_specified_value, simulated_random_number);\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 13-2: Adding optional type annotations of the\nparameter and return value types in the closure</span></p>\n<p>With type annotations added, the syntax of closures looks more similar to the\nsyntax of functions. Here we define a function that adds 1 to its parameter and\na closure that has the same behavior, for comparison. We’ve added some spaces\nto line up the relevant parts. This illustrates how closure syntax is similar\nto function syntax except for the use of pipes and the amount of syntax that is\noptional:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span>  <span class=\"hljs-title\">add_one_v1</span>   </span>(x: <span class=\"hljs-built_in\">u32</span>) -&gt; <span class=\"hljs-built_in\">u32</span> { x + <span class=\"hljs-number\">1</span> }\n<span class=\"hljs-keyword\">let</span> add_one_v2 = |x: <span class=\"hljs-built_in\">u32</span>| -&gt; <span class=\"hljs-built_in\">u32</span> { x + <span class=\"hljs-number\">1</span> };\n<span class=\"hljs-keyword\">let</span> add_one_v3 = |x|             { x + <span class=\"hljs-number\">1</span> };\n<span class=\"hljs-keyword\">let</span> add_one_v4 = |x|               x + <span class=\"hljs-number\">1</span>  ;</code></pre>\n<p>The first line shows a function definition, and the second line shows a fully\nannotated closure definition. In the third line, we remove the type annotations\nfrom the closure definition. In the fourth line, we remove the brackets, which\nare optional because the closure body has only one expression. These are all\nvalid definitions that will produce the same behavior when they’re called. The\n<code class=\"hljs\">add_one_v3</code> and <code class=\"hljs\">add_one_v4</code> lines require the closures to be evaluated to be\nable to compile because the types will be inferred from their usage. This is\nsimilar to <code class=\"hljs\">let v = Vec::new();</code> needing either type annotations or values of\nsome type to be inserted into the <code class=\"hljs\">Vec</code> for Rust to be able to infer the type.</p>\n<p>For closure definitions, the compiler will infer one concrete type for each of\ntheir parameters and for their return value. For instance, Listing 13-3 shows\nthe definition of a short closure that just returns the value it receives as a\nparameter. This closure isn’t very useful except for the purposes of this\nexample. Note that we haven’t added any type annotations to the definition.\nBecause there are no type annotations, we can call the closure with any type,\nwhich we’ve done here with <code class=\"hljs\">String</code> the first time. If we then try to call\n<code class=\"hljs\">example_closure</code> with an integer, we’ll get an error.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> example_closure = |x| x;\n\n    <span class=\"hljs-keyword\">let</span> s = example_closure(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>));\n    <span class=\"hljs-keyword\">let</span> n = example_closure(<span class=\"hljs-number\">5</span>);\n<span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 13-3: Attempting to call a closure whose types\nare inferred with two different types</span></p>\n<p>The compiler gives us this error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\nerror[E0308]: mismatched types\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:5:29</span>\n  |\n5 |     let n = example_closure(5);\n  |             --------------- ^- help: try using a conversion method: `.to_string()`\n  |             |               |\n  |             |               expected `String`, found integer\n  |             arguments to this function are incorrect\n  |\nnote: expected because the closure was earlier called with an argument of type `String`\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:4:29</span>\n  |\n4 |     let s = example_closure(String::from(\"hello\"));\n  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`\n  |             |\n  |             in this closure call\nnote: closure parameter defined here\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:2:28</span>\n  |\n2 |     let example_closure = |x| x;\n  |                            ^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `closure-example` (bin \"closure-example\") due to 1 previous error\n</code></pre>\n<p>The first time we call <code class=\"hljs\">example_closure</code> with the <code class=\"hljs\">String</code> value, the compiler\ninfers the type of <code class=\"hljs\">x</code> and the return type of the closure to be <code class=\"hljs\">String</code>. Those\ntypes are then locked into the closure in <code class=\"hljs\">example_closure</code>, and we get a type\nerror when we next try to use a different type with the same closure.</p>\n<h3 id=\"capturing-references-or-moving-ownership\"><a class=\"header\" href=\"#capturing-references-or-moving-ownership\">Capturing References or Moving Ownership</a></h3>\n<p>Closures can capture values from their environment in three ways, which\ndirectly map to the three ways a function can take a parameter: borrowing\nimmutably, borrowing mutably, and taking ownership. The closure will decide\nwhich of these to use based on what the body of the function does with the\ncaptured values.</p>\n<p>In Listing 13-4, we define a closure that captures an immutable reference to\nthe vector named <code class=\"hljs\">list</code> because it only needs an immutable reference to print\nthe value:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> list = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Before defining closure: {list:?}\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> only_borrows = || <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"From closure: {list:?}\"</span>);\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Before calling closure: {list:?}\"</span>);\n    only_borrows();\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"After calling closure: {list:?}\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 13-4: Defining and calling a closure that\ncaptures an immutable reference</span></p>\n<p>This example also illustrates that a variable can bind to a closure definition,\nand we can later call the closure by using the variable name and parentheses as\nif the variable name were a function name.</p>\n<p>Because we can have multiple immutable references to <code class=\"hljs\">list</code> at the same time,\n<code class=\"hljs\">list</code> is still accessible from the code before the closure definition, after\nthe closure definition but before the closure is called, and after the closure\nis called. This code compiles, runs, and prints:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/closure-example`\nBefore defining closure: [1, 2, 3]\nBefore calling closure: [1, 2, 3]\nFrom closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3]\n</code></pre>\n<p>Next, in Listing 13-5, we change the closure body so that it adds an element to\nthe <code class=\"hljs\">list</code> vector. The closure now captures a mutable reference:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> list = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Before defining closure: {list:?}\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> borrows_mutably = || list.push(<span class=\"hljs-number\">7</span>);\n\n    borrows_mutably();\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"After calling closure: {list:?}\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 13-5: Defining and calling a closure that\ncaptures a mutable reference</span></p>\n<p>This code compiles, runs, and prints:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/closure-example`\nBefore defining closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3, 7]\n</code></pre>\n<p>Note that there’s no longer a <code class=\"hljs\">println!</code> between the definition and the call of\nthe <code class=\"hljs\">borrows_mutably</code> closure: when <code class=\"hljs\">borrows_mutably</code> is defined, it captures a\nmutable reference to <code class=\"hljs\">list</code>. We don’t use the closure again after the closure\nis called, so the mutable borrow ends. Between the closure definition and the\nclosure call, an immutable borrow to print isn’t allowed because no other\nborrows are allowed when there’s a mutable borrow. Try adding a <code class=\"hljs\">println!</code>\nthere to see what error message you get!</p>\n<p>If you want to force the closure to take ownership of the values it uses in the\nenvironment even though the body of the closure doesn’t strictly need\nownership, you can use the <code class=\"hljs\">move</code> keyword before the parameter list.</p>\n<p>This technique is mostly useful when passing a closure to a new thread to move\nthe data so that it’s owned by the new thread. We’ll discuss threads and why\nyou would want to use them in detail in Chapter 16 when we talk about\nconcurrency, but for now, let’s briefly explore spawning a new thread using a\nclosure that needs the <code class=\"hljs\">move</code> keyword. Listing 13-6 shows Listing 13-4 modified\nto print the vector in a new thread rather than in the main thread:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> list = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Before defining closure: {list:?}\"</span>);\n\n    thread::spawn(<span class=\"hljs-keyword\">move</span> || <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"From thread: {list:?}\"</span>))\n        .join()\n        .unwrap();\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 13-6: Using <code class=\"hljs\">move</code> to force the closure for the\nthread to take ownership of <code class=\"hljs\">list</code></span></p>\n<p>We spawn a new thread, giving the thread a closure to run as an argument. The\nclosure body prints out the list. In Listing 13-4, the closure only captured\n<code class=\"hljs\">list</code> using an immutable reference because that’s the least amount of access\nto <code class=\"hljs\">list</code> needed to print it. In this example, even though the closure body\nstill only needs an immutable reference, we need to specify that <code class=\"hljs\">list</code> should\nbe moved into the closure by putting the <code class=\"hljs\">move</code> keyword at the beginning of the\nclosure definition. The new thread might finish before the rest of the main\nthread finishes, or the main thread might finish first. If the main thread\nmaintained ownership of <code class=\"hljs\">list</code> but ended before the new thread did and dropped\n<code class=\"hljs\">list</code>, the immutable reference in the thread would be invalid. Therefore, the\ncompiler requires that <code class=\"hljs\">list</code> be moved into the closure given to the new thread\nso the reference will be valid. Try removing the <code class=\"hljs\">move</code> keyword or using <code class=\"hljs\">list</code>\nin the main thread after the closure is defined to see what compiler errors you\nget!</p>\n<!-- Old headings. Do not remove or links may break. -->\n<p><a id=\"storing-closures-using-generic-parameters-and-the-fn-traits\"></a>\n<a id=\"limitations-of-the-cacher-implementation\"></a>\n<a id=\"moving-captured-values-out-of-the-closure-and-the-fn-traits\"></a></p>\n<h3 id=\"moving-captured-values-out-of-closures-and-the-fn-traits\"><a class=\"header\" href=\"#moving-captured-values-out-of-closures-and-the-fn-traits\">Moving Captured Values Out of Closures and the <code>Fn</code> Traits</a></h3>\n<p>Once a closure has captured a reference or captured ownership of a value from\nthe environment where the closure is defined (thus affecting what, if anything,\nis moved <em>into</em> the closure), the code in the body of the closure defines what\nhappens to the references or values when the closure is evaluated later (thus\naffecting what, if anything, is moved <em>out of</em> the closure). A closure body can\ndo any of the following: move a captured value out of the closure, mutate the\ncaptured value, neither move nor mutate the value, or capture nothing from the\nenvironment to begin with.</p>\n<p>The way a closure captures and handles values from the environment affects\nwhich traits the closure implements, and traits are how functions and structs\ncan specify what kinds of closures they can use. Closures will automatically\nimplement one, two, or all three of these <code class=\"hljs\">Fn</code> traits, in an additive fashion,\ndepending on how the closure’s body handles the values:</p>\n<ol>\n<li><code class=\"hljs\">FnOnce</code> applies to closures that can be called once. All closures implement\nat least this trait, because all closures can be called. A closure that\nmoves captured values out of its body will only implement <code class=\"hljs\">FnOnce</code> and none\nof the other <code class=\"hljs\">Fn</code> traits, because it can only be called once.</li>\n<li><code class=\"hljs\">FnMut</code> applies to closures that don’t move captured values out of their\nbody, but that might mutate the captured values. These closures can be\ncalled more than once.</li>\n<li><code class=\"hljs\">Fn</code> applies to closures that don’t move captured values out of their body\nand that don’t mutate captured values, as well as closures that capture\nnothing from their environment. These closures can be called more than once\nwithout mutating their environment, which is important in cases such as\ncalling a closure multiple times concurrently.</li>\n</ol>\n<p>Let’s look at the definition of the <code class=\"hljs\">unwrap_or_else</code> method on <code class=\"hljs\">Option&lt;T&gt;</code> that\nwe used in Listing 13-1:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">unwrap_or_else</span></span>&lt;F&gt;(<span class=\"hljs-keyword\">self</span>, f: F) -&gt; T\n    <span class=\"hljs-keyword\">where</span>\n        F: <span class=\"hljs-built_in\">FnOnce</span>() -&gt; T\n    {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            <span class=\"hljs-literal\">Some</span>(x) =&gt; x,\n            <span class=\"hljs-literal\">None</span> =&gt; f(),\n        }\n    }\n}</code></pre>\n<p>Recall that <code class=\"hljs\">T</code> is the generic type representing the type of the value in the\n<code class=\"hljs\">Some</code> variant of an <code class=\"hljs\">Option</code>. That type <code class=\"hljs\">T</code> is also the return type of the\n<code class=\"hljs\">unwrap_or_else</code> function: code that calls <code class=\"hljs\">unwrap_or_else</code> on an\n<code class=\"hljs\">Option&lt;String&gt;</code>, for example, will get a <code class=\"hljs\">String</code>.</p>\n<p>Next, notice that the <code class=\"hljs\">unwrap_or_else</code> function has the additional generic type\nparameter <code class=\"hljs\">F</code>. The <code class=\"hljs\">F</code> type is the type of the parameter named <code class=\"hljs\">f</code>, which is\nthe closure we provide when calling <code class=\"hljs\">unwrap_or_else</code>.</p>\n<p>The trait bound specified on the generic type <code class=\"hljs\">F</code> is <code class=\"hljs\">FnOnce() -&gt; T</code>, which\nmeans <code class=\"hljs\">F</code> must be able to be called once, take no arguments, and return a <code class=\"hljs\">T</code>.\nUsing <code class=\"hljs\">FnOnce</code> in the trait bound expresses the constraint that\n<code class=\"hljs\">unwrap_or_else</code> is only going to call <code class=\"hljs\">f</code> at most one time. In the body of\n<code class=\"hljs\">unwrap_or_else</code>, we can see that if the <code class=\"hljs\">Option</code> is <code class=\"hljs\">Some</code>, <code class=\"hljs\">f</code> won’t be\ncalled. If the <code class=\"hljs\">Option</code> is <code class=\"hljs\">None</code>, <code class=\"hljs\">f</code> will be called once. Because all\nclosures implement <code class=\"hljs\">FnOnce</code>, <code class=\"hljs\">unwrap_or_else</code> accepts all three kinds of\nclosures and is as flexible as it can be.</p>\n<section class=\"note\" aria-role=\"note\">\n<p>Note: Functions can implement all three of the <code class=\"hljs\">Fn</code> traits too. If what we\nwant to do doesn’t require capturing a value from the environment, we can use\nthe name of a function rather than a closure where we need something that\nimplements one of the <code class=\"hljs\">Fn</code> traits. For example, on an <code class=\"hljs\">Option&lt;Vec&lt;T&gt;&gt;</code> value,\nwe could call <code class=\"hljs\">unwrap_or_else(Vec::new)</code> to get a new, empty vector if the\nvalue is <code class=\"hljs\">None</code>.</p>\n</section>\n<p>Now let’s look at the standard library method <code class=\"hljs\">sort_by_key</code> defined on slices,\nto see how that differs from <code class=\"hljs\">unwrap_or_else</code> and why <code class=\"hljs\">sort_by_key</code> uses\n<code class=\"hljs\">FnMut</code> instead of <code class=\"hljs\">FnOnce</code> for the trait bound. The closure gets one argument\nin the form of a reference to the current item in the slice being considered,\nand returns a value of type <code class=\"hljs\">K</code> that can be ordered. This function is useful\nwhen you want to sort a slice by a particular attribute of each item. In\nListing 13-7, we have a list of <code class=\"hljs\">Rectangle</code> instances and we use <code class=\"hljs\">sort_by_key</code>\nto order them by their <code class=\"hljs\">width</code> attribute from low to high:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n    width: <span class=\"hljs-built_in\">u32</span>,\n    height: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> list = [\n        Rectangle { width: <span class=\"hljs-number\">10</span>, height: <span class=\"hljs-number\">1</span> },\n        Rectangle { width: <span class=\"hljs-number\">3</span>, height: <span class=\"hljs-number\">5</span> },\n        Rectangle { width: <span class=\"hljs-number\">7</span>, height: <span class=\"hljs-number\">12</span> },\n    ];\n\n    list.sort_by_key(|r| r.width);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{list:#?}\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 13-7: Using <code class=\"hljs\">sort_by_key</code> to order rectangles by\nwidth</span></p>\n<p>This code prints:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s\n     Running `target/debug/rectangles`\n[\n    Rectangle {\n        width: 3,\n        height: 5,\n    },\n    Rectangle {\n        width: 7,\n        height: 12,\n    },\n    Rectangle {\n        width: 10,\n        height: 1,\n    },\n]\n</code></pre>\n<p>The reason <code class=\"hljs\">sort_by_key</code> is defined to take an <code class=\"hljs\">FnMut</code> closure is that it calls\nthe closure multiple times: once for each item in the slice. The closure <code class=\"hljs\">|r| r.width</code> doesn’t capture, mutate, or move out anything from its environment, so\nit meets the trait bound requirements.</p>\n<p>In contrast, Listing 13-8 shows an example of a closure that implements just\nthe <code class=\"hljs\">FnOnce</code> trait, because it moves a value out of the environment. The\ncompiler won’t let us use this closure with <code class=\"hljs\">sort_by_key</code>:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n    width: <span class=\"hljs-built_in\">u32</span>,\n    height: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> list = [\n        Rectangle { width: <span class=\"hljs-number\">10</span>, height: <span class=\"hljs-number\">1</span> },\n        Rectangle { width: <span class=\"hljs-number\">3</span>, height: <span class=\"hljs-number\">5</span> },\n        Rectangle { width: <span class=\"hljs-number\">7</span>, height: <span class=\"hljs-number\">12</span> },\n    ];\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> sort_operations = <span class=\"hljs-built_in\">vec!</span>[];\n    <span class=\"hljs-keyword\">let</span> value = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"closure called\"</span>);\n\n    list.sort_by_key(|r| {\n        sort_operations.push(value);\n        r.width\n    });\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{list:#?}\"</span>);\n}</code></pre>\n<p><span class=\"caption\">Listing 13-8: Attempting to use an <code class=\"hljs\">FnOnce</code> closure with\n<code class=\"hljs\">sort_by_key</code></span></p>\n<p>This is a contrived, convoluted way (that doesn’t work) to try and count the\nnumber of times <code class=\"hljs\">sort_by_key</code> calls the closure when sorting <code class=\"hljs\">list</code>. This code\nattempts to do this counting by pushing <code class=\"hljs\">value</code>—a <code class=\"hljs\">String</code> from the closure’s\nenvironment—into the <code class=\"hljs\">sort_operations</code> vector. The closure captures <code class=\"hljs\">value</code>\nthen moves <code class=\"hljs\">value</code> out of the closure by transferring ownership of <code class=\"hljs\">value</code> to\nthe <code class=\"hljs\">sort_operations</code> vector. This closure can be called once; trying to call\nit a second time wouldn’t work because <code class=\"hljs\">value</code> would no longer be in the\nenvironment to be pushed into <code class=\"hljs\">sort_operations</code> again! Therefore, this closure\nonly implements <code class=\"hljs\">FnOnce</code>. When we try to compile this code, we get this error\nthat <code class=\"hljs\">value</code> can’t be moved out of the closure because the closure must\nimplement <code class=\"hljs\">FnMut</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\nerror[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/main.rs:18:30</span>\n   |\n15 |     let value = String::from(\"closure called\");\n   |         ----- captured outer variable\n16 |\n17 |     list.sort_by_key(|r| {\n   |                      --- captured by this `FnMut` closure\n18 |         sort_operations.push(value);\n   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait\n\nFor more information about this error, try `rustc --explain E0507`.\nerror: could not compile `rectangles` (bin \"rectangles\") due to 1 previous error\n</code></pre>\n<p>The error points to the line in the closure body that moves <code class=\"hljs\">value</code> out of the\nenvironment. To fix this, we need to change the closure body so that it doesn’t\nmove values out of the environment. To count the number of times the closure\nis called, keeping a counter in the environment and incrementing its value in\nthe closure body is a more straightforward way to calculate that. The closure\nin Listing 13-9 works with <code class=\"hljs\">sort_by_key</code> because it is only capturing a mutable\nreference to the <code class=\"hljs\">num_sort_operations</code> counter and can therefore be called more\nthan once:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n    width: <span class=\"hljs-built_in\">u32</span>,\n    height: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> list = [\n        Rectangle { width: <span class=\"hljs-number\">10</span>, height: <span class=\"hljs-number\">1</span> },\n        Rectangle { width: <span class=\"hljs-number\">3</span>, height: <span class=\"hljs-number\">5</span> },\n        Rectangle { width: <span class=\"hljs-number\">7</span>, height: <span class=\"hljs-number\">12</span> },\n    ];\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> num_sort_operations = <span class=\"hljs-number\">0</span>;\n    list.sort_by_key(|r| {\n        num_sort_operations += <span class=\"hljs-number\">1</span>;\n        r.width\n    });\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{list:#?}, sorted in {num_sort_operations} operations\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 13-9: Using an <code class=\"hljs\">FnMut</code> closure with <code class=\"hljs\">sort_by_key</code>\nis allowed</span></p>\n<p>The <code class=\"hljs\">Fn</code> traits are important when defining or using functions or types that\nmake use of closures. In the next section, we’ll discuss iterators. Many\niterator methods take closure arguments, so keep these closure details in mind\nas we continue!</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch13-00-functional-features.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch13-02-iterators.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch13-00-functional-features.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch13-02-iterators.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:25.869Z"
}