{
	"title": "fn - Rust",
	"url": "https://doc.rust-lang.org/stable/std/primitive.fn.html",
	"markdown": "# fn - Rust\n\nExpand description\n\nFunction pointers, like `fn(usize) -> bool`.\n\n_See also the traits [`Fn`](ops/trait.Fn.html \"trait std::ops::Fn\"), [`FnMut`](ops/trait.FnMut.html \"trait std::ops::FnMut\"), and [`FnOnce`](ops/trait.FnOnce.html \"trait std::ops::FnOnce\")._\n\nFunction pointers are pointers that point to _code_, not data. They can be called just like functions. Like references, function pointers are, among other things, assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type [`Option<fn()>`](about:blank/option/index.html#options-and-pointers-nullable-pointers \"mod std::option\") with your required signature.\n\n#### [§](#safety)Safety\n\nPlain function pointers are obtained by casting either plain functions, or closures that don’t capture an environment:\n\n```\nfn add_one(x: usize) -> usize {\n    x + 1\n}\n\nlet ptr: fn(usize) -> usize = add_one;\nassert_eq!(ptr(5), 6);\n\nlet clos: fn(usize) -> usize = |x| x + 5;\nassert_eq!(clos(5), 10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+add_one(x:+usize)+-%3E+usize+%7B%0A++++++++x+%2B+1%0A++++%7D%0A++++%0A++++let+ptr:+fn(usize)+-%3E+usize+=+add_one;%0A++++assert_eq!(ptr(5),+6);%0A++++%0A++++let+clos:+fn(usize)+-%3E+usize+=+%7Cx%7C+x+%2B+5;%0A++++assert_eq!(clos(5),+10);%0A%7D&edition=2021)\n\nIn addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain `fn()` function pointers can only point to safe functions, while `unsafe fn()` function pointers can point to safe or unsafe functions.\n\n```\nfn add_one(x: usize) -> usize {\n    x + 1\n}\n\nunsafe fn add_one_unsafely(x: usize) -> usize {\n    x + 1\n}\n\nlet safe_ptr: fn(usize) -> usize = add_one;\n\n//ERROR: mismatched types: expected normal fn, found unsafe fn\n//let bad_ptr: fn(usize) -> usize = add_one_unsafely;\n\nlet unsafe_ptr: unsafe fn(usize) -> usize = add_one_unsafely;\nlet really_safe_ptr: unsafe fn(usize) -> usize = add_one;\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+add_one(x:+usize)+-%3E+usize+%7B%0A++++++++x+%2B+1%0A++++%7D%0A++++%0A++++unsafe+fn+add_one_unsafely(x:+usize)+-%3E+usize+%7B%0A++++++++x+%2B+1%0A++++%7D%0A++++%0A++++let+safe_ptr:+fn(usize)+-%3E+usize+=+add_one;%0A++++%0A++++//ERROR:+mismatched+types:+expected+normal+fn,+found+unsafe+fn%0A++++//let+bad_ptr:+fn(usize)+-%3E+usize+=+add_one_unsafely;%0A++++%0A++++let+unsafe_ptr:+unsafe+fn(usize)+-%3E+usize+=+add_one_unsafely;%0A++++let+really_safe_ptr:+unsafe+fn(usize)+-%3E+usize+=+add_one;%0A%7D&edition=2021)\n\n#### [§](#abi)ABI\n\nOn top of that, function pointers can vary based on what ABI they use. This is achieved by adding the `extern` keyword before the type, followed by the ABI in question. The default ABI is “Rust”, i.e., `fn()` is the exact same type as `extern \"Rust\" fn()`. A pointer to a function with C ABI would have type `extern \"C\" fn()`.\n\n`extern \"ABI\" { ... }` blocks declare functions with ABI “ABI”. The default here is “C”, i.e., functions declared in an `extern {...}` block have “C” ABI.\n\nFor more information and a list of supported ABIs, see [the nomicon’s section on foreign calling conventions](about:blank/nomicon/ffi.html#foreign-calling-conventions).\n\n#### [§](#variadic-functions)Variadic functions\n\nExtern function declarations with the “C” or “cdecl” ABIs can also be _variadic_, allowing them to be called with a variable number of arguments. Normal Rust functions, even those with an `extern \"ABI\"`, cannot be variadic. For more information, see [the nomicon’s section on variadic functions](about:blank/nomicon/ffi.html#variadic-functions).\n\n#### [§](#creating-function-pointers)Creating function pointers\n\nWhen `bar` is the name of a function, then the expression `bar` is _not_ a function pointer. Rather, it denotes a value of an unnameable type that uniquely identifies the function `bar`. The value is zero-sized because the type already identifies the function. This has the advantage that “calling” the value (it implements the `Fn*` traits) does not require dynamic dispatch.\n\nThis zero-sized type _coerces_ to a regular function pointer. For example:\n\n```\nuse std::mem;\n\nfn bar(x: i32) {}\n\nlet not_bar_ptr = bar; // `not_bar_ptr` is zero-sized, uniquely identifying `bar`\nassert_eq!(mem::size_of_val(&not_bar_ptr), 0);\n\nlet bar_ptr: fn(i32) = not_bar_ptr; // force coercion to function pointer\nassert_eq!(mem::size_of_val(&bar_ptr), mem::size_of::<usize>());\n\nlet footgun = &bar; // this is a shared reference to the zero-sized type identifying `bar`\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++fn+bar(x:+i32)+%7B%7D%0A++++%0A++++let+not_bar_ptr+=+bar;+//+%60not_bar_ptr%60+is+zero-sized,+uniquely+identifying+%60bar%60%0A++++assert_eq!(mem::size_of_val(%26not_bar_ptr),+0);%0A++++%0A++++let+bar_ptr:+fn(i32)+=+not_bar_ptr;+//+force+coercion+to+function+pointer%0A++++assert_eq!(mem::size_of_val(%26bar_ptr),+mem::size_of::%3Cusize%3E());%0A++++%0A++++let+footgun+=+%26bar;+//+this+is+a+shared+reference+to+the+zero-sized+type+identifying+%60bar%60%0A%7D&edition=2021)\n\nThe last line shows that `&bar` is not a function pointer either. Rather, it is a reference to the function-specific ZST. `&bar` is basically never what you want when `bar` is a function.\n\n#### [§](#casting-to-and-from-integers)Casting to and from integers\n\nYou can cast function pointers directly to integers:\n\n```\nlet fnptr: fn(i32) -> i32 = |x| x+2;\nlet fnptr_addr = fnptr as usize;\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+fnptr:+fn(i32)+-%3E+i32+=+%7Cx%7C+x%2B2;%0A++++let+fnptr_addr+=+fnptr+as+usize;%0A%7D&edition=2021)\n\nHowever, a direct cast back is not possible. You need to use `transmute`:\n\n```\nlet fnptr = fnptr_addr as *const ();\nlet fnptr: fn(i32) -> i32 = unsafe { std::mem::transmute(fnptr) };\nassert_eq!(fnptr(40), 42);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(not(miri))%5D+%7B+//+FIXME:+use+strict+provenance+APIs+once+they+are+stable,+then+remove+this+%60cfg%60%0A++++let+fnptr:+fn(i32)+-%3E+i32+=+%7Cx%7C+x%2B2;%0A++++let+fnptr_addr+=+fnptr+as+usize;%0A++++let+fnptr+=+fnptr_addr+as+*const+();%0A++++let+fnptr:+fn(i32)+-%3E+i32+=+unsafe+%7B+std::mem::transmute(fnptr)+%7D;%0A++++assert_eq!(fnptr(40),+42);%0A++++%7D%0A%7D&edition=2021)\n\nCrucially, we `as`\\-cast to a raw pointer before `transmute`ing to a function pointer. This avoids an integer-to-pointer `transmute`, which can be problematic. Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine.\n\nNote that all of this is not portable to platforms where function pointers and data pointers have different sizes.\n\n#### [§](#abi-compatibility)ABI compatibility\n\nGenerally, when a function is declared with one signature and called via a function pointer with a different signature, the two signatures must be _ABI-compatible_ or else calling the function via that function pointer is Undefined Behavior. ABI compatibility is a lot stricter than merely having the same memory layout; for example, even if `i32` and `f32` have the same size and alignment, they might be passed in different registers and hence not be ABI-compatible.\n\nABI compatibility as a concern only arises in code that alters the type of function pointers, code that imports functions via `extern` blocks, and in code that combines `#[target_feature]` with `extern fn`. Altering the type of function pointers is wildly unsafe (as in, a lot more unsafe than even [`transmute_copy`](mem/fn.transmute_copy.html \"fn std::mem::transmute_copy\")), and should only occur in the most exceptional circumstances. Most Rust code just imports functions via `use`. `#[target_feature]` is also used rarely. So, most likely you do not have to worry about ABI compatibility.\n\nBut assuming such circumstances, what are the rules? For this section, we are only considering the ABI of direct Rust-to-Rust calls, not linking in general – once functions are imported via `extern` blocks, there are more things to consider that we do not go into here.\n\nFor two signatures to be considered _ABI-compatible_, they must use a compatible ABI string, must take the same number of arguments, the individual argument types and the return types must be ABI-compatible, and the target feature requirements must be met (see the subsection below for the last point). The ABI string is declared via `extern \"ABI\" fn(...) -> ...`; note that `fn name(...) -> ...` implicitly uses the `\"Rust\"` ABI string and `extern fn name(...) -> ...` implicitly uses the `\"C\"` ABI string.\n\nThe ABI strings are guaranteed to be compatible if they are the same, or if the caller ABI string is `$X-unwind` and the callee ABI string is `$X`, where `$X` is one of the following: “C”, “aapcs”, “fastcall”, “stdcall”, “system”, “sysv64”, “thiscall”, “vectorcall”, “win64”.\n\nThe following types are guaranteed to be ABI-compatible:\n\n-   `*const T`, `*mut T`, `&T`, `&mut T`, `Box<T>` (specifically, only `Box<T, Global>`), and `NonNull<T>` are all ABI-compatible with each other for all `T`. They are also ABI-compatible with each other for _different_ `T` if they have the same metadata type (`<T as Pointee>::Metadata`).\n-   `usize` is ABI-compatible with the `uN` integer type of the same size, and likewise `isize` is ABI-compatible with the `iN` integer type of the same size.\n-   `char` is ABI-compatible with `u32`.\n-   Any two `fn` (function pointer) types are ABI-compatible with each other if they have the same ABI string or the ABI string only differs in a trailing `-unwind`, independent of the rest of their signature. (This means you can pass `fn()` to a function expecting `fn(i32)`, and the call will be valid ABI-wise. The callee receives the result of transmuting the function pointer from `fn()` to `fn(i32)`; that transmutation is itself a well-defined operation, it’s just almost certainly UB to later call that function pointer.)\n-   Any two types with size 0 and alignment 1 are ABI-compatible.\n-   A `repr(transparent)` type `T` is ABI-compatible with its unique non-trivial field, i.e., the unique field that doesn’t have size 0 and alignment 1 (if there is such a field).\n-   `i32` is ABI-compatible with `NonZero<i32>`, and similar for all other integer types.\n-   If `T` is guaranteed to be subject to the [null pointer optimization](about:blank/option/index.html#representation), then `T` and `Option<T>` are ABI-compatible.\n\nFurthermore, ABI compatibility satisfies the following general properties:\n\n-   Every type is ABI-compatible with itself.\n-   If `T1` and `T2` are ABI-compatible and `T2` and `T3` are ABI-compatible, then so are `T1` and `T3` (i.e., ABI-compatibility is transitive).\n-   If `T1` and `T2` are ABI-compatible, then so are `T2` and `T1` (i.e., ABI-compatibility is symmetric).\n\nMore signatures can be ABI-compatible on specific targets, but that should not be relied upon since it is not portable and not a stable guarantee.\n\nNoteworthy cases of types _not_ being ABI-compatible in general are:\n\n-   `bool` vs `u8`, `i32` vs `u32`, `char` vs `i32`: on some targets, the calling conventions for these types differ in terms of what they guarantee for the remaining bits in the register that are not used by the value.\n-   `i32` vs `f32` are not compatible either, as has already been mentioned above.\n-   `struct Foo(u32)` and `u32` are not compatible (without `repr(transparent)`) since structs are aggregate types and often passed in a different way than primitives like `i32`.\n\nNote that these rules describe when two completely known types are ABI-compatible. When considering ABI compatibility of a type declared in another crate (including the standard library), consider that any type that has a private field or the `#[non_exhaustive]` attribute may change its layout as a non-breaking update unless documented otherwise – so for instance, even if such a type is a 1-ZST or `repr(transparent)` right now, this might change with any library version bump.\n\nIf the declared signature and the signature of the function pointer are ABI-compatible, then the function call behaves as if every argument was [`transmute`d](mem/fn.transmute.html \"fn std::mem::transmute\") from the type in the function pointer to the type at the function declaration, and the return value is [`transmute`d](mem/fn.transmute.html \"fn std::mem::transmute\") from the type in the declaration to the type in the pointer. All the usual caveats and concerns around transmutation apply; for instance, if the function expects a `NonZero<i32>` and the function pointer uses the ABI-compatible type `Option<NonZero<i32>>`, and the value used for the argument is `None`, then this call is Undefined Behavior since transmuting `None::<NonZero<i32>>` to `NonZero<i32>` violates the non-zero requirement.\n\n##### [§](#requirements-concerning-target-features)Requirements concerning target features\n\nUnder some conditions, the signature used by the caller and the callee can be ABI-incompatible even if the exact same ABI string and types are being used. As an example, the `std::arch::x86_64::__m256` type has a different `extern \"C\"` ABI when the `avx` feature is enabled vs when it is not enabled.\n\nTherefore, to ensure ABI compatibility when code using different target features is combined (such as via `#[target_feature]`), we further require that one of the following conditions is met:\n\n-   The function uses the `\"Rust\"` ABI string (which is the default without `extern`).\n-   Caller and callee are using the exact same set of target features. For the callee we consider the features enabled (via `#[target_feature]` and `-C target-feature`/`-C target-cpu`) at the declaration site; for the caller we consider the features enabled at the call site.\n-   Neither any argument nor the return value involves a SIMD type (`#[repr(simd)]`) that is not behind a pointer indirection (i.e., `*mut __m256` is fine, but `(i32, __m256)` is not).\n\n#### [§](#trait-implementations-1)Trait implementations\n\nIn this documentation the shorthand `fn(T₁, T₂, …, Tₙ)` is used to represent non-variadic function pointers of varying length. Note that this is a convenience notation to avoid repetitive documentation, not valid Rust syntax.\n\nThe following traits are implemented for function pointers with any number of arguments and any ABI.\n\n-   [`PartialEq`](cmp/trait.PartialEq.html \"trait std::cmp::PartialEq\")\n-   [`Eq`](cmp/trait.Eq.html \"trait std::cmp::Eq\")\n-   [`PartialOrd`](cmp/trait.PartialOrd.html \"trait std::cmp::PartialOrd\")\n-   [`Ord`](cmp/trait.Ord.html \"trait std::cmp::Ord\")\n-   [`Hash`](hash/trait.Hash.html \"trait std::hash::Hash\")\n-   [`Pointer`](fmt/trait.Pointer.html \"trait std::fmt::Pointer\")\n-   [`Debug`](fmt/derive.Debug.html \"derive std::fmt::Debug\")\n-   [`Clone`](clone/trait.Clone.html \"trait std::clone::Clone\")\n-   [`Copy`](marker/trait.Copy.html \"trait std::marker::Copy\")\n-   [`Send`](marker/trait.Send.html \"trait std::marker::Send\")\n-   [`Sync`](marker/trait.Sync.html \"trait std::marker::Sync\")\n-   [`Unpin`](marker/trait.Unpin.html \"trait std::marker::Unpin\")\n-   [`UnwindSafe`](panic/trait.UnwindSafe.html \"trait std::panic::UnwindSafe\")\n-   [`RefUnwindSafe`](panic/trait.RefUnwindSafe.html \"trait std::panic::RefUnwindSafe\")\n\nNote that while this type implements `PartialEq`, comparing function pointers is unreliable: pointers to the same function can compare inequal (because functions are duplicated in multiple codegen units), and pointers to _different_ functions can compare equal (since identical functions can be deduplicated within a codegen unit).\n\nIn addition, all _safe_ function pointers implement [`Fn`](ops/trait.Fn.html \"trait std::ops::Fn\"), [`FnMut`](ops/trait.FnMut.html \"trait std::ops::FnMut\"), and [`FnOnce`](ops/trait.FnOnce.html \"trait std::ops::FnOnce\"), because these traits are specially known to the compiler.\n\n[§](#impl-Freeze-for-fn(T)+-%3E+Ret)\n\n[§](#impl-RefUnwindSafe-for-fn(T)+-%3E+Ret)\n\n[§](#impl-Send-for-fn(T)+-%3E+Ret)\n\n[§](#impl-Sync-for-fn(T)+-%3E+Ret)\n\n[§](#impl-Unpin-for-fn(T)+-%3E+Ret)\n\n[§](#impl-UnwindSafe-for-fn(T)+-%3E+Ret)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140)[§](#impl-Any-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208)[§](#impl-Borrow%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216)[§](#impl-BorrowMut%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2131)[§](#impl-Debug-for-F)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765)[§](#impl-From%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768)[§](#method.from)\n\nReturns the argument unchanged.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2117)[§](#impl-Hash-for-F)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750)[§](#impl-Into%3CU%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758)[§](#method.into)\n\nCalls `U::from(self)`.\n\nThat is, this conversion is whatever the implementation of `[From](convert/trait.From.html \"trait std::convert::From\")<T> for U` chooses to do.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2109)[§](#impl-Ord-for-F)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2092)[§](#impl-PartialEq-for-F)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2094)[§](#method.eq)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263)[§](#method.ne)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2102)[§](#impl-PartialOrd-for-F)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2104)[§](#method.partial_cmp)\n\nThis method returns an ordering between `self` and `other` values if one exists. [Read more](about:blank/cmp/trait.PartialOrd.html#tymethod.partial_cmp)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180)[§](#method.lt)\n\nThis method tests less than (for `self` and `other`) and is used by the `<` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.lt)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198)[§](#method.le)\n\nThis method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.le)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215)[§](#method.gt)\n\nThis method tests greater than (for `self` and `other`) and is used by the `>` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.gt)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233)[§](#method.ge)\n\nThis method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.ge)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#922-924)[§](#impl-Pattern%3C'a%3E-for-F)\n\n[§](#associatedtype.Searcher)\n\n🔬This is a nightly-only experimental API. (`pattern` [#27721](https://github.com/rust-lang/rust/issues/27721))\n\nAssociated searcher for this pattern\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926)[§](#method.into_searcher)\n\n🔬This is a nightly-only experimental API. (`pattern` [#27721](https://github.com/rust-lang/rust/issues/27721))\n\nConstructs the associated searcher from `self` and the `haystack` to search in.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926)[§](#method.is_contained_in)\n\n🔬This is a nightly-only experimental API. (`pattern` [#27721](https://github.com/rust-lang/rust/issues/27721))\n\nChecks whether the pattern matches anywhere in the haystack\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926)[§](#method.is_prefix_of)\n\n🔬This is a nightly-only experimental API. (`pattern` [#27721](https://github.com/rust-lang/rust/issues/27721))\n\nChecks whether the pattern matches at the front of the haystack\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926)[§](#method.strip_prefix_of)\n\n🔬This is a nightly-only experimental API. (`pattern` [#27721](https://github.com/rust-lang/rust/issues/27721))\n\nRemoves the pattern from the front of haystack, if it matches.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926)[§](#method.is_suffix_of)\n\n🔬This is a nightly-only experimental API. (`pattern` [#27721](https://github.com/rust-lang/rust/issues/27721))\n\nChecks whether the pattern matches at the back of the haystack\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926)[§](#method.strip_suffix_of)\n\n🔬This is a nightly-only experimental API. (`pattern` [#27721](https://github.com/rust-lang/rust/issues/27721))\n\nRemoves the pattern from the back of haystack, if it matches.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2124)[§](#impl-Pointer-for-F)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85)[§](#impl-ToOwned-for-T)\n\n[§](#associatedtype.Owned)\n\nThe resulting type after obtaining ownership.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88)[§](#method.to_owned)\n\nCreates owned data from borrowed data, usually by cloning. [Read more](about:blank/borrow/trait.ToOwned.html#tymethod.to_owned)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92)[§](#method.clone_into)\n\nUses borrowed data to replace owned data, usually by cloning. [Read more](about:blank/borrow/trait.ToOwned.html#method.clone_into)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807)[§](#impl-TryFrom%3CU%3E-for-T)\n\n[§](#associatedtype.Error-1)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812)[§](#method.try_from)\n\nPerforms the conversion.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792)[§](#impl-TryInto%3CU%3E-for-T)\n\n[§](#associatedtype.Error)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797)[§](#method.try_into)\n\nPerforms the conversion.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2099)[§](#impl-Eq-for-F)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Function pointers, like `fn(usize) -> bool`.\"><title>fn - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../\" data-static-root-path=\"../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc primitive\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../std/index.html\"><img class=\"rust-logo\" src=\"../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">fn</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../std/index.html\"><img class=\"rust-logo\" src=\"../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">fn</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-fn(T)+-%3E+Ret\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-fn(T)+-%3E+Ret\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-fn(T)+-%3E+Ret\">Send</a></li><li><a href=\"#impl-Sync-for-fn(T)+-%3E+Ret\">Sync</a></li><li><a href=\"#impl-Unpin-for-fn(T)+-%3E+Ret\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-fn(T)+-%3E+Ret\">UnwindSafe</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-Debug-for-F\">Debug</a></li><li><a href=\"#impl-Eq-for-F\">Eq</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Hash-for-F\">Hash</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-Ord-for-F\">Ord</a></li><li><a href=\"#impl-PartialEq-for-F\">PartialEq</a></li><li><a href=\"#impl-PartialOrd-for-F\">PartialOrd</a></li><li><a href=\"#impl-Pattern%3C'a%3E-for-F\">Pattern&lt;'a&gt;</a></li><li><a href=\"#impl-Pointer-for-F\">Pointer</a></li><li><a href=\"#impl-ToOwned-for-T\">ToOwned</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In crate std</a></h2><h3><a href=\"index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"primitive.array.html\">array</a></li><li><a href=\"primitive.bool.html\">bool</a></li><li><a href=\"primitive.char.html\">char</a></li><li><a href=\"primitive.f128.html\">f128</a></li><li><a href=\"primitive.f16.html\">f16</a></li><li><a href=\"primitive.f32.html\">f32</a></li><li><a href=\"primitive.f64.html\">f64</a></li><li><a href=\"primitive.fn.html\">fn</a></li><li><a href=\"primitive.i128.html\">i128</a></li><li><a href=\"primitive.i16.html\">i16</a></li><li><a href=\"primitive.i32.html\">i32</a></li><li><a href=\"primitive.i64.html\">i64</a></li><li><a href=\"primitive.i8.html\">i8</a></li><li><a href=\"primitive.isize.html\">isize</a></li><li><a href=\"primitive.never.html\">never</a></li><li><a href=\"primitive.pointer.html\">pointer</a></li><li><a href=\"primitive.reference.html\">reference</a></li><li><a href=\"primitive.slice.html\">slice</a></li><li><a href=\"primitive.str.html\">str</a></li><li><a href=\"primitive.tuple.html\">tuple</a></li><li><a href=\"primitive.u128.html\">u128</a></li><li><a href=\"primitive.u16.html\">u16</a></li><li><a href=\"primitive.u32.html\">u32</a></li><li><a href=\"primitive.u64.html\">u64</a></li><li><a href=\"primitive.u8.html\">u8</a></li><li><a href=\"primitive.unit.html\">unit</a></li><li><a href=\"primitive.usize.html\">usize</a></li></ul><h3><a href=\"index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"alloc/index.html\">alloc</a></li><li><a href=\"any/index.html\">any</a></li><li><a href=\"arch/index.html\">arch</a></li><li><a href=\"array/index.html\">array</a></li><li><a href=\"ascii/index.html\">ascii</a></li><li><a href=\"assert_matches/index.html\">assert_matches</a></li><li><a href=\"async_iter/index.html\">async_iter</a></li><li><a href=\"backtrace/index.html\">backtrace</a></li><li><a href=\"borrow/index.html\">borrow</a></li><li><a href=\"boxed/index.html\">boxed</a></li><li><a href=\"cell/index.html\">cell</a></li><li><a href=\"char/index.html\">char</a></li><li><a href=\"clone/index.html\">clone</a></li><li><a href=\"cmp/index.html\">cmp</a></li><li><a href=\"collections/index.html\">collections</a></li><li><a href=\"convert/index.html\">convert</a></li><li><a href=\"default/index.html\">default</a></li><li><a href=\"env/index.html\">env</a></li><li><a href=\"error/index.html\">error</a></li><li><a href=\"f128/index.html\">f128</a></li><li><a href=\"f16/index.html\">f16</a></li><li><a href=\"f32/index.html\">f32</a></li><li><a href=\"f64/index.html\">f64</a></li><li><a href=\"ffi/index.html\">ffi</a></li><li><a href=\"fmt/index.html\">fmt</a></li><li><a href=\"fs/index.html\">fs</a></li><li><a href=\"future/index.html\">future</a></li><li><a href=\"hash/index.html\">hash</a></li><li><a href=\"hint/index.html\">hint</a></li><li><a href=\"i128/index.html\">i128</a></li><li><a href=\"i16/index.html\">i16</a></li><li><a href=\"i32/index.html\">i32</a></li><li><a href=\"i64/index.html\">i64</a></li><li><a href=\"i8/index.html\">i8</a></li><li><a href=\"intrinsics/index.html\">intrinsics</a></li><li><a href=\"io/index.html\">io</a></li><li><a href=\"isize/index.html\">isize</a></li><li><a href=\"iter/index.html\">iter</a></li><li><a href=\"marker/index.html\">marker</a></li><li><a href=\"mem/index.html\">mem</a></li><li><a href=\"net/index.html\">net</a></li><li><a href=\"num/index.html\">num</a></li><li><a href=\"ops/index.html\">ops</a></li><li><a href=\"option/index.html\">option</a></li><li><a href=\"os/index.html\">os</a></li><li><a href=\"panic/index.html\">panic</a></li><li><a href=\"pat/index.html\">pat</a></li><li><a href=\"path/index.html\">path</a></li><li><a href=\"pin/index.html\">pin</a></li><li><a href=\"prelude/index.html\">prelude</a></li><li><a href=\"primitive/index.html\">primitive</a></li><li><a href=\"process/index.html\">process</a></li><li><a href=\"ptr/index.html\">ptr</a></li><li><a href=\"rc/index.html\">rc</a></li><li><a href=\"result/index.html\">result</a></li><li><a href=\"simd/index.html\">simd</a></li><li><a href=\"slice/index.html\">slice</a></li><li><a href=\"str/index.html\">str</a></li><li><a href=\"string/index.html\">string</a></li><li><a href=\"sync/index.html\">sync</a></li><li><a href=\"task/index.html\">task</a></li><li><a href=\"thread/index.html\">thread</a></li><li><a href=\"time/index.html\">time</a></li><li><a href=\"u128/index.html\">u128</a></li><li><a href=\"u16/index.html\">u16</a></li><li><a href=\"u32/index.html\">u32</a></li><li><a href=\"u64/index.html\">u64</a></li><li><a href=\"u8/index.html\">u8</a></li><li><a href=\"usize/index.html\">usize</a></li><li><a href=\"vec/index.html\">vec</a></li></ul><h3><a href=\"index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"macro.assert.html\">assert</a></li><li><a href=\"macro.assert_eq.html\">assert_eq</a></li><li><a href=\"macro.assert_ne.html\">assert_ne</a></li><li><a href=\"macro.cfg.html\">cfg</a></li><li><a href=\"macro.cfg_match.html\">cfg_match</a></li><li><a href=\"macro.column.html\">column</a></li><li><a href=\"macro.compile_error.html\">compile_error</a></li><li><a href=\"macro.concat.html\">concat</a></li><li><a href=\"macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"macro.concat_idents.html\">concat_idents</a></li><li><a href=\"macro.const_format_args.html\">const_format_args</a></li><li><a href=\"macro.dbg.html\">dbg</a></li><li><a href=\"macro.debug_assert.html\">debug_assert</a></li><li><a href=\"macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"macro.env.html\">env</a></li><li><a href=\"macro.eprint.html\">eprint</a></li><li><a href=\"macro.eprintln.html\">eprintln</a></li><li><a href=\"macro.file.html\">file</a></li><li><a href=\"macro.format.html\">format</a></li><li><a href=\"macro.format_args.html\">format_args</a></li><li><a href=\"macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"macro.include.html\">include</a></li><li><a href=\"macro.include_bytes.html\">include_bytes</a></li><li><a href=\"macro.include_str.html\">include_str</a></li><li><a href=\"macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"macro.line.html\">line</a></li><li><a href=\"macro.log_syntax.html\">log_syntax</a></li><li><a href=\"macro.matches.html\">matches</a></li><li><a href=\"macro.module_path.html\">module_path</a></li><li><a href=\"macro.option_env.html\">option_env</a></li><li><a href=\"macro.panic.html\">panic</a></li><li><a href=\"macro.print.html\">print</a></li><li><a href=\"macro.println.html\">println</a></li><li><a href=\"macro.stringify.html\">stringify</a></li><li><a href=\"macro.thread_local.html\">thread_local</a></li><li><a href=\"macro.todo.html\">todo</a></li><li><a href=\"macro.trace_macros.html\">trace_macros</a></li><li><a href=\"macro.try.html\">try</a></li><li><a href=\"macro.unimplemented.html\">unimplemented</a></li><li><a href=\"macro.unreachable.html\">unreachable</a></li><li><a href=\"macro.vec.html\">vec</a></li><li><a href=\"macro.write.html\">write</a></li><li><a href=\"macro.writeln.html\">writeln</a></li></ul><h3><a href=\"index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"keyword.as.html\">as</a></li><li><a href=\"keyword.async.html\">async</a></li><li><a href=\"keyword.await.html\">await</a></li><li><a href=\"keyword.break.html\">break</a></li><li><a href=\"keyword.const.html\">const</a></li><li><a href=\"keyword.continue.html\">continue</a></li><li><a href=\"keyword.crate.html\">crate</a></li><li><a href=\"keyword.dyn.html\">dyn</a></li><li><a href=\"keyword.else.html\">else</a></li><li><a href=\"keyword.enum.html\">enum</a></li><li><a href=\"keyword.extern.html\">extern</a></li><li><a href=\"keyword.false.html\">false</a></li><li><a href=\"keyword.fn.html\">fn</a></li><li><a href=\"keyword.for.html\">for</a></li><li><a href=\"keyword.if.html\">if</a></li><li><a href=\"keyword.impl.html\">impl</a></li><li><a href=\"keyword.in.html\">in</a></li><li><a href=\"keyword.let.html\">let</a></li><li><a href=\"keyword.loop.html\">loop</a></li><li><a href=\"keyword.match.html\">match</a></li><li><a href=\"keyword.mod.html\">mod</a></li><li><a href=\"keyword.move.html\">move</a></li><li><a href=\"keyword.mut.html\">mut</a></li><li><a href=\"keyword.pub.html\">pub</a></li><li><a href=\"keyword.ref.html\">ref</a></li><li><a href=\"keyword.return.html\">return</a></li><li><a href=\"keyword.self.html\">self</a></li><li><a href=\"keyword.static.html\">static</a></li><li><a href=\"keyword.struct.html\">struct</a></li><li><a href=\"keyword.super.html\">super</a></li><li><a href=\"keyword.trait.html\">trait</a></li><li><a href=\"keyword.true.html\">true</a></li><li><a href=\"keyword.type.html\">type</a></li><li><a href=\"keyword.union.html\">union</a></li><li><a href=\"keyword.unsafe.html\">unsafe</a></li><li><a href=\"keyword.use.html\">use</a></li><li><a href=\"keyword.where.html\">where</a></li><li><a href=\"keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Primitive Type <a class=\"primitive\" href=\"#\">fn</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Function pointers, like <code>fn(usize) -&gt; bool</code>.</p>\n<p><em>See also the traits <a href=\"ops/trait.Fn.html\" title=\"trait std::ops::Fn\"><code>Fn</code></a>, <a href=\"ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\"><code>FnMut</code></a>, and <a href=\"ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\"><code>FnOnce</code></a>.</em></p>\n<p>Function pointers are pointers that point to <em>code</em>, not data. They can be called\njust like functions. Like references, function pointers are, among other things, assumed to\nnot be null, so if you want to pass a function pointer over FFI and be able to accommodate null\npointers, make your type <a href=\"option/index.html#options-and-pointers-nullable-pointers\" title=\"mod std::option\"><code>Option&lt;fn()&gt;</code></a>\nwith your required signature.</p>\n<h4 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h4>\n<p>Plain function pointers are obtained by casting either plain functions, or closures that don’t\ncapture an environment:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>add_one(x: usize) -&gt; usize {\n    x + <span class=\"number\">1\n</span>}\n\n<span class=\"kw\">let </span>ptr: <span class=\"kw\">fn</span>(usize) -&gt; usize = add_one;\n<span class=\"macro\">assert_eq!</span>(ptr(<span class=\"number\">5</span>), <span class=\"number\">6</span>);\n\n<span class=\"kw\">let </span>clos: <span class=\"kw\">fn</span>(usize) -&gt; usize = |x| x + <span class=\"number\">5</span>;\n<span class=\"macro\">assert_eq!</span>(clos(<span class=\"number\">5</span>), <span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+add_one(x:+usize)+-%3E+usize+%7B%0A++++++++x+%2B+1%0A++++%7D%0A++++%0A++++let+ptr:+fn(usize)+-%3E+usize+=+add_one;%0A++++assert_eq!(ptr(5),+6);%0A++++%0A++++let+clos:+fn(usize)+-%3E+usize+=+%7Cx%7C+x+%2B+5;%0A++++assert_eq!(clos(5),+10);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>In addition to varying based on their signature, function pointers come in two flavors: safe\nand unsafe. Plain <code>fn()</code> function pointers can only point to safe functions,\nwhile <code>unsafe fn()</code> function pointers can point to safe or unsafe functions.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>add_one(x: usize) -&gt; usize {\n    x + <span class=\"number\">1\n</span>}\n\n<span class=\"kw\">unsafe fn </span>add_one_unsafely(x: usize) -&gt; usize {\n    x + <span class=\"number\">1\n</span>}\n\n<span class=\"kw\">let </span>safe_ptr: <span class=\"kw\">fn</span>(usize) -&gt; usize = add_one;\n\n<span class=\"comment\">//ERROR: mismatched types: expected normal fn, found unsafe fn\n//let bad_ptr: fn(usize) -&gt; usize = add_one_unsafely;\n\n</span><span class=\"kw\">let </span>unsafe_ptr: <span class=\"kw\">unsafe fn</span>(usize) -&gt; usize = add_one_unsafely;\n<span class=\"kw\">let </span>really_safe_ptr: <span class=\"kw\">unsafe fn</span>(usize) -&gt; usize = add_one;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+add_one(x:+usize)+-%3E+usize+%7B%0A++++++++x+%2B+1%0A++++%7D%0A++++%0A++++unsafe+fn+add_one_unsafely(x:+usize)+-%3E+usize+%7B%0A++++++++x+%2B+1%0A++++%7D%0A++++%0A++++let+safe_ptr:+fn(usize)+-%3E+usize+=+add_one;%0A++++%0A++++//ERROR:+mismatched+types:+expected+normal+fn,+found+unsafe+fn%0A++++//let+bad_ptr:+fn(usize)+-%3E+usize+=+add_one_unsafely;%0A++++%0A++++let+unsafe_ptr:+unsafe+fn(usize)+-%3E+usize+=+add_one_unsafely;%0A++++let+really_safe_ptr:+unsafe+fn(usize)+-%3E+usize+=+add_one;%0A%7D&amp;edition=2021\">Run</a></div>\n<h4 id=\"abi\"><a class=\"doc-anchor\" href=\"#abi\">§</a>ABI</h4>\n<p>On top of that, function pointers can vary based on what ABI they use. This\nis achieved by adding the <code>extern</code> keyword before the type, followed by the\nABI in question. The default ABI is “Rust”, i.e., <code>fn()</code> is the exact same\ntype as <code>extern \"Rust\" fn()</code>. A pointer to a function with C ABI would have\ntype <code>extern \"C\" fn()</code>.</p>\n<p><code>extern \"ABI\" { ... }</code> blocks declare functions with ABI “ABI”. The default\nhere is “C”, i.e., functions declared in an <code>extern {...}</code> block have “C”\nABI.</p>\n<p>For more information and a list of supported ABIs, see <a href=\"../nomicon/ffi.html#foreign-calling-conventions\">the nomicon’s\nsection on foreign calling conventions</a>.</p>\n<h4 id=\"variadic-functions\"><a class=\"doc-anchor\" href=\"#variadic-functions\">§</a>Variadic functions</h4>\n<p>Extern function declarations with the “C” or “cdecl” ABIs can also be <em>variadic</em>, allowing them\nto be called with a variable number of arguments. Normal Rust functions, even those with an\n<code>extern \"ABI\"</code>, cannot be variadic. For more information, see <a href=\"../nomicon/ffi.html#variadic-functions\">the nomicon’s section on\nvariadic functions</a>.</p>\n<h4 id=\"creating-function-pointers\"><a class=\"doc-anchor\" href=\"#creating-function-pointers\">§</a>Creating function pointers</h4>\n<p>When <code>bar</code> is the name of a function, then the expression <code>bar</code> is <em>not</em> a\nfunction pointer. Rather, it denotes a value of an unnameable type that\nuniquely identifies the function <code>bar</code>. The value is zero-sized because the\ntype already identifies the function. This has the advantage that “calling”\nthe value (it implements the <code>Fn*</code> traits) does not require dynamic\ndispatch.</p>\n<p>This zero-sized type <em>coerces</em> to a regular function pointer. For example:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem;\n\n<span class=\"kw\">fn </span>bar(x: i32) {}\n\n<span class=\"kw\">let </span>not_bar_ptr = bar; <span class=\"comment\">// `not_bar_ptr` is zero-sized, uniquely identifying `bar`\n</span><span class=\"macro\">assert_eq!</span>(mem::size_of_val(<span class=\"kw-2\">&amp;</span>not_bar_ptr), <span class=\"number\">0</span>);\n\n<span class=\"kw\">let </span>bar_ptr: <span class=\"kw\">fn</span>(i32) = not_bar_ptr; <span class=\"comment\">// force coercion to function pointer\n</span><span class=\"macro\">assert_eq!</span>(mem::size_of_val(<span class=\"kw-2\">&amp;</span>bar_ptr), mem::size_of::&lt;usize&gt;());\n\n<span class=\"kw\">let </span>footgun = <span class=\"kw-2\">&amp;</span>bar; <span class=\"comment\">// this is a shared reference to the zero-sized type identifying `bar`</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++fn+bar(x:+i32)+%7B%7D%0A++++%0A++++let+not_bar_ptr+=+bar;+//+%60not_bar_ptr%60+is+zero-sized,+uniquely+identifying+%60bar%60%0A++++assert_eq!(mem::size_of_val(%26not_bar_ptr),+0);%0A++++%0A++++let+bar_ptr:+fn(i32)+=+not_bar_ptr;+//+force+coercion+to+function+pointer%0A++++assert_eq!(mem::size_of_val(%26bar_ptr),+mem::size_of::%3Cusize%3E());%0A++++%0A++++let+footgun+=+%26bar;+//+this+is+a+shared+reference+to+the+zero-sized+type+identifying+%60bar%60%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The last line shows that <code>&amp;bar</code> is not a function pointer either. Rather, it\nis a reference to the function-specific ZST. <code>&amp;bar</code> is basically never what you\nwant when <code>bar</code> is a function.</p>\n<h4 id=\"casting-to-and-from-integers\"><a class=\"doc-anchor\" href=\"#casting-to-and-from-integers\">§</a>Casting to and from integers</h4>\n<p>You can cast function pointers directly to integers:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>fnptr: <span class=\"kw\">fn</span>(i32) -&gt; i32 = |x| x+<span class=\"number\">2</span>;\n<span class=\"kw\">let </span>fnptr_addr = fnptr <span class=\"kw\">as </span>usize;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+fnptr:+fn(i32)+-%3E+i32+=+%7Cx%7C+x%2B2;%0A++++let+fnptr_addr+=+fnptr+as+usize;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>However, a direct cast back is not possible. You need to use <code>transmute</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>fnptr = fnptr_addr <span class=\"kw\">as </span><span class=\"kw-2\">*const </span>();\n<span class=\"kw\">let </span>fnptr: <span class=\"kw\">fn</span>(i32) -&gt; i32 = <span class=\"kw\">unsafe </span>{ std::mem::transmute(fnptr) };\n<span class=\"macro\">assert_eq!</span>(fnptr(<span class=\"number\">40</span>), <span class=\"number\">42</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(not(miri))%5D+%7B+//+FIXME:+use+strict+provenance+APIs+once+they+are+stable,+then+remove+this+%60cfg%60%0A++++let+fnptr:+fn(i32)+-%3E+i32+=+%7Cx%7C+x%2B2;%0A++++let+fnptr_addr+=+fnptr+as+usize;%0A++++let+fnptr+=+fnptr_addr+as+*const+();%0A++++let+fnptr:+fn(i32)+-%3E+i32+=+unsafe+%7B+std::mem::transmute(fnptr)+%7D;%0A++++assert_eq!(fnptr(40),+42);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Crucially, we <code>as</code>-cast to a raw pointer before <code>transmute</code>ing to a function pointer.\nThis avoids an integer-to-pointer <code>transmute</code>, which can be problematic.\nTransmuting between raw pointers and function pointers (i.e., two pointer types) is fine.</p>\n<p>Note that all of this is not portable to platforms where function pointers and data pointers\nhave different sizes.</p>\n<h4 id=\"abi-compatibility\"><a class=\"doc-anchor\" href=\"#abi-compatibility\">§</a>ABI compatibility</h4>\n<p>Generally, when a function is declared with one signature and called via a function pointer with\na different signature, the two signatures must be <em>ABI-compatible</em> or else calling the function\nvia that function pointer is Undefined Behavior. ABI compatibility is a lot stricter than merely\nhaving the same memory layout; for example, even if <code>i32</code> and <code>f32</code> have the same size and\nalignment, they might be passed in different registers and hence not be ABI-compatible.</p>\n<p>ABI compatibility as a concern only arises in code that alters the type of function pointers,\ncode that imports functions via <code>extern</code> blocks, and in code that combines <code>#[target_feature]</code>\nwith <code>extern fn</code>. Altering the type of function pointers is wildly unsafe (as in, a lot more\nunsafe than even <a href=\"mem/fn.transmute_copy.html\" title=\"fn std::mem::transmute_copy\"><code>transmute_copy</code></a>), and should only occur in the most\nexceptional circumstances. Most Rust code just imports functions via <code>use</code>. <code>#[target_feature]</code>\nis also used rarely. So, most likely you do not have to worry about ABI compatibility.</p>\n<p>But assuming such circumstances, what are the rules? For this section, we are only considering\nthe ABI of direct Rust-to-Rust calls, not linking in general – once functions are imported via\n<code>extern</code> blocks, there are more things to consider that we do not go into here.</p>\n<p>For two signatures to be considered <em>ABI-compatible</em>, they must use a compatible ABI string,\nmust take the same number of arguments, the individual argument types and the return types must\nbe ABI-compatible, and the target feature requirements must be met (see the subsection below for\nthe last point). The ABI string is declared via <code>extern \"ABI\" fn(...) -&gt; ...</code>; note that\n<code>fn name(...) -&gt; ...</code> implicitly uses the <code>\"Rust\"</code> ABI string and <code>extern fn name(...) -&gt; ...</code>\nimplicitly uses the <code>\"C\"</code> ABI string.</p>\n<p>The ABI strings are guaranteed to be compatible if they are the same, or if the caller ABI\nstring is <code>$X-unwind</code> and the callee ABI string is <code>$X</code>, where <code>$X</code> is one of the following:\n“C”, “aapcs”, “fastcall”, “stdcall”, “system”, “sysv64”, “thiscall”, “vectorcall”, “win64”.</p>\n<p>The following types are guaranteed to be ABI-compatible:</p>\n<ul>\n<li><code>*const T</code>, <code>*mut T</code>, <code>&amp;T</code>, <code>&amp;mut T</code>, <code>Box&lt;T&gt;</code> (specifically, only <code>Box&lt;T, Global&gt;</code>), and\n<code>NonNull&lt;T&gt;</code> are all ABI-compatible with each other for all <code>T</code>. They are also ABI-compatible\nwith each other for <em>different</em> <code>T</code> if they have the same metadata type (<code>&lt;T as Pointee&gt;::Metadata</code>).</li>\n<li><code>usize</code> is ABI-compatible with the <code>uN</code> integer type of the same size, and likewise <code>isize</code> is\nABI-compatible with the <code>iN</code> integer type of the same size.</li>\n<li><code>char</code> is ABI-compatible with <code>u32</code>.</li>\n<li>Any two <code>fn</code> (function pointer) types are ABI-compatible with each other if they have the same\nABI string or the ABI string only differs in a trailing <code>-unwind</code>, independent of the rest of\ntheir signature. (This means you can pass <code>fn()</code> to a function expecting <code>fn(i32)</code>, and the\ncall will be valid ABI-wise. The callee receives the result of transmuting the function pointer\nfrom <code>fn()</code> to <code>fn(i32)</code>; that transmutation is itself a well-defined operation, it’s just\nalmost certainly UB to later call that function pointer.)</li>\n<li>Any two types with size 0 and alignment 1 are ABI-compatible.</li>\n<li>A <code>repr(transparent)</code> type <code>T</code> is ABI-compatible with its unique non-trivial field, i.e., the\nunique field that doesn’t have size 0 and alignment 1 (if there is such a field).</li>\n<li><code>i32</code> is ABI-compatible with <code>NonZero&lt;i32&gt;</code>, and similar for all other integer types.</li>\n<li>If <code>T</code> is guaranteed to be subject to the <a href=\"option/index.html#representation\">null pointer\noptimization</a>, then <code>T</code> and <code>Option&lt;T&gt;</code> are ABI-compatible.</li>\n</ul>\n<p>Furthermore, ABI compatibility satisfies the following general properties:</p>\n<ul>\n<li>Every type is ABI-compatible with itself.</li>\n<li>If <code>T1</code> and <code>T2</code> are ABI-compatible and <code>T2</code> and <code>T3</code> are ABI-compatible, then so are <code>T1</code> and\n<code>T3</code> (i.e., ABI-compatibility is transitive).</li>\n<li>If <code>T1</code> and <code>T2</code> are ABI-compatible, then so are <code>T2</code> and <code>T1</code> (i.e., ABI-compatibility is\nsymmetric).</li>\n</ul>\n<p>More signatures can be ABI-compatible on specific targets, but that should not be relied upon\nsince it is not portable and not a stable guarantee.</p>\n<p>Noteworthy cases of types <em>not</em> being ABI-compatible in general are:</p>\n<ul>\n<li><code>bool</code> vs <code>u8</code>, <code>i32</code> vs <code>u32</code>, <code>char</code> vs <code>i32</code>: on some targets, the calling conventions for\nthese types differ in terms of what they guarantee for the remaining bits in the register that\nare not used by the value.</li>\n<li><code>i32</code> vs <code>f32</code> are not compatible either, as has already been mentioned above.</li>\n<li><code>struct Foo(u32)</code> and <code>u32</code> are not compatible (without <code>repr(transparent)</code>) since structs are\naggregate types and often passed in a different way than primitives like <code>i32</code>.</li>\n</ul>\n<p>Note that these rules describe when two completely known types are ABI-compatible. When\nconsidering ABI compatibility of a type declared in another crate (including the standard\nlibrary), consider that any type that has a private field or the <code>#[non_exhaustive]</code> attribute\nmay change its layout as a non-breaking update unless documented otherwise – so for instance,\neven if such a type is a 1-ZST or <code>repr(transparent)</code> right now, this might change with any\nlibrary version bump.</p>\n<p>If the declared signature and the signature of the function pointer are ABI-compatible, then the\nfunction call behaves as if every argument was <a href=\"mem/fn.transmute.html\" title=\"fn std::mem::transmute\"><code>transmute</code>d</a> from the\ntype in the function pointer to the type at the function declaration, and the return value is\n<a href=\"mem/fn.transmute.html\" title=\"fn std::mem::transmute\"><code>transmute</code>d</a> from the type in the declaration to the type in the\npointer. All the usual caveats and concerns around transmutation apply; for instance, if the\nfunction expects a <code>NonZero&lt;i32&gt;</code> and the function pointer uses the ABI-compatible type\n<code>Option&lt;NonZero&lt;i32&gt;&gt;</code>, and the value used for the argument is <code>None</code>, then this call is Undefined\nBehavior since transmuting <code>None::&lt;NonZero&lt;i32&gt;&gt;</code> to <code>NonZero&lt;i32&gt;</code> violates the non-zero\nrequirement.</p>\n<h5 id=\"requirements-concerning-target-features\"><a class=\"doc-anchor\" href=\"#requirements-concerning-target-features\">§</a>Requirements concerning target features</h5>\n<p>Under some conditions, the signature used by the caller and the callee can be ABI-incompatible\neven if the exact same ABI string and types are being used. As an example, the\n<code>std::arch::x86_64::__m256</code> type has a different <code>extern \"C\"</code> ABI when the <code>avx</code> feature is\nenabled vs when it is not enabled.</p>\n<p>Therefore, to ensure ABI compatibility when code using different target features is combined\n(such as via <code>#[target_feature]</code>), we further require that one of the following conditions is\nmet:</p>\n<ul>\n<li>The function uses the <code>\"Rust\"</code> ABI string (which is the default without <code>extern</code>).</li>\n<li>Caller and callee are using the exact same set of target features. For the callee we consider\nthe features enabled (via <code>#[target_feature]</code> and <code>-C target-feature</code>/<code>-C target-cpu</code>) at the\ndeclaration site; for the caller we consider the features enabled at the call site.</li>\n<li>Neither any argument nor the return value involves a SIMD type (<code>#[repr(simd)]</code>) that is not\nbehind a pointer indirection (i.e., <code>*mut __m256</code> is fine, but <code>(i32, __m256)</code> is not).</li>\n</ul>\n<h4 id=\"trait-implementations-1\"><a class=\"doc-anchor\" href=\"#trait-implementations-1\">§</a>Trait implementations</h4>\n<p>In this documentation the shorthand <code>fn(T₁, T₂, …, Tₙ)</code> is used to represent non-variadic\nfunction pointers of varying length. Note that this is a convenience notation to avoid\nrepetitive documentation, not valid Rust syntax.</p>\n<p>The following traits are implemented for function pointers with any number of arguments and\nany ABI.</p>\n<ul>\n<li><a href=\"cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\"><code>PartialEq</code></a></li>\n<li><a href=\"cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\"><code>Eq</code></a></li>\n<li><a href=\"cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\"><code>PartialOrd</code></a></li>\n<li><a href=\"cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\"><code>Ord</code></a></li>\n<li><a href=\"hash/trait.Hash.html\" title=\"trait std::hash::Hash\"><code>Hash</code></a></li>\n<li><a href=\"fmt/trait.Pointer.html\" title=\"trait std::fmt::Pointer\"><code>Pointer</code></a></li>\n<li><a href=\"fmt/derive.Debug.html\" title=\"derive std::fmt::Debug\"><code>Debug</code></a></li>\n<li><a href=\"clone/trait.Clone.html\" title=\"trait std::clone::Clone\"><code>Clone</code></a></li>\n<li><a href=\"marker/trait.Copy.html\" title=\"trait std::marker::Copy\"><code>Copy</code></a></li>\n<li><a href=\"marker/trait.Send.html\" title=\"trait std::marker::Send\"><code>Send</code></a></li>\n<li><a href=\"marker/trait.Sync.html\" title=\"trait std::marker::Sync\"><code>Sync</code></a></li>\n<li><a href=\"marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a></li>\n<li><a href=\"panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\"><code>UnwindSafe</code></a></li>\n<li><a href=\"panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\"><code>RefUnwindSafe</code></a></li>\n</ul>\n<p>Note that while this type implements <code>PartialEq</code>, comparing function pointers is unreliable:\npointers to the same function can compare inequal (because functions are duplicated in multiple\ncodegen units), and pointers to <em>different</em> functions can compare equal (since identical\nfunctions can be deduplicated within a codegen unit).</p>\n<p>In addition, all <em>safe</em> function pointers implement <a href=\"ops/trait.Fn.html\" title=\"trait std::ops::Fn\"><code>Fn</code></a>, <a href=\"ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\"><code>FnMut</code></a>, and <a href=\"ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\"><code>FnOnce</code></a>, because\nthese traits are specially known to the compiler.</p>\n</div></details><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-fn(T)+-%3E+Ret\" class=\"impl\"><a href=\"#impl-Freeze-for-fn(T)+-%3E+Ret\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;Ret, T&gt; <a class=\"trait\" href=\"marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"primitive\" href=\"primitive.tuple.html#trait-implementations-1\">fn(T₁, T₂, …, Tₙ)</a> -&gt; Ret</h3></section><section id=\"impl-RefUnwindSafe-for-fn(T)+-%3E+Ret\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-fn(T)+-%3E+Ret\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;Ret, T&gt; <a class=\"trait\" href=\"panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"primitive\" href=\"primitive.tuple.html#trait-implementations-1\">fn(T₁, T₂, …, Tₙ)</a> -&gt; Ret</h3></section><section id=\"impl-Send-for-fn(T)+-%3E+Ret\" class=\"impl\"><a href=\"#impl-Send-for-fn(T)+-%3E+Ret\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;Ret, T&gt; <a class=\"trait\" href=\"marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"primitive\" href=\"primitive.tuple.html#trait-implementations-1\">fn(T₁, T₂, …, Tₙ)</a> -&gt; Ret</h3></section><section id=\"impl-Sync-for-fn(T)+-%3E+Ret\" class=\"impl\"><a href=\"#impl-Sync-for-fn(T)+-%3E+Ret\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;Ret, T&gt; <a class=\"trait\" href=\"marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"primitive\" href=\"primitive.tuple.html#trait-implementations-1\">fn(T₁, T₂, …, Tₙ)</a> -&gt; Ret</h3></section><section id=\"impl-Unpin-for-fn(T)+-%3E+Ret\" class=\"impl\"><a href=\"#impl-Unpin-for-fn(T)+-%3E+Ret\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;Ret, T&gt; <a class=\"trait\" href=\"marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"primitive\" href=\"primitive.tuple.html#trait-implementations-1\">fn(T₁, T₂, …, Tₙ)</a> -&gt; Ret</h3></section><section id=\"impl-UnwindSafe-for-fn(T)+-%3E+Ret\" class=\"impl\"><a href=\"#impl-UnwindSafe-for-fn(T)+-%3E+Ret\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;Ret, T&gt; <a class=\"trait\" href=\"panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"primitive\" href=\"primitive.tuple.html#trait-implementations-1\">fn(T₁, T₂, …, Tₙ)</a> -&gt; Ret</h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Debug-for-F\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2131\">source</a><a href=\"#impl-Debug-for-F\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F&gt; <a class=\"trait\" href=\"fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for F<div class=\"where\">where\n    F: <a class=\"trait\" href=\"marker/trait.FnPtr.html\" title=\"trait std::marker::FnPtr\">FnPtr</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2132\">source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"primitive.unit.html\">()</a>, <a class=\"struct\" href=\"fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Hash-for-F\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2117\">source</a><a href=\"#impl-Hash-for-F\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F&gt; <a class=\"trait\" href=\"hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a> for F<div class=\"where\">where\n    F: <a class=\"trait\" href=\"marker/trait.FnPtr.html\" title=\"trait std::marker::FnPtr\">FnPtr</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2118\">source</a><a href=\"#method.hash\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"hash/trait.Hash.html#tymethod.hash\" class=\"fn\">hash</a>&lt;HH&gt;(&amp;self, state: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;mut HH</a>)<div class=\"where\">where\n    HH: <a class=\"trait\" href=\"hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,</div></h4></section></summary><div class=\"docblock\">Feeds this value into the given <a href=\"hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"hash/trait.Hash.html#tymethod.hash\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/hash/mod.rs.html#238-240\">source</a></span><a href=\"#method.hash_slice\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"hash/trait.Hash.html#method.hash_slice\" class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;<a class=\"primitive\" href=\"primitive.slice.html\">[Self]</a>, state: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,\n    Self: <a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Feeds a slice of this type into the given <a href=\"hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"hash/trait.Hash.html#method.hash_slice\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Ord-for-F\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2109\">source</a><a href=\"#impl-Ord-for-F\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F&gt; <a class=\"trait\" href=\"cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> for F<div class=\"where\">where\n    F: <a class=\"trait\" href=\"marker/trait.FnPtr.html\" title=\"trait std::marker::FnPtr\">FnPtr</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2111\">source</a><a href=\"#method.cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.Ord.html#tymethod.cmp\" class=\"fn\">cmp</a>(&amp;self, other: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;F</a>) -&gt; <a class=\"enum\" href=\"cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></h4></section></summary><div class=\"docblock\">This method returns an <a href=\"cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href=\"cmp/trait.Ord.html#tymethod.cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#856-858\">source</a></span><a href=\"#method.max\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.Ord.html#method.max\" class=\"fn\">max</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the maximum of two values. <a href=\"cmp/trait.Ord.html#method.max\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#877-879\">source</a></span><a href=\"#method.min\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.Ord.html#method.min\" class=\"fn\">min</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the minimum of two values. <a href=\"cmp/trait.Ord.html#method.min\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clamp\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.50.0\">1.50.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#903-906\">source</a></span><a href=\"#method.clamp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.Ord.html#method.clamp\" class=\"fn\">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section></summary><div class=\"docblock\">Restrict a value to a certain interval. <a href=\"cmp/trait.Ord.html#method.clamp\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-PartialEq-for-F\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2092\">source</a><a href=\"#impl-PartialEq-for-F\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F&gt; <a class=\"trait\" href=\"cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a> for F<div class=\"where\">where\n    F: <a class=\"trait\" href=\"marker/trait.FnPtr.html\" title=\"trait std::marker::FnPtr\">FnPtr</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2094\">source</a><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;F</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263\">source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-PartialOrd-for-F\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2102\">source</a><a href=\"#impl-PartialOrd-for-F\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F&gt; <a class=\"trait\" href=\"cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a> for F<div class=\"where\">where\n    F: <a class=\"trait\" href=\"marker/trait.FnPtr.html\" title=\"trait std::marker::FnPtr\">FnPtr</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2104\">source</a><a href=\"#method.partial_cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;F</a>) -&gt; <a class=\"enum\" href=\"option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class=\"docblock\">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180\">source</a></span><a href=\"#method.lt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198\">source</a></span><a href=\"#method.le\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>\noperator. <a href=\"cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215\">source</a></span><a href=\"#method.gt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href=\"cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233\">source</a></span><a href=\"#method.ge\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>\noperator. <a href=\"cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Pattern%3C'a%3E-for-F\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#922-924\">source</a><a href=\"#impl-Pattern%3C'a%3E-for-F\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, F&gt; <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt; for F<div class=\"where\">where\n    F: <a class=\"trait\" href=\"ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"primitive.char.html\">char</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Searcher\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Searcher\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"str/pattern/trait.Pattern.html#associatedtype.Searcher\" class=\"associatedtype\">Searcher</a> = <a class=\"struct\" href=\"str/pattern/struct.CharPredicateSearcher.html\" title=\"struct std::str::pattern::CharPredicateSearcher\">CharPredicateSearcher</a>&lt;'a, F&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Associated searcher for this pattern</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_searcher\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926\">source</a><a href=\"#method.into_searcher\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"str/pattern/trait.Pattern.html#tymethod.into_searcher\" class=\"fn\">into_searcher</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"str/pattern/struct.CharPredicateSearcher.html\" title=\"struct std::str::pattern::CharPredicateSearcher\">CharPredicateSearcher</a>&lt;'a, F&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Constructs the associated searcher from\n<code>self</code> and the <code>haystack</code> to search in.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_contained_in\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926\">source</a><a href=\"#method.is_contained_in\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"str/pattern/trait.Pattern.html#method.is_contained_in\" class=\"fn\">is_contained_in</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Checks whether the pattern matches anywhere in the haystack</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_prefix_of\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926\">source</a><a href=\"#method.is_prefix_of\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"str/pattern/trait.Pattern.html#method.is_prefix_of\" class=\"fn\">is_prefix_of</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Checks whether the pattern matches at the front of the haystack</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.strip_prefix_of\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926\">source</a><a href=\"#method.strip_prefix_of\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"str/pattern/trait.Pattern.html#method.strip_prefix_of\" class=\"fn\">strip_prefix_of</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>) -&gt; <a class=\"enum\" href=\"option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Removes the pattern from the front of haystack, if it matches.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_suffix_of\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926\">source</a><a href=\"#method.is_suffix_of\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"str/pattern/trait.Pattern.html#method.is_suffix_of\" class=\"fn\">is_suffix_of</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a><div class=\"where\">where\n    <a class=\"struct\" href=\"str/pattern/struct.CharPredicateSearcher.html\" title=\"struct std::str::pattern::CharPredicateSearcher\">CharPredicateSearcher</a>&lt;'a, F&gt;: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Checks whether the pattern matches at the back of the haystack</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.strip_suffix_of\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926\">source</a><a href=\"#method.strip_suffix_of\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"str/pattern/trait.Pattern.html#method.strip_suffix_of\" class=\"fn\">strip_suffix_of</a>(self, haystack: &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>) -&gt; <a class=\"enum\" href=\"option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>&gt;<div class=\"where\">where\n    <a class=\"struct\" href=\"str/pattern/struct.CharPredicateSearcher.html\" title=\"struct std::str::pattern::CharPredicateSearcher\">CharPredicateSearcher</a>&lt;'a, F&gt;: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27721\">#27721</a>)</span></div></span><div class=\"docblock\">Removes the pattern from the back of haystack, if it matches.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Pointer-for-F\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2124\">source</a><a href=\"#impl-Pointer-for-F\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F&gt; <a class=\"trait\" href=\"fmt/trait.Pointer.html\" title=\"trait std::fmt::Pointer\">Pointer</a> for F<div class=\"where\">where\n    F: <a class=\"trait\" href=\"marker/trait.FnPtr.html\" title=\"trait std::marker::FnPtr\">FnPtr</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2125\">source</a><a href=\"#method.fmt-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"fmt/trait.Pointer.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"primitive.unit.html\">()</a>, <a class=\"struct\" href=\"fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"fmt/trait.Pointer.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToOwned-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85\">source</a><a href=\"#impl-ToOwned-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Owned\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88\">source</a><a href=\"#method.to_owned\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\">Creates owned data from borrowed data, usually by cloning. <a href=\"borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92\">source</a><a href=\"#method.clone_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;mut T</a>)</h4></section></summary><div class=\"docblock\">Uses borrowed data to replace owned data, usually by cloning. <a href=\"borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><section id=\"impl-Eq-for-F\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2099\">source</a><a href=\"#impl-Eq-for-F\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F&gt; <a class=\"trait\" href=\"cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> for F<div class=\"where\">where\n    F: <a class=\"trait\" href=\"marker/trait.FnPtr.html\" title=\"trait std::marker::FnPtr\">FnPtr</a>,</div></h3></section></div></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:09:55.376Z"
}