{
	"title": "Refactoring to Improve Modularity and Error Handling - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch12-03-improving-error-handling-and-modularity.html",
	"markdown": "# Refactoring to Improve Modularity and Error Handling\n\nTo improve our program, we’ll fix four problems that have to do with the program’s structure and how it’s handling potential errors. First, our `main` function now performs two tasks: it parses arguments and reads files. As our program grows, the number of separate tasks the `main` function handles will increase. As a function gains responsibilities, it becomes more difficult to reason about, harder to test, and harder to change without breaking one of its parts. It’s best to separate functionality so each function is responsible for one task.\n\nThis issue also ties into the second problem: although `query` and `file_path` are configuration variables to our program, variables like `contents` are used to perform the program’s logic. The longer `main` becomes, the more variables we’ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It’s best to group the configuration variables into one structure to make their purpose clear.\n\nThe third problem is that we’ve used `expect` to print an error message when reading the file fails, but the error message just prints `Should have been able to read the file`. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we’d print the same error message for everything, which wouldn’t give the user any information!\n\nFourth, we use `expect` to handle an error, and if the user runs our program without specifying enough arguments, they’ll get an `index out of bounds` error from Rust that doesn’t clearly explain the problem. It would be best if all the error-handling code were in one place so future maintainers had only one place to consult the code if the error-handling logic needed to change. Having all the error-handling code in one place will also ensure that we’re printing messages that will be meaningful to our end users.\n\nLet’s address these four problems by refactoring our project.\n\n### [Separation of Concerns for Binary Projects](#separation-of-concerns-for-binary-projects)\n\nThe organizational problem of allocating responsibility for multiple tasks to the `main` function is common to many binary projects. As a result, the Rust community has developed guidelines for splitting the separate concerns of a binary program when `main` starts getting large. This process has the following steps:\n\n-   Split your program into a _main.rs_ and a _lib.rs_ and move your program’s logic to _lib.rs_.\n-   As long as your command line parsing logic is small, it can remain in _main.rs_.\n-   When the command line parsing logic starts getting complicated, extract it from _main.rs_ and move it to _lib.rs_.\n\nThe responsibilities that remain in the `main` function after this process should be limited to the following:\n\n-   Calling the command line parsing logic with the argument values\n-   Setting up any other configuration\n-   Calling a `run` function in _lib.rs_\n-   Handling the error if `run` returns an error\n\nThis pattern is about separating concerns: _main.rs_ handles running the program, and _lib.rs_ handles all the logic of the task at hand. Because you can’t test the `main` function directly, this structure lets you test all of your program’s logic by moving it into functions in _lib.rs_. The code that remains in _main.rs_ will be small enough to verify its correctness by reading it. Let’s rework our program by following this process.\n\nWe’ll extract the functionality for parsing arguments into a function that `main` will call to prepare for moving the command line parsing logic to _src/lib.rs_. Listing 12-5 shows the new start of `main` that calls a new function `parse_config`, which we’ll define in _src/main.rs_ for the moment.\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::fs;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let (query, file_path) = parse_config(&args);\n\n    // --snip--\n\n    println!(\"Searching for {query}\");\n    println!(\"In file {file_path}\");\n\n    let contents = fs::read_to_string(file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\nfn parse_config(args: &[String]) -> (&str, &str) {\n    let query = &args[1];\n    let file_path = &args[2];\n\n    (query, file_path)\n}\n```\n\nListing 12-5: Extracting a `parse_config` function from `main`\n\nWe’re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable `query` and the argument value at index 2 to the variable `file_path` within the `main` function, we pass the whole vector to the `parse_config` function. The `parse_config` function then holds the logic that determines which argument goes in which variable and passes the values back to `main`. We still create the `query` and `file_path` variables in `main`, but `main` no longer has the responsibility of determining how the command line arguments and variables correspond.\n\nThis rework may seem like overkill for our small program, but we’re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It’s good to check your progress often, to help identify the cause of problems when they occur.\n\n#### [Grouping Configuration Values](#grouping-configuration-values)\n\nWe can take another small step to improve the `parse_config` function further. At the moment, we’re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don’t have the right abstraction yet.\n\nAnother indicator that shows there’s room for improvement is the `config` part of `parse_config`, which implies that the two values we return are related and are both part of one configuration value. We’re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we’ll instead put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.\n\nListing 12-6 shows the improvements to the `parse_config` function.\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::fs;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = parse_config(&args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    // --snip--\n\n    println!(\"With text:\\n{contents}\");\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nfn parse_config(args: &[String]) -> Config {\n    let query = args[1].clone();\n    let file_path = args[2].clone();\n\n    Config { query, file_path }\n}\n```\n\nListing 12-6: Refactoring `parse_config` to return an instance of a `Config` struct\n\nWe’ve added a struct named `Config` defined to have fields named `query` and `file_path`. The signature of `parse_config` now indicates that it returns a `Config` value. In the body of `parse_config`, where we used to return string slices that reference `String` values in `args`, we now define `Config` to contain owned `String` values. The `args` variable in `main` is the owner of the argument values and is only letting the `parse_config` function borrow them, which means we’d violate Rust’s borrowing rules if `Config` tried to take ownership of the values in `args`.\n\nThere are a number of ways we could manage the `String` data; the easiest, though somewhat inefficient, route is to call the `clone` method on the values. This will make a full copy of the data for the `Config` instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don’t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.\n\n### [The Trade-Offs of Using `clone`](#the-trade-offs-of-using-clone)\n\nThere’s a tendency among many Rustaceans to avoid using `clone` to fix ownership problems because of its runtime cost. In [Chapter 13](ch13-00-functional-features.html), you’ll learn how to use more efficient methods in this type of situation. But for now, it’s okay to copy a few strings to continue making progress because you’ll make these copies only once and your file path and query string are very small. It’s better to have a working program that’s a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it’ll be easier to start with the most efficient solution, but for now, it’s perfectly acceptable to call `clone`.\n\nWe’ve updated `main` so it places the instance of `Config` returned by `parse_config` into a variable named `config`, and we updated the code that previously used the separate `query` and `file_path` variables so it now uses the fields on the `Config` struct instead.\n\nNow our code more clearly conveys that `query` and `file_path` are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the `config` instance in the fields named for their purpose.\n\n#### [Creating a Constructor for `Config`](#creating-a-constructor-for-config)\n\nSo far, we’ve extracted the logic responsible for parsing the command line arguments from `main` and placed it in the `parse_config` function. Doing so helped us to see that the `query` and `file_path` values were related and that relationship should be conveyed in our code. We then added a `Config` struct to name the related purpose of `query` and `file_path` and to be able to return the values’ names as struct field names from the `parse_config` function.\n\nSo now that the purpose of the `parse_config` function is to create a `Config` instance, we can change `parse_config` from a plain function to a function named `new` that is associated with the `Config` struct. Making this change will make the code more idiomatic. We can create instances of types in the standard library, such as `String`, by calling `String::new`. Similarly, by changing `parse_config` into a `new` function associated with `Config`, we’ll be able to create instances of `Config` by calling `Config::new`. Listing 12-7 shows the changes we need to make.\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::fs;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n\n    // --snip--\n}\n\n// --snip--\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn new(args: &[String]) -> Config {\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config { query, file_path }\n    }\n}\n```\n\nListing 12-7: Changing `parse_config` into `Config::new`\n\nWe’ve updated `main` where we were calling `parse_config` to instead call `Config::new`. We’ve changed the name of `parse_config` to `new` and moved it within an `impl` block, which associates the `new` function with `Config`. Try compiling this code again to make sure it works.\n\n### [Fixing the Error Handling](#fixing-the-error-handling)\n\nNow we’ll work on fixing our error handling. Recall that attempting to access the values in the `args` vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:\n\n```console\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep`\nthread 'main' panicked at src/main.rs:27:21:\nindex out of bounds: the len is 1 but the index is 1\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n```\n\nThe line `index out of bounds: the len is 1 but the index is 1` is an error message intended for programmers. It won’t help our end users understand what they should do instead. Let’s fix that now.\n\n#### [Improving the Error Message](#improving-the-error-message)\n\nIn Listing 12-8, we add a check in the `new` function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn’t long enough, the program panics and displays a better error message.\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::fs;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    // --snip--\n    fn new(args: &[String]) -> Config {\n        if args.len() < 3 {\n            panic!(\"not enough arguments\");\n        }\n        // --snip--\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config { query, file_path }\n    }\n}\n```\n\nListing 12-8: Adding a check for the number of arguments\n\nThis code is similar to [the `Guess::new` function we wrote in Listing 9-13](about:blank/ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation), where we called `panic!` when the `value` argument was out of the range of valid values. Instead of checking for a range of values here, we’re checking that the length of `args` is at least 3 and the rest of the function can operate under the assumption that this condition has been met. If `args` has fewer than three items, this condition will be true, and we call the `panic!` macro to end the program immediately.\n\nWith these extra few lines of code in `new`, let’s run the program without any arguments again to see what the error looks like now:\n\n```console\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep`\nthread 'main' panicked at src/main.rs:26:13:\nnot enough arguments\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n```\n\nThis output is better: we now have a reasonable error message. However, we also have extraneous information we don’t want to give to our users. Perhaps using the technique we used in Listing 9-13 isn’t the best to use here: a call to `panic!` is more appropriate for a programming problem than a usage problem, [as discussed in Chapter 9](about:blank/ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling). Instead, we’ll use the other technique you learned about in Chapter 9—[returning a `Result`](ch09-02-recoverable-errors-with-result.html) that indicates either success or an error.\n\n#### [Returning a `Result` Instead of Calling `panic!`](#returning-a-result-instead-of-calling-panic)\n\nWe can instead return a `Result` value that will contain a `Config` instance in the successful case and will describe the problem in the error case. We’re also going to change the function name from `new` to `build` because many programmers expect `new` functions to never fail. When `Config::build` is communicating to `main`, we can use the `Result` type to signal there was a problem. Then we can change `main` to convert an `Err` variant into a more practical error for our users without the surrounding text about `thread 'main'` and `RUST_BACKTRACE` that a call to `panic!` causes.\n\nListing 12-9 shows the changes we need to make to the return value of the function we’re now calling `Config::build` and the body of the function needed to return a `Result`. Note that this won’t compile until we update `main` as well, which we’ll do in the next listing.\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::fs;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n```\n\nListing 12-9: Returning a `Result` from `Config::build`\n\nOur `build` function returns a `Result` with a `Config` instance in the success case and a `&'static str` in the error case. Our error values will always be string literals that have the `'static` lifetime.\n\nWe’ve made two changes in the body of the function: instead of calling `panic!` when the user doesn’t pass enough arguments, we now return an `Err` value, and we’ve wrapped the `Config` return value in an `Ok`. These changes make the function conform to its new type signature.\n\nReturning an `Err` value from `Config::build` allows the `main` function to handle the `Result` value returned from the `build` function and exit the process more cleanly in the error case.\n\n#### [Calling `Config::build` and Handling Errors](#calling-configbuild-and-handling-errors)\n\nTo handle the error case and print a user-friendly message, we need to update `main` to handle the `Result` being returned by `Config::build`, as shown in Listing 12-10. We’ll also take the responsibility of exiting the command line tool with a nonzero error code away from `panic!` and instead implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::fs;\nuse std::process;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n```\n\nListing 12-10: Exiting with an error code if building a `Config` fails\n\nIn this listing, we’ve used a method we haven’t covered in detail yet: `unwrap_or_else`, which is defined on `Result<T, E>` by the standard library. Using `unwrap_or_else` allows us to define some custom, non-`panic!` error handling. If the `Result` is an `Ok` value, this method’s behavior is similar to `unwrap`: it returns the inner value `Ok` is wrapping. However, if the value is an `Err` value, this method calls the code in the _closure_, which is an anonymous function we define and pass as an argument to `unwrap_or_else`. We’ll cover closures in more detail in [Chapter 13](ch13-00-functional-features.html). For now, you just need to know that `unwrap_or_else` will pass the inner value of the `Err`, which in this case is the static string `\"not enough arguments\"` that we added in Listing 12-9, to our closure in the argument `err` that appears between the vertical pipes. The code in the closure can then use the `err` value when it runs.\n\nWe’ve added a new `use` line to bring `process` from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the `err` value and then call `process::exit`. The `process::exit` function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the `panic!`\\-based handling we used in Listing 12-8, but we no longer get all the extra output. Let’s try it:\n\n```console\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/minigrep`\nProblem parsing arguments: not enough arguments\n\n```\n\nGreat! This output is much friendlier for our users.\n\n### [Extracting Logic from `main`](#extracting-logic-from-main)\n\nNow that we’ve finished refactoring the configuration parsing, let’s turn to the program’s logic. As we stated in [“Separation of Concerns for Binary Projects”](#separation-of-concerns-for-binary-projects), we’ll extract a function named `run` that will hold all the logic currently in the `main` function that isn’t involved with setting up configuration or handling errors. When we’re done, `main` will be concise and easy to verify by inspection, and we’ll be able to write tests for all the other logic.\n\nListing 12-11 shows the extracted `run` function. For now, we’re just making the small, incremental improvement of extracting the function. We’re still defining the function in _src/main.rs_.\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::fs;\nuse std::process;\n\nfn main() {\n    // --snip--\n\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    run(config);\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\n// --snip--\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n```\n\nListing 12-11: Extracting a `run` function containing the rest of the program logic\n\nThe `run` function now contains all the remaining logic from `main`, starting from reading the file. The `run` function takes the `Config` instance as an argument.\n\n#### [Returning Errors from the `run` Function](#returning-errors-from-the-run-function)\n\nWith the remaining program logic separated into the `run` function, we can improve the error handling, as we did with `Config::build` in Listing 12-9. Instead of allowing the program to panic by calling `expect`, the `run` function will return a `Result<T, E>` when something goes wrong. This will let us further consolidate the logic around handling errors into `main` in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of `run`.\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::fs;\nuse std::process;\nuse std::error::Error;\n\n// --snip--\n\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    run(config);\n}\n\nfn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    println!(\"With text:\\n{contents}\");\n\n    Ok(())\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n```\n\nListing 12-12: Changing the `run` function to return `Result`\n\nWe’ve made three significant changes here. First, we changed the return type of the `run` function to `Result<(), Box<dyn Error>>`. This function previously returned the unit type, `()`, and we keep that as the value returned in the `Ok` case.\n\nFor the error type, we used the _trait object_ `Box<dyn Error>` (and we’ve brought `std::error::Error` into scope with a `use` statement at the top). We’ll cover trait objects in [Chapter 17](ch17-00-oop.html). For now, just know that `Box<dyn Error>` means the function will return a type that implements the `Error` trait, but we don’t have to specify what particular type the return value will be. This gives us flexibility to return error values that may be of different types in different error cases. The `dyn` keyword is short for “dynamic.”\n\nSecond, we’ve removed the call to `expect` in favor of the `?` operator, as we talked about in [Chapter 9](about:blank/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator). Rather than `panic!` on an error, `?` will return the error value from the current function for the caller to handle.\n\nThird, the `run` function now returns an `Ok` value in the success case. We’ve declared the `run` function’s success type as `()` in the signature, which means we need to wrap the unit type value in the `Ok` value. This `Ok(())` syntax might look a bit strange at first, but using `()` like this is the idiomatic way to indicate that we’re calling `run` for its side effects only; it doesn’t return a value we need.\n\nWhen you run this code, it will compile but will display a warning:\n\n```console\n$ cargo run -- the poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nwarning: unused `Result` that must be used\n  --> src/main.rs:19:5\n   |\n19 |     run(config);\n   |     ^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n19 |     let _ = run(config);\n   |     +++++++\n\nwarning: `minigrep` (bin \"minigrep\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s\n     Running `target/debug/minigrep the poem.txt`\nSearching for the\nIn file poem.txt\nWith text:\nI'm nobody! Who are you?\nAre you nobody, too?\nThen there's a pair of us - don't tell!\nThey'd banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\n\n```\n\nRust tells us that our code ignored the `Result` value and the `Result` value might indicate that an error occurred. But we’re not checking to see whether or not there was an error, and the compiler reminds us that we probably meant to have some error-handling code here! Let’s rectify that problem now.\n\n#### [Handling Errors Returned from `run` in `main`](#handling-errors-returned-from-run-in-main)\n\nWe’ll check for errors and handle them using a technique similar to one we used with `Config::build` in Listing 12-10, but with a slight difference:\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::error::Error;\nuse std::fs;\nuse std::process;\n\nfn main() {\n    // --snip--\n\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    if let Err(e) = run(config) {\n        println!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}\n\nfn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    println!(\"With text:\\n{contents}\");\n\n    Ok(())\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n```\n\nWe use `if let` rather than `unwrap_or_else` to check whether `run` returns an `Err` value and call `process::exit(1)` if it does. The `run` function doesn’t return a value that we want to `unwrap` in the same way that `Config::build` returns the `Config` instance. Because `run` returns `()` in the success case, we only care about detecting an error, so we don’t need `unwrap_or_else` to return the unwrapped value, which would only be `()`.\n\nThe bodies of the `if let` and the `unwrap_or_else` functions are the same in both cases: we print the error and exit.\n\n### [Splitting Code into a Library Crate](#splitting-code-into-a-library-crate)\n\nOur `minigrep` project is looking good so far! Now we’ll split the _src/main.rs_ file and put some code into the _src/lib.rs_ file. That way we can test the code and have a _src/main.rs_ file with fewer responsibilities.\n\nLet’s move all the code that isn’t the `main` function from _src/main.rs_ to _src/lib.rs_:\n\n-   The `run` function definition\n-   The relevant `use` statements\n-   The definition of `Config`\n-   The `Config::build` function definition\n\nThe contents of _src/lib.rs_ should have the signatures shown in Listing 12-13 (we’ve omitted the bodies of the functions for brevity). Note that this won’t compile until we modify _src/main.rs_ in Listing 12-14.\n\nFilename: src/lib.rs\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        // --snip--\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    // --snip--\n    let contents = fs::read_to_string(config.file_path)?;\n\n    println!(\"With text:\\n{contents}\");\n\n    Ok(())\n}\n```\n\nListing 12-13: Moving `Config` and `run` into _src/lib.rs_\n\nWe’ve made liberal use of the `pub` keyword: on `Config`, on its fields and its `build` method, and on the `run` function. We now have a library crate that has a public API we can test!\n\nNow we need to bring the code we moved to _src/lib.rs_ into the scope of the binary crate in _src/main.rs_, as shown in Listing 12-14.\n\nFilename: src/main.rs\n\n```rust\nuse std::env;\nuse std::process;\n\nuse minigrep::Config;\n\nfn main() {\n    // --snip--\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    if let Err(e) = minigrep::run(config) {\n        // --snip--\n        println!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}\n```\n\nListing 12-14: Using the `minigrep` library crate in _src/main.rs_\n\nWe add a `use minigrep::Config` line to bring the `Config` type from the library crate into the binary crate’s scope, and we prefix the `run` function with our crate name. Now all the functionality should be connected and should work. Run the program with `cargo run` and make sure everything works correctly.\n\nWhew! That was a lot of work, but we’ve set ourselves up for success in the future. Now it’s much easier to handle errors, and we’ve made the code more modular. Almost all of our work will be done in _src/lib.rs_ from here on out.\n\nLet’s take advantage of this newfound modularity by doing something that would have been difficult with the old code but is easy with the new code: we’ll write some tests!",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Refactoring to Improve Modularity and Error Handling - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"refactoring-to-improve-modularity-and-error-handling\"><a class=\"header\" href=\"#refactoring-to-improve-modularity-and-error-handling\">Refactoring to Improve Modularity and Error Handling</a></h2>\n<p>To improve our program, we’ll fix four problems that have to do with the\nprogram’s structure and how it’s handling potential errors. First, our <code class=\"hljs\">main</code>\nfunction now performs two tasks: it parses arguments and reads files. As our\nprogram grows, the number of separate tasks the <code class=\"hljs\">main</code> function handles will\nincrease. As a function gains responsibilities, it becomes more difficult to\nreason about, harder to test, and harder to change without breaking one of its\nparts. It’s best to separate functionality so each function is responsible for\none task.</p>\n<p>This issue also ties into the second problem: although <code class=\"hljs\">query</code> and <code class=\"hljs\">file_path</code>\nare configuration variables to our program, variables like <code class=\"hljs\">contents</code> are used\nto perform the program’s logic. The longer <code class=\"hljs\">main</code> becomes, the more variables\nwe’ll need to bring into scope; the more variables we have in scope, the harder\nit will be to keep track of the purpose of each. It’s best to group the\nconfiguration variables into one structure to make their purpose clear.</p>\n<p>The third problem is that we’ve used <code class=\"hljs\">expect</code> to print an error message when\nreading the file fails, but the error message just prints <code class=\"hljs\">Should have been able to read the file</code>. Reading a file can fail in a number of ways: for\nexample, the file could be missing, or we might not have permission to open it.\nRight now, regardless of the situation, we’d print the same error message for\neverything, which wouldn’t give the user any information!</p>\n<p>Fourth, we use <code class=\"hljs\">expect</code> to handle an error, and if the user runs our program\nwithout specifying enough arguments, they’ll get an <code class=\"hljs\">index out of bounds</code> error\nfrom Rust that doesn’t clearly explain the problem. It would be best if all the\nerror-handling code were in one place so future maintainers had only one place\nto consult the code if the error-handling logic needed to change. Having all the\nerror-handling code in one place will also ensure that we’re printing messages\nthat will be meaningful to our end users.</p>\n<p>Let’s address these four problems by refactoring our project.</p>\n<h3 id=\"separation-of-concerns-for-binary-projects\"><a class=\"header\" href=\"#separation-of-concerns-for-binary-projects\">Separation of Concerns for Binary Projects</a></h3>\n<p>The organizational problem of allocating responsibility for multiple tasks to\nthe <code class=\"hljs\">main</code> function is common to many binary projects. As a result, the Rust\ncommunity has developed guidelines for splitting the separate concerns of a\nbinary program when <code class=\"hljs\">main</code> starts getting large. This process has the following\nsteps:</p>\n<ul>\n<li>Split your program into a <em>main.rs</em> and a <em>lib.rs</em> and move your program’s\nlogic to <em>lib.rs</em>.</li>\n<li>As long as your command line parsing logic is small, it can remain in\n<em>main.rs</em>.</li>\n<li>When the command line parsing logic starts getting complicated, extract it\nfrom <em>main.rs</em> and move it to <em>lib.rs</em>.</li>\n</ul>\n<p>The responsibilities that remain in the <code class=\"hljs\">main</code> function after this process\nshould be limited to the following:</p>\n<ul>\n<li>Calling the command line parsing logic with the argument values</li>\n<li>Setting up any other configuration</li>\n<li>Calling a <code class=\"hljs\">run</code> function in <em>lib.rs</em></li>\n<li>Handling the error if <code class=\"hljs\">run</code> returns an error</li>\n</ul>\n<p>This pattern is about separating concerns: <em>main.rs</em> handles running the\nprogram, and <em>lib.rs</em> handles all the logic of the task at hand. Because you\ncan’t test the <code class=\"hljs\">main</code> function directly, this structure lets you test all of\nyour program’s logic by moving it into functions in <em>lib.rs</em>. The code that\nremains in <em>main.rs</em> will be small enough to verify its correctness by reading\nit. Let’s rework our program by following this process.</p>\n<h4 id=\"extracting-the-argument-parser\"><a class=\"header\" href=\"#extracting-the-argument-parser\">Extracting the Argument Parser</a></h4>\n<p>We’ll extract the functionality for parsing arguments into a function that\n<code class=\"hljs\">main</code> will call to prepare for moving the command line parsing logic to\n<em>src/lib.rs</em>. Listing 12-5 shows the new start of <code class=\"hljs\">main</code> that calls a new\nfunction <code class=\"hljs\">parse_config</code>, which we’ll define in <em>src/main.rs</em> for the moment.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::env;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n\n    <span class=\"hljs-keyword\">let</span> (query, file_path) = parse_config(&amp;args);\n\n    <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {query}\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {file_path}\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(file_path)\n</span><span class=\"boring\">        .expect(<span class=\"hljs-string\">\"Should have been able to read the file\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n</span>}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">parse_config</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; (&amp;<span class=\"hljs-built_in\">str</span>, &amp;<span class=\"hljs-built_in\">str</span>) {\n    <span class=\"hljs-keyword\">let</span> query = &amp;args[<span class=\"hljs-number\">1</span>];\n    <span class=\"hljs-keyword\">let</span> file_path = &amp;args[<span class=\"hljs-number\">2</span>];\n\n    (query, file_path)\n}</code></pre>\n<p><span class=\"caption\">Listing 12-5: Extracting a <code class=\"hljs\">parse_config</code> function from\n<code class=\"hljs\">main</code></span></p>\n<p>We’re still collecting the command line arguments into a vector, but instead of\nassigning the argument value at index 1 to the variable <code class=\"hljs\">query</code> and the\nargument value at index 2 to the variable <code class=\"hljs\">file_path</code> within the <code class=\"hljs\">main</code>\nfunction, we pass the whole vector to the <code class=\"hljs\">parse_config</code> function. The\n<code class=\"hljs\">parse_config</code> function then holds the logic that determines which argument\ngoes in which variable and passes the values back to <code class=\"hljs\">main</code>. We still create\nthe <code class=\"hljs\">query</code> and <code class=\"hljs\">file_path</code> variables in <code class=\"hljs\">main</code>, but <code class=\"hljs\">main</code> no longer has the\nresponsibility of determining how the command line arguments and variables\ncorrespond.</p>\n<p>This rework may seem like overkill for our small program, but we’re refactoring\nin small, incremental steps. After making this change, run the program again to\nverify that the argument parsing still works. It’s good to check your progress\noften, to help identify the cause of problems when they occur.</p>\n<h4 id=\"grouping-configuration-values\"><a class=\"header\" href=\"#grouping-configuration-values\">Grouping Configuration Values</a></h4>\n<p>We can take another small step to improve the <code class=\"hljs\">parse_config</code> function further.\nAt the moment, we’re returning a tuple, but then we immediately break that\ntuple into individual parts again. This is a sign that perhaps we don’t have\nthe right abstraction yet.</p>\n<p>Another indicator that shows there’s room for improvement is the <code class=\"hljs\">config</code> part\nof <code class=\"hljs\">parse_config</code>, which implies that the two values we return are related and\nare both part of one configuration value. We’re not currently conveying this\nmeaning in the structure of the data other than by grouping the two values into\na tuple; we’ll instead put the two values into one struct and give each of the\nstruct fields a meaningful name. Doing so will make it easier for future\nmaintainers of this code to understand how the different values relate to each\nother and what their purpose is.</p>\n<p>Listing 12-6 shows the improvements to the <code class=\"hljs\">parse_config</code> function.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust should_panic noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::env;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n\n    <span class=\"hljs-keyword\">let</span> config = parse_config(&amp;args);\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {}\"</span>, config.query);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {}\"</span>, config.file_path);\n\n    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)\n        .expect(<span class=\"hljs-string\">\"Should have been able to read the file\"</span>);\n\n    <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n</span>}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n    query: <span class=\"hljs-built_in\">String</span>,\n    file_path: <span class=\"hljs-built_in\">String</span>,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">parse_config</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; Config {\n    <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n    <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n\n    Config { query, file_path }\n}</code></pre>\n<p><span class=\"caption\">Listing 12-6: Refactoring <code class=\"hljs\">parse_config</code> to return an\ninstance of a <code class=\"hljs\">Config</code> struct</span></p>\n<p>We’ve added a struct named <code class=\"hljs\">Config</code> defined to have fields named <code class=\"hljs\">query</code> and\n<code class=\"hljs\">file_path</code>. The signature of <code class=\"hljs\">parse_config</code> now indicates that it returns a\n<code class=\"hljs\">Config</code> value. In the body of <code class=\"hljs\">parse_config</code>, where we used to return\nstring slices that reference <code class=\"hljs\">String</code> values in <code class=\"hljs\">args</code>, we now define <code class=\"hljs\">Config</code>\nto contain owned <code class=\"hljs\">String</code> values. The <code class=\"hljs\">args</code> variable in <code class=\"hljs\">main</code> is the owner of\nthe argument values and is only letting the <code class=\"hljs\">parse_config</code> function borrow\nthem, which means we’d violate Rust’s borrowing rules if <code class=\"hljs\">Config</code> tried to take\nownership of the values in <code class=\"hljs\">args</code>.</p>\n<p>There are a number of ways we could manage the <code class=\"hljs\">String</code> data; the easiest,\nthough somewhat inefficient, route is to call the <code class=\"hljs\">clone</code> method on the values.\nThis will make a full copy of the data for the <code class=\"hljs\">Config</code> instance to own, which\ntakes more time and memory than storing a reference to the string data.\nHowever, cloning the data also makes our code very straightforward because we\ndon’t have to manage the lifetimes of the references; in this circumstance,\ngiving up a little performance to gain simplicity is a worthwhile trade-off.</p>\n<section class=\"note\" aria-role=\"note\">\n<h3 id=\"the-trade-offs-of-using-clone\"><a class=\"header\" href=\"#the-trade-offs-of-using-clone\">The Trade-Offs of Using <code>clone</code></a></h3>\n<p>There’s a tendency among many Rustaceans to avoid using <code class=\"hljs\">clone</code> to fix\nownership problems because of its runtime cost. In\n<a href=\"ch13-00-functional-features.html\">Chapter 13</a><!-- ignore -->, you’ll learn how to use more efficient\nmethods in this type of situation. But for now, it’s okay to copy a few\nstrings to continue making progress because you’ll make these copies only\nonce and your file path and query string are very small. It’s better to have\na working program that’s a bit inefficient than to try to hyperoptimize code\non your first pass. As you become more experienced with Rust, it’ll be\neasier to start with the most efficient solution, but for now, it’s\nperfectly acceptable to call <code class=\"hljs\">clone</code>.</p>\n</section>\n<p>We’ve updated <code class=\"hljs\">main</code> so it places the instance of <code class=\"hljs\">Config</code> returned by\n<code class=\"hljs\">parse_config</code> into a variable named <code class=\"hljs\">config</code>, and we updated the code that\npreviously used the separate <code class=\"hljs\">query</code> and <code class=\"hljs\">file_path</code> variables so it now uses\nthe fields on the <code class=\"hljs\">Config</code> struct instead.</p>\n<p>Now our code more clearly conveys that <code class=\"hljs\">query</code> and <code class=\"hljs\">file_path</code> are related and\nthat their purpose is to configure how the program will work. Any code that\nuses these values knows to find them in the <code class=\"hljs\">config</code> instance in the fields\nnamed for their purpose.</p>\n<h4 id=\"creating-a-constructor-for-config\"><a class=\"header\" href=\"#creating-a-constructor-for-config\">Creating a Constructor for <code>Config</code></a></h4>\n<p>So far, we’ve extracted the logic responsible for parsing the command line\narguments from <code class=\"hljs\">main</code> and placed it in the <code class=\"hljs\">parse_config</code> function. Doing so\nhelped us to see that the <code class=\"hljs\">query</code> and <code class=\"hljs\">file_path</code> values were related and that\nrelationship should be conveyed in our code. We then added a <code class=\"hljs\">Config</code> struct to\nname the related purpose of <code class=\"hljs\">query</code> and <code class=\"hljs\">file_path</code> and to be able to return the\nvalues’ names as struct field names from the <code class=\"hljs\">parse_config</code> function.</p>\n<p>So now that the purpose of the <code class=\"hljs\">parse_config</code> function is to create a <code class=\"hljs\">Config</code>\ninstance, we can change <code class=\"hljs\">parse_config</code> from a plain function to a function\nnamed <code class=\"hljs\">new</code> that is associated with the <code class=\"hljs\">Config</code> struct. Making this change\nwill make the code more idiomatic. We can create instances of types in the\nstandard library, such as <code class=\"hljs\">String</code>, by calling <code class=\"hljs\">String::new</code>. Similarly, by\nchanging <code class=\"hljs\">parse_config</code> into a <code class=\"hljs\">new</code> function associated with <code class=\"hljs\">Config</code>, we’ll\nbe able to create instances of <code class=\"hljs\">Config</code> by calling <code class=\"hljs\">Config::new</code>. Listing 12-7\nshows the changes we need to make.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust should_panic noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::env;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n\n    <span class=\"hljs-keyword\">let</span> config = Config::new(&amp;args);\n<span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {}\"</span>, config.query);\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {}\"</span>, config.file_path);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)\n</span><span class=\"boring\">        .expect(<span class=\"hljs-string\">\"Should have been able to read the file\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n</span>\n    <span class=\"hljs-comment\">// --snip--</span>\n}\n\n<span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Config {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; Config {\n        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n\n        Config { query, file_path }\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 12-7: Changing <code class=\"hljs\">parse_config</code> into\n<code class=\"hljs\">Config::new</code></span></p>\n<p>We’ve updated <code class=\"hljs\">main</code> where we were calling <code class=\"hljs\">parse_config</code> to instead call\n<code class=\"hljs\">Config::new</code>. We’ve changed the name of <code class=\"hljs\">parse_config</code> to <code class=\"hljs\">new</code> and moved it\nwithin an <code class=\"hljs\">impl</code> block, which associates the <code class=\"hljs\">new</code> function with <code class=\"hljs\">Config</code>. Try\ncompiling this code again to make sure it works.</p>\n<h3 id=\"fixing-the-error-handling\"><a class=\"header\" href=\"#fixing-the-error-handling\">Fixing the Error Handling</a></h3>\n<p>Now we’ll work on fixing our error handling. Recall that attempting to access\nthe values in the <code class=\"hljs\">args</code> vector at index 1 or index 2 will cause the program to\npanic if the vector contains fewer than three items. Try running the program\nwithout any arguments; it will look like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep`\nthread 'main' panicked at src/main.rs:27:21:\nindex out of bounds: the len is 1 but the index is 1\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre>\n<p>The line <code class=\"hljs\">index out of bounds: the len is 1 but the index is 1</code> is an error\nmessage intended for programmers. It won’t help our end users understand what\nthey should do instead. Let’s fix that now.</p>\n<h4 id=\"improving-the-error-message\"><a class=\"header\" href=\"#improving-the-error-message\">Improving the Error Message</a></h4>\n<p>In Listing 12-8, we add a check in the <code class=\"hljs\">new</code> function that will verify that the\nslice is long enough before accessing index 1 and 2. If the slice isn’t long\nenough, the program panics and displays a better error message.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::env;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> config = Config::new(&amp;args);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {}\"</span>, config.query);\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {}\"</span>, config.file_path);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)\n</span><span class=\"boring\">        .expect(<span class=\"hljs-string\">\"Should have been able to read the file\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span>    <span class=\"hljs-comment\">// --snip--</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; Config {\n        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n            <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n        }\n        <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        Config { query, file_path }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 12-8: Adding a check for the number of\narguments</span></p>\n<p>This code is similar to <a href=\"ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation\">the <code class=\"hljs\">Guess::new</code> function we wrote in Listing\n9-13</a><!-- ignore -->, where we called <code class=\"hljs\">panic!</code> when the\n<code class=\"hljs\">value</code> argument was out of the range of valid values. Instead of checking for\na range of values here, we’re checking that the length of <code class=\"hljs\">args</code> is at least 3\nand the rest of the function can operate under the assumption that this\ncondition has been met. If <code class=\"hljs\">args</code> has fewer than three items, this condition\nwill be true, and we call the <code class=\"hljs\">panic!</code> macro to end the program immediately.</p>\n<p>With these extra few lines of code in <code class=\"hljs\">new</code>, let’s run the program without any\narguments again to see what the error looks like now:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep`\nthread 'main' panicked at src/main.rs:26:13:\nnot enough arguments\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre>\n<p>This output is better: we now have a reasonable error message. However, we also\nhave extraneous information we don’t want to give to our users. Perhaps using\nthe technique we used in Listing 9-13 isn’t the best to use here: a call to\n<code class=\"hljs\">panic!</code> is more appropriate for a programming problem than a usage problem,\n<a href=\"ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling\">as discussed in Chapter 9</a><!-- ignore -->. Instead,\nwe’ll use the other technique you learned about in Chapter 9—<a href=\"ch09-02-recoverable-errors-with-result.html\">returning a\n<code class=\"hljs\">Result</code></a><!-- ignore --> that indicates either success or an error.</p>\n<!-- Old headings. Do not remove or links may break. -->\n<p><a id=\"returning-a-result-from-new-instead-of-calling-panic\"></a></p>\n<h4 id=\"returning-a-result-instead-of-calling-panic\"><a class=\"header\" href=\"#returning-a-result-instead-of-calling-panic\">Returning a <code>Result</code> Instead of Calling <code>panic!</code></a></h4>\n<p>We can instead return a <code class=\"hljs\">Result</code> value that will contain a <code class=\"hljs\">Config</code> instance in\nthe successful case and will describe the problem in the error case. We’re also\ngoing to change the function name from <code class=\"hljs\">new</code> to <code class=\"hljs\">build</code> because many\nprogrammers expect <code class=\"hljs\">new</code> functions to never fail. When <code class=\"hljs\">Config::build</code> is\ncommunicating to <code class=\"hljs\">main</code>, we can use the <code class=\"hljs\">Result</code> type to signal there was a\nproblem. Then we can change <code class=\"hljs\">main</code> to convert an <code class=\"hljs\">Err</code> variant into a more\npractical error for our users without the surrounding text about <code class=\"hljs\">thread 'main'</code> and <code class=\"hljs\">RUST_BACKTRACE</code> that a call to <code class=\"hljs\">panic!</code> causes.</p>\n<p>Listing 12-9 shows the changes we need to make to the return value of the\nfunction we’re now calling <code class=\"hljs\">Config::build</code> and the body of the function needed\nto return a <code class=\"hljs\">Result</code>. Note that this won’t compile until we update <code class=\"hljs\">main</code> as\nwell, which we’ll do in the next listing.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::env;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> config = Config::new(&amp;args);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {}\"</span>, config.query);\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {}\"</span>, config.file_path);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)\n</span><span class=\"boring\">        .expect(<span class=\"hljs-string\">\"Should have been able to read the file\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Config {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n        }\n\n        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n\n        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 12-9: Returning a <code class=\"hljs\">Result</code> from\n<code class=\"hljs\">Config::build</code></span></p>\n<p>Our <code class=\"hljs\">build</code> function returns a <code class=\"hljs\">Result</code> with a <code class=\"hljs\">Config</code> instance in the success\ncase and a <code class=\"hljs\">&amp;'static str</code> in the error case. Our error values will always be\nstring literals that have the <code class=\"hljs\">'static</code> lifetime.</p>\n<p>We’ve made two changes in the body of the function: instead of calling <code class=\"hljs\">panic!</code>\nwhen the user doesn’t pass enough arguments, we now return an <code class=\"hljs\">Err</code> value, and\nwe’ve wrapped the <code class=\"hljs\">Config</code> return value in an <code class=\"hljs\">Ok</code>. These changes make the\nfunction conform to its new type signature.</p>\n<p>Returning an <code class=\"hljs\">Err</code> value from <code class=\"hljs\">Config::build</code> allows the <code class=\"hljs\">main</code> function to\nhandle the <code class=\"hljs\">Result</code> value returned from the <code class=\"hljs\">build</code> function and exit the\nprocess more cleanly in the error case.</p>\n<!-- Old headings. Do not remove or links may break. -->\n<p><a id=\"calling-confignew-and-handling-errors\"></a></p>\n<h4 id=\"calling-configbuild-and-handling-errors\"><a class=\"header\" href=\"#calling-configbuild-and-handling-errors\">Calling <code>Config::build</code> and Handling Errors</a></h4>\n<p>To handle the error case and print a user-friendly message, we need to update\n<code class=\"hljs\">main</code> to handle the <code class=\"hljs\">Result</code> being returned by <code class=\"hljs\">Config::build</code>, as shown in\nListing 12-10. We’ll also take the responsibility of exiting the command line\ntool with a nonzero error code away from <code class=\"hljs\">panic!</code> and instead implement it by\nhand. A nonzero exit status is a convention to signal to the process that\ncalled our program that the program exited with an error state.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::env;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"hljs-keyword\">use</span> std::process;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n\n    <span class=\"hljs-keyword\">let</span> config = Config::build(&amp;args).unwrap_or_else(|err| {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Problem parsing arguments: {err}\"</span>);\n        process::exit(<span class=\"hljs-number\">1</span>);\n    });\n\n    <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {}\"</span>, config.query);\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {}\"</span>, config.file_path);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)\n</span><span class=\"boring\">        .expect(<span class=\"hljs-string\">\"Should have been able to read the file\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 12-10: Exiting with an error code if building a\n<code class=\"hljs\">Config</code> fails</span></p>\n<p>In this listing, we’ve used a method we haven’t covered in detail yet:\n<code class=\"hljs\">unwrap_or_else</code>, which is defined on <code class=\"hljs\">Result&lt;T, E&gt;</code> by the standard library.\nUsing <code class=\"hljs\">unwrap_or_else</code> allows us to define some custom, non-<code class=\"hljs\">panic!</code> error\nhandling. If the <code class=\"hljs\">Result</code> is an <code class=\"hljs\">Ok</code> value, this method’s behavior is similar\nto <code class=\"hljs\">unwrap</code>: it returns the inner value <code class=\"hljs\">Ok</code> is wrapping. However, if the value\nis an <code class=\"hljs\">Err</code> value, this method calls the code in the <em>closure</em>, which is an\nanonymous function we define and pass as an argument to <code class=\"hljs\">unwrap_or_else</code>. We’ll\ncover closures in more detail in <a href=\"ch13-00-functional-features.html\">Chapter 13</a><!-- ignore -->. For now,\nyou just need to know that <code class=\"hljs\">unwrap_or_else</code> will pass the inner value of the\n<code class=\"hljs\">Err</code>, which in this case is the static string <code class=\"hljs\">\"not enough arguments\"</code> that we\nadded in Listing 12-9, to our closure in the argument <code class=\"hljs\">err</code> that appears\nbetween the vertical pipes. The code in the closure can then use the <code class=\"hljs\">err</code>\nvalue when it runs.</p>\n<p>We’ve added a new <code class=\"hljs\">use</code> line to bring <code class=\"hljs\">process</code> from the standard library into\nscope. The code in the closure that will be run in the error case is only two\nlines: we print the <code class=\"hljs\">err</code> value and then call <code class=\"hljs\">process::exit</code>. The\n<code class=\"hljs\">process::exit</code> function will stop the program immediately and return the\nnumber that was passed as the exit status code. This is similar to the\n<code class=\"hljs\">panic!</code>-based handling we used in Listing 12-8, but we no longer get all the\nextra output. Let’s try it:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/minigrep`\nProblem parsing arguments: not enough arguments\n</code></pre>\n<p>Great! This output is much friendlier for our users.</p>\n<h3 id=\"extracting-logic-from-main\"><a class=\"header\" href=\"#extracting-logic-from-main\">Extracting Logic from <code>main</code></a></h3>\n<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to\nthe program’s logic. As we stated in <a href=\"#separation-of-concerns-for-binary-projects\">“Separation of Concerns for Binary\nProjects”</a><!-- ignore -->, we’ll\nextract a function named <code class=\"hljs\">run</code> that will hold all the logic currently in the\n<code class=\"hljs\">main</code> function that isn’t involved with setting up configuration or handling\nerrors. When we’re done, <code class=\"hljs\">main</code> will be concise and easy to verify by\ninspection, and we’ll be able to write tests for all the other logic.</p>\n<p>Listing 12-11 shows the extracted <code class=\"hljs\">run</code> function. For now, we’re just making\nthe small, incremental improvement of extracting the function. We’re still\ndefining the function in <em>src/main.rs</em>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::env;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::process;\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"boring\">    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> config = Config::build(&amp;args).unwrap_or_else(|err| {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Problem parsing arguments: {err}\"</span>);\n</span><span class=\"boring\">        process::exit(<span class=\"hljs-number\">1</span>);\n</span><span class=\"boring\">    });\n</span><span class=\"boring\">\n</span>    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {}\"</span>, config.query);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {}\"</span>, config.file_path);\n\n    run(config);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) {\n    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)\n        .expect(<span class=\"hljs-string\">\"Should have been able to read the file\"</span>);\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n}\n\n<span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 12-11: Extracting a <code class=\"hljs\">run</code> function containing the\nrest of the program logic</span></p>\n<p>The <code class=\"hljs\">run</code> function now contains all the remaining logic from <code class=\"hljs\">main</code>, starting\nfrom reading the file. The <code class=\"hljs\">run</code> function takes the <code class=\"hljs\">Config</code> instance as an\nargument.</p>\n<h4 id=\"returning-errors-from-the-run-function\"><a class=\"header\" href=\"#returning-errors-from-the-run-function\">Returning Errors from the <code>run</code> Function</a></h4>\n<p>With the remaining program logic separated into the <code class=\"hljs\">run</code> function, we can\nimprove the error handling, as we did with <code class=\"hljs\">Config::build</code> in Listing 12-9.\nInstead of allowing the program to panic by calling <code class=\"hljs\">expect</code>, the <code class=\"hljs\">run</code>\nfunction will return a <code class=\"hljs\">Result&lt;T, E&gt;</code> when something goes wrong. This will let\nus further consolidate the logic around handling errors into <code class=\"hljs\">main</code> in a\nuser-friendly way. Listing 12-12 shows the changes we need to make to the\nsignature and body of <code class=\"hljs\">run</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::env;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::process;\n</span><span class=\"hljs-keyword\">use</span> std::error::Error;\n\n<span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> config = Config::build(&amp;args).unwrap_or_else(|err| {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Problem parsing arguments: {err}\"</span>);\n</span><span class=\"boring\">        process::exit(<span class=\"hljs-number\">1</span>);\n</span><span class=\"boring\">    });\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {}\"</span>, config.query);\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {}\"</span>, config.file_path);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    run(config);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Error&gt;&gt; {\n    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)?;\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n\n    <span class=\"hljs-literal\">Ok</span>(())\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 12-12: Changing the <code class=\"hljs\">run</code> function to return\n<code class=\"hljs\">Result</code></span></p>\n<p>We’ve made three significant changes here. First, we changed the return type of\nthe <code class=\"hljs\">run</code> function to <code class=\"hljs\">Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. This function previously\nreturned the unit type, <code class=\"hljs\">()</code>, and we keep that as the value returned in the\n<code class=\"hljs\">Ok</code> case.</p>\n<p>For the error type, we used the <em>trait object</em> <code class=\"hljs\">Box&lt;dyn Error&gt;</code> (and we’ve\nbrought <code class=\"hljs\">std::error::Error</code> into scope with a <code class=\"hljs\">use</code> statement at the top).\nWe’ll cover trait objects in <a href=\"ch17-00-oop.html\">Chapter 17</a><!-- ignore -->. For now, just\nknow that <code class=\"hljs\">Box&lt;dyn Error&gt;</code> means the function will return a type that\nimplements the <code class=\"hljs\">Error</code> trait, but we don’t have to specify what particular type\nthe return value will be. This gives us flexibility to return error values that\nmay be of different types in different error cases. The <code class=\"hljs\">dyn</code> keyword is short\nfor “dynamic.”</p>\n<p>Second, we’ve removed the call to <code class=\"hljs\">expect</code> in favor of the <code class=\"hljs\">?</code> operator, as we\ntalked about in <a href=\"ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\">Chapter 9</a><!-- ignore -->. Rather than\n<code class=\"hljs\">panic!</code> on an error, <code class=\"hljs\">?</code> will return the error value from the current function\nfor the caller to handle.</p>\n<p>Third, the <code class=\"hljs\">run</code> function now returns an <code class=\"hljs\">Ok</code> value in the success case.\nWe’ve declared the <code class=\"hljs\">run</code> function’s success type as <code class=\"hljs\">()</code> in the signature,\nwhich means we need to wrap the unit type value in the <code class=\"hljs\">Ok</code> value. This\n<code class=\"hljs\">Ok(())</code> syntax might look a bit strange at first, but using <code class=\"hljs\">()</code> like this is\nthe idiomatic way to indicate that we’re calling <code class=\"hljs\">run</code> for its side effects\nonly; it doesn’t return a value we need.</p>\n<p>When you run this code, it will compile but will display a warning:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run -- the poem.txt</span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nwarning: unused `Result` that must be used\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/main.rs:19:5</span>\n   |\n19 |     run(config);\n   |     ^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n19 |     let _ = run(config);\n   |     +++++++\n\nwarning: `minigrep` (bin \"minigrep\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s\n     Running `target/debug/minigrep the poem.txt`\nSearching for the\nIn file poem.txt\nWith text:\nI'm nobody! Who are you?\nAre you nobody, too?\nThen there's a pair of us - don't tell!\nThey'd banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\n</code></pre>\n<p>Rust tells us that our code ignored the <code class=\"hljs\">Result</code> value and the <code class=\"hljs\">Result</code> value\nmight indicate that an error occurred. But we’re not checking to see whether or\nnot there was an error, and the compiler reminds us that we probably meant to\nhave some error-handling code here! Let’s rectify that problem now.</p>\n<h4 id=\"handling-errors-returned-from-run-in-main\"><a class=\"header\" href=\"#handling-errors-returned-from-run-in-main\">Handling Errors Returned from <code>run</code> in <code>main</code></a></h4>\n<p>We’ll check for errors and handle them using a technique similar to one we used\nwith <code class=\"hljs\">Config::build</code> in Listing 12-10, but with a slight difference:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::env;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::error::Error;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::process;\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"boring\">    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> config = Config::build(&amp;args).unwrap_or_else(|err| {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Problem parsing arguments: {err}\"</span>);\n</span><span class=\"boring\">        process::exit(<span class=\"hljs-number\">1</span>);\n</span><span class=\"boring\">    });\n</span><span class=\"boring\">\n</span>    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {}\"</span>, config.query);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {}\"</span>, config.file_path);\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Err</span>(e) = run(config) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Application error: {e}\"</span>);\n        process::exit(<span class=\"hljs-number\">1</span>);\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Error&gt;&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)?;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-literal\">Ok</span>(())\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>We use <code class=\"hljs\">if let</code> rather than <code class=\"hljs\">unwrap_or_else</code> to check whether <code class=\"hljs\">run</code> returns an\n<code class=\"hljs\">Err</code> value and call <code class=\"hljs\">process::exit(1)</code> if it does. The <code class=\"hljs\">run</code> function doesn’t\nreturn a value that we want to <code class=\"hljs\">unwrap</code> in the same way that <code class=\"hljs\">Config::build</code>\nreturns the <code class=\"hljs\">Config</code> instance. Because <code class=\"hljs\">run</code> returns <code class=\"hljs\">()</code> in the success case,\nwe only care about detecting an error, so we don’t need <code class=\"hljs\">unwrap_or_else</code> to\nreturn the unwrapped value, which would only be <code class=\"hljs\">()</code>.</p>\n<p>The bodies of the <code class=\"hljs\">if let</code> and the <code class=\"hljs\">unwrap_or_else</code> functions are the same in\nboth cases: we print the error and exit.</p>\n<h3 id=\"splitting-code-into-a-library-crate\"><a class=\"header\" href=\"#splitting-code-into-a-library-crate\">Splitting Code into a Library Crate</a></h3>\n<p>Our <code class=\"hljs\">minigrep</code> project is looking good so far! Now we’ll split the\n<em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file. That way we\ncan test the code and have a <em>src/main.rs</em> file with fewer responsibilities.</p>\n<p>Let’s move all the code that isn’t the <code class=\"hljs\">main</code> function from <em>src/main.rs</em> to\n<em>src/lib.rs</em>:</p>\n<ul>\n<li>The <code class=\"hljs\">run</code> function definition</li>\n<li>The relevant <code class=\"hljs\">use</code> statements</li>\n<li>The definition of <code class=\"hljs\">Config</code></li>\n<li>The <code class=\"hljs\">Config::build</code> function definition</li>\n</ul>\n<p>The contents of <em>src/lib.rs</em> should have the signatures shown in Listing 12-13\n(we’ve omitted the bodies of the functions for brevity). Note that this won’t\ncompile until we modify <em>src/main.rs</em> in Listing 12-14.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::error::Error;\n<span class=\"hljs-keyword\">use</span> std::fs;\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n    <span class=\"hljs-keyword\">pub</span> query: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-keyword\">pub</span> file_path: <span class=\"hljs-built_in\">String</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> Config {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n        <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span>    }\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Error&gt;&gt; {\n    <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)?;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"With text:\\n{contents}\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-literal\">Ok</span>(())\n</span>}</code></pre>\n<p><span class=\"caption\">Listing 12-13: Moving <code class=\"hljs\">Config</code> and <code class=\"hljs\">run</code> into\n<em>src/lib.rs</em></span></p>\n<p>We’ve made liberal use of the <code class=\"hljs\">pub</code> keyword: on <code class=\"hljs\">Config</code>, on its fields and its\n<code class=\"hljs\">build</code> method, and on the <code class=\"hljs\">run</code> function. We now have a library crate that has\na public API we can test!</p>\n<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the\nbinary crate in <em>src/main.rs</em>, as shown in Listing 12-14.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::env;\n<span class=\"hljs-keyword\">use</span> std::process;\n\n<span class=\"hljs-keyword\">use</span> minigrep::Config;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; = env::args().collect();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> config = Config::build(&amp;args).unwrap_or_else(|err| {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Problem parsing arguments: {err}\"</span>);\n</span><span class=\"boring\">        process::exit(<span class=\"hljs-number\">1</span>);\n</span><span class=\"boring\">    });\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Searching for {}\"</span>, config.query);\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"In file {}\"</span>, config.file_path);\n</span><span class=\"boring\">\n</span>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Err</span>(e) = minigrep::run(config) {\n        <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Application error: {e}\"</span>);\n</span><span class=\"boring\">        process::exit(<span class=\"hljs-number\">1</span>);\n</span>    }\n}</code></pre>\n<p><span class=\"caption\">Listing 12-14: Using the <code class=\"hljs\">minigrep</code> library crate in\n<em>src/main.rs</em></span></p>\n<p>We add a <code class=\"hljs\">use minigrep::Config</code> line to bring the <code class=\"hljs\">Config</code> type from the\nlibrary crate into the binary crate’s scope, and we prefix the <code class=\"hljs\">run</code> function\nwith our crate name. Now all the functionality should be connected and should\nwork. Run the program with <code class=\"hljs\">cargo run</code> and make sure everything works\ncorrectly.</p>\n<p>Whew! That was a lot of work, but we’ve set ourselves up for success in the\nfuture. Now it’s much easier to handle errors, and we’ve made the code more\nmodular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>\n<p>Let’s take advantage of this newfound modularity by doing something that would\nhave been difficult with the old code but is easy with the new code: we’ll\nwrite some tests!</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch12-02-reading-a-file.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch12-04-testing-the-librarys-functionality.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch12-02-reading-a-file.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch12-04-testing-the-librarys-functionality.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:24.635Z"
}