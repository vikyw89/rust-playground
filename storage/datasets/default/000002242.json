{
	"title": "must_use in std::hint - Rust",
	"url": "https://doc.rust-lang.org/stable/std/hint/fn.must_use.html",
	"markdown": "# must\\_use in std::hint - Rust\n\n```\npub const fn must_use<T>(value: T) -> T\n```\n\nðŸ”¬This is a nightly-only experimental API. (`hint_must_use`Â [#94745](https://github.com/rust-lang/rust/issues/94745))\n\nExpand description\n\nAn identity function that causes an `unused_must_use` warning to be triggered if the given value is not used (returned, stored in a variable, etc) by the caller.\n\nThis is primarily intended for use in macro-generated code, in which a [`#[must_use]` attribute](https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute) either on a type or a function would not be convenient.\n\n## [Â§](#example)Example\n\n```\n#![feature(hint_must_use)]\n\nuse core::fmt;\n\npub struct Error(/* ... */);\n\n#[macro_export]\nmacro_rules! make_error {\n    ($($args:expr),*) => {\n        core::hint::must_use({\n            let error = $crate::make_error(core::format_args!($($args),*));\n            error\n        })\n    };\n}\n\n// Implementation detail of make_error! macro.\n#[doc(hidden)]\npub fn make_error(args: fmt::Arguments<'_>) -> Error {\n    Error(/* ... */)\n}\n\nfn demo() -> Option<Error> {\n    if true {\n        // Oops, meant to write `return Some(make_error!(\"...\"));`\n        Some(make_error!(\"...\"));\n    }\n    None\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(hint_must_use)%5D%0A%0Ause+core::fmt;%0A%0Apub+struct+Error(/*+...+*/);%0A%0A%23%5Bmacro_export%5D%0Amacro_rules!+make_error+%7B%0A++++(%24(%24args:expr),*)+=%3E+%7B%0A++++++++core::hint::must_use(%7B%0A++++++++++++let+error+=+%24crate::make_error(core::format_args!(%24(%24args),*));%0A++++++++++++error%0A++++++++%7D)%0A++++%7D;%0A%7D%0A%0A//+Implementation+detail+of+make_error!+macro.%0A%23%5Bdoc(hidden)%5D%0Apub+fn+make_error(args:+fmt::Arguments%3C%27_%3E)+-%3E+Error+%7B%0A++++Error(/*+...+*/)%0A%7D%0A%0Afn+demo()+-%3E+Option%3CError%3E+%7B%0A++++if+true+%7B%0A++++++++//+Oops,+meant+to+write+%60return+Some(make_error!(%22...%22));%60%0A++++++++Some(make_error!(%22...%22));%0A++++%7D%0A++++None%0A%7D%0A%0A//+Make+rustdoc+not+wrap+the+whole+snippet+in+fn+main,+so+that+%24crate::make_error+works%0Afn+main()+%7B%7D&version=nightly&edition=2021)\n\nIn the above example, weâ€™d like an `unused_must_use` lint to apply to the value created by `make_error!`. However, neither `#[must_use]` on a struct nor `#[must_use]` on a function is appropriate here, so the macro expands using `core::hint::must_use` instead.\n\n-   We wouldnâ€™t want `#[must_use]` on the `struct Error` because that would make the following unproblematic code trigger a warning:\n    \n    ```\n    fn f(arg: &str) -> Result<(), Error>\n    \n    #[test]\n    fn t() {\n        // Assert that `f` returns error if passed an empty string.\n        // A value of type `Error` is unused here but that's not a problem.\n        f(\"\").unwrap_err();\n    }\n    ```\n    \n    [Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+Error;%0A++++%0A++++fn+f(arg:+%26str)+-%3E+Result%3C(),+Error%3E%0A++++%7B+Ok(())+%7D%0A++++%0A++++%23%5Btest%5D%0A++++fn+t()+%7B%0A++++++++//+Assert+that+%60f%60+returns+error+if+passed+an+empty+string.%0A++++++++//+A+value+of+type+%60Error%60+is+unused+here+but+that%27s+not+a+problem.%0A++++++++f(%22%22).unwrap_err();%0A++++%7D%0A%7D&edition=2021)\n    \n-   Using `#[must_use]` on `fn make_error` canâ€™t help because the return value _is_ used, as the right-hand side of a `let` statement. The `let` statement looks useless but is in fact necessary for ensuring that temporaries within the `format_args` expansion are not kept alive past the creation of the `Error`, as keeping them alive past that point can cause autotrait issues in async code:\n    \n    ```\n    async fn f() {\n        // Using `let` inside the make_error expansion causes temporaries like\n        // `unsync()` to drop at the semicolon of that `let` statement, which\n        // is prior to the await point. They would otherwise stay around until\n        // the semicolon on *this* statement, which is after the await point,\n        // and the enclosing Future would not implement Send.\n        log(make_error!(\"look: {:p}\", unsync())).await;\n    }\n    \n    async fn log(error: Error) {/* ... */}\n    \n    // Returns something without a Sync impl.\n    fn unsync() -> *const () {\n        0 as *const ()\n    }\n    ```\n    \n    [Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(hint_must_use)%5D%0A%0Afn+main()+%7B%0A++++struct+Error;%0A++++%0A++++macro_rules!+make_error+%7B%0A++++++++(%24(%24args:expr),*)+=%3E+%7B%0A++++++++++++core::hint::must_use(%7B%0A++++++++++++++++//+If+%60let%60+isn%27t+used,+then+%60f()%60+produces+a+non-Send+future.%0A++++++++++++++++let+error+=+make_error(core::format_args!(%24(%24args),*));%0A++++++++++++++++error%0A++++++++++++%7D)%0A++++++++%7D;%0A++++%7D%0A++++%0A++++fn+make_error(args:+core::fmt::Arguments%3C%27_%3E)+-%3E+Error+%7B%0A++++++++Error%0A++++%7D%0A++++%0A++++async+fn+f()+%7B%0A++++++++//+Using+%60let%60+inside+the+make_error+expansion+causes+temporaries+like%0A++++++++//+%60unsync()%60+to+drop+at+the+semicolon+of+that+%60let%60+statement,+which%0A++++++++//+is+prior+to+the+await+point.+They+would+otherwise+stay+around+until%0A++++++++//+the+semicolon+on+*this*+statement,+which+is+after+the+await+point,%0A++++++++//+and+the+enclosing+Future+would+not+implement+Send.%0A++++++++log(make_error!(%22look:+%7B:p%7D%22,+unsync())).await;%0A++++%7D%0A++++%0A++++async+fn+log(error:+Error)+%7B/*+...+*/%7D%0A++++%0A++++//+Returns+something+without+a+Sync+impl.%0A++++fn+unsync()+-%3E+*const+()+%7B%0A++++++++0+as+*const+()%0A++++%7D%0A++++%0A++++fn+test()+%7B%0A++++++++fn+assert_send(_:+impl+Send)+%7B%7D%0A++++++++assert_send(f());%0A++++%7D%0A%7D&version=nightly&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"An identity function that causes an `unused_must_use` warning to be triggered if the given value is not used (returned, stored in a variable, etc) by the caller.\"><title>must_use in std::hint - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::hint</a></h2><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.assert_unchecked.html\">assert_unchecked</a></li><li><a href=\"fn.black_box.html\">black_box</a></li><li><a href=\"fn.must_use.html\">must_use</a></li><li><a href=\"fn.spin_loop.html\">spin_loop</a></li><li><a href=\"fn.unreachable_unchecked.html\">unreachable_unchecked</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type â€˜Sâ€™ or â€˜/â€™ to search, â€˜?â€™ for more optionsâ€¦\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">hint</a>::<wbr><a class=\"fn\" href=\"#\">must_use</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/hint.rs.html#461\">source</a> Â· <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>âˆ’</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub const fn must_use&lt;T&gt;(value: T) -&gt; T</code></pre><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>hint_must_use</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/94745\">#94745</a>)</span></div></span><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>An identity function that causes an <code>unused_must_use</code> warning to be\ntriggered if the given value is not used (returned, stored in a variable,\netc) by the caller.</p>\n<p>This is primarily intended for use in macro-generated code, in which a\n<a href=\"https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\"><code>#[must_use]</code> attribute</a> either on a type or a function would not\nbe convenient.</p>\n<h2 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">Â§</a>Example</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(hint_must_use)]\n\n</span><span class=\"kw\">use </span>core::fmt;\n\n<span class=\"kw\">pub struct </span>Error(<span class=\"comment\">/* ... */</span>);\n\n<span class=\"attr\">#[macro_export]\n</span><span class=\"macro\">macro_rules!</span> make_error {\n    ($(<span class=\"macro-nonterminal\">$args</span>:expr),<span class=\"kw-2\">*</span>) =&gt; {\n        core::hint::must_use({\n            <span class=\"kw\">let </span>error = <span class=\"macro-nonterminal\">$crate::make_error</span>(<span class=\"macro\">core::format_args!</span>($(<span class=\"macro-nonterminal\">$args</span>),<span class=\"kw-2\">*</span>));\n            error\n        })\n    };\n}\n\n<span class=\"comment\">// Implementation detail of make_error! macro.\n</span><span class=\"attr\">#[doc(hidden)]\n</span><span class=\"kw\">pub fn </span>make_error(args: fmt::Arguments&lt;<span class=\"lifetime\">'_</span>&gt;) -&gt; Error {\n    Error(<span class=\"comment\">/* ... */</span>)\n}\n\n<span class=\"kw\">fn </span>demo() -&gt; <span class=\"prelude-ty\">Option</span>&lt;Error&gt; {\n    <span class=\"kw\">if </span><span class=\"bool-val\">true </span>{\n        <span class=\"comment\">// Oops, meant to write `return Some(make_error!(\"...\"));`\n        </span><span class=\"prelude-val\">Some</span>(<span class=\"macro\">make_error!</span>(<span class=\"string\">\"...\"</span>));\n    }\n    <span class=\"prelude-val\">None\n</span>}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(hint_must_use)%5D%0A%0Ause+core::fmt;%0A%0Apub+struct+Error(/*+...+*/);%0A%0A%23%5Bmacro_export%5D%0Amacro_rules!+make_error+%7B%0A++++(%24(%24args:expr),*)+=%3E+%7B%0A++++++++core::hint::must_use(%7B%0A++++++++++++let+error+=+%24crate::make_error(core::format_args!(%24(%24args),*));%0A++++++++++++error%0A++++++++%7D)%0A++++%7D;%0A%7D%0A%0A//+Implementation+detail+of+make_error!+macro.%0A%23%5Bdoc(hidden)%5D%0Apub+fn+make_error(args:+fmt::Arguments%3C'_%3E)+-%3E+Error+%7B%0A++++Error(/*+...+*/)%0A%7D%0A%0Afn+demo()+-%3E+Option%3CError%3E+%7B%0A++++if+true+%7B%0A++++++++//+Oops,+meant+to+write+%60return+Some(make_error!(%22...%22));%60%0A++++++++Some(make_error!(%22...%22));%0A++++%7D%0A++++None%0A%7D%0A%0A//+Make+rustdoc+not+wrap+the+whole+snippet+in+fn+main,+so+that+%24crate::make_error+works%0Afn+main()+%7B%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>In the above example, weâ€™d like an <code>unused_must_use</code> lint to apply to the\nvalue created by <code>make_error!</code>. However, neither <code>#[must_use]</code> on a struct\nnor <code>#[must_use]</code> on a function is appropriate here, so the macro expands\nusing <code>core::hint::must_use</code> instead.</p>\n<ul>\n<li>\n<p>We wouldnâ€™t want <code>#[must_use]</code> on the <code>struct Error</code> because that would\nmake the following unproblematic code trigger a warning:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>f(arg: <span class=\"kw-2\">&amp;</span>str) -&gt; <span class=\"prelude-ty\">Result</span>&lt;(), Error&gt;\n\n<span class=\"attr\">#[test]\n</span><span class=\"kw\">fn </span>t() {\n    <span class=\"comment\">// Assert that `f` returns error if passed an empty string.\n    // A value of type `Error` is unused here but that's not a problem.\n    </span>f(<span class=\"string\">\"\"</span>).unwrap_err();\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+Error;%0A++++%0A++++fn+f(arg:+%26str)+-%3E+Result%3C(),+Error%3E%0A++++%7B+Ok(())+%7D%0A++++%0A++++%23%5Btest%5D%0A++++fn+t()+%7B%0A++++++++//+Assert+that+%60f%60+returns+error+if+passed+an+empty+string.%0A++++++++//+A+value+of+type+%60Error%60+is+unused+here+but+that's+not+a+problem.%0A++++++++f(%22%22).unwrap_err();%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</li>\n<li>\n<p>Using <code>#[must_use]</code> on <code>fn make_error</code> canâ€™t help because the return value\n<em>is</em> used, as the right-hand side of a <code>let</code> statement. The <code>let</code>\nstatement looks useless but is in fact necessary for ensuring that\ntemporaries within the <code>format_args</code> expansion are not kept alive past the\ncreation of the <code>Error</code>, as keeping them alive past that point can cause\nautotrait issues in async code:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">async fn </span>f() {\n    <span class=\"comment\">// Using `let` inside the make_error expansion causes temporaries like\n    // `unsync()` to drop at the semicolon of that `let` statement, which\n    // is prior to the await point. They would otherwise stay around until\n    // the semicolon on *this* statement, which is after the await point,\n    // and the enclosing Future would not implement Send.\n    </span>log(<span class=\"macro\">make_error!</span>(<span class=\"string\">\"look: {:p}\"</span>, unsync())).<span class=\"kw\">await</span>;\n}\n\n<span class=\"kw\">async fn </span>log(error: Error) {<span class=\"comment\">/* ... */</span>}\n\n<span class=\"comment\">// Returns something without a Sync impl.\n</span><span class=\"kw\">fn </span>unsync() -&gt; <span class=\"kw-2\">*const </span>() {\n    <span class=\"number\">0 </span><span class=\"kw\">as </span><span class=\"kw-2\">*const </span>()\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(hint_must_use)%5D%0A%0Afn+main()+%7B%0A++++struct+Error;%0A++++%0A++++macro_rules!+make_error+%7B%0A++++++++(%24(%24args:expr),*)+=%3E+%7B%0A++++++++++++core::hint::must_use(%7B%0A++++++++++++++++//+If+%60let%60+isn't+used,+then+%60f()%60+produces+a+non-Send+future.%0A++++++++++++++++let+error+=+make_error(core::format_args!(%24(%24args),*));%0A++++++++++++++++error%0A++++++++++++%7D)%0A++++++++%7D;%0A++++%7D%0A++++%0A++++fn+make_error(args:+core::fmt::Arguments%3C'_%3E)+-%3E+Error+%7B%0A++++++++Error%0A++++%7D%0A++++%0A++++async+fn+f()+%7B%0A++++++++//+Using+%60let%60+inside+the+make_error+expansion+causes+temporaries+like%0A++++++++//+%60unsync()%60+to+drop+at+the+semicolon+of+that+%60let%60+statement,+which%0A++++++++//+is+prior+to+the+await+point.+They+would+otherwise+stay+around+until%0A++++++++//+the+semicolon+on+*this*+statement,+which+is+after+the+await+point,%0A++++++++//+and+the+enclosing+Future+would+not+implement+Send.%0A++++++++log(make_error!(%22look:+%7B:p%7D%22,+unsync())).await;%0A++++%7D%0A++++%0A++++async+fn+log(error:+Error)+%7B/*+...+*/%7D%0A++++%0A++++//+Returns+something+without+a+Sync+impl.%0A++++fn+unsync()+-%3E+*const+()+%7B%0A++++++++0+as+*const+()%0A++++%7D%0A++++%0A++++fn+test()+%7B%0A++++++++fn+assert_send(_:+impl+Send)+%7B%7D%0A++++++++assert_send(f());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</li>\n</ul>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:23:17.882Z"
}