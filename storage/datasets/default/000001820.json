{
	"title": "Warn-by-default Lints - The rustc book",
	"url": "https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#unexpected-cfgs",
	"markdown": "# Warn-by-default Lints - The rustc book\n\nThese lints are all set to the 'warn' level by default.\n\n-   [`ambiguous_glob_imports`](#ambiguous-glob-imports)\n-   [`ambiguous_glob_reexports`](#ambiguous-glob-reexports)\n-   [`ambiguous_wide_pointer_comparisons`](#ambiguous-wide-pointer-comparisons)\n-   [`anonymous_parameters`](#anonymous-parameters)\n-   [`array_into_iter`](#array-into-iter)\n-   [`asm_sub_register`](#asm-sub-register)\n-   [`async_fn_in_trait`](#async-fn-in-trait)\n-   [`bad_asm_style`](#bad-asm-style)\n-   [`bare-trait-object`](#bare-trait-object)\n-   [`bare_trait_objects`](#bare-trait-objects)\n-   [`boxed_slice_into_iter`](#boxed-slice-into-iter)\n-   [`break_with_label_and_loop`](#break-with-label-and-loop)\n-   [`byte_slice_in_packed_struct_with_derive`](#byte-slice-in-packed-struct-with-derive)\n-   [`clashing_extern_declarations`](#clashing-extern-declarations)\n-   [`coherence_leak_check`](#coherence-leak-check)\n-   [`confusable_idents`](#confusable-idents)\n-   [`const_eval_mutable_ptr_in_final_value`](#const-eval-mutable-ptr-in-final-value)\n-   [`const_evaluatable_unchecked`](#const-evaluatable-unchecked)\n-   [`const_item_mutation`](#const-item-mutation)\n-   [`dead_code`](#dead-code)\n-   [`deprecated`](#deprecated)\n-   [`deprecated_where_clause_location`](#deprecated-where-clause-location)\n-   [`deref_into_dyn_supertrait`](#deref-into-dyn-supertrait)\n-   [`deref_nullptr`](#deref-nullptr)\n-   [`drop_bounds`](#drop-bounds)\n-   [`dropping_copy_types`](#dropping-copy-types)\n-   [`dropping_references`](#dropping-references)\n-   [`duplicate_macro_attributes`](#duplicate-macro-attributes)\n-   [`dyn_drop`](#dyn-drop)\n-   [`elided_lifetimes_in_associated_constant`](#elided-lifetimes-in-associated-constant)\n-   [`ellipsis_inclusive_range_patterns`](#ellipsis-inclusive-range-patterns)\n-   [`exported_private_dependencies`](#exported-private-dependencies)\n-   [`for_loops_over_fallibles`](#for-loops-over-fallibles)\n-   [`forbidden_lint_groups`](#forbidden-lint-groups)\n-   [`forgetting_copy_types`](#forgetting-copy-types)\n-   [`forgetting_references`](#forgetting-references)\n-   [`function_item_references`](#function-item-references)\n-   [`hidden_glob_reexports`](#hidden-glob-reexports)\n-   [`impl_trait_redundant_captures`](#impl-trait-redundant-captures)\n-   [`improper_ctypes`](#improper-ctypes)\n-   [`improper_ctypes_definitions`](#improper-ctypes-definitions)\n-   [`incomplete_features`](#incomplete-features)\n-   [`inline_no_sanitize`](#inline-no-sanitize)\n-   [`internal_features`](#internal-features)\n-   [`invalid_from_utf8`](#invalid-from-utf8)\n-   [`invalid_macro_export_arguments`](#invalid-macro-export-arguments)\n-   [`invalid_nan_comparisons`](#invalid-nan-comparisons)\n-   [`invalid_value`](#invalid-value)\n-   [`irrefutable_let_patterns`](#irrefutable-let-patterns)\n-   [`large_assignments`](#large-assignments)\n-   [`late_bound_lifetime_arguments`](#late-bound-lifetime-arguments)\n-   [`legacy_derive_helpers`](#legacy-derive-helpers)\n-   [`map_unit_fn`](#map-unit-fn)\n-   [`mixed_script_confusables`](#mixed-script-confusables)\n-   [`named_arguments_used_positionally`](#named-arguments-used-positionally)\n-   [`never_type_fallback_flowing_into_unsafe`](#never-type-fallback-flowing-into-unsafe)\n-   [`no_mangle_generic_items`](#no-mangle-generic-items)\n-   [`non-fmt-panic`](#non-fmt-panic)\n-   [`non_camel_case_types`](#non-camel-case-types)\n-   [`non_contiguous_range_endpoints`](#non-contiguous-range-endpoints)\n-   [`non_fmt_panics`](#non-fmt-panics)\n-   [`non_shorthand_field_patterns`](#non-shorthand-field-patterns)\n-   [`non_snake_case`](#non-snake-case)\n-   [`non_upper_case_globals`](#non-upper-case-globals)\n-   [`noop_method_call`](#noop-method-call)\n-   [`opaque_hidden_inferred_bound`](#opaque-hidden-inferred-bound)\n-   [`overlapping-patterns`](#overlapping-patterns)\n-   [`overlapping_range_endpoints`](#overlapping-range-endpoints)\n-   [`path_statements`](#path-statements)\n-   [`private_bounds`](#private-bounds)\n-   [`private_interfaces`](#private-interfaces)\n-   [`private_macro_use`](#private-macro-use)\n-   [`redundant-semicolon`](#redundant-semicolon)\n-   [`redundant_semicolons`](#redundant-semicolons)\n-   [`refining_impl_trait_internal`](#refining-impl-trait-internal)\n-   [`refining_impl_trait_reachable`](#refining-impl-trait-reachable)\n-   [`renamed_and_removed_lints`](#renamed-and-removed-lints)\n-   [`repr_transparent_external_private_fields`](#repr-transparent-external-private-fields)\n-   [`self_constructor_from_outer_item`](#self-constructor-from-outer-item)\n-   [`semicolon_in_expressions_from_macros`](#semicolon-in-expressions-from-macros)\n-   [`special_module_name`](#special-module-name)\n-   [`stable_features`](#stable-features)\n-   [`static-mut-ref`](#static-mut-ref)\n-   [`static_mut_refs`](#static-mut-refs)\n-   [`suspicious_double_ref_op`](#suspicious-double-ref-op)\n-   [`temporary_cstring_as_ptr`](#temporary-cstring-as-ptr)\n-   [`trivial_bounds`](#trivial-bounds)\n-   [`type_alias_bounds`](#type-alias-bounds)\n-   [`tyvar_behind_raw_pointer`](#tyvar-behind-raw-pointer)\n-   [`uncommon_codepoints`](#uncommon-codepoints)\n-   [`unconditional_recursion`](#unconditional-recursion)\n-   [`uncovered_param_in_projection`](#uncovered-param-in-projection)\n-   [`undefined_naked_function_abi`](#undefined-naked-function-abi)\n-   [`unexpected_cfgs`](#unexpected-cfgs)\n-   [`unfulfilled_lint_expectations`](#unfulfilled-lint-expectations)\n-   [`ungated_async_fn_track_caller`](#ungated-async-fn-track-caller)\n-   [`uninhabited_static`](#uninhabited-static)\n-   [`unknown_lints`](#unknown-lints)\n-   [`unknown_or_malformed_diagnostic_attributes`](#unknown-or-malformed-diagnostic-attributes)\n-   [`unnameable_test_items`](#unnameable-test-items)\n-   [`unreachable_code`](#unreachable-code)\n-   [`unreachable_patterns`](#unreachable-patterns)\n-   [`unstable-name-collision`](#unstable-name-collision)\n-   [`unstable_name_collisions`](#unstable-name-collisions)\n-   [`unstable_syntax_pre_expansion`](#unstable-syntax-pre-expansion)\n-   [`unsupported_calling_conventions`](#unsupported-calling-conventions)\n-   [`unused-doc-comment`](#unused-doc-comment)\n-   [`unused-tuple-struct-fields`](#unused-tuple-struct-fields)\n-   [`unused_allocation`](#unused-allocation)\n-   [`unused_assignments`](#unused-assignments)\n-   [`unused_associated_type_bounds`](#unused-associated-type-bounds)\n-   [`unused_attributes`](#unused-attributes)\n-   [`unused_braces`](#unused-braces)\n-   [`unused_comparisons`](#unused-comparisons)\n-   [`unused_doc_comments`](#unused-doc-comments)\n-   [`unused_features`](#unused-features)\n-   [`unused_imports`](#unused-imports)\n-   [`unused_labels`](#unused-labels)\n-   [`unused_macros`](#unused-macros)\n-   [`unused_must_use`](#unused-must-use)\n-   [`unused_mut`](#unused-mut)\n-   [`unused_parens`](#unused-parens)\n-   [`unused_unsafe`](#unused-unsafe)\n-   [`unused_variables`](#unused-variables)\n-   [`useless_ptr_null_checks`](#useless-ptr-null-checks)\n-   [`warnings`](#warnings)\n-   [`wasm_c_abi`](#wasm-c-abi)\n-   [`while_true`](#while-true)\n-   [`writes_through_immutable_pointer`](#writes-through-immutable-pointer)\n\n## [ambiguous-glob-imports](#ambiguous-glob-imports)\n\nThe `ambiguous_glob_imports` lint detects glob imports that should report ambiguity errors, but previously didn't do that due to rustc bugs.\n\n### [Example](#example)\n\n```rust\n#![deny(ambiguous_glob_imports)]\npub fn foo() -> u32 {\n    use sub::*;\n    C\n}\n\nmod sub {\n    mod mod1 { pub const C: u32 = 1; }\n    mod mod2 { pub const C: u32 = 2; }\n\n    pub use mod1::*;\n    pub use mod2::*;\n}\n```\n\nThis will produce:\n\n```text\nerror: `C` is ambiguous\n  --> lint_example.rs:5:5\n   |\n5  |     C\n   |     ^ ambiguous name\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>\n   = note: ambiguous because of multiple glob imports of a name in the same module\nnote: `C` could refer to the constant imported here\n  --> lint_example.rs:12:13\n   |\n12 |     pub use mod1::*;\n   |             ^^^^^^^\n   = help: consider adding an explicit import of `C` to disambiguate\nnote: `C` could also refer to the constant imported here\n  --> lint_example.rs:13:13\n   |\n13 |     pub use mod2::*;\n   |             ^^^^^^^\n   = help: consider adding an explicit import of `C` to disambiguate\nnote: the lint level is defined here\n  --> lint_example.rs:1:9\n   |\n1  | #![deny(ambiguous_glob_imports)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation)\n\nPrevious versions of Rust compile it successfully because it had lost the ambiguity error when resolve `use sub::mod2::*`.\n\nThis is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the future.\n\n## [ambiguous-glob-reexports](#ambiguous-glob-reexports)\n\nThe `ambiguous_glob_reexports` lint detects cases where names re-exported via globs collide. Downstream users trying to use the same name re-exported from multiple globs will receive a warning pointing out redefinition of the same name.\n\n### [Example](#example-1)\n\n```rust\n#![deny(ambiguous_glob_reexports)]\npub mod foo {\n    pub type X = u8;\n}\n\npub mod bar {\n    pub type Y = u8;\n    pub type X = u8;\n}\n\npub use foo::*;\npub use bar::*;\n\n\npub fn main() {}\n```\n\nThis will produce:\n\n```text\nerror: ambiguous glob re-exports\n  --> lint_example.rs:11:9\n   |\n11 | pub use foo::*;\n   |         ^^^^^^ the name `X` in the type namespace is first re-exported here\n12 | pub use bar::*;\n   |         ------ but the name `X` in the type namespace is also re-exported here\n   |\nnote: the lint level is defined here\n  --> lint_example.rs:1:9\n   |\n1  | #![deny(ambiguous_glob_reexports)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-1)\n\nThis was previously accepted but it could silently break a crate's downstream users code. For example, if `foo::*` and `bar::*` were re-exported before `bar::X` was added to the re-exports, down stream users could use `this_crate::X` without problems. However, adding `bar::X` would cause compilation errors in downstream crates because `X` is defined multiple times in the same namespace of `this_crate`.\n\n## [ambiguous-wide-pointer-comparisons](#ambiguous-wide-pointer-comparisons)\n\nThe `ambiguous_wide_pointer_comparisons` lint checks comparison of `*const/*mut ?Sized` as the operands.\n\n### [Example](#example-2)\n\n```rust\nstruct A;\nstruct B;\n\ntrait T {}\nimpl T for A {}\nimpl T for B {}\n\nlet ab = (A, B);\nlet a = &ab.0 as *const dyn T;\nlet b = &ab.1 as *const dyn T;\n\nlet _ = a == b;\n```\n\nThis will produce:\n\n```text\nwarning: ambiguous wide pointer comparison, the comparison includes metadata which may not be expected\n  --> lint_example.rs:13:9\n   |\n13 | let _ = a == b;\n   |         ^^^^^^\n   |\n   = note: `#[warn(ambiguous_wide_pointer_comparisons)]` on by default\nhelp: use `std::ptr::addr_eq` or untyped pointers to only compare their addresses\n   |\n13 | let _ = std::ptr::addr_eq(a, b);\n   |         ++++++++++++++++++ ~  +\n\n\n```\n\n### [Explanation](#explanation-2)\n\nThe comparison includes metadata which may not be expected.\n\n## [anonymous-parameters](#anonymous-parameters)\n\nThe `anonymous_parameters` lint detects anonymous parameters in trait definitions.\n\n### [Example](#example-3)\n\n```rust\n#![deny(anonymous_parameters)]\n// edition 2015\npub trait Foo {\n    fn foo(usize);\n}\nfn main() {}\n```\n\nThis will produce:\n\n```text\nerror: anonymous parameters are deprecated and will be removed in the next edition\n --> lint_example.rs:4:12\n  |\n4 |     fn foo(usize);\n  |            ^^^^^ help: try naming the parameter or explicitly ignoring it: `_: usize`\n  |\n  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n  = note: for more information, see issue #41686 <https://github.com/rust-lang/rust/issues/41686>\nnote: the lint level is defined here\n --> lint_example.rs:1:9\n  |\n1 | #![deny(anonymous_parameters)]\n  |         ^^^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-3)\n\nThis syntax is mostly a historical accident, and can be worked around quite easily by adding an `_` pattern or a descriptive identifier:\n\n```rust\ntrait Foo {\n    fn foo(_: usize);\n}\n```\n\nThis syntax is now a hard error in the 2018 edition. In the 2015 edition, this lint is \"warn\" by default. This lint enables the [`cargo fix`](https://doc.rust-lang.org/cargo/commands/cargo-fix.html) tool with the `--edition` flag to automatically transition old code from the 2015 edition to 2018. The tool will run this lint and automatically apply the suggested fix from the compiler (which is to add `_` to each parameter). This provides a completely automated way to update old code for a new edition. See [issue #41686](https://github.com/rust-lang/rust/issues/41686) for more details.\n\n## [array-into-iter](#array-into-iter)\n\nThe `array_into_iter` lint detects calling `into_iter` on arrays.\n\n### [Example](#example-4)\n\n```rust\n#![allow(unused)]\n[1, 2, 3].into_iter().for_each(|n| { *n; });\n```\n\nThis will produce:\n\n```text\nwarning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to `<[T; N] as IntoIterator>::into_iter` in Rust 2021\n --> lint_example.rs:3:11\n  |\n3 | [1, 2, 3].into_iter().for_each(|n| { *n; });\n  |           ^^^^^^^^^\n  |\n  = warning: this changes meaning in Rust 2021\n  = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n  = note: `#[warn(array_into_iter)]` on by default\nhelp: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n  |\n3 | [1, 2, 3].iter().for_each(|n| { *n; });\n  |           ~~~~\nhelp: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n  |\n3 | IntoIterator::into_iter([1, 2, 3]).for_each(|n| { *n; });\n  | ++++++++++++++++++++++++         ~\n\n\n```\n\n### [Explanation](#explanation-4)\n\nSince Rust 1.53, arrays implement `IntoIterator`. However, to avoid breakage, `array.into_iter()` in Rust 2015 and 2018 code will still behave as `(&array).into_iter()`, returning an iterator over references, just like in Rust 1.52 and earlier. This only applies to the method call syntax `array.into_iter()`, not to any other syntax such as `for _ in array` or `IntoIterator::into_iter(array)`.\n\n## [asm-sub-register](#asm-sub-register)\n\nThe `asm_sub_register` lint detects using only a subset of a register for inline asm inputs.\n\n### [Example](#example-5)\n\n```rust\n#[cfg(target_arch=\"x86_64\")]\nuse std::arch::asm;\n\nfn main() {\n    #[cfg(target_arch=\"x86_64\")]\n    unsafe {\n        asm!(\"mov {0}, {0}\", in(reg) 0i16);\n    }\n}\n```\n\nThis will produce:\n\n```text\nwarning: formatting may not be suitable for sub-register argument\n --> src/main.rs:7:19\n  |\n7 |         asm!(\"mov {0}, {0}\", in(reg) 0i16);\n  |                   ^^^  ^^^           ---- for this argument\n  |\n  = note: `#[warn(asm_sub_register)]` on by default\n  = help: use the `x` modifier to have the register formatted as `ax`\n  = help: or use the `r` modifier to keep the default formatting of `rax`\n\n```\n\n### [Explanation](#explanation-5)\n\nRegisters on some architectures can use different names to refer to a subset of the register. By default, the compiler will use the name for the full register size. To explicitly use a subset of the register, you can override the default by using a modifier on the template string operand to specify when subregister to use. This lint is issued if you pass in a value with a smaller data type than the default register size, to alert you of possibly using the incorrect width. To fix this, add the suggested modifier to the template, or cast the value to the correct size.\n\nSee [register template modifiers](https://doc.rust-lang.org/nightly/reference/inline-assembly.html#template-modifiers) in the reference for more details.\n\n## [async-fn-in-trait](#async-fn-in-trait)\n\nThe `async_fn_in_trait` lint detects use of `async fn` in the definition of a publicly-reachable trait.\n\n### [Example](#example-6)\n\n```rust\npub trait Trait {\n    async fn method(&self);\n}\nfn main() {}\n```\n\nThis will produce:\n\n```text\nwarning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified\n --> lint_example.rs:2:5\n  |\n2 |     async fn method(&self);\n  |     ^^^^^\n  |\n  = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`\n  = note: `#[warn(async_fn_in_trait)]` on by default\nhelp: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change\n  |\n2 -     async fn method(&self);\n2 +     fn method(&self) -> impl std::future::Future<Output = ()> + Send;\n  |\n\n\n```\n\n### [Explanation](#explanation-6)\n\nWhen `async fn` is used in a trait definition, the trait does not promise that the opaque [`Future`](https://doc.rust-lang.org/core/future/trait.Future.html) returned by the associated function or method will implement any [auto traits](https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits) such as [`Send`](https://doc.rust-lang.org/core/marker/trait.Send.html). This may be surprising and may make the associated functions or methods on the trait less useful than intended. On traits exposed publicly from a crate, this may affect downstream crates whose authors cannot alter the trait definition.\n\nFor example, this code is invalid:\n\n```rust\npub trait Trait {\n    async fn method(&self) {}\n}\n\nfn test<T: Trait>(x: T) {\n    fn spawn<T: Send>(_: T) {}\n    spawn(x.method()); // Not OK.\n}\n```\n\nThis lint exists to warn authors of publicly-reachable traits that they may want to consider desugaring the `async fn` to a normal `fn` that returns an opaque `impl Future<..> + Send` type.\n\nFor example, instead of:\n\n```rust\npub trait Trait {\n    async fn method(&self) {}\n}\n```\n\nThe author of the trait may want to write:\n\n```rust\nuse core::future::Future;\npub trait Trait {\n    fn method(&self) -> impl Future<Output = ()> + Send { async {} }\n}\n```\n\nThis still allows the use of `async fn` within impls of the trait. However, it also means that the trait will never be compatible with impls where the returned [`Future`](https://doc.rust-lang.org/core/future/trait.Future.html) of the method does not implement `Send`.\n\nConversely, if the trait is used only locally, if it is never used in generic functions, or if it is only used in single-threaded contexts that do not care whether the returned [`Future`](https://doc.rust-lang.org/core/future/trait.Future.html) implements [`Send`](https://doc.rust-lang.org/core/marker/trait.Send.html), then the lint may be suppressed.\n\n## [bad-asm-style](#bad-asm-style)\n\nThe `bad_asm_style` lint detects the use of the `.intel_syntax` and `.att_syntax` directives.\n\n### [Example](#example-7)\n\n```rust\n#[cfg(target_arch=\"x86_64\")]\nuse std::arch::asm;\n\nfn main() {\n    #[cfg(target_arch=\"x86_64\")]\n    unsafe {\n        asm!(\n            \".att_syntax\",\n            \"movq %{0}, %{0}\", in(reg) 0usize\n        );\n    }\n}\n```\n\nThis will produce:\n\n```text\nwarning: avoid using `.att_syntax`, prefer using `options(att_syntax)` instead\n --> src/main.rs:8:14\n  |\n8 |             \".att_syntax\",\n  |              ^^^^^^^^^^^\n  |\n  = note: `#[warn(bad_asm_style)]` on by default\n\n```\n\n### [Explanation](#explanation-7)\n\nOn x86, `asm!` uses the intel assembly syntax by default. While this can be switched using assembler directives like `.att_syntax`, using the `att_syntax` option is recommended instead because it will also properly prefix register placeholders with `%` as required by AT&T syntax.\n\n## [bare-trait-object](#bare-trait-object)\n\nThe lint `bare-trait-object` has been renamed to [`bare-trait-objects`](#bare-trait-objects).\n\n## [bare-trait-objects](#bare-trait-objects)\n\nThe `bare_trait_objects` lint suggests using `dyn Trait` for trait objects.\n\n### [Example](#example-8)\n\n```rust\ntrait Trait { }\n\nfn takes_trait_object(_: Box<Trait>) {\n}\n```\n\nThis will produce:\n\n```text\nwarning: trait objects without an explicit `dyn` are deprecated\n --> lint_example.rs:4:30\n  |\n4 | fn takes_trait_object(_: Box<Trait>) {\n  |                              ^^^^^\n  |\n  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n  = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n  = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n  |\n4 | fn takes_trait_object(_: Box<dyn Trait>) {\n  |                              +++\n\n\n```\n\n### [Explanation](#explanation-8)\n\nWithout the `dyn` indicator, it can be ambiguous or confusing when reading code as to whether or not you are looking at a trait object. The `dyn` keyword makes it explicit, and adds a symmetry to contrast with [`impl Trait`](https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters).\n\n## [boxed-slice-into-iter](#boxed-slice-into-iter)\n\nThe `boxed_slice_into_iter` lint detects calling `into_iter` on boxed slices.\n\n### [Example](#example-9)\n\n```rust\n#![allow(unused)]\nvec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });\n```\n\nThis will produce:\n\n```text\nwarning: this method call resolves to `<&Box<[T]> as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to `<Box<[T]> as IntoIterator>::into_iter` in Rust 2024\n --> lint_example.rs:3:34\n  |\n3 | vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });\n  |                                  ^^^^^^^^^\n  |\n  = warning: this changes meaning in Rust 2024\n  = note: `#[warn(boxed_slice_into_iter)]` on by default\nhelp: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n  |\n3 | vec![1, 2, 3].into_boxed_slice().iter().for_each(|n| { *n; });\n  |                                  ~~~~\nhelp: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n  |\n3 | IntoIterator::into_iter(vec![1, 2, 3].into_boxed_slice()).for_each(|n| { *n; });\n  | ++++++++++++++++++++++++                                ~\n\n\n```\n\n### [Explanation](#explanation-9)\n\nSince Rust 1.80.0, boxed slices implement `IntoIterator`. However, to avoid breakage, `boxed_slice.into_iter()` in Rust 2015, 2018, and 2021 code will still behave as `(&boxed_slice).into_iter()`, returning an iterator over references, just like in Rust 1.80.0 and earlier. This only applies to the method call syntax `boxed_slice.into_iter()`, not to any other syntax such as `for _ in boxed_slice` or `IntoIterator::into_iter(boxed_slice)`.\n\n## [break-with-label-and-loop](#break-with-label-and-loop)\n\nThe `break_with_label_and_loop` lint detects labeled `break` expressions with an unlabeled loop as their value expression.\n\n### [Example](#example-10)\n\n```rust\n'label: loop {\n    break 'label loop { break 42; };\n};\n```\n\nThis will produce:\n\n```text\nwarning: this labeled break expression is easy to confuse with an unlabeled break with a labeled value expression\n --> lint_example.rs:3:5\n  |\n3 |     break 'label loop { break 42; };\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(break_with_label_and_loop)]` on by default\nhelp: wrap this expression in parentheses\n  |\n3 |     break 'label (loop { break 42; });\n  |                  +                  +\n\n\n```\n\n### [Explanation](#explanation-10)\n\nIn Rust, loops can have a label, and `break` expressions can refer to that label to break out of specific loops (and not necessarily the innermost one). `break` expressions can also carry a value expression, which can be another loop. A labeled `break` with an unlabeled loop as its value expression is easy to confuse with an unlabeled break with a labeled loop and is thus discouraged (but allowed for compatibility); use parentheses around the loop expression to silence this warning. Unlabeled `break` expressions with labeled loops yield a hard error, which can also be silenced by wrapping the expression in parentheses.\n\n## [byte-slice-in-packed-struct-with-derive](#byte-slice-in-packed-struct-with-derive)\n\nThe `byte_slice_in_packed_struct_with_derive` lint detects cases where a byte slice field (`[u8]`) or string slice field (`str`) is used in a `packed` struct that derives one or more built-in traits.\n\n### [Example](#example-11)\n\n```rust\n#[repr(packed)]\n#[derive(Hash)]\nstruct FlexZeroSlice {\n    width: u8,\n    data: [u8],\n}\n```\n\nThis will produce:\n\n```text\nwarning: byte slice in a packed struct that derives a built-in trait\n --> lint_example.rs:6:5\n  |\n3 | #[derive(Hash)]\n  |          ---- in this derive macro expansion\n...\n6 |     data: [u8],\n  |     ^^^^^^^^^^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #107457 <https://github.com/rust-lang/rust/issues/107457>\n  = help: consider implementing the trait by hand, or remove the `packed` attribute\n  = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n  = note: this warning originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n\n```\n\n### [Explanation](#explanation-11)\n\nThis was previously accepted but is being phased out, because fields in packed structs are now required to implement `Copy` for `derive` to work. Byte slices and string slices are a temporary exception because certain crates depended on them.\n\n## [clashing-extern-declarations](#clashing-extern-declarations)\n\nThe `clashing_extern_declarations` lint detects when an `extern fn` has been declared with the same name but different types.\n\n### [Example](#example-12)\n\n```rust\nmod m {\n    extern \"C\" {\n        fn foo();\n    }\n}\n\nextern \"C\" {\n    fn foo(_: u32);\n}\n```\n\nThis will produce:\n\n```text\nwarning: `foo` redeclared with a different signature\n --> lint_example.rs:9:5\n  |\n4 |         fn foo();\n  |         -------- `foo` previously declared here\n...\n9 |     fn foo(_: u32);\n  |     ^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n  |\n  = note: expected `unsafe extern \"C\" fn()`\n             found `unsafe extern \"C\" fn(u32)`\n  = note: `#[warn(clashing_extern_declarations)]` on by default\n\n\n```\n\n### [Explanation](#explanation-12)\n\nBecause two symbols of the same name cannot be resolved to two different functions at link time, and one function cannot possibly have two types, a clashing extern declaration is almost certainly a mistake. Check to make sure that the `extern` definitions are correct and equivalent, and possibly consider unifying them in one location.\n\nThis lint does not run between crates because a project may have dependencies which both rely on the same extern function, but declare it in a different (but valid) way. For example, they may both declare an opaque type for one or more of the arguments (which would end up distinct types), or use types that are valid conversions in the language the `extern fn` is defined in. In these cases, the compiler can't say that the clashing declaration is incorrect.\n\n## [coherence-leak-check](#coherence-leak-check)\n\nThe `coherence_leak_check` lint detects conflicting implementations of a trait that are only distinguished by the old leak-check code.\n\n### [Example](#example-13)\n\n```rust\ntrait SomeTrait { }\nimpl SomeTrait for for<'a> fn(&'a u8) { }\nimpl<'a> SomeTrait for fn(&'a u8) { }\n```\n\nThis will produce:\n\n```text\nwarning: conflicting implementations of trait `SomeTrait` for type `for<'a> fn(&'a u8)`\n --> lint_example.rs:4:1\n  |\n3 | impl SomeTrait for for<'a> fn(&'a u8) { }\n  | ------------------------------------- first implementation here\n4 | impl<'a> SomeTrait for fn(&'a u8) { }\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'a> fn(&'a u8)`\n  |\n  = warning: the behavior may change in a future release\n  = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105>\n  = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n  = note: `#[warn(coherence_leak_check)]` on by default\n\n\n```\n\n### [Explanation](#explanation-13)\n\nIn the past, the compiler would accept trait implementations for identical functions that differed only in where the lifetime binder appeared. Due to a change in the borrow checker implementation to fix several bugs, this is no longer allowed. However, since this affects existing code, this is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the future.\n\nCode relying on this pattern should introduce \"[newtypes](https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction)\", like `struct Foo(for<'a> fn(&'a u8))`.\n\nSee [issue #56105](https://github.com/rust-lang/rust/issues/56105) for more details.\n\n## [confusable-idents](#confusable-idents)\n\nThe `confusable_idents` lint detects visually confusable pairs between identifiers.\n\n### [Example](#example-14)\n\n```rust\n// Latin Capital Letter E With Caron\npub const Ě: i32 = 1;\n// Latin Capital Letter E With Breve\npub const Ĕ: i32 = 2;\n```\n\nThis will produce:\n\n```text\nwarning: found both `Ě` and `Ĕ` as identifiers, which look alike\n --> lint_example.rs:5:11\n  |\n3 | pub const Ě: i32 = 1;\n  |           - other identifier used here\n4 | // Latin Capital Letter E With Breve\n5 | pub const Ĕ: i32 = 2;\n  |           ^ this identifier can be confused with `Ě`\n  |\n  = note: `#[warn(confusable_idents)]` on by default\n\n\n```\n\n### [Explanation](#explanation-14)\n\nThis lint warns when different identifiers may appear visually similar, which can cause confusion.\n\nThe confusable detection algorithm is based on [Unicode® Technical Standard #39 Unicode Security Mechanisms Section 4 Confusable Detection](https://www.unicode.org/reports/tr39/#Confusable_Detection). For every distinct identifier X execute the function `skeleton(X)`. If there exist two distinct identifiers X and Y in the same crate where `skeleton(X) = skeleton(Y)` report it. The compiler uses the same mechanism to check if an identifier is too similar to a keyword.\n\nNote that the set of confusable characters may change over time. Beware that if you \"forbid\" this lint that existing code may fail in the future.\n\n## [const-eval-mutable-ptr-in-final-value](#const-eval-mutable-ptr-in-final-value)\n\nThe `const_eval_mutable_ptr_in_final_value` lint detects if a mutable pointer has leaked into the final value of a const expression.\n\n### [Example](#example-15)\n\n```rust\npub enum JsValue {\n    Undefined,\n    Object(std::cell::Cell<bool>),\n}\n\nimpl ::std::ops::Drop for JsValue {\n    fn drop(&mut self) {}\n}\n\nconst UNDEFINED: &JsValue = &JsValue::Undefined;\n\nfn main() {\n}\n```\n\nThis will produce:\n\n```text\nwarning: encountered mutable pointer in final value of constant\n  --> lint_example.rs:10:1\n   |\n10 | const UNDEFINED: &JsValue = &JsValue::Undefined;\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #122153 <https://github.com/rust-lang/rust/issues/122153>\n   = note: `#[warn(const_eval_mutable_ptr_in_final_value)]` on by default\n\n\n```\n\n### [Explanation](#explanation-15)\n\nIn the 1.77 release, the const evaluation machinery adopted some stricter rules to reject expressions with values that could end up holding mutable references to state stored in static memory (which is inherently immutable).\n\nThis is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to ease the transition to an error. See [issue #122153](https://github.com/rust-lang/rust/issues/122153) for more details.\n\n## [const-evaluatable-unchecked](#const-evaluatable-unchecked)\n\nThe `const_evaluatable_unchecked` lint detects a generic constant used in a type.\n\n### [Example](#example-16)\n\n```rust\nconst fn foo<T>() -> usize {\n    if std::mem::size_of::<*mut T>() < 8 { // size of *mut T does not depend on T\n        4\n    } else {\n        8\n    }\n}\n\nfn test<T>() {\n    let _ = [0; foo::<T>()];\n}\n```\n\nThis will produce:\n\n```text\nwarning: cannot use constants which depend on generic parameters in types\n  --> lint_example.rs:11:17\n   |\n11 |     let _ = [0; foo::<T>()];\n   |                 ^^^^^^^^^^\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n   = note: `#[warn(const_evaluatable_unchecked)]` on by default\n\n\n```\n\n### [Explanation](#explanation-16)\n\nIn the 1.43 release, some uses of generic parameters in array repeat expressions were accidentally allowed. This is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the future. See [issue #76200](https://github.com/rust-lang/rust/issues/76200) for a more detailed description and possible fixes.\n\n## [const-item-mutation](#const-item-mutation)\n\nThe `const_item_mutation` lint detects attempts to mutate a `const` item.\n\n### [Example](#example-17)\n\n```rust\nconst FOO: [i32; 1] = [0];\n\nfn main() {\n    FOO[0] = 1;\n    // This will print \"[0]\".\n    println!(\"{:?}\", FOO);\n}\n```\n\nThis will produce:\n\n```text\nwarning: attempting to modify a `const` item\n --> lint_example.rs:4:5\n  |\n4 |     FOO[0] = 1;\n  |     ^^^^^^^^^^\n  |\n  = note: each usage of a `const` item creates a new temporary; the original `const` item will not be modified\nnote: `const` item defined here\n --> lint_example.rs:1:1\n  |\n1 | const FOO: [i32; 1] = [0];\n  | ^^^^^^^^^^^^^^^^^^^\n  = note: `#[warn(const_item_mutation)]` on by default\n\n\n```\n\n### [Explanation](#explanation-17)\n\nTrying to directly mutate a `const` item is almost always a mistake. What is happening in the example above is that a temporary copy of the `const` is mutated, but the original `const` is not. Each time you refer to the `const` by name (such as `FOO` in the example above), a separate copy of the value is inlined at that location.\n\nThis lint checks for writing directly to a field (`FOO.field = some_value`) or array entry (`FOO[0] = val`), or taking a mutable reference to the const item (`&mut FOO`), including through an autoderef (`FOO.some_mut_self_method()`).\n\nThere are various alternatives depending on what you are trying to accomplish:\n\n-   First, always reconsider using mutable globals, as they can be difficult to use correctly, and can make the code more difficult to use or understand.\n-   If you are trying to perform a one-time initialization of a global:\n    -   If the value can be computed at compile-time, consider using const-compatible values (see [Constant Evaluation](https://doc.rust-lang.org/reference/const_eval.html)).\n    -   For more complex single-initialization cases, consider using [`std::sync::LazyLock`](https://doc.rust-lang.org/stable/std/sync/struct.LazyLock.html).\n-   If you truly need a mutable global, consider using a [`static`](https://doc.rust-lang.org/reference/items/static-items.html), which has a variety of options:\n    -   Simple data types can be directly defined and mutated with an [`atomic`](https://doc.rust-lang.org/std/sync/atomic/index.html) type.\n    -   More complex types can be placed in a synchronization primitive like a [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html), which can be initialized with one of the options listed above.\n    -   A [mutable `static`](https://doc.rust-lang.org/reference/items/static-items.html#mutable-statics) is a low-level primitive, requiring unsafe. Typically This should be avoided in preference of something higher-level like one of the above.\n\n## [dead-code](#dead-code)\n\nThe `dead_code` lint detects unused, unexported items.\n\n### [Example](#example-18)\n\n```rust\nfn foo() {}\n```\n\nThis will produce:\n\n```text\nwarning: function `foo` is never used\n --> lint_example.rs:2:4\n  |\n2 | fn foo() {}\n  |    ^^^\n  |\n  = note: `#[warn(dead_code)]` on by default\n\n\n```\n\n### [Explanation](#explanation-18)\n\nDead code may signal a mistake or unfinished code. To silence the warning for individual items, prefix the name with an underscore such as `_foo`. If it was intended to expose the item outside of the crate, consider adding a visibility modifier like `pub`.\n\nTo preserve the numbering of tuple structs with unused fields, change the unused fields to have unit type or use `PhantomData`.\n\nOtherwise consider removing the unused code.\n\n### [Limitations](#limitations)\n\nRemoving fields that are only used for side-effects and never read will result in behavioral changes. Examples of this include:\n\n-   If a field's value performs an action when it is dropped.\n-   If a field's type does not implement an auto trait (e.g. `Send`, `Sync`, `Unpin`).\n\nFor side-effects from dropping field values, this lint should be allowed on those fields. For side-effects from containing field types, `PhantomData` should be used.\n\n## [deprecated](#deprecated)\n\nThe `deprecated` lint detects use of deprecated items.\n\n### [Example](#example-19)\n\n```rust\n#[deprecated]\nfn foo() {}\n\nfn bar() {\n    foo();\n}\n```\n\nThis will produce:\n\n```text\nwarning: use of deprecated function `main::foo`\n --> lint_example.rs:6:5\n  |\n6 |     foo();\n  |     ^^^\n  |\n  = note: `#[warn(deprecated)]` on by default\n\n\n```\n\n### [Explanation](#explanation-19)\n\nItems may be marked \"deprecated\" with the [`deprecated` attribute](https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute) to indicate that they should no longer be used. Usually the attribute should include a note on what to use instead, or check the documentation.\n\n## [deprecated-where-clause-location](#deprecated-where-clause-location)\n\nThe `deprecated_where_clause_location` lint detects when a where clause in front of the equals in an associated type.\n\n### [Example](#example-20)\n\n```rust\ntrait Trait {\n  type Assoc<'a> where Self: 'a;\n}\n\nimpl Trait for () {\n  type Assoc<'a> where Self: 'a = ();\n}\n```\n\nThis will produce:\n\n```text\nwarning: where clause not allowed here\n --> lint_example.rs:7:18\n  |\n7 |   type Assoc<'a> where Self: 'a = ();\n  |                  ^^^^^^^^^^^^^^\n  |\n  = note: see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\n  = note: `#[warn(deprecated_where_clause_location)]` on by default\nhelp: move it to the end of the type declaration\n  |\n7 -   type Assoc<'a> where Self: 'a = ();\n7 +   type Assoc<'a>  = () where Self: 'a;\n  |\n\n\n```\n\n### [Explanation](#explanation-20)\n\nThe preferred location for where clauses on associated types is after the type. However, for most of generic associated types development, it was only accepted before the equals. To provide a transition period and further evaluate this change, both are currently accepted. At some point in the future, this may be disallowed at an edition boundary; but, that is undecided currently.\n\n## [deref-into-dyn-supertrait](#deref-into-dyn-supertrait)\n\nThe `deref_into_dyn_supertrait` lint is output whenever there is a use of the `Deref` implementation with a `dyn SuperTrait` type as `Output`.\n\nThese implementations will become shadowed when the `trait_upcasting` feature is stabilized. The `deref` functions will no longer be called implicitly, so there might be behavior change.\n\n### [Example](#example-21)\n\n```rust\n#![deny(deref_into_dyn_supertrait)]\n#![allow(dead_code)]\n\nuse core::ops::Deref;\n\ntrait A {}\ntrait B: A {}\nimpl<'a> Deref for dyn 'a + B {\n    type Target = dyn A;\n    fn deref(&self) -> &Self::Target {\n        todo!()\n    }\n}\n\nfn take_a(_: &dyn A) { }\n\nfn take_b(b: &dyn B) {\n    take_a(b);\n}\n```\n\nThis will produce:\n\n```text\nerror: this `Deref` implementation is covered by an implicit supertrait coercion\n  --> lint_example.rs:9:1\n   |\n9  | impl<'a> Deref for dyn 'a + B {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `dyn B` implements `Deref<Target = dyn A>` which conflicts with supertrait `A`\n10 |     type Target = dyn A;\n   |     -------------------- target type is a supertrait of `dyn B`\n   |\n   = warning: this will change its meaning in a future release!\n   = note: for more information, see issue #89460 <https://github.com/rust-lang/rust/issues/89460>\nnote: the lint level is defined here\n  --> lint_example.rs:1:9\n   |\n1  | #![deny(deref_into_dyn_supertrait)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-21)\n\nThe dyn upcasting coercion feature adds new coercion rules, taking priority over certain other coercion rules, which will cause some behavior change.\n\n## [deref-nullptr](#deref-nullptr)\n\nThe `deref_nullptr` lint detects when an null pointer is dereferenced, which causes [undefined behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html).\n\n### [Example](#example-22)\n\n```rust\n#![allow(unused)]\nuse std::ptr;\nunsafe {\n    let x = &*ptr::null::<i32>();\n    let x = ptr::addr_of!(*ptr::null::<i32>());\n    let x = *(0 as *const i32);\n}\n```\n\nThis will produce:\n\n```text\nwarning: dereferencing a null pointer\n --> lint_example.rs:5:14\n  |\n5 |     let x = &*ptr::null::<i32>();\n  |              ^^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed\n  |\n  = note: `#[warn(deref_nullptr)]` on by default\n\n\nwarning: dereferencing a null pointer\n --> lint_example.rs:6:27\n  |\n6 |     let x = ptr::addr_of!(*ptr::null::<i32>());\n  |                           ^^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed\n\n\nwarning: dereferencing a null pointer\n --> lint_example.rs:7:13\n  |\n7 |     let x = *(0 as *const i32);\n  |             ^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed\n\n\n```\n\n### [Explanation](#explanation-22)\n\nDereferencing a null pointer causes [undefined behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html) even as a place expression, like `&*(0 as *const i32)` or `addr_of!(*(0 as *const i32))`.\n\n## [drop-bounds](#drop-bounds)\n\nThe `drop_bounds` lint checks for generics with `std::ops::Drop` as bounds.\n\n### [Example](#example-23)\n\n```rust\nfn foo<T: Drop>() {}\n```\n\nThis will produce:\n\n```text\nwarning: bounds on `T: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped\n --> lint_example.rs:2:11\n  |\n2 | fn foo<T: Drop>() {}\n  |           ^^^^\n  |\n  = note: `#[warn(drop_bounds)]` on by default\n\n\n```\n\n### [Explanation](#explanation-23)\n\nA generic trait bound of the form `T: Drop` is most likely misleading and not what the programmer intended (they probably should have used `std::mem::needs_drop` instead).\n\n`Drop` bounds do not actually indicate whether a type can be trivially dropped or not, because a composite type containing `Drop` types does not necessarily implement `Drop` itself. Naïvely, one might be tempted to write an implementation that assumes that a type can be trivially dropped while also supplying a specialization for `T: Drop` that actually calls the destructor. However, this breaks down e.g. when `T` is `String`, which does not implement `Drop` itself but contains a `Vec`, which does implement `Drop`, so assuming `T` can be trivially dropped would lead to a memory leak here.\n\nFurthermore, the `Drop` trait only contains one method, `Drop::drop`, which may not be called explicitly in user code (`E0040`), so there is really no use case for using `Drop` in trait bounds, save perhaps for some obscure corner cases, which can use `#[allow(drop_bounds)]`.\n\n## [dropping-copy-types](#dropping-copy-types)\n\nThe `dropping_copy_types` lint checks for calls to `std::mem::drop` with a value that derives the Copy trait.\n\n### [Example](#example-24)\n\n```rust\nlet x: i32 = 42; // i32 implements Copy\nstd::mem::drop(x); // A copy of x is passed to the function, leaving the\n                   // original unaffected\n```\n\nThis will produce:\n\n```text\nwarning: calls to `std::mem::drop` with a value that implements `Copy` does nothing\n --> lint_example.rs:3:1\n  |\n3 | std::mem::drop(x); // A copy of x is passed to the function, leaving the\n  | ^^^^^^^^^^^^^^^-^\n  |                |\n  |                argument has type `i32`\n  |\n  = note: `#[warn(dropping_copy_types)]` on by default\nhelp: use `let _ = ...` to ignore the expression or result\n  |\n3 - std::mem::drop(x); // A copy of x is passed to the function, leaving the\n3 + let _ = x; // A copy of x is passed to the function, leaving the\n  |\n\n\n```\n\n### [Explanation](#explanation-24)\n\nCalling `std::mem::drop` [does nothing for types that implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the value will be copied and moved into the function on invocation.\n\n## [dropping-references](#dropping-references)\n\nThe `dropping_references` lint checks for calls to `std::mem::drop` with a reference instead of an owned value.\n\n### [Example](#example-25)\n\n```rust\nfn operation_that_requires_mutex_to_be_unlocked() {} // just to make it compile\nlet mutex = std::sync::Mutex::new(1); // just to make it compile\nlet mut lock_guard = mutex.lock();\nstd::mem::drop(&lock_guard); // Should have been drop(lock_guard), mutex\n// still locked\noperation_that_requires_mutex_to_be_unlocked();\n```\n\nThis will produce:\n\n```text\nwarning: calls to `std::mem::drop` with a reference instead of an owned value does nothing\n --> lint_example.rs:5:1\n  |\n5 | std::mem::drop(&lock_guard); // Should have been drop(lock_guard), mutex\n  | ^^^^^^^^^^^^^^^-----------^\n  |                |\n  |                argument has type `&Result<MutexGuard<'_, i32>, PoisonError<MutexGuard<'_, i32>>>`\n  |\n  = note: `#[warn(dropping_references)]` on by default\nhelp: use `let _ = ...` to ignore the expression or result\n  |\n5 - std::mem::drop(&lock_guard); // Should have been drop(lock_guard), mutex\n5 + let _ = &lock_guard; // Should have been drop(lock_guard), mutex\n  |\n\n\n```\n\n### [Explanation](#explanation-25)\n\nCalling `drop` on a reference will only drop the reference itself, which is a no-op. It will not call the `drop` method (from the `Drop` trait implementation) on the underlying referenced value, which is likely what was intended.\n\n## [duplicate-macro-attributes](#duplicate-macro-attributes)\n\nThe `duplicate_macro_attributes` lint detects when a `#[test]`\\-like built-in macro attribute is duplicated on an item. This lint may trigger on `bench`, `cfg_eval`, `test` and `test_case`.\n\n### [Example](#example-26)\n\n```rust\n#[test]\n#[test]\nfn foo() {}\n```\n\nThis will produce:\n\n```text\nwarning: duplicated attribute\n --> src/lib.rs:2:1\n  |\n2 | #[test]\n  | ^^^^^^^\n  |\n  = note: `#[warn(duplicate_macro_attributes)]` on by default\n\n```\n\n### [Explanation](#explanation-26)\n\nA duplicated attribute may erroneously originate from a copy-paste and the effect of it being duplicated may not be obvious or desirable.\n\nFor instance, doubling the `#[test]` attributes registers the test to be run twice with no change to its environment.\n\n## [dyn-drop](#dyn-drop)\n\nThe `dyn_drop` lint checks for trait objects with `std::ops::Drop`.\n\n### [Example](#example-27)\n\n```rust\nfn foo(_x: Box<dyn Drop>) {}\n```\n\nThis will produce:\n\n```text\nwarning: types that do not implement `Drop` can still have drop glue, consider instead using `std::mem::needs_drop` to detect whether a type is trivially dropped\n --> lint_example.rs:2:20\n  |\n2 | fn foo(_x: Box<dyn Drop>) {}\n  |                    ^^^^\n  |\n  = note: `#[warn(dyn_drop)]` on by default\n\n\n```\n\n### [Explanation](#explanation-27)\n\nA trait object bound of the form `dyn Drop` is most likely misleading and not what the programmer intended.\n\n`Drop` bounds do not actually indicate whether a type can be trivially dropped or not, because a composite type containing `Drop` types does not necessarily implement `Drop` itself. Naïvely, one might be tempted to write a deferred drop system, to pull cleaning up memory out of a latency-sensitive code path, using `dyn Drop` trait objects. However, this breaks down e.g. when `T` is `String`, which does not implement `Drop`, but should probably be accepted.\n\nTo write a trait object bound that accepts anything, use a placeholder trait with a blanket implementation.\n\n```rust\ntrait Placeholder {}\nimpl<T> Placeholder for T {}\nfn foo(_x: Box<dyn Placeholder>) {}\n```\n\n## [elided-lifetimes-in-associated-constant](#elided-lifetimes-in-associated-constant)\n\nThe `elided_lifetimes_in_associated_constant` lint detects elided lifetimes that were erroneously allowed in associated constants.\n\n### [Example](#example-28)\n\n```rust\n#![deny(elided_lifetimes_in_associated_constant)]\n\nstruct Foo;\n\nimpl Foo {\n    const STR: &str = \"hello, world\";\n}\n```\n\nThis will produce:\n\n```text\nerror: `&` without an explicit lifetime name cannot be used here\n --> lint_example.rs:7:16\n  |\n7 |     const STR: &str = \"hello, world\";\n  |                ^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #115010 <https://github.com/rust-lang/rust/issues/115010>\nnote: the lint level is defined here\n --> lint_example.rs:1:9\n  |\n1 | #![deny(elided_lifetimes_in_associated_constant)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: use the `'static` lifetime\n  |\n7 |     const STR: &'static str = \"hello, world\";\n  |                 +++++++\n\n\n```\n\n### [Explanation](#explanation-28)\n\nPrevious version of Rust\n\nImplicit static-in-const behavior was decided [against](https://github.com/rust-lang/rust/issues/38831) for associated constants because of ambiguity. This, however, regressed and the compiler erroneously treats elided lifetimes in associated constants as lifetime parameters on the impl.\n\nThis is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the future.\n\n## [ellipsis-inclusive-range-patterns](#ellipsis-inclusive-range-patterns)\n\nThe `ellipsis_inclusive_range_patterns` lint detects the [`...` range pattern](https://doc.rust-lang.org/reference/patterns.html#range-patterns), which is deprecated.\n\n### [Example](#example-29)\n\n```rust\nlet x = 123;\nmatch x {\n    0...100 => {}\n    _ => {}\n}\n```\n\nThis will produce:\n\n```text\nwarning: `...` range patterns are deprecated\n --> lint_example.rs:4:6\n  |\n4 |     0...100 => {}\n  |      ^^^ help: use `..=` for an inclusive range\n  |\n  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n  = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n  = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\n\n```\n\n### [Explanation](#explanation-29)\n\nThe `...` range pattern syntax was changed to `..=` to avoid potential confusion with the [`..` range expression](https://doc.rust-lang.org/reference/expressions/range-expr.html). Use the new form instead.\n\n## [exported-private-dependencies](#exported-private-dependencies)\n\nThe `exported_private_dependencies` lint detects private dependencies that are exposed in a public interface.\n\n### [Example](#example-30)\n\n```rust\npub fn foo() -> Option<some_private_dependency::Thing> {\n    None\n}\n```\n\nThis will produce:\n\n```text\nwarning: type `bar::Thing` from private dependency 'bar' in public interface\n --> src/lib.rs:3:1\n  |\n3 | pub fn foo() -> Option<bar::Thing> {\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(exported_private_dependencies)]` on by default\n\n```\n\n### [Explanation](#explanation-30)\n\nDependencies can be marked as \"private\" to indicate that they are not exposed in the public interface of a crate. This can be used by Cargo to independently resolve those dependencies because it can assume it does not need to unify them with other packages using that same dependency. This lint is an indication of a violation of that contract.\n\nTo fix this, avoid exposing the dependency in your public interface. Or, switch the dependency to a public dependency.\n\nNote that support for this is only available on the nightly channel. See [RFC 1977](https://github.com/rust-lang/rfcs/blob/master/text/1977-public-private-dependencies.md) for more details, as well as the [Cargo documentation](https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#public-dependency).\n\n## [for-loops-over-fallibles](#for-loops-over-fallibles)\n\nThe `for_loops_over_fallibles` lint checks for `for` loops over `Option` or `Result` values.\n\n### [Example](#example-31)\n\n```rust\nlet opt = Some(1);\nfor x in opt { /* ... */}\n```\n\nThis will produce:\n\n```text\nwarning: for loop over an `Option`. This is more readably written as an `if let` statement\n --> lint_example.rs:3:10\n  |\n3 | for x in opt { /* ... */}\n  |          ^^^\n  |\n  = note: `#[warn(for_loops_over_fallibles)]` on by default\nhelp: to check pattern in a loop use `while let`\n  |\n3 | while let Some(x) = opt { /* ... */}\n  | ~~~~~~~~~~~~~~~ ~~~\nhelp: consider using `if let` to clear intent\n  |\n3 | if let Some(x) = opt { /* ... */}\n  | ~~~~~~~~~~~~ ~~~\n\n\n```\n\n### [Explanation](#explanation-31)\n\nBoth `Option` and `Result` implement `IntoIterator` trait, which allows using them in a `for` loop. `for` loop over `Option` or `Result` will iterate either 0 (if the value is `None`/`Err(_)`) or 1 time (if the value is `Some(_)`/`Ok(_)`). This is not very useful and is more clearly expressed via `if let`.\n\n`for` loop can also be accidentally written with the intention to call a function multiple times, while the function returns `Some(_)`, in these cases `while let` loop should be used instead.\n\nThe \"intended\" use of `IntoIterator` implementations for `Option` and `Result` is passing them to generic code that expects something implementing `IntoIterator`. For example using `.chain(option)` to optionally add a value to an iterator.\n\n## [forbidden-lint-groups](#forbidden-lint-groups)\n\nThe `forbidden_lint_groups` lint detects violations of `forbid` applied to a lint group. Due to a bug in the compiler, these used to be overlooked entirely. They now generate a warning.\n\n### [Example](#example-32)\n\n```rust\n#![forbid(warnings)]\n#![deny(bad_style)]\n\nfn main() {}\n```\n\nThis will produce:\n\n```text\nwarning: deny(bad_style) incompatible with previous forbid\n --> lint_example.rs:2:9\n  |\n1 | #![forbid(warnings)]\n  |           -------- `forbid` level set here\n2 | #![deny(bad_style)]\n  |         ^^^^^^^^^ overruled by previous forbid\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #81670 <https://github.com/rust-lang/rust/issues/81670>\n  = note: `#[warn(forbidden_lint_groups)]` on by default\n\n\n```\n\n### [Recommended fix](#recommended-fix)\n\nIf your crate is using `#![forbid(warnings)]`, we recommend that you change to `#![deny(warnings)]`.\n\n### [Explanation](#explanation-32)\n\nDue to a compiler bug, applying `forbid` to lint groups previously had no effect. The bug is now fixed but instead of enforcing `forbid` we issue this future-compatibility warning to avoid breaking existing crates.\n\n## [forgetting-copy-types](#forgetting-copy-types)\n\nThe `forgetting_copy_types` lint checks for calls to `std::mem::forget` with a value that derives the Copy trait.\n\n### [Example](#example-33)\n\n```rust\nlet x: i32 = 42; // i32 implements Copy\nstd::mem::forget(x); // A copy of x is passed to the function, leaving the\n                     // original unaffected\n```\n\nThis will produce:\n\n```text\nwarning: calls to `std::mem::forget` with a value that implements `Copy` does nothing\n --> lint_example.rs:3:1\n  |\n3 | std::mem::forget(x); // A copy of x is passed to the function, leaving the\n  | ^^^^^^^^^^^^^^^^^-^\n  |                  |\n  |                  argument has type `i32`\n  |\n  = note: `#[warn(forgetting_copy_types)]` on by default\nhelp: use `let _ = ...` to ignore the expression or result\n  |\n3 - std::mem::forget(x); // A copy of x is passed to the function, leaving the\n3 + let _ = x; // A copy of x is passed to the function, leaving the\n  |\n\n\n```\n\n### [Explanation](#explanation-33)\n\nCalling `std::mem::forget` [does nothing for types that implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the value will be copied and moved into the function on invocation.\n\nAn alternative, but also valid, explanation is that Copy types do not implement the Drop trait, which means they have no destructors. Without a destructor, there is nothing for `std::mem::forget` to ignore.\n\n## [forgetting-references](#forgetting-references)\n\nThe `forgetting_references` lint checks for calls to `std::mem::forget` with a reference instead of an owned value.\n\n### [Example](#example-34)\n\n```rust\nlet x = Box::new(1);\nstd::mem::forget(&x); // Should have been forget(x), x will still be dropped\n```\n\nThis will produce:\n\n```text\nwarning: calls to `std::mem::forget` with a reference instead of an owned value does nothing\n --> lint_example.rs:3:1\n  |\n3 | std::mem::forget(&x); // Should have been forget(x), x will still be dropped\n  | ^^^^^^^^^^^^^^^^^--^\n  |                  |\n  |                  argument has type `&Box<i32>`\n  |\n  = note: `#[warn(forgetting_references)]` on by default\nhelp: use `let _ = ...` to ignore the expression or result\n  |\n3 - std::mem::forget(&x); // Should have been forget(x), x will still be dropped\n3 + let _ = &x; // Should have been forget(x), x will still be dropped\n  |\n\n\n```\n\n### [Explanation](#explanation-34)\n\nCalling `forget` on a reference will only forget the reference itself, which is a no-op. It will not forget the underlying referenced value, which is likely what was intended.\n\n## [function-item-references](#function-item-references)\n\nThe `function_item_references` lint detects function references that are formatted with [`fmt::Pointer`](https://doc.rust-lang.org/std/fmt/trait.Pointer.html) or transmuted.\n\n### [Example](#example-35)\n\n```rust\nfn foo() { }\n\nfn main() {\n    println!(\"{:p}\", &foo);\n}\n```\n\nThis will produce:\n\n```text\nwarning: taking a reference to a function item does not give a function pointer\n --> lint_example.rs:4:22\n  |\n4 |     println!(\"{:p}\", &foo);\n  |                      ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn()`\n  |\n  = note: `#[warn(function_item_references)]` on by default\n\n\n```\n\n### [Explanation](#explanation-35)\n\nTaking a reference to a function may be mistaken as a way to obtain a pointer to that function. This can give unexpected results when formatting the reference as a pointer or transmuting it. This lint is issued when function references are formatted as pointers, passed as arguments bound by [`fmt::Pointer`](https://doc.rust-lang.org/std/fmt/trait.Pointer.html) or transmuted.\n\nThe `hidden_glob_reexports` lint detects cases where glob re-export items are shadowed by private items.\n\n### [Example](#example-36)\n\n```rust\n#![deny(hidden_glob_reexports)]\n\npub mod upstream {\n    mod inner { pub struct Foo {}; pub struct Bar {}; }\n    pub use self::inner::*;\n    struct Foo {} // private item shadows `inner::Foo`\n}\n\n// mod downstream {\n//     fn test() {\n//         let _ = crate::upstream::Foo; // inaccessible\n//     }\n// }\n\npub fn main() {}\n```\n\nThis will produce:\n\n```text\nerror: private item shadows public glob re-export\n --> lint_example.rs:6:5\n  |\n6 |     struct Foo {} // private item shadows `inner::Foo`\n  |     ^^^^^^^^^^^^^\n  |\nnote: the name `Foo` in the type namespace is supposed to be publicly re-exported here\n --> lint_example.rs:5:13\n  |\n5 |     pub use self::inner::*;\n  |             ^^^^^^^^^^^^^^\nnote: but the private item here shadows it\n --> lint_example.rs:6:5\n  |\n6 |     struct Foo {} // private item shadows `inner::Foo`\n  |     ^^^^^^^^^^^^^\nnote: the lint level is defined here\n --> lint_example.rs:1:9\n  |\n1 | #![deny(hidden_glob_reexports)]\n  |         ^^^^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-36)\n\nThis was previously accepted without any errors or warnings but it could silently break a crate's downstream user code. If the `struct Foo` was added, `dep::inner::Foo` would silently become inaccessible and trigger a \"`struct` Foo `is private`\" visibility error at the downstream use site.\n\n## [impl-trait-redundant-captures](#impl-trait-redundant-captures)\n\nThe `impl_trait_redundant_captures` lint warns against cases where use of the precise capturing `use<...>` syntax is not needed.\n\nIn the 2024 edition, `impl Trait`s will capture all lifetimes in scope. If precise-capturing `use<...>` syntax is used, and the set of parameters that are captures are _equal_ to the set of parameters in scope, then the syntax is redundant, and can be removed.\n\n### [Example](#example-37)\n\n```rust\n#![feature(precise_capturing, lifetime_capture_rules_2024)]\n#![allow(incomplete_features)]\n#![deny(impl_trait_redundant_captures)]\nfn test<'a>(x: &'a i32) -> impl use<'a> Sized { x }\n```\n\nThis will produce:\n\n```text\nerror: all possible in-scope parameters are already captured, so `use<...>` syntax is redundant\n --> lint_example.rs:5:28\n  |\n5 | fn test<'a>(x: &'a i32) -> impl use<'a> Sized { x }\n  |                            ^^^^^-------^^^^^^\n  |                                 |\n  |                                 help: remove the `use<...>` syntax\n  |\nnote: the lint level is defined here\n --> lint_example.rs:3:9\n  |\n3 | #![deny(impl_trait_redundant_captures)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-37)\n\nTo fix this, remove the `use<'a>`, since the lifetime is already captured since it is in scope.\n\n## [improper-ctypes](#improper-ctypes)\n\nThe `improper_ctypes` lint detects incorrect use of types in foreign modules.\n\n### [Example](#example-38)\n\n```rust\nextern \"C\" {\n    static STATIC: String;\n}\n```\n\nThis will produce:\n\n```text\nwarning: `extern` block uses type `String`, which is not FFI-safe\n --> lint_example.rs:3:20\n  |\n3 |     static STATIC: String;\n  |                    ^^^^^^ not FFI-safe\n  |\n  = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n  = note: this struct has unspecified layout\n  = note: `#[warn(improper_ctypes)]` on by default\n\n\n```\n\n### [Explanation](#explanation-38)\n\nThe compiler has several checks to verify that types used in `extern` blocks are safe and follow certain rules to ensure proper compatibility with the foreign interfaces. This lint is issued when it detects a probable mistake in a definition. The lint usually should provide a description of the issue, along with possibly a hint on how to resolve it.\n\n## [improper-ctypes-definitions](#improper-ctypes-definitions)\n\nThe `improper_ctypes_definitions` lint detects incorrect use of [`extern` function](https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier) definitions.\n\n### [Example](#example-39)\n\n```rust\n#![allow(unused)]\npub extern \"C\" fn str_type(p: &str) { }\n```\n\nThis will produce:\n\n```text\nwarning: `extern` fn uses type `str`, which is not FFI-safe\n --> lint_example.rs:3:31\n  |\n3 | pub extern \"C\" fn str_type(p: &str) { }\n  |                               ^^^^ not FFI-safe\n  |\n  = help: consider using `*const u8` and a length instead\n  = note: string slices have no C equivalent\n  = note: `#[warn(improper_ctypes_definitions)]` on by default\n\n\n```\n\n### [Explanation](#explanation-39)\n\nThere are many parameter and return types that may be specified in an `extern` function that are not compatible with the given ABI. This lint is an alert that these types should not be used. The lint usually should provide a description of the issue, along with possibly a hint on how to resolve it.\n\n## [incomplete-features](#incomplete-features)\n\nThe `incomplete_features` lint detects unstable features enabled with the [`feature` attribute](https://doc.rust-lang.org/nightly/unstable-book/) that may function improperly in some or all cases.\n\n### [Example](#example-40)\n\n```rust\n#![feature(generic_const_exprs)]\n```\n\nThis will produce:\n\n```text\nwarning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes\n --> lint_example.rs:1:12\n  |\n1 | #![feature(generic_const_exprs)]\n  |            ^^^^^^^^^^^^^^^^^^^\n  |\n  = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n  = note: `#[warn(incomplete_features)]` on by default\n\n\n```\n\n### [Explanation](#explanation-40)\n\nAlthough it is encouraged for people to experiment with unstable features, some of them are known to be incomplete or faulty. This lint is a signal that the feature has not yet been finished, and you may experience problems with it.\n\n## [inline-no-sanitize](#inline-no-sanitize)\n\nThe `inline_no_sanitize` lint detects incompatible use of [`#[inline(always)]`](https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute) and [`#[no_sanitize(...)]`](https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html).\n\n### [Example](#example-41)\n\n```rust\n#![feature(no_sanitize)]\n\n#[inline(always)]\n#[no_sanitize(address)]\nfn x() {}\n\nfn main() {\n    x()\n}\n```\n\nThis will produce:\n\n```text\nwarning: `no_sanitize` will have no effect after inlining\n --> lint_example.rs:4:1\n  |\n4 | #[no_sanitize(address)]\n  | ^^^^^^^^^^^^^^^^^^^^^^^\n  |\nnote: inlining requested here\n --> lint_example.rs:3:1\n  |\n3 | #[inline(always)]\n  | ^^^^^^^^^^^^^^^^^\n  = note: `#[warn(inline_no_sanitize)]` on by default\n\n\n```\n\n### [Explanation](#explanation-41)\n\nThe use of the [`#[inline(always)]`](https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute) attribute prevents the the [`#[no_sanitize(...)]`](https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html) attribute from working. Consider temporarily removing `inline` attribute.\n\n## [internal-features](#internal-features)\n\nThe `internal_features` lint detects unstable features enabled with the [`feature` attribute](https://doc.rust-lang.org/nightly/unstable-book/) that are internal to the compiler or standard library.\n\n### [Example](#example-42)\n\n```rust\n#![feature(rustc_attrs)]\n```\n\nThis will produce:\n\n```text\nwarning: the feature `rustc_attrs` is internal to the compiler or standard library\n --> lint_example.rs:1:12\n  |\n1 | #![feature(rustc_attrs)]\n  |            ^^^^^^^^^^^\n  |\n  = note: using it is strongly discouraged\n  = note: `#[warn(internal_features)]` on by default\n\n\n```\n\n### [Explanation](#explanation-42)\n\nThese features are an implementation detail of the compiler and standard library and are not supposed to be used in user code.\n\n## [invalid-from-utf8](#invalid-from-utf8)\n\nThe `invalid_from_utf8` lint checks for calls to `std::str::from_utf8` and `std::str::from_utf8_mut` with a known invalid UTF-8 value.\n\n### [Example](#example-43)\n\n```rust\n#[allow(unused)]\nstd::str::from_utf8(b\"Ru\\x82st\");\n```\n\nThis will produce:\n\n```text\nwarning: calls to `std::str::from_utf8` with a invalid literal always return an error\n --> lint_example.rs:3:1\n  |\n3 | std::str::from_utf8(b\"Ru\\x82st\");\n  | ^^^^^^^^^^^^^^^^^^^^-----------^\n  |                     |\n  |                     the literal was valid UTF-8 up to the 2 bytes\n  |\n  = note: `#[warn(invalid_from_utf8)]` on by default\n\n\n```\n\n### [Explanation](#explanation-43)\n\nTrying to create such a `str` would always return an error as per documentation for `std::str::from_utf8` and `std::str::from_utf8_mut`.\n\n## [invalid-macro-export-arguments](#invalid-macro-export-arguments)\n\nThe `invalid_macro_export_arguments` lint detects cases where `#[macro_export]` is being used with invalid arguments.\n\n### [Example](#example-44)\n\n```rust\n#![deny(invalid_macro_export_arguments)]\n\n#[macro_export(invalid_parameter)]\nmacro_rules! myMacro {\n   () => {\n        // [...]\n   }\n}\n\n#[macro_export(too, many, items)]\n```\n\nThis will produce:\n\n```text\nerror: `invalid_parameter` isn't a valid `#[macro_export]` argument\n --> lint_example.rs:4:16\n  |\n4 | #[macro_export(invalid_parameter)]\n  |                ^^^^^^^^^^^^^^^^^\n  |\nnote: the lint level is defined here\n --> lint_example.rs:1:9\n  |\n1 | #![deny(invalid_macro_export_arguments)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-44)\n\nThe only valid argument is `#[macro_export(local_inner_macros)]` or no argument (`#[macro_export]`). You can't have multiple arguments in a `#[macro_export(..)]`, or mention arguments other than `local_inner_macros`.\n\n## [invalid-nan-comparisons](#invalid-nan-comparisons)\n\nThe `invalid_nan_comparisons` lint checks comparison with `f32::NAN` or `f64::NAN` as one of the operand.\n\n### [Example](#example-45)\n\n```rust\nlet a = 2.3f32;\nif a == f32::NAN {}\n```\n\nThis will produce:\n\n```text\nwarning: incorrect NaN comparison, NaN cannot be directly compared to itself\n --> lint_example.rs:3:4\n  |\n3 | if a == f32::NAN {}\n  |    ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(invalid_nan_comparisons)]` on by default\nhelp: use `f32::is_nan()` or `f64::is_nan()` instead\n  |\n3 - if a == f32::NAN {}\n3 + if a.is_nan() {}\n  |\n\n\n```\n\n### [Explanation](#explanation-45)\n\nNaN does not compare meaningfully to anything – not even itself – so those comparisons are always false.\n\n## [invalid-value](#invalid-value)\n\nThe `invalid_value` lint detects creating a value that is not valid, such as a null reference.\n\n### [Example](#example-46)\n\n```rust\n#![allow(unused)]\nunsafe {\n    let x: &'static i32 = std::mem::zeroed();\n}\n```\n\nThis will produce:\n\n```text\nwarning: the type `&i32` does not permit zero-initialization\n --> lint_example.rs:4:27\n  |\n4 |     let x: &'static i32 = std::mem::zeroed();\n  |                           ^^^^^^^^^^^^^^^^^^\n  |                           |\n  |                           this code causes undefined behavior when executed\n  |                           help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n  |\n  = note: references must be non-null\n  = note: `#[warn(invalid_value)]` on by default\n\n\n```\n\n### [Explanation](#explanation-46)\n\nIn some situations the compiler can detect that the code is creating an invalid value, which should be avoided.\n\nIn particular, this lint will check for improper use of [`mem::zeroed`](https://doc.rust-lang.org/std/mem/fn.zeroed.html), [`mem::uninitialized`](https://doc.rust-lang.org/std/mem/fn.uninitialized.html), [`mem::transmute`](https://doc.rust-lang.org/std/mem/fn.transmute.html), and [`MaybeUninit::assume_init`](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#method.assume_init) that can cause [undefined behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html). The lint should provide extra information to indicate what the problem is and a possible solution.\n\n## [irrefutable-let-patterns](#irrefutable-let-patterns)\n\nThe `irrefutable_let_patterns` lint detects [irrefutable patterns](https://doc.rust-lang.org/reference/patterns.html#refutability) in [`if let`](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions)s, [`while let`](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops)s, and `if let` guards.\n\n### [Example](#example-47)\n\n```rust\nif let _ = 123 {\n    println!(\"always runs!\");\n}\n```\n\nThis will produce:\n\n```text\nwarning: irrefutable `if let` pattern\n --> lint_example.rs:2:4\n  |\n2 | if let _ = 123 {\n  |    ^^^^^^^^^^^\n  |\n  = note: this pattern will always match, so the `if let` is useless\n  = help: consider replacing the `if let` with a `let`\n  = note: `#[warn(irrefutable_let_patterns)]` on by default\n\n\n```\n\n### [Explanation](#explanation-47)\n\nThere usually isn't a reason to have an irrefutable pattern in an `if let` or `while let` statement, because the pattern will always match successfully. A [`let`](https://doc.rust-lang.org/reference/statements.html#let-statements) or [`loop`](https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops) statement will suffice. However, when generating code with a macro, forbidding irrefutable patterns would require awkward workarounds in situations where the macro doesn't know if the pattern is refutable or not. This lint allows macros to accept this form, while alerting for a possibly incorrect use in normal code.\n\nSee [RFC 2086](https://github.com/rust-lang/rfcs/blob/master/text/2086-allow-if-let-irrefutables.md) for more details.\n\n## [large-assignments](#large-assignments)\n\nThe `large_assignments` lint detects when objects of large types are being moved around.\n\n### [Example](#example-48)\n\n```rust\nlet x = [0; 50000];\nlet y = x;\n```\n\nproduces:\n\n```text\nwarning: moving a large value\n  --> $DIR/move-large.rs:1:3\n  let y = x;\n          - Copied large value here\n\n```\n\n### [Explanation](#explanation-48)\n\nWhen using a large type in a plain assignment or in a function argument, idiomatic code can be inefficient. Ideally appropriate optimizations would resolve this, but such optimizations are only done in a best-effort manner. This lint will trigger on all sites of large moves and thus allow the user to resolve them in code.\n\n## [late-bound-lifetime-arguments](#late-bound-lifetime-arguments)\n\nThe `late_bound_lifetime_arguments` lint detects generic lifetime arguments in path segments with late bound lifetime parameters.\n\n### [Example](#example-49)\n\n```rust\nstruct S;\n\nimpl S {\n    fn late(self, _: &u8, _: &u8) {}\n}\n\nfn main() {\n    S.late::<'static>(&0, &0);\n}\n```\n\nThis will produce:\n\n```text\nwarning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n --> lint_example.rs:8:14\n  |\n4 |     fn late(self, _: &u8, _: &u8) {}\n  |                      - the late bound lifetime parameter is introduced here\n...\n8 |     S.late::<'static>(&0, &0);\n  |              ^^^^^^^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n  = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n\n\n```\n\n### [Explanation](#explanation-49)\n\nIt is not clear how to provide arguments for early-bound lifetime parameters if they are intermixed with late-bound parameters in the same list. For now, providing any explicit arguments will trigger this lint if late-bound parameters are present, so in the future a solution can be adopted without hitting backward compatibility issues. This is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the future. See [issue #42868](https://github.com/rust-lang/rust/issues/42868) for more details, along with a description of the difference between early and late-bound parameters.\n\n## [legacy-derive-helpers](#legacy-derive-helpers)\n\nThe `legacy_derive_helpers` lint detects derive helper attributes that are used before they are introduced.\n\n### [Example](#example-50)\n\n```rust\n#[serde(rename_all = \"camelCase\")]\n#[derive(Deserialize)]\nstruct S { /* fields */ }\n```\n\nproduces:\n\n```text\nwarning: derive helper attribute is used before it is introduced\n  --> $DIR/legacy-derive-helpers.rs:1:3\n   |\n 1 | #[serde(rename_all = \"camelCase\")]\n   |   ^^^^^\n...\n 2 | #[derive(Deserialize)]\n   |          ----------- the attribute is introduced here\n\n```\n\n### [Explanation](#explanation-50)\n\nAttributes like this work for historical reasons, but attribute expansion works in left-to-right order in general, so, to resolve `#[serde]`, compiler has to try to \"look into the future\" at not yet expanded part of the item , but such attempts are not always reliable.\n\nTo fix the warning place the helper attribute after its corresponding derive.\n\n```rust\n#[derive(Deserialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct S { /* fields */ }\n```\n\n## [map-unit-fn](#map-unit-fn)\n\nThe `map_unit_fn` lint checks for `Iterator::map` receive a callable that returns `()`.\n\n### [Example](#example-51)\n\n```rust\nfn foo(items: &mut Vec<u8>) {\n    items.sort();\n}\n\nfn main() {\n    let mut x: Vec<Vec<u8>> = vec![\n        vec![0, 2, 1],\n        vec![5, 4, 3],\n    ];\n    x.iter_mut().map(foo);\n}\n```\n\nThis will produce:\n\n```text\nwarning: `Iterator::map` call that discard the iterator's values\n  --> lint_example.rs:10:18\n   |\n1  | fn foo(items: &mut Vec<u8>) {\n   | --------------------------- this function returns `()`, which is likely not what you wanted\n...\n10 |     x.iter_mut().map(foo);\n   |                  ^^^^---^\n   |                  |   |\n   |                  |   called `Iterator::map` with callable that returns `()`\n   |                  after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n   |\n   = note: `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n   = note: `#[warn(map_unit_fn)]` on by default\nhelp: you might have meant to use `Iterator::for_each`\n   |\n10 |     x.iter_mut().for_each(foo);\n   |                  ~~~~~~~~\n\n\n```\n\n### [Explanation](#explanation-51)\n\nMapping to `()` is almost always a mistake.\n\n## [mixed-script-confusables](#mixed-script-confusables)\n\nThe `mixed_script_confusables` lint detects visually confusable characters in identifiers between different [scripts](https://en.wikipedia.org/wiki/Script_(Unicode)).\n\n### [Example](#example-52)\n\n```rust\n// The Japanese katakana character エ can be confused with the Han character 工.\nconst エ: &'static str = \"アイウ\";\n```\n\nThis will produce:\n\n```text\nwarning: the usage of Script Group `Japanese, Katakana` in this crate consists solely of mixed script confusables\n --> lint_example.rs:3:7\n  |\n3 | const エ: &'static str = \"アイウ\";\n  |       ^^\n  |\n  = note: the usage includes 'エ' (U+30A8)\n  = note: please recheck to make sure their usages are indeed what you want\n  = note: `#[warn(mixed_script_confusables)]` on by default\n\n\n```\n\n### [Explanation](#explanation-52)\n\nThis lint warns when characters between different scripts may appear visually similar, which can cause confusion.\n\nIf the crate contains other identifiers in the same script that have non-confusable characters, then this lint will _not_ be issued. For example, if the example given above has another identifier with katakana characters (such as `let カタカナ = 123;`), then this indicates that you are intentionally using katakana, and it will not warn about it.\n\nNote that the set of confusable characters may change over time. Beware that if you \"forbid\" this lint that existing code may fail in the future.\n\n## [named-arguments-used-positionally](#named-arguments-used-positionally)\n\nThe `named_arguments_used_positionally` lint detects cases where named arguments are only used positionally in format strings. This usage is valid but potentially very confusing.\n\n### [Example](#example-53)\n\n```rust\n#![deny(named_arguments_used_positionally)]\nfn main() {\n    let _x = 5;\n    println!(\"{}\", _x = 1); // Prints 1, will trigger lint\n\n    println!(\"{}\", _x); // Prints 5, no lint emitted\n    println!(\"{_x}\", _x = _x); // Prints 5, no lint emitted\n}\n```\n\nThis will produce:\n\n```text\nerror: named argument `_x` is not used by name\n --> lint_example.rs:4:20\n  |\n4 |     println!(\"{}\", _x = 1); // Prints 1, will trigger lint\n  |               --   ^^ this named argument is referred to by position in formatting string\n  |               |\n  |               this formatting argument uses named argument `_x` by position\n  |\nnote: the lint level is defined here\n --> lint_example.rs:1:9\n  |\n1 | #![deny(named_arguments_used_positionally)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: use the named argument by name to avoid ambiguity\n  |\n4 |     println!(\"{_x}\", _x = 1); // Prints 1, will trigger lint\n  |                ++\n\n\n```\n\n### [Explanation](#explanation-53)\n\nRust formatting strings can refer to named arguments by their position, but this usage is potentially confusing. In particular, readers can incorrectly assume that the declaration of named arguments is an assignment (which would produce the unit type). For backwards compatibility, this is not a hard error.\n\n## [never-type-fallback-flowing-into-unsafe](#never-type-fallback-flowing-into-unsafe)\n\nThe `never_type_fallback_flowing_into_unsafe` lint detects cases where never type fallback affects unsafe function calls.\n\n### [Never type fallback](#never-type-fallback)\n\nWhen the compiler sees a value of type [`!`](https://doc.rust-lang.org/core/primitive.never.html) it implicitly inserts a coercion (if possible), to allow type check to infer any type:\n\n```ignore\n// this\nlet x: u8 = panic!();\n\n// is (essentially) turned by the compiler into\nlet x: u8 = absurd(panic!());\n\n// where absurd is a function with the following signature\n// (it's sound, because `!` always marks unreachable code):\nfn absurd<T>(never: !) -> T { ... }\n\n```\n\nWhile it's convenient to be able to use non-diverging code in one of the branches (like `if a { b } else { return }`) this could lead to compilation errors:\n\n```compile\n// this\n{ panic!() };\n\n// gets turned into this\n{ absurd(panic!()) }; // error: can't infer the type of `absurd`\n\n```\n\nTo prevent such errors, compiler remembers where it inserted `absurd` calls, and if it can't infer their type, it sets the type to fallback. `{ absurd::<Fallback>(panic!()) };`. This is what is known as \"never type fallback\".\n\n### [Example](#example-54)\n\n```rust\n#![deny(never_type_fallback_flowing_into_unsafe)]\nfn main() {\n    if true {\n        // return has type `!` which, is some cases, causes never type fallback\n        return\n    } else {\n        // `zeroed` is an unsafe function, which returns an unbounded type\n        unsafe { std::mem::zeroed() }\n    };\n    // depending on the fallback, `zeroed` may create `()` (which is completely sound),\n    // or `!` (which is instant undefined behavior)\n}\n```\n\nThis will produce:\n\n```text\nerror: never type fallback affects this call to an `unsafe` function\n --> lint_example.rs:8:18\n  |\n8 |         unsafe { std::mem::zeroed() }\n  |                  ^^^^^^^^^^^^^^^^^^\n  |\n  = warning: this will change its meaning in a future release!\n  = note: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\n  = help: specify the type explicitly\nnote: the lint level is defined here\n --> lint_example.rs:1:9\n  |\n1 | #![deny(never_type_fallback_flowing_into_unsafe)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-54)\n\nDue to historic reasons never type fallback was `()`, meaning that `!` got spontaneously coerced to `()`. There are plans to change that, but they may make the code such as above unsound. Instead of depending on the fallback, you should specify the type explicitly:\n\n```\nif true {\n    return\n} else {\n    // type is explicitly specified, fallback can't hurt us no more\n    unsafe { std::mem::zeroed::<()>() }\n};\n\n```\n\nSee [Tracking Issue for making `!` fall back to `!`](https://github.com/rust-lang/rust/issues/123748).\n\n## [no-mangle-generic-items](#no-mangle-generic-items)\n\nThe `no_mangle_generic_items` lint detects generic items that must be mangled.\n\n### [Example](#example-55)\n\n```rust\n#[no_mangle]\nfn foo<T>(t: T) {\n\n}\n```\n\nThis will produce:\n\n```text\nwarning: functions generic over types or consts must be mangled\n --> lint_example.rs:3:1\n  |\n2 |   #[no_mangle]\n  |   ------------ help: remove this attribute\n3 | / fn foo<T>(t: T) {\n4 | |\n5 | | }\n  | |_^\n  |\n  = note: `#[warn(no_mangle_generic_items)]` on by default\n\n\n```\n\n### [Explanation](#explanation-55)\n\nA function with generics must have its symbol mangled to accommodate the generic parameter. The [`no_mangle` attribute](https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute) has no effect in this situation, and should be removed.\n\n## [non-fmt-panic](#non-fmt-panic)\n\nThe lint `non-fmt-panic` has been renamed to [`non-fmt-panics`](#non-fmt-panics).\n\n## [non-camel-case-types](#non-camel-case-types)\n\nThe `non_camel_case_types` lint detects types, variants, traits and type parameters that don't have camel case names.\n\n### [Example](#example-56)\n\n```rust\nstruct my_struct;\n```\n\nThis will produce:\n\n```text\nwarning: type `my_struct` should have an upper camel case name\n --> lint_example.rs:2:8\n  |\n2 | struct my_struct;\n  |        ^^^^^^^^^ help: convert the identifier to upper camel case: `MyStruct`\n  |\n  = note: `#[warn(non_camel_case_types)]` on by default\n\n\n```\n\n### [Explanation](#explanation-56)\n\nThe preferred style for these identifiers is to use \"camel case\", such as `MyStruct`, where the first letter should not be lowercase, and should not use underscores between letters. Underscores are allowed at the beginning and end of the identifier, as well as between non-letters (such as `X86_64`).\n\n## [non-contiguous-range-endpoints](#non-contiguous-range-endpoints)\n\nThe `non_contiguous_range_endpoints` lint detects likely off-by-one errors when using exclusive [range patterns](https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns).\n\n### [Example](#example-57)\n\n```rust\nlet x = 123u32;\nmatch x {\n    0..100 => { println!(\"small\"); }\n    101..1000 => { println!(\"large\"); }\n    _ => { println!(\"larger\"); }\n}\n```\n\nThis will produce:\n\n```text\nwarning: multiple ranges are one apart\n --> lint_example.rs:4:5\n  |\n4 |     0..100 => { println!(\"small\"); }\n  |     ^^^^^^\n  |     |\n  |     this range doesn't match `100_u32` because `..` is an exclusive range\n  |     help: use an inclusive range instead: `0_u32..=100_u32`\n5 |     101..1000 => { println!(\"large\"); }\n  |     --------- this could appear to continue range `0_u32..100_u32`, but `100_u32` isn't matched by either of them\n  |\n  = note: `#[warn(non_contiguous_range_endpoints)]` on by default\n\n\n```\n\n### [Explanation](#explanation-57)\n\nIt is likely a mistake to have range patterns in a match expression that miss out a single number. Check that the beginning and end values are what you expect, and keep in mind that with `..=` the right bound is inclusive, and with `..` it is exclusive.\n\n## [non-fmt-panics](#non-fmt-panics)\n\nThe `non_fmt_panics` lint detects `panic!(..)` invocations where the first argument is not a formatting string.\n\n### [Example](#example-58)\n\n```rust\npanic!(\"{}\");\npanic!(123);\n```\n\nThis will produce:\n\n```text\nwarning: panic message contains an unused formatting placeholder\n --> lint_example.rs:2:9\n  |\n2 | panic!(\"{}\");\n  |         ^^\n  |\n  = note: this message is not used as a format string when given without arguments, but will be in Rust 2021\n  = note: `#[warn(non_fmt_panics)]` on by default\nhelp: add the missing argument\n  |\n2 | panic!(\"{}\", ...);\n  |            +++++\nhelp: or add a \"{}\" format string to use the message literally\n  |\n2 | panic!(\"{}\", \"{}\");\n  |        +++++\n\n\nwarning: panic message is not a string literal\n --> lint_example.rs:3:8\n  |\n3 | panic!(123);\n  |        ^^^\n  |\n  = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n  = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\nhelp: add a \"{}\" format string to `Display` the message\n  |\n3 | panic!(\"{}\", 123);\n  |        +++++\nhelp: or use std::panic::panic_any instead\n  |\n3 | std::panic::panic_any(123);\n  | ~~~~~~~~~~~~~~~~~~~~~\n\n\n```\n\n### [Explanation](#explanation-58)\n\nIn Rust 2018 and earlier, `panic!(x)` directly uses `x` as the message. That means that `panic!(\"{}\")` panics with the message `\"{}\"` instead of using it as a formatting string, and `panic!(123)` will panic with an `i32` as message.\n\nRust 2021 always interprets the first argument as format string.\n\n## [non-shorthand-field-patterns](#non-shorthand-field-patterns)\n\nThe `non_shorthand_field_patterns` lint detects using `Struct { x: x }` instead of `Struct { x }` in a pattern.\n\n### [Example](#example-59)\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\n\nfn main() {\n    let p = Point {\n        x: 5,\n        y: 5,\n    };\n\n    match p {\n        Point { x: x, y: y } => (),\n    }\n}\n```\n\nThis will produce:\n\n```text\nwarning: the `x:` in this pattern is redundant\n  --> lint_example.rs:14:17\n   |\n14 |         Point { x: x, y: y } => (),\n   |                 ^^^^ help: use shorthand field pattern: `x`\n   |\n   = note: `#[warn(non_shorthand_field_patterns)]` on by default\n\n\nwarning: the `y:` in this pattern is redundant\n  --> lint_example.rs:14:23\n   |\n14 |         Point { x: x, y: y } => (),\n   |                       ^^^^ help: use shorthand field pattern: `y`\n\n\n```\n\n### [Explanation](#explanation-59)\n\nThe preferred style is to avoid the repetition of specifying both the field name and the binding name if both identifiers are the same.\n\n## [non-snake-case](#non-snake-case)\n\nThe `non_snake_case` lint detects variables, methods, functions, lifetime parameters and modules that don't have snake case names.\n\n### [Example](#example-60)\n\n```rust\nlet MY_VALUE = 5;\n```\n\nThis will produce:\n\n```text\nwarning: variable `MY_VALUE` should have a snake case name\n --> lint_example.rs:2:5\n  |\n2 | let MY_VALUE = 5;\n  |     ^^^^^^^^ help: convert the identifier to snake case: `my_value`\n  |\n  = note: `#[warn(non_snake_case)]` on by default\n\n\n```\n\n### [Explanation](#explanation-60)\n\nThe preferred style for these identifiers is to use \"snake case\", where all the characters are in lowercase, with words separated with a single underscore, such as `my_value`.\n\n## [non-upper-case-globals](#non-upper-case-globals)\n\nThe `non_upper_case_globals` lint detects static items that don't have uppercase identifiers.\n\n### [Example](#example-61)\n\n```rust\nstatic max_points: i32 = 5;\n```\n\nThis will produce:\n\n```text\nwarning: static variable `max_points` should have an upper case name\n --> lint_example.rs:2:8\n  |\n2 | static max_points: i32 = 5;\n  |        ^^^^^^^^^^ help: convert the identifier to upper case: `MAX_POINTS`\n  |\n  = note: `#[warn(non_upper_case_globals)]` on by default\n\n\n```\n\n### [Explanation](#explanation-61)\n\nThe preferred style is for static item names to use all uppercase letters such as `MAX_POINTS`.\n\n## [noop-method-call](#noop-method-call)\n\nThe `noop_method_call` lint detects specific calls to noop methods such as a calling `<&T as Clone>::clone` where `T: !Clone`.\n\n### [Example](#example-62)\n\n```rust\n#![allow(unused)]\nstruct Foo;\nlet foo = &Foo;\nlet clone: &Foo = foo.clone();\n```\n\nThis will produce:\n\n```text\nwarning: call to `.clone()` on a reference in this situation does nothing\n --> lint_example.rs:5:22\n  |\n5 | let clone: &Foo = foo.clone();\n  |                      ^^^^^^^^\n  |\n  = note: the type `Foo` does not implement `Clone`, so calling `clone` on `&Foo` copies the reference, which does not do anything and can be removed\n  = note: `#[warn(noop_method_call)]` on by default\nhelp: remove this redundant call\n  |\n5 - let clone: &Foo = foo.clone();\n5 + let clone: &Foo = foo;\n  |\nhelp: if you meant to clone `Foo`, implement `Clone` for it\n  |\n3 + #[derive(Clone)]\n4 | struct Foo;\n  |\n\n\n```\n\n### [Explanation](#explanation-62)\n\nSome method calls are noops meaning that they do nothing. Usually such methods are the result of blanket implementations that happen to create some method invocations that end up not doing anything. For instance, `Clone` is implemented on all `&T`, but calling `clone` on a `&T` where `T` does not implement clone, actually doesn't do anything as references are copy. This lint detects these calls and warns the user about them.\n\nThe `opaque_hidden_inferred_bound` lint detects cases in which nested `impl Trait` in associated type bounds are not written generally enough to satisfy the bounds of the associated type.\n\n### [Explanation](#explanation-63)\n\nThis functionality was removed in #97346, but then rolled back in #99860 because it caused regressions.\n\nWe plan on reintroducing this as a hard error, but in the meantime, this lint serves to warn and suggest fixes for any use-cases which rely on this behavior.\n\n### [Example](#example-63)\n\n```rust\n#![feature(type_alias_impl_trait)]\n\ntrait Duh {}\n\nimpl Duh for i32 {}\n\ntrait Trait {\n    type Assoc: Duh;\n}\n\nimpl<F: Duh> Trait for F {\n    type Assoc = F;\n}\n\ntype Tait = impl Sized;\n\nfn test() -> impl Trait<Assoc = Tait> {\n    42\n}\n```\n\nThis will produce:\n\n```text\nwarning: opaque type `impl Trait<Assoc = Tait>` does not satisfy its associated type bounds\n  --> lint_example.rs:18:25\n   |\n9  |     type Assoc: Duh;\n   |                 --- this associated type bound is unsatisfied for `Tait`\n...\n18 | fn test() -> impl Trait<Assoc = Tait> {\n   |                         ^^^^^^^^^^^^\n   |\n   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n\n\n```\n\nIn this example, `test` declares that the associated type `Assoc` for `impl Trait` is `impl Sized`, which does not satisfy the bound `Duh` on the associated type.\n\nAlthough the hidden type, `i32` does satisfy this bound, we do not consider the return type to be well-formed with this lint. It can be fixed by changing `Tait = impl Sized` into `Tait = impl Sized + Duh`.\n\n## [overlapping-patterns](#overlapping-patterns)\n\nThe lint `overlapping-patterns` has been renamed to [`overlapping-range-endpoints`](#overlapping-range-endpoints).\n\n## [overlapping-range-endpoints](#overlapping-range-endpoints)\n\nThe `overlapping_range_endpoints` lint detects `match` arms that have [range patterns](https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns) that overlap on their endpoints.\n\n### [Example](#example-64)\n\n```rust\nlet x = 123u8;\nmatch x {\n    0..=100 => { println!(\"small\"); }\n    100..=255 => { println!(\"large\"); }\n}\n```\n\nThis will produce:\n\n```text\nwarning: multiple patterns overlap on their endpoints\n --> lint_example.rs:5:5\n  |\n4 |     0..=100 => { println!(\"small\"); }\n  |     ------- this range overlaps on `100_u8`...\n5 |     100..=255 => { println!(\"large\"); }\n  |     ^^^^^^^^^ ... with this range\n  |\n  = note: you likely meant to write mutually exclusive ranges\n  = note: `#[warn(overlapping_range_endpoints)]` on by default\n\n\n```\n\n### [Explanation](#explanation-64)\n\nIt is likely a mistake to have range patterns in a match expression that overlap in this way. Check that the beginning and end values are what you expect, and keep in mind that with `..=` the left and right bounds are inclusive.\n\n## [path-statements](#path-statements)\n\nThe `path_statements` lint detects path statements with no effect.\n\n### [Example](#example-65)\n\n```rust\nlet x = 42;\n\nx;\n```\n\nThis will produce:\n\n```text\nwarning: path statement with no effect\n --> lint_example.rs:4:1\n  |\n4 | x;\n  | ^^\n  |\n  = note: `#[warn(path_statements)]` on by default\n\n\n```\n\n### [Explanation](#explanation-65)\n\nIt is usually a mistake to have a statement that has no effect.\n\n## [private-bounds](#private-bounds)\n\nThe `private_bounds` lint detects types in a secondary interface of an item, that are more private than the item itself. Secondary interface of an item consists of bounds on generic parameters and where clauses, including supertraits for trait items.\n\n### [Example](#example-66)\n\n```rust\n#![allow(unused)]\n#![deny(private_bounds)]\n\nstruct PrivTy;\npub struct S\n    where PrivTy:\n{}\nfn main() {}\n```\n\nThis will produce:\n\n```text\nerror: type `PrivTy` is more private than the item `S`\n --> lint_example.rs:5:1\n  |\n5 | pub struct S\n  | ^^^^^^^^^^^^ struct `S` is reachable at visibility `pub`\n  |\nnote: but type `PrivTy` is only usable at visibility `pub(crate)`\n --> lint_example.rs:4:1\n  |\n4 | struct PrivTy;\n  | ^^^^^^^^^^^^^\nnote: the lint level is defined here\n --> lint_example.rs:2:9\n  |\n2 | #![deny(private_bounds)]\n  |         ^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-66)\n\nHaving private types or traits in item bounds makes it less clear what interface the item actually provides.\n\n## [private-interfaces](#private-interfaces)\n\nThe `private_interfaces` lint detects types in a primary interface of an item, that are more private than the item itself. Primary interface of an item is all its interface except for bounds on generic parameters and where clauses.\n\n### [Example](#example-67)\n\n```rust\n#![allow(unused)]\n#![deny(private_interfaces)]\nstruct SemiPriv;\n\nmod m1 {\n    struct Priv;\n    impl crate::SemiPriv {\n        pub fn f(_: Priv) {}\n    }\n}\n\nfn main() {}\n```\n\nThis will produce:\n\n```text\nerror: type `Priv` is more private than the item `m1::<impl SemiPriv>::f`\n --> lint_example.rs:8:9\n  |\n8 |         pub fn f(_: Priv) {}\n  |         ^^^^^^^^^^^^^^^^^ associated function `m1::<impl SemiPriv>::f` is reachable at visibility `pub(crate)`\n  |\nnote: but type `Priv` is only usable at visibility `pub(self)`\n --> lint_example.rs:6:5\n  |\n6 |     struct Priv;\n  |     ^^^^^^^^^^^\nnote: the lint level is defined here\n --> lint_example.rs:2:9\n  |\n2 | #![deny(private_interfaces)]\n  |         ^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-67)\n\nHaving something private in primary interface guarantees that the item will be unusable from outer modules due to type privacy.\n\n## [private-macro-use](#private-macro-use)\n\nThe `private_macro_use` lint detects private macros that are imported with `#[macro_use]`.\n\n### [Example](#example-68)\n\n```rust\n// extern_macro.rs\nmacro_rules! foo_ { () => {}; }\nuse foo_ as foo;\n\n// code.rs\n\n#![deny(private_macro_use)]\n\n#[macro_use]\nextern crate extern_macro;\n\nfn main() {\n    foo!();\n}\n```\n\nThis will produce:\n\n```text\nerror: cannot find macro `foo` in this scope\n\n```\n\n### [Explanation](#explanation-68)\n\nThis lint arises from overlooking visibility checks for macros in an external crate.\n\nThis is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the future.\n\n## [redundant-semicolon](#redundant-semicolon)\n\nThe lint `redundant-semicolon` has been renamed to [`redundant-semicolons`](#redundant-semicolons).\n\n## [redundant-semicolons](#redundant-semicolons)\n\nThe `redundant_semicolons` lint detects unnecessary trailing semicolons.\n\n### [Example](#example-69)\n\n```rust\nlet _ = 123;;\n```\n\nThis will produce:\n\n```text\nwarning: unnecessary trailing semicolon\n --> lint_example.rs:2:13\n  |\n2 | let _ = 123;;\n  |             ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\n\n```\n\n### [Explanation](#explanation-69)\n\nExtra semicolons are not needed, and may be removed to avoid confusion and visual clutter.\n\n## [refining-impl-trait-internal](#refining-impl-trait-internal)\n\nThe `refining_impl_trait_internal` lint detects `impl Trait` return types in method signatures that are refined by a trait implementation, meaning the implementation adds information about the return type that is not present in the trait.\n\n### [Example](#example-70)\n\n```rust\n#![deny(refining_impl_trait)]\n\nuse std::fmt::Display;\n\ntrait AsDisplay {\n    fn as_display(&self) -> impl Display;\n}\n\nimpl<'s> AsDisplay for &'s str {\n    fn as_display(&self) -> Self {\n        *self\n    }\n}\n\nfn main() {\n    // users can observe that the return type of\n    // `<&str as AsDisplay>::as_display()` is `&str`.\n    let _x: &str = \"\".as_display();\n}\n```\n\nThis will produce:\n\n```text\nerror: impl trait in impl method signature does not match trait method signature\n  --> lint_example.rs:10:29\n   |\n6  |     fn as_display(&self) -> impl Display;\n   |                             ------------ return type from trait method defined here\n...\n10 |     fn as_display(&self) -> Self {\n   |                             ^^^^\n   |\n   = note: add `#[allow(refining_impl_trait)]` if it is intended for this to be part of the public API of this crate\n   = note: we are soliciting feedback, see issue #121718 <https://github.com/rust-lang/rust/issues/121718> for more information\nnote: the lint level is defined here\n  --> lint_example.rs:1:9\n   |\n1  | #![deny(refining_impl_trait)]\n   |         ^^^^^^^^^^^^^^^^^^^\n   = note: `#[deny(refining_impl_trait_internal)]` implied by `#[deny(refining_impl_trait)]`\nhelp: replace the return type so that it matches the trait\n   |\n10 |     fn as_display(&self) -> impl std::fmt::Display {\n   |                             ~~~~~~~~~~~~~~~~~~~~~~\n\n\n```\n\n### [Explanation](#explanation-70)\n\nCallers of methods for types where the implementation is known are able to observe the types written in the impl signature. This may be intended behavior, but may also lead to implementation details being revealed unintentionally. In particular, it may pose a semver hazard for authors of libraries who do not wish to make stronger guarantees about the types than what is written in the trait signature.\n\n`refining_impl_trait` is a lint group composed of two lints:\n\n-   `refining_impl_trait_reachable`, for refinements that are publically reachable outside a crate, and\n-   `refining_impl_trait_internal`, for refinements that are only visible within a crate.\n\nWe are seeking feedback on each of these lints; see issue [#121718](https://github.com/rust-lang/rust/issues/121718) for more information.\n\n## [refining-impl-trait-reachable](#refining-impl-trait-reachable)\n\nThe `refining_impl_trait_reachable` lint detects `impl Trait` return types in method signatures that are refined by a publically reachable trait implementation, meaning the implementation adds information about the return type that is not present in the trait.\n\n### [Example](#example-71)\n\n```rust\n#![deny(refining_impl_trait)]\n\nuse std::fmt::Display;\n\npub trait AsDisplay {\n    fn as_display(&self) -> impl Display;\n}\n\nimpl<'s> AsDisplay for &'s str {\n    fn as_display(&self) -> Self {\n        *self\n    }\n}\n\nfn main() {\n    // users can observe that the return type of\n    // `<&str as AsDisplay>::as_display()` is `&str`.\n    let _x: &str = \"\".as_display();\n}\n```\n\nThis will produce:\n\n```text\nerror: impl trait in impl method signature does not match trait method signature\n  --> lint_example.rs:10:29\n   |\n6  |     fn as_display(&self) -> impl Display;\n   |                             ------------ return type from trait method defined here\n...\n10 |     fn as_display(&self) -> Self {\n   |                             ^^^^\n   |\n   = note: add `#[allow(refining_impl_trait)]` if it is intended for this to be part of the public API of this crate\n   = note: we are soliciting feedback, see issue #121718 <https://github.com/rust-lang/rust/issues/121718> for more information\nnote: the lint level is defined here\n  --> lint_example.rs:1:9\n   |\n1  | #![deny(refining_impl_trait)]\n   |         ^^^^^^^^^^^^^^^^^^^\n   = note: `#[deny(refining_impl_trait_reachable)]` implied by `#[deny(refining_impl_trait)]`\nhelp: replace the return type so that it matches the trait\n   |\n10 |     fn as_display(&self) -> impl std::fmt::Display {\n   |                             ~~~~~~~~~~~~~~~~~~~~~~\n\n\n```\n\n### [Explanation](#explanation-71)\n\nCallers of methods for types where the implementation is known are able to observe the types written in the impl signature. This may be intended behavior, but may also lead to implementation details being revealed unintentionally. In particular, it may pose a semver hazard for authors of libraries who do not wish to make stronger guarantees about the types than what is written in the trait signature.\n\n`refining_impl_trait` is a lint group composed of two lints:\n\n-   `refining_impl_trait_reachable`, for refinements that are publically reachable outside a crate, and\n-   `refining_impl_trait_internal`, for refinements that are only visible within a crate.\n\nWe are seeking feedback on each of these lints; see issue [#121718](https://github.com/rust-lang/rust/issues/121718) for more information.\n\n## [renamed-and-removed-lints](#renamed-and-removed-lints)\n\nThe `renamed_and_removed_lints` lint detects lints that have been renamed or removed.\n\n### [Example](#example-72)\n\n```rust\n#![deny(raw_pointer_derive)]\n```\n\nThis will produce:\n\n```text\nwarning: lint `raw_pointer_derive` has been removed: using derive with raw pointers is ok\n --> lint_example.rs:1:9\n  |\n1 | #![deny(raw_pointer_derive)]\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(renamed_and_removed_lints)]` on by default\n\n\n```\n\n### [Explanation](#explanation-72)\n\nTo fix this, either remove the lint or use the new name. This can help avoid confusion about lints that are no longer valid, and help maintain consistency for renamed lints.\n\n## [repr-transparent-external-private-fields](#repr-transparent-external-private-fields)\n\nThe `repr_transparent_external_private_fields` lint detects types marked `#[repr(transparent)]` that (transitively) contain an external ZST type marked `#[non_exhaustive]` or containing private fields\n\n### [Example](#example-73)\n\n```rust\n#![deny(repr_transparent_external_private_fields)]\nuse foo::NonExhaustiveZst;\n\n#[repr(transparent)]\nstruct Bar(u32, ([u32; 0], NonExhaustiveZst));\n```\n\nThis will produce:\n\n```text\nerror: zero-sized fields in repr(transparent) cannot contain external non-exhaustive types\n --> src/main.rs:5:28\n  |\n5 | struct Bar(u32, ([u32; 0], NonExhaustiveZst));\n  |                            ^^^^^^^^^^^^^^^^\n  |\nnote: the lint level is defined here\n --> src/main.rs:1:9\n  |\n1 | #![deny(repr_transparent_external_private_fields)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #78586 <https://github.com/rust-lang/rust/issues/78586>\n  = note: this struct contains `NonExhaustiveZst`, which is marked with `#[non_exhaustive]`, and makes it not a breaking change to become non-zero-sized in the future.\n\n```\n\n### [Explanation](#explanation-73)\n\nPrevious, Rust accepted fields that contain external private zero-sized types, even though it should not be a breaking change to add a non-zero-sized field to that private type.\n\nThis is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the future. See [issue #78586](https://github.com/rust-lang/rust/issues/78586) for more details.\n\n## [self-constructor-from-outer-item](#self-constructor-from-outer-item)\n\nThe `self_constructor_from_outer_item` lint detects cases where the `Self` constructor was silently allowed due to a bug in the resolver, and which may produce surprising and unintended behavior.\n\nUsing a `Self` type alias from an outer item was never intended, but was silently allowed. This is deprecated -- and is a hard error when the `Self` type alias references generics that are not in scope.\n\n### [Example](#example-74)\n\n```rust\n#![deny(self_constructor_from_outer_item)]\n\nstruct S0(usize);\n\nimpl S0 {\n    fn foo() {\n        const C: S0 = Self(0);\n        fn bar() -> S0 {\n            Self(0)\n        }\n    }\n}\n```\n\nThis will produce:\n\n```text\nerror: can't reference `Self` constructor from outer item\n --> lint_example.rs:8:23\n  |\n6 | impl S0 {\n  | ------- the inner item doesn't inherit generics from this impl, so `Self` is invalid to reference\n7 |     fn foo() {\n8 |         const C: S0 = Self(0);\n  |                       ^^^^ help: replace `Self` with the actual type: `S0`\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #124186 <https://github.com/rust-lang/rust/issues/124186>\nnote: the lint level is defined here\n --> lint_example.rs:1:9\n  |\n1 | #![deny(self_constructor_from_outer_item)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nerror: can't reference `Self` constructor from outer item\n  --> lint_example.rs:10:13\n   |\n6  | impl S0 {\n   | ------- the inner item doesn't inherit generics from this impl, so `Self` is invalid to reference\n...\n10 |             Self(0)\n   |             ^^^^ help: replace `Self` with the actual type: `S0`\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #124186 <https://github.com/rust-lang/rust/issues/124186>\n\n\n```\n\n### [Explanation](#explanation-74)\n\nThe `Self` type alias should not be reachable because nested items are not associated with the scope of the parameters from the parent item.\n\n## [semicolon-in-expressions-from-macros](#semicolon-in-expressions-from-macros)\n\nThe `semicolon_in_expressions_from_macros` lint detects trailing semicolons in macro bodies when the macro is invoked in expression position. This was previous accepted, but is being phased out.\n\n### [Example](#example-75)\n\n```rust\n#![deny(semicolon_in_expressions_from_macros)]\nmacro_rules! foo {\n    () => { true; }\n}\n\nfn main() {\n    let val = match true {\n        true => false,\n        _ => foo!()\n    };\n}\n```\n\nThis will produce:\n\n```text\nerror: trailing semicolon in macro used in expression position\n --> lint_example.rs:3:17\n  |\n3 |     () => { true; }\n  |                 ^\n...\n9 |         _ => foo!()\n  |              ------ in this macro invocation\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\nnote: the lint level is defined here\n --> lint_example.rs:1:9\n  |\n1 | #![deny(semicolon_in_expressions_from_macros)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  = note: this error originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n\n```\n\n### [Explanation](#explanation-75)\n\nPrevious, Rust ignored trailing semicolon in a macro body when a macro was invoked in expression position. However, this makes the treatment of semicolons in the language inconsistent, and could lead to unexpected runtime behavior in some circumstances (e.g. if the macro author expects a value to be dropped).\n\nThis is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the future. See [issue #79813](https://github.com/rust-lang/rust/issues/79813) for more details.\n\n## [special-module-name](#special-module-name)\n\nThe `special_module_name` lint detects module declarations for files that have a special meaning.\n\n### [Example](#example-76)\n\n```rust\nmod lib;\n\nfn main() {\n    lib::run();\n}\n```\n\nThis will produce:\n\n```text\nwarning: found module declaration for lib.rs\n --> lint_example.rs:1:1\n  |\n1 | mod lib;\n  | ^^^^^^^^\n  |\n  = note: lib.rs is the root of this crate's library target\n  = help: to refer to it from other targets, use the library's name as the path\n  = note: `#[warn(special_module_name)]` on by default\n\n\n```\n\n### [Explanation](#explanation-76)\n\nCargo recognizes `lib.rs` and `main.rs` as the root of a library or binary crate, so declaring them as modules will lead to miscompilation of the crate unless configured explicitly.\n\nTo access a library from a binary target within the same crate, use `your_crate_name::` as the path instead of `lib::`:\n\n```rust\n// bar/src/lib.rs\nfn run() {\n    // ...\n}\n\n// bar/src/main.rs\nfn main() {\n    bar::run();\n}\n```\n\nBinary targets cannot be used as libraries and so declaring one as a module is not allowed.\n\n## [stable-features](#stable-features)\n\nThe `stable_features` lint detects a [`feature` attribute](https://doc.rust-lang.org/nightly/unstable-book/) that has since been made stable.\n\n### [Example](#example-77)\n\n```rust\n#![feature(test_accepted_feature)]\nfn main() {}\n```\n\nThis will produce:\n\n```text\nwarning: the feature `test_accepted_feature` has been stable since 1.0.0 and no longer requires an attribute to enable\n --> lint_example.rs:1:12\n  |\n1 | #![feature(test_accepted_feature)]\n  |            ^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(stable_features)]` on by default\n\n\n```\n\n### [Explanation](#explanation-77)\n\nWhen a feature is stabilized, it is no longer necessary to include a `#![feature]` attribute for it. To fix, simply remove the `#![feature]` attribute.\n\n## [static-mut-ref](#static-mut-ref)\n\nThe lint `static-mut-ref` has been renamed to [`static-mut-refs`](#static-mut-refs).\n\n## [static-mut-refs](#static-mut-refs)\n\nThe `static_mut_refs` lint checks for shared or mutable references of mutable static inside `unsafe` blocks and `unsafe` functions.\n\n### [Example](#example-78)\n\n```rust\nfn main() {\n    static mut X: i32 = 23;\n    static mut Y: i32 = 24;\n\n    unsafe {\n        let y = &X;\n        let ref x = X;\n        let (x, y) = (&X, &Y);\n        foo(&X);\n    }\n}\n\nunsafe fn _foo() {\n    static mut X: i32 = 23;\n    static mut Y: i32 = 24;\n\n    let y = &X;\n    let ref x = X;\n    let (x, y) = (&X, &Y);\n    foo(&X);\n}\n\nfn foo<'a>(_x: &'a i32) {}\n```\n\nThis will produce:\n\n```text\nwarning: creating a shared reference to mutable static is discouraged\n --> lint_example.rs:6:17\n  |\n6 |         let y = &X;\n  |                 ^^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\n  = note: `#[warn(static_mut_refs)]` on by default\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n6 |         let y = addr_of!(X);\n  |                 ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n --> lint_example.rs:7:21\n  |\n7 |         let ref x = X;\n  |                     ^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n7 |         let ref x = addr_of!(X);\n  |                     ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n --> lint_example.rs:8:23\n  |\n8 |         let (x, y) = (&X, &Y);\n  |                       ^^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n8 |         let (x, y) = (addr_of!(X), &Y);\n  |                       ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n --> lint_example.rs:8:27\n  |\n8 |         let (x, y) = (&X, &Y);\n  |                           ^^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n8 |         let (x, y) = (&X, addr_of!(Y));\n  |                           ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n --> lint_example.rs:9:13\n  |\n9 |         foo(&X);\n  |             ^^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n9 |         foo(addr_of!(X));\n  |             ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --> lint_example.rs:17:13\n   |\n17 |     let y = &X;\n   |             ^^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n17 |     let y = addr_of!(X);\n   |             ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --> lint_example.rs:18:17\n   |\n18 |     let ref x = X;\n   |                 ^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n18 |     let ref x = addr_of!(X);\n   |                 ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --> lint_example.rs:19:19\n   |\n19 |     let (x, y) = (&X, &Y);\n   |                   ^^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n19 |     let (x, y) = (addr_of!(X), &Y);\n   |                   ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --> lint_example.rs:19:23\n   |\n19 |     let (x, y) = (&X, &Y);\n   |                       ^^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n19 |     let (x, y) = (&X, addr_of!(Y));\n   |                       ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --> lint_example.rs:20:9\n   |\n20 |     foo(&X);\n   |         ^^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n20 |     foo(addr_of!(X));\n   |         ~~~~~~~~~~~\n\n\n```\n\n### [Explanation](#explanation-78)\n\nShared or mutable references of mutable static are almost always a mistake and can lead to undefined behavior and various other problems in your code.\n\nThis lint is \"warn\" by default on editions up to 2021, in 2024 there is a hard error instead.\n\n## [suspicious-double-ref-op](#suspicious-double-ref-op)\n\nThe `suspicious_double_ref_op` lint checks for usage of `.clone()`/`.borrow()`/`.deref()` on an `&&T` when `T: !Deref/Borrow/Clone`, which means the call will return the inner `&T`, instead of performing the operation on the underlying `T` and can be confusing.\n\n### [Example](#example-79)\n\n```rust\n#![allow(unused)]\nstruct Foo;\nlet foo = &&Foo;\nlet clone: &Foo = foo.clone();\n```\n\nThis will produce:\n\n```text\nwarning: using `.clone()` on a double reference, which returns `&Foo` instead of cloning the inner type\n --> lint_example.rs:5:22\n  |\n5 | let clone: &Foo = foo.clone();\n  |                      ^^^^^^^^\n  |\n  = note: `#[warn(suspicious_double_ref_op)]` on by default\n\n\n```\n\n### [Explanation](#explanation-79)\n\nSince `Foo` doesn't implement `Clone`, running `.clone()` only dereferences the double reference, instead of cloning the inner type which should be what was intended.\n\n## [temporary-cstring-as-ptr](#temporary-cstring-as-ptr)\n\nThe `temporary_cstring_as_ptr` lint detects getting the inner pointer of a temporary `CString`.\n\n### [Example](#example-80)\n\n```rust\n#![allow(unused)]\nuse std::ffi::CString;\nlet c_str = CString::new(\"foo\").unwrap().as_ptr();\n```\n\nThis will produce:\n\n```text\nwarning: getting the inner pointer of a temporary `CString`\n --> lint_example.rs:4:42\n  |\n4 | let c_str = CString::new(\"foo\").unwrap().as_ptr();\n  |             ---------------------------- ^^^^^^ this pointer will be invalid\n  |             |\n  |             this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n  |\n  = note: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n  = help: for more information, see https://doc.rust-lang.org/reference/destructors.html\n  = note: `#[warn(temporary_cstring_as_ptr)]` on by default\n\n\n```\n\n### [Explanation](#explanation-80)\n\nThe inner pointer of a `CString` lives only as long as the `CString` it points to. Getting the inner pointer of a _temporary_ `CString` allows the `CString` to be dropped at the end of the statement, as it is not being referenced as far as the typesystem is concerned. This means outside of the statement the pointer will point to freed memory, which causes undefined behavior if the pointer is later dereferenced.\n\n## [trivial-bounds](#trivial-bounds)\n\nThe `trivial_bounds` lint detects trait bounds that don't depend on any type parameters.\n\n### [Example](#example-81)\n\n```rust\n#![feature(trivial_bounds)]\npub struct A where i32: Copy;\n```\n\nThis will produce:\n\n```text\nwarning: trait bound i32: Copy does not depend on any type or lifetime parameters\n --> lint_example.rs:3:25\n  |\n3 | pub struct A where i32: Copy;\n  |                         ^^^^\n  |\n  = note: `#[warn(trivial_bounds)]` on by default\n\n\n```\n\n### [Explanation](#explanation-81)\n\nUsually you would not write a trait bound that you know is always true, or never true. However, when using macros, the macro may not know whether or not the constraint would hold or not at the time when generating the code. Currently, the compiler does not alert you if the constraint is always true, and generates an error if it is never true. The `trivial_bounds` feature changes this to be a warning in both cases, giving macros more freedom and flexibility to generate code, while still providing a signal when writing non-macro code that something is amiss.\n\nSee [RFC 2056](https://github.com/rust-lang/rfcs/blob/master/text/2056-allow-trivial-where-clause-constraints.md) for more details. This feature is currently only available on the nightly channel, see [tracking issue #48214](https://github.com/rust-lang/rust/issues/48214).\n\n## [type-alias-bounds](#type-alias-bounds)\n\nThe `type_alias_bounds` lint detects bounds in type aliases.\n\n### [Example](#example-82)\n\n```rust\ntype SendVec<T: Send> = Vec<T>;\n```\n\nThis will produce:\n\n```text\nwarning: bounds on generic parameters are not enforced in type aliases\n --> lint_example.rs:2:17\n  |\n2 | type SendVec<T: Send> = Vec<T>;\n  |                 ^^^^\n  |\n  = note: `#[warn(type_alias_bounds)]` on by default\nhelp: the bound will not be checked when the type alias is used, and should be removed\n  |\n2 - type SendVec<T: Send> = Vec<T>;\n2 + type SendVec<T> = Vec<T>;\n  |\n\n\n```\n\n### [Explanation](#explanation-82)\n\nThe trait bounds in a type alias are currently ignored, and should not be included to avoid confusion. This was previously allowed unintentionally; this may become a hard error in the future.\n\n## [tyvar-behind-raw-pointer](#tyvar-behind-raw-pointer)\n\nThe `tyvar_behind_raw_pointer` lint detects raw pointer to an inference variable.\n\n### [Example](#example-83)\n\n```rust\n// edition 2015\nlet data = std::ptr::null();\nlet _ = &data as *const *const ();\n\nif data.is_null() {}\n```\n\nThis will produce:\n\n```text\nwarning: type annotations needed\n --> lint_example.rs:6:9\n  |\n6 | if data.is_null() {}\n  |         ^^^^^^^\n  |\n  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n  = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n  = note: `#[warn(tyvar_behind_raw_pointer)]` on by default\n\n\n```\n\n### [Explanation](#explanation-83)\n\nThis kind of inference was previously allowed, but with the future arrival of [arbitrary self types](https://github.com/rust-lang/rust/issues/44874), this can introduce ambiguity. To resolve this, use an explicit type instead of relying on type inference.\n\nThis is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the 2018 edition. See [issue #46906](https://github.com/rust-lang/rust/issues/46906) for more details. This is currently a hard-error on the 2018 edition, and is \"warn\" by default in the 2015 edition.\n\n## [uncommon-codepoints](#uncommon-codepoints)\n\nThe `uncommon_codepoints` lint detects uncommon Unicode codepoints in identifiers.\n\n### [Example](#example-84)\n\n```rust\n#![allow(unused)]\nconst µ: f64 = 0.000001;\n```\n\nThis will produce:\n\n```text\nwarning: identifier contains a non normalized (NFKC) character: 'µ'\n --> lint_example.rs:3:7\n  |\n3 | const µ: f64 = 0.000001;\n  |       ^\n  |\n  = note: this character is included in the Not_NFKC Unicode general security profile\n  = note: `#[warn(uncommon_codepoints)]` on by default\n\n\n```\n\n### [Explanation](#explanation-84)\n\nThis lint warns about using characters which are not commonly used, and may cause visual confusion.\n\nThis lint is triggered by identifiers that contain a codepoint that is not part of the set of \"Allowed\" codepoints as described by [Unicode® Technical Standard #39 Unicode Security Mechanisms Section 3.1 General Security Profile for Identifiers](https://www.unicode.org/reports/tr39/#General_Security_Profile).\n\nNote that the set of uncommon codepoints may change over time. Beware that if you \"forbid\" this lint that existing code may fail in the future.\n\n## [unconditional-recursion](#unconditional-recursion)\n\nThe `unconditional_recursion` lint detects functions that cannot return without calling themselves.\n\n### [Example](#example-85)\n\n```rust\nfn foo() {\n    foo();\n}\n```\n\nThis will produce:\n\n```text\nwarning: function cannot return without recursing\n --> lint_example.rs:2:1\n  |\n2 | fn foo() {\n  | ^^^^^^^^ cannot return without recursing\n3 |     foo();\n  |     ----- recursive call site\n  |\n  = help: a `loop` may express intention better if this is on purpose\n  = note: `#[warn(unconditional_recursion)]` on by default\n\n\n```\n\n### [Explanation](#explanation-85)\n\nIt is usually a mistake to have a recursive call that does not have some condition to cause it to terminate. If you really intend to have an infinite loop, using a `loop` expression is recommended.\n\n## [uncovered-param-in-projection](#uncovered-param-in-projection)\n\nThe `uncovered_param_in_projection` lint detects a violation of one of Rust's orphan rules for foreign trait implementations that concerns the use of type parameters inside trait associated type paths (\"projections\") whose output may not be a local type that is mistakenly considered to \"cover\" said parameters which is **unsound** and which may be rejected by a future version of the compiler.\n\nOriginally reported in [#99554](https://github.com/rust-lang/rust/issues/99554).\n\n### [Example](#example-86)\n\n```rust\n// dependency.rs\n#![crate_type = \"lib\"]\n\npub trait Trait<T, U> {}\n```\n\n```edition\n// dependent.rs\ntrait Identity {\n    type Output;\n}\n\nimpl<T> Identity for T {\n    type Output = T;\n}\n\nstruct Local;\n\nimpl<T> dependency::Trait<Local, T> for <T as Identity>::Output {}\n\nfn main() {}\n\n```\n\nThis will produce:\n\n```text\nwarning[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n  --> dependent.rs:11:6\n   |\n11 | impl<T> dependency::Trait<Local, T> for <T as Identity>::Output {}\n   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #124559 <https://github.com/rust-lang/rust/issues/124559>\n   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n   = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n   = note: `#[warn(uncovered_param_in_projection)]` on by default\n\n```\n\n### [Explanation](#explanation-86)\n\nFIXME(fmease): Write explainer.\n\n## [undefined-naked-function-abi](#undefined-naked-function-abi)\n\nThe `undefined_naked_function_abi` lint detects naked function definitions that either do not specify an ABI or specify the Rust ABI.\n\n### [Example](#example-87)\n\n```rust\n#![feature(asm_experimental_arch, naked_functions)]\n\nuse std::arch::asm;\n\n#[naked]\npub fn default_abi() -> u32 {\n    unsafe { asm!(\"\", options(noreturn)); }\n}\n\n#[naked]\npub extern \"Rust\" fn rust_abi() -> u32 {\n    unsafe { asm!(\"\", options(noreturn)); }\n}\n```\n\nThis will produce:\n\n```text\nwarning: Rust ABI is unsupported in naked functions\n --> lint_example.rs:7:1\n  |\n7 | pub fn default_abi() -> u32 {\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(undefined_naked_function_abi)]` on by default\n\n\nwarning: Rust ABI is unsupported in naked functions\n  --> lint_example.rs:12:1\n   |\n12 | pub extern \"Rust\" fn rust_abi() -> u32 {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n```\n\n### [Explanation](#explanation-87)\n\nThe Rust ABI is currently undefined. Therefore, naked functions should specify a non-Rust ABI.\n\n## [unexpected-cfgs](#unexpected-cfgs)\n\nThe `unexpected_cfgs` lint detects unexpected conditional compilation conditions.\n\n### [Example](#example-88)\n\n```text\nrustc --check-cfg 'cfg()'\n\n```\n\n```rust\n#[cfg(widnows)]\nfn foo() {}\n```\n\nThis will produce:\n\n```text\nwarning: unexpected `cfg` condition name: `widnows`\n --> lint_example.rs:1:7\n  |\n1 | #[cfg(widnows)]\n  |       ^^^^^^^\n  |\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\n```\n\n### [Explanation](#explanation-88)\n\nThis lint is only active when [`--check-cfg`](https://doc.rust-lang.org/nightly/rustc/check-cfg.html) arguments are being passed to the compiler and triggers whenever an unexpected condition name or value is used.\n\nSee the [Checking Conditional Configurations](https://doc.rust-lang.org/nightly/rustc/check-cfg.html) section for more details.\n\n## [unfulfilled-lint-expectations](#unfulfilled-lint-expectations)\n\nThe `unfulfilled_lint_expectations` lint detects lint trigger expectations that have not been fulfilled.\n\n### [Example](#example-89)\n\n```rust\n#![feature(lint_reasons)]\n\n#[expect(unused_variables)]\nlet x = 10;\nprintln!(\"{}\", x);\n```\n\nThis will produce:\n\n```text\nwarning: this lint expectation is unfulfilled\n --> lint_example.rs:4:10\n  |\n4 | #[expect(unused_variables)]\n  |          ^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unfulfilled_lint_expectations)]` on by default\n\n\n```\n\n### [Explanation](#explanation-89)\n\nIt was expected that the marked code would emit a lint. This expectation has not been fulfilled.\n\nThe `expect` attribute can be removed if this is intended behavior otherwise it should be investigated why the expected lint is no longer issued.\n\nIn rare cases, the expectation might be emitted at a different location than shown in the shown code snippet. In most cases, the `#[expect]` attribute works when added to the outer scope. A few lints can only be expected on a crate level.\n\nPart of RFC 2383. The progress is being tracked in [#54503](https://github.com/rust-lang/rust/issues/54503)\n\n## [ungated-async-fn-track-caller](#ungated-async-fn-track-caller)\n\nThe `ungated_async_fn_track_caller` lint warns when the `#[track_caller]` attribute is used on an async function without enabling the corresponding unstable feature flag.\n\n### [Example](#example-90)\n\n```rust\n#[track_caller]\nasync fn foo() {}\n```\n\nThis will produce:\n\n```text\nwarning: `#[track_caller]` on async functions is a no-op\n --> lint_example.rs:2:1\n  |\n2 | #[track_caller]\n  | ^^^^^^^^^^^^^^^\n3 | async fn foo() {}\n  | ----------------- this function will not propagate the caller location\n  |\n  = note: see issue #110011 <https://github.com/rust-lang/rust/issues/110011> for more information\n  = help: add `#![feature(async_fn_track_caller)]` to the crate attributes to enable\n  = note: this compiler was built on 2024-07-21; consider upgrading it if it is out of date\n  = note: `#[warn(ungated_async_fn_track_caller)]` on by default\n\n\n```\n\n### [Explanation](#explanation-90)\n\nThe attribute must be used in conjunction with the [`async_fn_track_caller` feature flag](https://doc.rust-lang.org/beta/unstable-book/language-features/async-fn-track-caller.html). Otherwise, the `#[track_caller]` annotation will function as a no-op.\n\n## [uninhabited-static](#uninhabited-static)\n\nThe `uninhabited_static` lint detects uninhabited statics.\n\n### [Example](#example-91)\n\n```rust\nenum Void {}\nextern {\n    static EXTERN: Void;\n}\n```\n\nThis will produce:\n\n```text\nwarning: static of uninhabited type\n --> lint_example.rs:4:5\n  |\n4 |     static EXTERN: Void;\n  |     ^^^^^^^^^^^^^^^^^^^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #74840 <https://github.com/rust-lang/rust/issues/74840>\n  = note: uninhabited statics cannot be initialized, and any access would be an immediate error\n  = note: `#[warn(uninhabited_static)]` on by default\n\n\n```\n\n### [Explanation](#explanation-91)\n\nStatics with an uninhabited type can never be initialized, so they are impossible to define. However, this can be side-stepped with an `extern static`, leading to problems later in the compiler which assumes that there are no initialized uninhabited places (such as locals or statics). This was accidentally allowed, but is being phased out.\n\n## [unknown-lints](#unknown-lints)\n\nThe `unknown_lints` lint detects unrecognized lint attributes.\n\n### [Example](#example-92)\n\n```rust\n#![allow(not_a_real_lint)]\n```\n\nThis will produce:\n\n```text\nwarning: unknown lint: `not_a_real_lint`\n --> lint_example.rs:1:10\n  |\n1 | #![allow(not_a_real_lint)]\n  |          ^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unknown_lints)]` on by default\n\n\n```\n\n### [Explanation](#explanation-92)\n\nIt is usually a mistake to specify a lint that does not exist. Check the spelling, and check the lint listing for the correct name. Also consider if you are using an old version of the compiler, and the lint is only available in a newer version.\n\n## [unknown-or-malformed-diagnostic-attributes](#unknown-or-malformed-diagnostic-attributes)\n\nThe `unknown_or_malformed_diagnostic_attributes` lint detects unrecognized or otherwise malformed diagnostic attributes.\n\n### [Example](#example-93)\n\n```rust\n#![feature(diagnostic_namespace)]\n#[diagnostic::does_not_exist]\nstruct Foo;\n```\n\nThis will produce:\n\n```text\nwarning: unknown diagnostic attribute\n --> lint_example.rs:3:15\n  |\n3 | #[diagnostic::does_not_exist]\n  |               ^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unknown_or_malformed_diagnostic_attributes)]` on by default\n\n\n```\n\n### [Explanation](#explanation-93)\n\nIt is usually a mistake to specify a diagnostic attribute that does not exist. Check the spelling, and check the diagnostic attribute listing for the correct name. Also consider if you are using an old version of the compiler, and the attribute is only available in a newer version.\n\n## [unnameable-test-items](#unnameable-test-items)\n\nThe `unnameable_test_items` lint detects [`#[test]`](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) functions that are not able to be run by the test harness because they are in a position where they are not nameable.\n\n### [Example](#example-94)\n\n```rust\nfn main() {\n    #[test]\n    fn foo() {\n        // This test will not fail because it does not run.\n        assert_eq!(1, 2);\n    }\n}\n```\n\nThis will produce:\n\n```text\nwarning: cannot test inner items\n --> lint_example.rs:2:5\n  |\n2 |     #[test]\n  |     ^^^^^^^\n  |\n  = note: `#[warn(unnameable_test_items)]` on by default\n  = note: this warning originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n\n```\n\n### [Explanation](#explanation-94)\n\nIn order for the test harness to run a test, the test function must be located in a position where it can be accessed from the crate root. This generally means it must be defined in a module, and not anywhere else such as inside another function. The compiler previously allowed this without an error, so a lint was added as an alert that a test is not being used. Whether or not this should be allowed has not yet been decided, see [RFC 2471](https://github.com/rust-lang/rfcs/pull/2471#issuecomment-397414443) and [issue #36629](https://github.com/rust-lang/rust/issues/36629).\n\n## [unreachable-code](#unreachable-code)\n\nThe `unreachable_code` lint detects unreachable code paths.\n\n### [Example](#example-95)\n\n```rust\npanic!(\"we never go past here!\");\n\nlet x = 5;\n```\n\nThis will produce:\n\n```text\nwarning: unreachable statement\n --> lint_example.rs:4:1\n  |\n2 | panic!(\"we never go past here!\");\n  | -------------------------------- any code following this expression is unreachable\n3 |\n4 | let x = 5;\n  | ^^^^^^^^^^ unreachable statement\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\n\n```\n\n### [Explanation](#explanation-95)\n\nUnreachable code may signal a mistake or unfinished code. If the code is no longer in use, consider removing it.\n\n## [unreachable-patterns](#unreachable-patterns)\n\nThe `unreachable_patterns` lint detects unreachable patterns.\n\n### [Example](#example-96)\n\n```rust\nlet x = 5;\nmatch x {\n    y => (),\n    5 => (),\n}\n```\n\nThis will produce:\n\n```text\nwarning: unreachable pattern\n --> lint_example.rs:5:5\n  |\n4 |     y => (),\n  |     - matches any value\n5 |     5 => (),\n  |     ^ unreachable pattern\n  |\n  = note: `#[warn(unreachable_patterns)]` on by default\n\n\n```\n\n### [Explanation](#explanation-96)\n\nThis usually indicates a mistake in how the patterns are specified or ordered. In this example, the `y` pattern will always match, so the five is impossible to reach. Remember, match arms match in order, you probably wanted to put the `5` case above the `y` case.\n\n## [unstable-name-collision](#unstable-name-collision)\n\nThe lint `unstable-name-collision` has been renamed to [`unstable-name-collisions`](#unstable-name-collisions).\n\n## [unstable-name-collisions](#unstable-name-collisions)\n\nThe `unstable_name_collisions` lint detects that you have used a name that the standard library plans to add in the future.\n\n### [Example](#example-97)\n\n```rust\ntrait MyIterator : Iterator {\n    // is_sorted is an unstable method that already exists on the Iterator trait\n    fn is_sorted(self) -> bool where Self: Sized {true}\n}\n\nimpl<T: ?Sized> MyIterator for T where T: Iterator { }\n\nlet x = vec![1, 2, 3];\nlet _ = x.iter().is_sorted();\n```\n\nThis will produce:\n\n```text\nwarning: a method with this name may be added to the standard library in the future\n  --> lint_example.rs:10:18\n   |\n10 | let _ = x.iter().is_sorted();\n   |                  ^^^^^^^^^\n   |\n   = warning: once this associated item is added to the standard library, the ambiguity may cause an error or change in behavior!\n   = note: for more information, see issue #48919 <https://github.com/rust-lang/rust/issues/48919>\n   = help: call with fully qualified syntax `MyIterator::is_sorted(...)` to keep using the current method\n   = note: `#[warn(unstable_name_collisions)]` on by default\nhelp: add `#![feature(is_sorted)]` to the crate attributes to enable `is_sorted`\n   |\n1  + #![feature(is_sorted)]\n   |\n\n\n```\n\n### [Explanation](#explanation-97)\n\nWhen new methods are added to traits in the standard library, they are usually added in an \"unstable\" form which is only available on the [nightly channel](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html) with a [`feature` attribute](https://doc.rust-lang.org/nightly/unstable-book/). If there is any preexisting code which extends a trait to have a method with the same name, then the names will collide. In the future, when the method is stabilized, this will cause an error due to the ambiguity. This lint is an early-warning to let you know that there may be a collision in the future. This can be avoided by adding type annotations to disambiguate which trait method you intend to call, such as `MyIterator::is_sorted(my_iter)` or renaming or removing the method.\n\n## [unstable-syntax-pre-expansion](#unstable-syntax-pre-expansion)\n\nThe `unstable_syntax_pre_expansion` lint detects the use of unstable syntax that is discarded during attribute expansion.\n\n### [Example](#example-98)\n\n```rust\n#[cfg(FALSE)]\nmacro foo() {}\n```\n\nThis will produce:\n\n```text\nwarning: `macro` is experimental\n --> lint_example.rs:3:1\n  |\n3 | macro foo() {}\n  | ^^^^^^^^^^^^^^\n  |\n  = note: see issue #39412 <https://github.com/rust-lang/rust/issues/39412> for more information\n  = help: add `#![feature(decl_macro)]` to the crate attributes to enable\n  = note: this compiler was built on 2024-07-21; consider upgrading it if it is out of date\n  = warning: unstable syntax can change at any point in the future, causing a hard error!\n  = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n\n\n```\n\n### [Explanation](#explanation-98)\n\nThe input to active attributes such as `#[cfg]` or procedural macro attributes is required to be valid syntax. Previously, the compiler only gated the use of unstable syntax features after resolving `#[cfg]` gates and expanding procedural macros.\n\nTo avoid relying on unstable syntax, move the use of unstable syntax into a position where the compiler does not parse the syntax, such as a functionlike macro.\n\n```rust\n#![deny(unstable_syntax_pre_expansion)]\n\nmacro_rules! identity {\n   ( $($tokens:tt)* ) => { $($tokens)* }\n}\n\n#[cfg(FALSE)]\nidentity! {\n   macro foo() {}\n}\n```\n\nThis is a [future-incompatible](about:blank/index.html#future-incompatible-lints) lint to transition this to a hard error in the future. See [issue #65860](https://github.com/rust-lang/rust/issues/65860) for more details.\n\n## [unsupported-calling-conventions](#unsupported-calling-conventions)\n\nThe `unsupported_calling_conventions` lint is output whenever there is a use of the `stdcall`, `fastcall`, `thiscall`, `vectorcall` calling conventions (or their unwind variants) on targets that cannot meaningfully be supported for the requested target.\n\nFor example `stdcall` does not make much sense for a x86\\_64 or, more apparently, powerpc code, because this calling convention was never specified for those targets.\n\nHistorically MSVC toolchains have fallen back to the regular C calling convention for targets other than x86, but Rust doesn't really see a similar need to introduce a similar hack across many more targets.\n\n### [Example](#example-99)\n\n```rust\nextern \"stdcall\" fn stdcall() {}\n```\n\nThis will produce:\n\n```text\nwarning: use of calling convention not supported on this target\n  --> $DIR/unsupported.rs:39:1\n   |\nLL | extern \"stdcall\" fn stdcall() {}\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unsupported_calling_conventions)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out;\n              it will become a hard error in a future release!\n   = note: for more information, see issue ...\n\n```\n\n### [Explanation](#explanation-99)\n\nOn most of the targets the behaviour of `stdcall` and similar calling conventions is not defined at all, but was previously accepted due to a bug in the implementation of the compiler.\n\nThe lint `unused-doc-comment` has been renamed to [`unused-doc-comments`](#unused-doc-comments).\n\n## [unused-tuple-struct-fields](#unused-tuple-struct-fields)\n\nThe lint `unused-tuple-struct-fields` has been renamed to [`dead-code`](#dead-code).\n\n## [unused-allocation](#unused-allocation)\n\nThe `unused_allocation` lint detects unnecessary allocations that can be eliminated.\n\n### [Example](#example-100)\n\n```rust\nfn main() {\n    let a = Box::new([1, 2, 3]).len();\n}\n```\n\nThis will produce:\n\n```text\nwarning: unnecessary allocation, use `&` instead\n --> lint_example.rs:2:13\n  |\n2 |     let a = Box::new([1, 2, 3]).len();\n  |             ^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_allocation)]` on by default\n\n\n```\n\n### [Explanation](#explanation-100)\n\nWhen a `box` expression is immediately coerced to a reference, then the allocation is unnecessary, and a reference (using `&` or `&mut`) should be used instead to avoid the allocation.\n\n## [unused-assignments](#unused-assignments)\n\nThe `unused_assignments` lint detects assignments that will never be read.\n\n### [Example](#example-101)\n\n```rust\nlet mut x = 5;\nx = 6;\n```\n\nThis will produce:\n\n```text\nwarning: value assigned to `x` is never read\n --> lint_example.rs:3:1\n  |\n3 | x = 6;\n  | ^\n  |\n  = help: maybe it is overwritten before being read?\n  = note: `#[warn(unused_assignments)]` on by default\n\n\n```\n\n### [Explanation](#explanation-101)\n\nUnused assignments may signal a mistake or unfinished code. If the variable is never used after being assigned, then the assignment can be removed. Variables with an underscore prefix such as `_x` will not trigger this lint.\n\n## [unused-associated-type-bounds](#unused-associated-type-bounds)\n\nThe `unused_associated_type_bounds` lint is emitted when an associated type bound is added to a trait object, but the associated type has a `where Self: Sized` bound, and is thus unavailable on the trait object anyway.\n\n### [Example](#example-102)\n\n```rust\ntrait Foo {\n    type Bar where Self: Sized;\n}\ntype Mop = dyn Foo<Bar = ()>;\n```\n\nThis will produce:\n\n```text\nwarning: unnecessary associated type bound for not object safe associated type\n --> lint_example.rs:5:20\n  |\n5 | type Mop = dyn Foo<Bar = ()>;\n  |                    ^^^^^^^^ help: remove this bound\n  |\n  = note: this associated type has a `where Self: Sized` bound. Thus, while the associated type can be specified, it cannot be used in any way, because trait objects are not `Sized`.\n  = note: `#[warn(unused_associated_type_bounds)]` on by default\n\n\n```\n\n### [Explanation](#explanation-102)\n\nJust like methods with `Self: Sized` bounds are unavailable on trait objects, associated types can be removed from the trait object.\n\n## [unused-attributes](#unused-attributes)\n\nThe `unused_attributes` lint detects attributes that were not used by the compiler.\n\n### [Example](#example-103)\n\n```rust\n#![ignore]\n```\n\nThis will produce:\n\n```text\nwarning: `#[ignore]` only has an effect on functions\n --> lint_example.rs:1:1\n  |\n1 | #![ignore]\n  | ^^^^^^^^^^\n  |\n  = note: `#[warn(unused_attributes)]` on by default\n\n\n```\n\n### [Explanation](#explanation-103)\n\nUnused [attributes](https://doc.rust-lang.org/reference/attributes.html) may indicate the attribute is placed in the wrong position. Consider removing it, or placing it in the correct position. Also consider if you intended to use an _inner attribute_ (with a `!` such as `#![allow(unused)]`) which applies to the item the attribute is within, or an _outer attribute_ (without a `!` such as `#[allow(unused)]`) which applies to the item _following_ the attribute.\n\n## [unused-braces](#unused-braces)\n\nThe `unused_braces` lint detects unnecessary braces around an expression.\n\n### [Example](#example-104)\n\n```rust\nif { true } {\n    // ...\n}\n```\n\nThis will produce:\n\n```text\nwarning: unnecessary braces around `if` condition\n --> lint_example.rs:2:4\n  |\n2 | if { true } {\n  |    ^^    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n2 - if { true } {\n2 + if true {\n  |\n\n\n```\n\n### [Explanation](#explanation-104)\n\nThe braces are not needed, and should be removed. This is the preferred style for writing these expressions.\n\n## [unused-comparisons](#unused-comparisons)\n\nThe `unused_comparisons` lint detects comparisons made useless by limits of the types involved.\n\n### [Example](#example-105)\n\n```rust\nfn foo(x: u8) {\n    x >= 0;\n}\n```\n\nThis will produce:\n\n```text\nwarning: comparison is useless due to type limits\n --> lint_example.rs:3:5\n  |\n3 |     x >= 0;\n  |     ^^^^^^\n  |\n  = note: `#[warn(unused_comparisons)]` on by default\n\n\n```\n\n### [Explanation](#explanation-105)\n\nA useless comparison may indicate a mistake, and should be fixed or removed.\n\nThe `unused_doc_comments` lint detects doc comments that aren't used by `rustdoc`.\n\n### [Example](#example-106)\n\n```rust\n/// docs for x\nlet x = 12;\n```\n\nThis will produce:\n\n```text\nwarning: unused doc comment\n --> lint_example.rs:2:1\n  |\n2 | /// docs for x\n  | ^^^^^^^^^^^^^^\n3 | let x = 12;\n  | ----------- rustdoc does not generate documentation for statements\n  |\n  = help: use `//` for a plain comment\n  = note: `#[warn(unused_doc_comments)]` on by default\n\n\n```\n\n### [Explanation](#explanation-106)\n\n`rustdoc` does not use doc comments in all positions, and so the doc comment will be ignored. Try changing it to a normal comment with `//` to avoid the warning.\n\n## [unused-features](#unused-features)\n\nThe `unused_features` lint detects unused or unknown features found in crate-level [`feature` attributes](https://doc.rust-lang.org/nightly/unstable-book/).\n\nNote: This lint is currently not functional, see [issue #44232](https://github.com/rust-lang/rust/issues/44232) for more details.\n\n## [unused-imports](#unused-imports)\n\nThe `unused_imports` lint detects imports that are never used.\n\n### [Example](#example-107)\n\n```rust\nuse std::collections::HashMap;\n```\n\nThis will produce:\n\n```text\nwarning: unused import: `std::collections::HashMap`\n --> lint_example.rs:2:5\n  |\n2 | use std::collections::HashMap;\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\n\n```\n\n### [Explanation](#explanation-107)\n\nUnused imports may signal a mistake or unfinished code, and clutter the code, and should be removed. If you intended to re-export the item to make it available outside of the module, add a visibility modifier like `pub`.\n\n## [unused-labels](#unused-labels)\n\nThe `unused_labels` lint detects [labels](https://doc.rust-lang.org/reference/expressions/loop-expr.html#loop-labels) that are never used.\n\n### [Example](#example-108)\n\n```rust\n'unused_label: loop {}\n```\n\nThis will produce:\n\n```text\nwarning: unused label\n --> lint_example.rs:2:1\n  |\n2 | 'unused_label: loop {}\n  | ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_labels)]` on by default\n\n\n```\n\n### [Explanation](#explanation-108)\n\nUnused labels may signal a mistake or unfinished code. To silence the warning for the individual label, prefix it with an underscore such as `'_my_label:`.\n\n## [unused-macros](#unused-macros)\n\nThe `unused_macros` lint detects macros that were not used.\n\nNote that this lint is distinct from the `unused_macro_rules` lint, which checks for single rules that never match of an otherwise used macro, and thus never expand.\n\n### [Example](#example-109)\n\n```rust\nmacro_rules! unused {\n    () => {};\n}\n\nfn main() {\n}\n```\n\nThis will produce:\n\n```text\nwarning: unused macro definition: `unused`\n --> lint_example.rs:1:14\n  |\n1 | macro_rules! unused {\n  |              ^^^^^^\n  |\n  = note: `#[warn(unused_macros)]` on by default\n\n\n```\n\n### [Explanation](#explanation-109)\n\nUnused macros may signal a mistake or unfinished code. To silence the warning for the individual macro, prefix the name with an underscore such as `_my_macro`. If you intended to export the macro to make it available outside of the crate, use the [`macro_export` attribute](https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope).\n\n## [unused-must-use](#unused-must-use)\n\nThe `unused_must_use` lint detects unused result of a type flagged as `#[must_use]`.\n\n### [Example](#example-110)\n\n```rust\nfn returns_result() -> Result<(), ()> {\n    Ok(())\n}\n\nfn main() {\n    returns_result();\n}\n```\n\nThis will produce:\n\n```text\nwarning: unused `Result` that must be used\n --> lint_example.rs:6:5\n  |\n6 |     returns_result();\n  |     ^^^^^^^^^^^^^^^^\n  |\n  = note: this `Result` may be an `Err` variant, which should be handled\n  = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n  |\n6 |     let _ = returns_result();\n  |     +++++++\n\n\n```\n\n### [Explanation](#explanation-110)\n\nThe `#[must_use]` attribute is an indicator that it is a mistake to ignore the value. See [the reference](https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute) for more details.\n\n## [unused-mut](#unused-mut)\n\nThe `unused_mut` lint detects mut variables which don't need to be mutable.\n\n### [Example](#example-111)\n\n```rust\nlet mut x = 5;\n```\n\nThis will produce:\n\n```text\nwarning: variable does not need to be mutable\n --> lint_example.rs:2:5\n  |\n2 | let mut x = 5;\n  |     ----^\n  |     |\n  |     help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\n\n```\n\n### [Explanation](#explanation-111)\n\nThe preferred style is to only mark variables as `mut` if it is required.\n\n## [unused-parens](#unused-parens)\n\nThe `unused_parens` lint detects `if`, `match`, `while` and `return` with parentheses; they do not need them.\n\n### [Examples](#examples)\n\n```rust\nif(true) {}\n```\n\nThis will produce:\n\n```text\nwarning: unnecessary parentheses around `if` condition\n --> lint_example.rs:2:3\n  |\n2 | if(true) {}\n  |   ^    ^\n  |\n  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n  |\n2 - if(true) {}\n2 + if true {}\n  |\n\n\n```\n\n### [Explanation](#explanation-112)\n\nThe parentheses are not needed, and should be removed. This is the preferred style for writing these expressions.\n\n## [unused-unsafe](#unused-unsafe)\n\nThe `unused_unsafe` lint detects unnecessary use of an `unsafe` block.\n\n### [Example](#example-112)\n\n```rust\nunsafe {}\n```\n\nThis will produce:\n\n```text\nwarning: unnecessary `unsafe` block\n --> lint_example.rs:2:1\n  |\n2 | unsafe {}\n  | ^^^^^^ unnecessary `unsafe` block\n  |\n  = note: `#[warn(unused_unsafe)]` on by default\n\n\n```\n\n### [Explanation](#explanation-113)\n\nIf nothing within the block requires `unsafe`, then remove the `unsafe` marker because it is not required and may cause confusion.\n\n## [unused-variables](#unused-variables)\n\nThe `unused_variables` lint detects variables which are not used in any way.\n\n### [Example](#example-113)\n\n```rust\nlet x = 5;\n```\n\nThis will produce:\n\n```text\nwarning: unused variable: `x`\n --> lint_example.rs:2:5\n  |\n2 | let x = 5;\n  |     ^ help: if this is intentional, prefix it with an underscore: `_x`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\n\n```\n\n### [Explanation](#explanation-114)\n\nUnused variables may signal a mistake or unfinished code. To silence the warning for the individual variable, prefix it with an underscore such as `_x`.\n\n## [useless-ptr-null-checks](#useless-ptr-null-checks)\n\nThe `useless_ptr_null_checks` lint checks for useless null checks against pointers obtained from non-null types.\n\n### [Example](#example-114)\n\n```rust\nfn test() {}\nlet fn_ptr: fn() = /* somehow obtained nullable function pointer */\n  test;\n\nif (fn_ptr as *const ()).is_null() { /* ... */ }\n```\n\nThis will produce:\n\n```text\nwarning: function pointers are not nullable, so checking them for null will always return false\n --> lint_example.rs:6:4\n  |\n6 | if (fn_ptr as *const ()).is_null() { /* ... */ }\n  |    ^------^^^^^^^^^^^^^^^^^^^^^^^^\n  |     |\n  |     expression has type `fn()`\n  |\n  = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value\n  = note: `#[warn(useless_ptr_null_checks)]` on by default\n\n\n```\n\n### [Explanation](#explanation-115)\n\nFunction pointers and references are assumed to be non-null, checking them for null will always return false.\n\n## [warnings](#warnings)\n\nThe `warnings` lint allows you to change the level of other lints which produce warnings.\n\n### [Example](#example-115)\n\n```rust\n#![deny(warnings)]\nfn foo() {}\n```\n\nThis will produce:\n\n```text\nerror: function `foo` is never used\n --> lint_example.rs:3:4\n  |\n3 | fn foo() {}\n  |    ^^^\n  |\nnote: the lint level is defined here\n --> lint_example.rs:1:9\n  |\n1 | #![deny(warnings)]\n  |         ^^^^^^^^\n  = note: `#[deny(dead_code)]` implied by `#[deny(warnings)]`\n\n\n```\n\n### [Explanation](#explanation-116)\n\nThe `warnings` lint is a bit special; by changing its level, you change every other warning that would produce a warning to whatever value you'd like. As such, you won't ever trigger this lint in your code directly.\n\n## [wasm-c-abi](#wasm-c-abi)\n\nThe `wasm_c_abi` lint detects crate dependencies that are incompatible with future versions of Rust that will emit spec-compliant C ABI.\n\n### [Example](#example-116)\n\n```rust\n#![deny(wasm_c_abi)]\n```\n\nThis will produce:\n\n```text\nerror: the following packages contain code that will be rejected by a future version of Rust: wasm-bindgen v0.2.87\n  |\nnote: the lint level is defined here\n --> src/lib.rs:1:9\n  |\n1 | #![deny(wasm_c_abi)]\n  |         ^^^^^^^^^^\n\n```\n\n### [Explanation](#explanation-117)\n\nRust has historically emitted non-spec-compliant C ABI. This has caused incompatibilities between other compilers and Wasm targets. In a future version of Rust this will be fixed and therefore dependencies relying on the non-spec-compliant C ABI will stop functioning.\n\n## [while-true](#while-true)\n\nThe `while_true` lint detects `while true { }`.\n\n### [Example](#example-117)\n\n```rust\nwhile true {\n\n}\n```\n\nThis will produce:\n\n```text\nwarning: denote infinite loops with `loop { ... }`\n --> lint_example.rs:2:1\n  |\n2 | while true {\n  | ^^^^^^^^^^ help: use `loop`\n  |\n  = note: `#[warn(while_true)]` on by default\n\n\n```\n\n### [Explanation](#explanation-118)\n\n`while true` should be replaced with `loop`. A `loop` expression is the preferred way to write an infinite loop because it more directly expresses the intent of the loop.\n\n## [writes-through-immutable-pointer](#writes-through-immutable-pointer)\n\nThe `writes_through_immutable_pointer` lint detects writes through pointers derived from shared references.\n\n### [Example](#example-118)\n\n```rust\n#![feature(const_mut_refs)]\nconst WRITE_AFTER_CAST: () = unsafe {\n    let mut x = 0;\n    let ptr = &x as *const i32 as *mut i32;\n    *ptr = 0;\n};\n```\n\nThis will produce:\n\n```text\nwarning: writing through a pointer that was derived from a shared (immutable) reference\n --> lint_example.rs:6:5\n  |\n6 |     *ptr = 0;\n  |     ^^^^^^^^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #X <https://github.com/rust-lang/rust/issues/X>\n  = note: `#[warn(writes_through_immutable_pointer)]` on by default\n\n\n```\n\n### [Explanation](#explanation-119)\n\nShared references are immutable (when there is no `UnsafeCell` involved), and writing through them or through pointers derived from them is Undefined Behavior. The compiler recently learned to detect such Undefined Behavior during compile-time evaluation, and in the future this will raise a hard error.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Warn-by-default Lints - The rustc book</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"../../favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"../../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded \"><a href=\"../../what-is-rustc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> What is rustc?</a></li><li class=\"chapter-item expanded \"><a href=\"../../command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Command-line Arguments</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../codegen-options/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Codegen Options</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../../jobserver.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Jobserver</a></li><li class=\"chapter-item expanded \"><a href=\"../../lints/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Lints</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../lints/levels.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Lint Levels</a></li><li class=\"chapter-item expanded \"><a href=\"../../lints/groups.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> Lint Groups</a></li><li class=\"chapter-item expanded \"><a href=\"../../lints/listing/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Lint Listing</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../lints/listing/allowed-by-default.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.1.</strong> Allowed-by-default Lints</a></li><li class=\"chapter-item expanded \"><a href=\"../../lints/listing/warn-by-default.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.2.</strong> Warn-by-default Lints</a></li><li class=\"chapter-item expanded \"><a href=\"../../lints/listing/deny-by-default.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.3.</strong> Deny-by-default Lints</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../../json.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> JSON Output</a></li><li class=\"chapter-item expanded \"><a href=\"../../tests/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Tests</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Platform Support</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../target-tier-policy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Target Tier Policy</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/TEMPLATE.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Template for Target-specific Documentation</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/arm64ec-pc-windows-msvc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> arm64ec-pc-windows-msvc</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/apple-darwin.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> *-apple-darwin</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../platform-support/i686-apple-darwin.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.1.</strong> i686-apple-darwin</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/x86_64h-apple-darwin.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.2.</strong> x86_64h-apple-darwin</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/arm64e-apple-darwin.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.3.</strong> arm64e-apple-darwin</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/apple-ios.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> *-apple-ios</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../platform-support/apple-ios-macabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.1.</strong> *-apple-ios-macabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/arm64e-apple-ios.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.2.</strong> arm64e-apple-ios</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/apple-tvos.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.6.</strong> *-apple-tvos</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/apple-watchos.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.7.</strong> *-apple-watchos</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/apple-visionos.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.8.</strong> *-apple-visionos</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/aarch64-nintendo-switch-freestanding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.9.</strong> aarch64-nintendo-switch-freestanding</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/armeb-unknown-linux-gnueabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.10.</strong> armeb-unknown-linux-gnueabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/arm-none-eabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.</strong> arm-none-eabi</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../platform-support/armv4t-none-eabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.1.</strong> armv4t-none-eabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/armv5te-none-eabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.2.</strong> armv5te-none-eabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/armv7r-none-eabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.3.</strong> armv7r-none-eabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/armv8r-none-eabihf.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.4.</strong> armv8r-none-eabihf</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/thumbv6m-none-eabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.5.</strong> thumbv6m-none-eabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/thumbv7em-none-eabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.6.</strong> thumbv7em-none-eabi*</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/thumbv7m-none-eabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.7.</strong> thumbv7m-none-eabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/thumbv8m.base-none-eabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.8.</strong> thumbv8m.base-none-eabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/thumbv8m.main-none-eabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.11.9.</strong> thumbv8m.main-none-eabi*</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/armv6k-nintendo-3ds.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.12.</strong> armv6k-nintendo-3ds</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/armv7-sony-vita-newlibeabihf.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.13.</strong> armv7-sony-vita-newlibeabihf</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/armv7-unknown-linux-uclibceabi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.14.</strong> armv7-unknown-linux-uclibceabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/armv7-unknown-linux-uclibceabihf.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.15.</strong> armv7-unknown-linux-uclibceabihf</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/android.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.16.</strong> *-android and *-androideabi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/openharmony.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.17.</strong> *-linux-ohos</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/hurd.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.18.</strong> *-hurd-gnu</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/aarch64-unknown-teeos.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.19.</strong> aarch64-unknown-teeos</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/esp-idf.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.20.</strong> *-esp-espidf</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/fuchsia.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.21.</strong> *-unknown-fuchsia</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/kmc-solid.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.22.</strong> *-kmc-solid_*</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/csky-unknown-linux-gnuabiv2.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.23.</strong> csky-unknown-linux-gnuabiv2*</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/hexagon-unknown-linux-musl.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.24.</strong> hexagon-unknown-linux-musl</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/hexagon-unknown-none-elf.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.25.</strong> hexagon-unknown-none-elf</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/loongarch-linux.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.26.</strong> loongarch*-unknown-linux-*</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/loongarch-none.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.27.</strong> loongarch*-unknown-none*</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/m68k-unknown-linux-gnu.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.28.</strong> m68k-unknown-linux-gnu</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/mips64-openwrt-linux-musl.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.29.</strong> mips64-openwrt-linux-musl</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/mipsel-sony-psx.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.30.</strong> mipsel-sony-psx</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/mips-release-6.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.31.</strong> mipsisa*r6*-unknown-linux-gnu*</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/nvptx64-nvidia-cuda.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.32.</strong> nvptx64-nvidia-cuda</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/aix.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.33.</strong> powerpc64-ibm-aix</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/riscv32im-risc0-zkvm-elf.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.34.</strong> riscv32im-risc0-zkvm-elf</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/riscv32imac-unknown-xous-elf.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.35.</strong> riscv32imac-unknown-xous-elf</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/riscv32-unknown-none-elf.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.36.</strong> riscv32*-unknown-none-elf</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/sparc-unknown-none-elf.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.37.</strong> sparc-unknown-none-elf</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/pc-windows-gnullvm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.38.</strong> *-pc-windows-gnullvm</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/nto-qnx.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.39.</strong> *-nto-qnx-*</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/unikraft-linux-musl.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.40.</strong> *-unikraft-linux-musl</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/hermit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.41.</strong> *-unknown-hermit</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/netbsd.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.42.</strong> *-unknown-netbsd*</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/openbsd.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.43.</strong> *-unknown-openbsd</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/unknown-uefi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.44.</strong> *-unknown-uefi</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/wasm32-wasip1.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.45.</strong> wasm32-wasip1</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/wasm32-wasip1-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.46.</strong> wasm32-wasip1-threads</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/wasm32-wasip2.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.47.</strong> wasm32-wasip2</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/wasm64-unknown-unknown.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.48.</strong> wasm64-unknown-unknown</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/win7-windows-msvc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.49.</strong> *-win7-windows-msvc</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/x86_64-fortanix-unknown-sgx.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.50.</strong> x86_64-fortanix-unknown-sgx</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/x86_64-unknown-linux-none.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.51.</strong> x86_64-unknown-linux-none.md</a></li><li class=\"chapter-item expanded \"><a href=\"../../platform-support/x86_64-unknown-none.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.52.</strong> x86_64-unknown-none</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../../targets/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Targets</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../targets/built-in.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Built-in Targets</a></li><li class=\"chapter-item expanded \"><a href=\"../../targets/custom.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Custom Targets</a></li><li class=\"chapter-item expanded \"><a href=\"../../targets/known-issues.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Known Issues</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../../profile-guided-optimization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Profile-guided Optimization</a></li><li class=\"chapter-item expanded \"><a href=\"../../instrument-coverage.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Instrumentation-based Code Coverage</a></li><li class=\"chapter-item expanded \"><a href=\"../../linker-plugin-lto.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Linker-plugin-based LTO</a></li><li class=\"chapter-item expanded \"><a href=\"../../check-cfg.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Checking Conditional Configurations</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../check-cfg/cargo-specifics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Cargo Specifics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../../exploit-mitigations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Exploit Mitigations</a></li><li class=\"chapter-item expanded \"><a href=\"../../symbol-mangling/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> Symbol Mangling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../../symbol-mangling/v0.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> v0 Symbol Format</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../../contributing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Contributing to rustc</a></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar bordered\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The rustc book</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/rust/tree/master/src/doc/rustc\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/rust/edit/master/src/doc/rustc/src/lints/listing/warn-by-default.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"warn-by-default-lints\"><a class=\"header\" href=\"#warn-by-default-lints\">Warn-by-default Lints</a></h1>\n<p>These lints are all set to the 'warn' level by default.</p>\n<ul>\n<li><a href=\"#ambiguous-glob-imports\"><code class=\"hljs\">ambiguous_glob_imports</code></a></li>\n<li><a href=\"#ambiguous-glob-reexports\"><code class=\"hljs\">ambiguous_glob_reexports</code></a></li>\n<li><a href=\"#ambiguous-wide-pointer-comparisons\"><code class=\"hljs\">ambiguous_wide_pointer_comparisons</code></a></li>\n<li><a href=\"#anonymous-parameters\"><code class=\"hljs\">anonymous_parameters</code></a></li>\n<li><a href=\"#array-into-iter\"><code class=\"hljs\">array_into_iter</code></a></li>\n<li><a href=\"#asm-sub-register\"><code class=\"hljs\">asm_sub_register</code></a></li>\n<li><a href=\"#async-fn-in-trait\"><code class=\"hljs\">async_fn_in_trait</code></a></li>\n<li><a href=\"#bad-asm-style\"><code class=\"hljs\">bad_asm_style</code></a></li>\n<li><a href=\"#bare-trait-object\"><code class=\"hljs\">bare-trait-object</code></a></li>\n<li><a href=\"#bare-trait-objects\"><code class=\"hljs\">bare_trait_objects</code></a></li>\n<li><a href=\"#boxed-slice-into-iter\"><code class=\"hljs\">boxed_slice_into_iter</code></a></li>\n<li><a href=\"#break-with-label-and-loop\"><code class=\"hljs\">break_with_label_and_loop</code></a></li>\n<li><a href=\"#byte-slice-in-packed-struct-with-derive\"><code class=\"hljs\">byte_slice_in_packed_struct_with_derive</code></a></li>\n<li><a href=\"#clashing-extern-declarations\"><code class=\"hljs\">clashing_extern_declarations</code></a></li>\n<li><a href=\"#coherence-leak-check\"><code class=\"hljs\">coherence_leak_check</code></a></li>\n<li><a href=\"#confusable-idents\"><code class=\"hljs\">confusable_idents</code></a></li>\n<li><a href=\"#const-eval-mutable-ptr-in-final-value\"><code class=\"hljs\">const_eval_mutable_ptr_in_final_value</code></a></li>\n<li><a href=\"#const-evaluatable-unchecked\"><code class=\"hljs\">const_evaluatable_unchecked</code></a></li>\n<li><a href=\"#const-item-mutation\"><code class=\"hljs\">const_item_mutation</code></a></li>\n<li><a href=\"#dead-code\"><code class=\"hljs\">dead_code</code></a></li>\n<li><a href=\"#deprecated\"><code class=\"hljs\">deprecated</code></a></li>\n<li><a href=\"#deprecated-where-clause-location\"><code class=\"hljs\">deprecated_where_clause_location</code></a></li>\n<li><a href=\"#deref-into-dyn-supertrait\"><code class=\"hljs\">deref_into_dyn_supertrait</code></a></li>\n<li><a href=\"#deref-nullptr\"><code class=\"hljs\">deref_nullptr</code></a></li>\n<li><a href=\"#drop-bounds\"><code class=\"hljs\">drop_bounds</code></a></li>\n<li><a href=\"#dropping-copy-types\"><code class=\"hljs\">dropping_copy_types</code></a></li>\n<li><a href=\"#dropping-references\"><code class=\"hljs\">dropping_references</code></a></li>\n<li><a href=\"#duplicate-macro-attributes\"><code class=\"hljs\">duplicate_macro_attributes</code></a></li>\n<li><a href=\"#dyn-drop\"><code class=\"hljs\">dyn_drop</code></a></li>\n<li><a href=\"#elided-lifetimes-in-associated-constant\"><code class=\"hljs\">elided_lifetimes_in_associated_constant</code></a></li>\n<li><a href=\"#ellipsis-inclusive-range-patterns\"><code class=\"hljs\">ellipsis_inclusive_range_patterns</code></a></li>\n<li><a href=\"#exported-private-dependencies\"><code class=\"hljs\">exported_private_dependencies</code></a></li>\n<li><a href=\"#for-loops-over-fallibles\"><code class=\"hljs\">for_loops_over_fallibles</code></a></li>\n<li><a href=\"#forbidden-lint-groups\"><code class=\"hljs\">forbidden_lint_groups</code></a></li>\n<li><a href=\"#forgetting-copy-types\"><code class=\"hljs\">forgetting_copy_types</code></a></li>\n<li><a href=\"#forgetting-references\"><code class=\"hljs\">forgetting_references</code></a></li>\n<li><a href=\"#function-item-references\"><code class=\"hljs\">function_item_references</code></a></li>\n<li><a href=\"#hidden-glob-reexports\"><code class=\"hljs\">hidden_glob_reexports</code></a></li>\n<li><a href=\"#impl-trait-redundant-captures\"><code class=\"hljs\">impl_trait_redundant_captures</code></a></li>\n<li><a href=\"#improper-ctypes\"><code class=\"hljs\">improper_ctypes</code></a></li>\n<li><a href=\"#improper-ctypes-definitions\"><code class=\"hljs\">improper_ctypes_definitions</code></a></li>\n<li><a href=\"#incomplete-features\"><code class=\"hljs\">incomplete_features</code></a></li>\n<li><a href=\"#inline-no-sanitize\"><code class=\"hljs\">inline_no_sanitize</code></a></li>\n<li><a href=\"#internal-features\"><code class=\"hljs\">internal_features</code></a></li>\n<li><a href=\"#invalid-from-utf8\"><code class=\"hljs\">invalid_from_utf8</code></a></li>\n<li><a href=\"#invalid-macro-export-arguments\"><code class=\"hljs\">invalid_macro_export_arguments</code></a></li>\n<li><a href=\"#invalid-nan-comparisons\"><code class=\"hljs\">invalid_nan_comparisons</code></a></li>\n<li><a href=\"#invalid-value\"><code class=\"hljs\">invalid_value</code></a></li>\n<li><a href=\"#irrefutable-let-patterns\"><code class=\"hljs\">irrefutable_let_patterns</code></a></li>\n<li><a href=\"#large-assignments\"><code class=\"hljs\">large_assignments</code></a></li>\n<li><a href=\"#late-bound-lifetime-arguments\"><code class=\"hljs\">late_bound_lifetime_arguments</code></a></li>\n<li><a href=\"#legacy-derive-helpers\"><code class=\"hljs\">legacy_derive_helpers</code></a></li>\n<li><a href=\"#map-unit-fn\"><code class=\"hljs\">map_unit_fn</code></a></li>\n<li><a href=\"#mixed-script-confusables\"><code class=\"hljs\">mixed_script_confusables</code></a></li>\n<li><a href=\"#named-arguments-used-positionally\"><code class=\"hljs\">named_arguments_used_positionally</code></a></li>\n<li><a href=\"#never-type-fallback-flowing-into-unsafe\"><code class=\"hljs\">never_type_fallback_flowing_into_unsafe</code></a></li>\n<li><a href=\"#no-mangle-generic-items\"><code class=\"hljs\">no_mangle_generic_items</code></a></li>\n<li><a href=\"#non-fmt-panic\"><code class=\"hljs\">non-fmt-panic</code></a></li>\n<li><a href=\"#non-camel-case-types\"><code class=\"hljs\">non_camel_case_types</code></a></li>\n<li><a href=\"#non-contiguous-range-endpoints\"><code class=\"hljs\">non_contiguous_range_endpoints</code></a></li>\n<li><a href=\"#non-fmt-panics\"><code class=\"hljs\">non_fmt_panics</code></a></li>\n<li><a href=\"#non-shorthand-field-patterns\"><code class=\"hljs\">non_shorthand_field_patterns</code></a></li>\n<li><a href=\"#non-snake-case\"><code class=\"hljs\">non_snake_case</code></a></li>\n<li><a href=\"#non-upper-case-globals\"><code class=\"hljs\">non_upper_case_globals</code></a></li>\n<li><a href=\"#noop-method-call\"><code class=\"hljs\">noop_method_call</code></a></li>\n<li><a href=\"#opaque-hidden-inferred-bound\"><code class=\"hljs\">opaque_hidden_inferred_bound</code></a></li>\n<li><a href=\"#overlapping-patterns\"><code class=\"hljs\">overlapping-patterns</code></a></li>\n<li><a href=\"#overlapping-range-endpoints\"><code class=\"hljs\">overlapping_range_endpoints</code></a></li>\n<li><a href=\"#path-statements\"><code class=\"hljs\">path_statements</code></a></li>\n<li><a href=\"#private-bounds\"><code class=\"hljs\">private_bounds</code></a></li>\n<li><a href=\"#private-interfaces\"><code class=\"hljs\">private_interfaces</code></a></li>\n<li><a href=\"#private-macro-use\"><code class=\"hljs\">private_macro_use</code></a></li>\n<li><a href=\"#redundant-semicolon\"><code class=\"hljs\">redundant-semicolon</code></a></li>\n<li><a href=\"#redundant-semicolons\"><code class=\"hljs\">redundant_semicolons</code></a></li>\n<li><a href=\"#refining-impl-trait-internal\"><code class=\"hljs\">refining_impl_trait_internal</code></a></li>\n<li><a href=\"#refining-impl-trait-reachable\"><code class=\"hljs\">refining_impl_trait_reachable</code></a></li>\n<li><a href=\"#renamed-and-removed-lints\"><code class=\"hljs\">renamed_and_removed_lints</code></a></li>\n<li><a href=\"#repr-transparent-external-private-fields\"><code class=\"hljs\">repr_transparent_external_private_fields</code></a></li>\n<li><a href=\"#self-constructor-from-outer-item\"><code class=\"hljs\">self_constructor_from_outer_item</code></a></li>\n<li><a href=\"#semicolon-in-expressions-from-macros\"><code class=\"hljs\">semicolon_in_expressions_from_macros</code></a></li>\n<li><a href=\"#special-module-name\"><code class=\"hljs\">special_module_name</code></a></li>\n<li><a href=\"#stable-features\"><code class=\"hljs\">stable_features</code></a></li>\n<li><a href=\"#static-mut-ref\"><code class=\"hljs\">static-mut-ref</code></a></li>\n<li><a href=\"#static-mut-refs\"><code class=\"hljs\">static_mut_refs</code></a></li>\n<li><a href=\"#suspicious-double-ref-op\"><code class=\"hljs\">suspicious_double_ref_op</code></a></li>\n<li><a href=\"#temporary-cstring-as-ptr\"><code class=\"hljs\">temporary_cstring_as_ptr</code></a></li>\n<li><a href=\"#trivial-bounds\"><code class=\"hljs\">trivial_bounds</code></a></li>\n<li><a href=\"#type-alias-bounds\"><code class=\"hljs\">type_alias_bounds</code></a></li>\n<li><a href=\"#tyvar-behind-raw-pointer\"><code class=\"hljs\">tyvar_behind_raw_pointer</code></a></li>\n<li><a href=\"#uncommon-codepoints\"><code class=\"hljs\">uncommon_codepoints</code></a></li>\n<li><a href=\"#unconditional-recursion\"><code class=\"hljs\">unconditional_recursion</code></a></li>\n<li><a href=\"#uncovered-param-in-projection\"><code class=\"hljs\">uncovered_param_in_projection</code></a></li>\n<li><a href=\"#undefined-naked-function-abi\"><code class=\"hljs\">undefined_naked_function_abi</code></a></li>\n<li><a href=\"#unexpected-cfgs\"><code class=\"hljs\">unexpected_cfgs</code></a></li>\n<li><a href=\"#unfulfilled-lint-expectations\"><code class=\"hljs\">unfulfilled_lint_expectations</code></a></li>\n<li><a href=\"#ungated-async-fn-track-caller\"><code class=\"hljs\">ungated_async_fn_track_caller</code></a></li>\n<li><a href=\"#uninhabited-static\"><code class=\"hljs\">uninhabited_static</code></a></li>\n<li><a href=\"#unknown-lints\"><code class=\"hljs\">unknown_lints</code></a></li>\n<li><a href=\"#unknown-or-malformed-diagnostic-attributes\"><code class=\"hljs\">unknown_or_malformed_diagnostic_attributes</code></a></li>\n<li><a href=\"#unnameable-test-items\"><code class=\"hljs\">unnameable_test_items</code></a></li>\n<li><a href=\"#unreachable-code\"><code class=\"hljs\">unreachable_code</code></a></li>\n<li><a href=\"#unreachable-patterns\"><code class=\"hljs\">unreachable_patterns</code></a></li>\n<li><a href=\"#unstable-name-collision\"><code class=\"hljs\">unstable-name-collision</code></a></li>\n<li><a href=\"#unstable-name-collisions\"><code class=\"hljs\">unstable_name_collisions</code></a></li>\n<li><a href=\"#unstable-syntax-pre-expansion\"><code class=\"hljs\">unstable_syntax_pre_expansion</code></a></li>\n<li><a href=\"#unsupported-calling-conventions\"><code class=\"hljs\">unsupported_calling_conventions</code></a></li>\n<li><a href=\"#unused-doc-comment\"><code class=\"hljs\">unused-doc-comment</code></a></li>\n<li><a href=\"#unused-tuple-struct-fields\"><code class=\"hljs\">unused-tuple-struct-fields</code></a></li>\n<li><a href=\"#unused-allocation\"><code class=\"hljs\">unused_allocation</code></a></li>\n<li><a href=\"#unused-assignments\"><code class=\"hljs\">unused_assignments</code></a></li>\n<li><a href=\"#unused-associated-type-bounds\"><code class=\"hljs\">unused_associated_type_bounds</code></a></li>\n<li><a href=\"#unused-attributes\"><code class=\"hljs\">unused_attributes</code></a></li>\n<li><a href=\"#unused-braces\"><code class=\"hljs\">unused_braces</code></a></li>\n<li><a href=\"#unused-comparisons\"><code class=\"hljs\">unused_comparisons</code></a></li>\n<li><a href=\"#unused-doc-comments\"><code class=\"hljs\">unused_doc_comments</code></a></li>\n<li><a href=\"#unused-features\"><code class=\"hljs\">unused_features</code></a></li>\n<li><a href=\"#unused-imports\"><code class=\"hljs\">unused_imports</code></a></li>\n<li><a href=\"#unused-labels\"><code class=\"hljs\">unused_labels</code></a></li>\n<li><a href=\"#unused-macros\"><code class=\"hljs\">unused_macros</code></a></li>\n<li><a href=\"#unused-must-use\"><code class=\"hljs\">unused_must_use</code></a></li>\n<li><a href=\"#unused-mut\"><code class=\"hljs\">unused_mut</code></a></li>\n<li><a href=\"#unused-parens\"><code class=\"hljs\">unused_parens</code></a></li>\n<li><a href=\"#unused-unsafe\"><code class=\"hljs\">unused_unsafe</code></a></li>\n<li><a href=\"#unused-variables\"><code class=\"hljs\">unused_variables</code></a></li>\n<li><a href=\"#useless-ptr-null-checks\"><code class=\"hljs\">useless_ptr_null_checks</code></a></li>\n<li><a href=\"#warnings\"><code class=\"hljs\">warnings</code></a></li>\n<li><a href=\"#wasm-c-abi\"><code class=\"hljs\">wasm_c_abi</code></a></li>\n<li><a href=\"#while-true\"><code class=\"hljs\">while_true</code></a></li>\n<li><a href=\"#writes-through-immutable-pointer\"><code class=\"hljs\">writes_through_immutable_pointer</code></a></li>\n</ul>\n<h2 id=\"ambiguous-glob-imports\"><a class=\"header\" href=\"#ambiguous-glob-imports\">ambiguous-glob-imports</a></h2>\n<p>The <code class=\"hljs\">ambiguous_glob_imports</code> lint detects glob imports that should report ambiguity\nerrors, but previously didn't do that due to rustc bugs.</p>\n<h3 id=\"example\"><a class=\"header\" href=\"#example\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(ambiguous_glob_imports)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() -&gt; <span class=\"hljs-built_in\">u32</span> {\n    <span class=\"hljs-keyword\">use</span> sub::*;\n    C\n}\n\n<span class=\"hljs-keyword\">mod</span> sub {\n    <span class=\"hljs-keyword\">mod</span> mod1 { <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">const</span> C: <span class=\"hljs-built_in\">u32</span> = <span class=\"hljs-number\">1</span>; }\n    <span class=\"hljs-keyword\">mod</span> mod2 { <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">const</span> C: <span class=\"hljs-built_in\">u32</span> = <span class=\"hljs-number\">2</span>; }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">use</span> mod1::*;\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">use</span> mod2::*;\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: `C` is ambiguous\n  --&gt; lint_example.rs:5:5\n   |\n5  |     C\n   |     ^ ambiguous name\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #114095 &lt;https://github.com/rust-lang/rust/issues/114095&gt;\n   = note: ambiguous because of multiple glob imports of a name in the same module\nnote: `C` could refer to the constant imported here\n  --&gt; lint_example.rs:12:13\n   |\n12 |     pub use mod1::*;\n   |             ^^^^^^^\n   = help: consider adding an explicit import of `C` to disambiguate\nnote: `C` could also refer to the constant imported here\n  --&gt; lint_example.rs:13:13\n   |\n13 |     pub use mod2::*;\n   |             ^^^^^^^\n   = help: consider adding an explicit import of `C` to disambiguate\nnote: the lint level is defined here\n  --&gt; lint_example.rs:1:9\n   |\n1  | #![deny(ambiguous_glob_imports)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation\"><a class=\"header\" href=\"#explanation\">Explanation</a></h3>\n<p>Previous versions of Rust compile it successfully because it\nhad lost the ambiguity error when resolve <code class=\"hljs\">use sub::mod2::*</code>.</p>\n<p>This is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to transition this to a\nhard error in the future.</p>\n<h2 id=\"ambiguous-glob-reexports\"><a class=\"header\" href=\"#ambiguous-glob-reexports\">ambiguous-glob-reexports</a></h2>\n<p>The <code class=\"hljs\">ambiguous_glob_reexports</code> lint detects cases where names re-exported via globs\ncollide. Downstream users trying to use the same name re-exported from multiple globs\nwill receive a warning pointing out redefinition of the same name.</p>\n<h3 id=\"example-1\"><a class=\"header\" href=\"#example-1\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(ambiguous_glob_reexports)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">mod</span> foo {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">X</span></span> = <span class=\"hljs-built_in\">u8</span>;\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">mod</span> bar {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Y</span></span> = <span class=\"hljs-built_in\">u8</span>;\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">X</span></span> = <span class=\"hljs-built_in\">u8</span>;\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">use</span> foo::*;\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">use</span> bar::*;\n\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: ambiguous glob re-exports\n  --&gt; lint_example.rs:11:9\n   |\n11 | pub use foo::*;\n   |         ^^^^^^ the name `X` in the type namespace is first re-exported here\n12 | pub use bar::*;\n   |         ------ but the name `X` in the type namespace is also re-exported here\n   |\nnote: the lint level is defined here\n  --&gt; lint_example.rs:1:9\n   |\n1  | #![deny(ambiguous_glob_reexports)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-1\"><a class=\"header\" href=\"#explanation-1\">Explanation</a></h3>\n<p>This was previously accepted but it could silently break a crate's downstream users code.\nFor example, if <code class=\"hljs\">foo::*</code> and <code class=\"hljs\">bar::*</code> were re-exported before <code class=\"hljs\">bar::X</code> was added to the\nre-exports, down stream users could use <code class=\"hljs\">this_crate::X</code> without problems. However, adding\n<code class=\"hljs\">bar::X</code> would cause compilation errors in downstream crates because <code class=\"hljs\">X</code> is defined\nmultiple times in the same namespace of <code class=\"hljs\">this_crate</code>.</p>\n<h2 id=\"ambiguous-wide-pointer-comparisons\"><a class=\"header\" href=\"#ambiguous-wide-pointer-comparisons\">ambiguous-wide-pointer-comparisons</a></h2>\n<p>The <code class=\"hljs\">ambiguous_wide_pointer_comparisons</code> lint checks comparison\nof <code class=\"hljs\">*const/*mut ?Sized</code> as the operands.</p>\n<h3 id=\"example-2\"><a class=\"header\" href=\"#example-2\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">A</span></span>;\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">B</span></span>;\n</span>\n<span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">T</span></span> {}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> T <span class=\"hljs-keyword\">for</span> A {}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> T <span class=\"hljs-keyword\">for</span> B {}\n</span>\n<span class=\"hljs-keyword\">let</span> ab = (A, B);\n<span class=\"hljs-keyword\">let</span> a = &amp;ab.<span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">dyn</span> T;\n<span class=\"hljs-keyword\">let</span> b = &amp;ab.<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">dyn</span> T;\n\n<span class=\"hljs-keyword\">let</span> _ = a == b;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: ambiguous wide pointer comparison, the comparison includes metadata which may not be expected\n  --&gt; lint_example.rs:13:9\n   |\n13 | let _ = a == b;\n   |         ^^^^^^\n   |\n   = note: `#[warn(ambiguous_wide_pointer_comparisons)]` on by default\nhelp: use `std::ptr::addr_eq` or untyped pointers to only compare their addresses\n   |\n13 | let _ = std::ptr::addr_eq(a, b);\n   |         ++++++++++++++++++ ~  +\n\n</code></pre>\n<h3 id=\"explanation-2\"><a class=\"header\" href=\"#explanation-2\">Explanation</a></h3>\n<p>The comparison includes metadata which may not be expected.</p>\n<h2 id=\"anonymous-parameters\"><a class=\"header\" href=\"#anonymous-parameters\">anonymous-parameters</a></h2>\n<p>The <code class=\"hljs\">anonymous_parameters</code> lint detects anonymous parameters in trait\ndefinitions.</p>\n<h3 id=\"example-3\"><a class=\"header\" href=\"#example-3\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust edition2015 compile_fail hljs\"><span class=\"hljs-meta\">#![deny(anonymous_parameters)]</span>\n<span class=\"hljs-comment\">// edition 2015</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(<span class=\"hljs-built_in\">usize</span>);\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: anonymous parameters are deprecated and will be removed in the next edition\n --&gt; lint_example.rs:4:12\n  |\n4 |     fn foo(usize);\n  |            ^^^^^ help: try naming the parameter or explicitly ignoring it: `_: usize`\n  |\n  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n  = note: for more information, see issue #41686 &lt;https://github.com/rust-lang/rust/issues/41686&gt;\nnote: the lint level is defined here\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(anonymous_parameters)]\n  |         ^^^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-3\"><a class=\"header\" href=\"#explanation-3\">Explanation</a></h3>\n<p>This syntax is mostly a historical accident, and can be worked around\nquite easily by adding an <code class=\"hljs\">_</code> pattern or a descriptive identifier:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(_: <span class=\"hljs-built_in\">usize</span>);\n}</code></pre>\n<p>This syntax is now a hard error in the 2018 edition. In the 2015\nedition, this lint is \"warn\" by default. This lint\nenables the <a href=\"https://doc.rust-lang.org/cargo/commands/cargo-fix.html\"><code class=\"hljs\">cargo fix</code></a> tool with the <code class=\"hljs\">--edition</code> flag to\nautomatically transition old code from the 2015 edition to 2018. The\ntool will run this lint and automatically apply the\nsuggested fix from the compiler (which is to add <code class=\"hljs\">_</code> to each\nparameter). This provides a completely automated way to update old\ncode for a new edition. See <a href=\"https://github.com/rust-lang/rust/issues/41686\">issue #41686</a> for more details.</p>\n<h2 id=\"array-into-iter\"><a class=\"header\" href=\"#array-into-iter\">array-into-iter</a></h2>\n<p>The <code class=\"hljs\">array_into_iter</code> lint detects calling <code class=\"hljs\">into_iter</code> on arrays.</p>\n<h3 id=\"example-4\"><a class=\"header\" href=\"#example-4\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2018 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].into_iter().for_each(|n| { *n; });</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: this method call resolves to `&lt;&amp;[T; N] as IntoIterator&gt;::into_iter` (due to backwards compatibility), but will resolve to `&lt;[T; N] as IntoIterator&gt;::into_iter` in Rust 2021\n --&gt; lint_example.rs:3:11\n  |\n3 | [1, 2, 3].into_iter().for_each(|n| { *n; });\n  |           ^^^^^^^^^\n  |\n  = warning: this changes meaning in Rust 2021\n  = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html&gt;\n  = note: `#[warn(array_into_iter)]` on by default\nhelp: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n  |\n3 | [1, 2, 3].iter().for_each(|n| { *n; });\n  |           ~~~~\nhelp: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n  |\n3 | IntoIterator::into_iter([1, 2, 3]).for_each(|n| { *n; });\n  | ++++++++++++++++++++++++         ~\n\n</code></pre>\n<h3 id=\"explanation-4\"><a class=\"header\" href=\"#explanation-4\">Explanation</a></h3>\n<p>Since Rust 1.53, arrays implement <code class=\"hljs\">IntoIterator</code>. However, to avoid\nbreakage, <code class=\"hljs\">array.into_iter()</code> in Rust 2015 and 2018 code will still\nbehave as <code class=\"hljs\">(&amp;array).into_iter()</code>, returning an iterator over\nreferences, just like in Rust 1.52 and earlier.\nThis only applies to the method call syntax <code class=\"hljs\">array.into_iter()</code>, not to\nany other syntax such as <code class=\"hljs\">for _ in array</code> or <code class=\"hljs\">IntoIterator::into_iter(array)</code>.</p>\n<h2 id=\"asm-sub-register\"><a class=\"header\" href=\"#asm-sub-register\">asm-sub-register</a></h2>\n<p>The <code class=\"hljs\">asm_sub_register</code> lint detects using only a subset of a register\nfor inline asm inputs.</p>\n<h3 id=\"example-5\"><a class=\"header\" href=\"#example-5\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (fails on non-x86_64) hljs\"><span class=\"hljs-meta\">#[cfg(target_arch=<span class=\"hljs-meta-string\">\"x86_64\"</span>)]</span>\n<span class=\"hljs-keyword\">use</span> std::arch::asm;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-meta\">#[cfg(target_arch=<span class=\"hljs-meta-string\">\"x86_64\"</span>)]</span>\n    <span class=\"hljs-keyword\">unsafe</span> {\n        asm!(<span class=\"hljs-string\">\"mov {0}, {0}\"</span>, <span class=\"hljs-keyword\">in</span>(reg) <span class=\"hljs-number\">0i16</span>);\n    }\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: formatting may not be suitable for sub-register argument\n --&gt; src/main.rs:7:19\n  |\n7 |         asm!(\"mov {0}, {0}\", in(reg) 0i16);\n  |                   ^^^  ^^^           ---- for this argument\n  |\n  = note: `#[warn(asm_sub_register)]` on by default\n  = help: use the `x` modifier to have the register formatted as `ax`\n  = help: or use the `r` modifier to keep the default formatting of `rax`\n</code></pre>\n<h3 id=\"explanation-5\"><a class=\"header\" href=\"#explanation-5\">Explanation</a></h3>\n<p>Registers on some architectures can use different names to refer to a\nsubset of the register. By default, the compiler will use the name for\nthe full register size. To explicitly use a subset of the register,\nyou can override the default by using a modifier on the template\nstring operand to specify when subregister to use. This lint is issued\nif you pass in a value with a smaller data type than the default\nregister size, to alert you of possibly using the incorrect width. To\nfix this, add the suggested modifier to the template, or cast the\nvalue to the correct size.</p>\n<p>See <a href=\"https://doc.rust-lang.org/nightly/reference/inline-assembly.html#template-modifiers\">register template modifiers</a> in the reference for more details.</p>\n<h2 id=\"async-fn-in-trait\"><a class=\"header\" href=\"#async-fn-in-trait\">async-fn-in-trait</a></h2>\n<p>The <code class=\"hljs\">async_fn_in_trait</code> lint detects use of <code class=\"hljs\">async fn</code> in the\ndefinition of a publicly-reachable trait.</p>\n<h3 id=\"example-6\"><a class=\"header\" href=\"#example-6\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">method</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified\n --&gt; lint_example.rs:2:5\n  |\n2 |     async fn method(&amp;self);\n  |     ^^^^^\n  |\n  = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`\n  = note: `#[warn(async_fn_in_trait)]` on by default\nhelp: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change\n  |\n2 -     async fn method(&amp;self);\n2 +     fn method(&amp;self) -&gt; impl std::future::Future&lt;Output = ()&gt; + Send;\n  |\n\n</code></pre>\n<h3 id=\"explanation-6\"><a class=\"header\" href=\"#explanation-6\">Explanation</a></h3>\n<p>When <code class=\"hljs\">async fn</code> is used in a trait definition, the trait does not\npromise that the opaque <a href=\"https://doc.rust-lang.org/core/future/trait.Future.html\"><code class=\"hljs\">Future</code></a> returned by the associated function\nor method will implement any <a href=\"https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits\">auto traits</a> such as <a href=\"https://doc.rust-lang.org/core/marker/trait.Send.html\"><code class=\"hljs\">Send</code></a>. This may\nbe surprising and may make the associated functions or methods on the\ntrait less useful than intended. On traits exposed publicly from a\ncrate, this may affect downstream crates whose authors cannot alter\nthe trait definition.</p>\n<p>For example, this code is invalid:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">method</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">test</span></span>&lt;T: Trait&gt;(x: T) {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">spawn</span></span>&lt;T: <span class=\"hljs-built_in\">Send</span>&gt;(_: T) {}\n    spawn(x.method()); <span class=\"hljs-comment\">// Not OK.</span>\n}</code></pre>\n<p>This lint exists to warn authors of publicly-reachable traits that\nthey may want to consider desugaring the <code class=\"hljs\">async fn</code> to a normal <code class=\"hljs\">fn</code>\nthat returns an opaque <code class=\"hljs\">impl Future&lt;..&gt; + Send</code> type.</p>\n<p>For example, instead of:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">method</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {}\n}</code></pre>\n<p>The author of the trait may want to write:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">use</span> core::future::Future;\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">method</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-keyword\">impl</span> Future&lt;Output = ()&gt; + <span class=\"hljs-built_in\">Send</span> { <span class=\"hljs-keyword\">async</span> {} }\n}</code></pre>\n<p>This still allows the use of <code class=\"hljs\">async fn</code> within impls of the trait.\nHowever, it also means that the trait will never be compatible with\nimpls where the returned <a href=\"https://doc.rust-lang.org/core/future/trait.Future.html\"><code class=\"hljs\">Future</code></a> of the method does not implement\n<code class=\"hljs\">Send</code>.</p>\n<p>Conversely, if the trait is used only locally, if it is never used in\ngeneric functions, or if it is only used in single-threaded contexts\nthat do not care whether the returned <a href=\"https://doc.rust-lang.org/core/future/trait.Future.html\"><code class=\"hljs\">Future</code></a> implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Send.html\"><code class=\"hljs\">Send</code></a>,\nthen the lint may be suppressed.</p>\n<h2 id=\"bad-asm-style\"><a class=\"header\" href=\"#bad-asm-style\">bad-asm-style</a></h2>\n<p>The <code class=\"hljs\">bad_asm_style</code> lint detects the use of the <code class=\"hljs\">.intel_syntax</code> and\n<code class=\"hljs\">.att_syntax</code> directives.</p>\n<h3 id=\"example-7\"><a class=\"header\" href=\"#example-7\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (fails on non-x86_64) hljs\"><span class=\"hljs-meta\">#[cfg(target_arch=<span class=\"hljs-meta-string\">\"x86_64\"</span>)]</span>\n<span class=\"hljs-keyword\">use</span> std::arch::asm;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-meta\">#[cfg(target_arch=<span class=\"hljs-meta-string\">\"x86_64\"</span>)]</span>\n    <span class=\"hljs-keyword\">unsafe</span> {\n        asm!(\n            <span class=\"hljs-string\">\".att_syntax\"</span>,\n            <span class=\"hljs-string\">\"movq %{0}, %{0}\"</span>, <span class=\"hljs-keyword\">in</span>(reg) <span class=\"hljs-number\">0usize</span>\n        );\n    }\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: avoid using `.att_syntax`, prefer using `options(att_syntax)` instead\n --&gt; src/main.rs:8:14\n  |\n8 |             \".att_syntax\",\n  |              ^^^^^^^^^^^\n  |\n  = note: `#[warn(bad_asm_style)]` on by default\n</code></pre>\n<h3 id=\"explanation-7\"><a class=\"header\" href=\"#explanation-7\">Explanation</a></h3>\n<p>On x86, <code class=\"hljs\">asm!</code> uses the intel assembly syntax by default. While this\ncan be switched using assembler directives like <code class=\"hljs\">.att_syntax</code>, using the\n<code class=\"hljs\">att_syntax</code> option is recommended instead because it will also properly\nprefix register placeholders with <code class=\"hljs\">%</code> as required by AT&amp;T syntax.</p>\n<h2 id=\"bare-trait-object\"><a class=\"header\" href=\"#bare-trait-object\">bare-trait-object</a></h2>\n<p>The lint <code class=\"hljs\">bare-trait-object</code> has been renamed to <a href=\"#bare-trait-objects\"><code class=\"hljs\">bare-trait-objects</code></a>.</p>\n<h2 id=\"bare-trait-objects\"><a class=\"header\" href=\"#bare-trait-objects\">bare-trait-objects</a></h2>\n<p>The <code class=\"hljs\">bare_trait_objects</code> lint suggests using <code class=\"hljs\">dyn Trait</code> for trait\nobjects.</p>\n<h3 id=\"example-8\"><a class=\"header\" href=\"#example-8\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust edition2018 hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> { }\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">takes_trait_object</span></span>(_: <span class=\"hljs-built_in\">Box</span>&lt;Trait&gt;) {\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: trait objects without an explicit `dyn` are deprecated\n --&gt; lint_example.rs:4:30\n  |\n4 | fn takes_trait_object(_: Box&lt;Trait&gt;) {\n  |                              ^^^^^\n  |\n  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n  = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html&gt;\n  = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n  |\n4 | fn takes_trait_object(_: Box&lt;dyn Trait&gt;) {\n  |                              +++\n\n</code></pre>\n<h3 id=\"explanation-8\"><a class=\"header\" href=\"#explanation-8\">Explanation</a></h3>\n<p>Without the <code class=\"hljs\">dyn</code> indicator, it can be ambiguous or confusing when\nreading code as to whether or not you are looking at a trait object.\nThe <code class=\"hljs\">dyn</code> keyword makes it explicit, and adds a symmetry to contrast\nwith <a href=\"https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\"><code class=\"hljs\">impl Trait</code></a>.</p>\n<h2 id=\"boxed-slice-into-iter\"><a class=\"header\" href=\"#boxed-slice-into-iter\">boxed-slice-into-iter</a></h2>\n<p>The <code class=\"hljs\">boxed_slice_into_iter</code> lint detects calling <code class=\"hljs\">into_iter</code> on boxed slices.</p>\n<h3 id=\"example-9\"><a class=\"header\" href=\"#example-9\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].into_boxed_slice().into_iter().for_each(|n| { *n; });</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: this method call resolves to `&lt;&amp;Box&lt;[T]&gt; as IntoIterator&gt;::into_iter` (due to backwards compatibility), but will resolve to `&lt;Box&lt;[T]&gt; as IntoIterator&gt;::into_iter` in Rust 2024\n --&gt; lint_example.rs:3:34\n  |\n3 | vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });\n  |                                  ^^^^^^^^^\n  |\n  = warning: this changes meaning in Rust 2024\n  = note: `#[warn(boxed_slice_into_iter)]` on by default\nhelp: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n  |\n3 | vec![1, 2, 3].into_boxed_slice().iter().for_each(|n| { *n; });\n  |                                  ~~~~\nhelp: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n  |\n3 | IntoIterator::into_iter(vec![1, 2, 3].into_boxed_slice()).for_each(|n| { *n; });\n  | ++++++++++++++++++++++++                                ~\n\n</code></pre>\n<h3 id=\"explanation-9\"><a class=\"header\" href=\"#explanation-9\">Explanation</a></h3>\n<p>Since Rust 1.80.0, boxed slices implement <code class=\"hljs\">IntoIterator</code>. However, to avoid\nbreakage, <code class=\"hljs\">boxed_slice.into_iter()</code> in Rust 2015, 2018, and 2021 code will still\nbehave as <code class=\"hljs\">(&amp;boxed_slice).into_iter()</code>, returning an iterator over\nreferences, just like in Rust 1.80.0 and earlier.\nThis only applies to the method call syntax <code class=\"hljs\">boxed_slice.into_iter()</code>, not to\nany other syntax such as <code class=\"hljs\">for _ in boxed_slice</code> or <code class=\"hljs\">IntoIterator::into_iter(boxed_slice)</code>.</p>\n<h2 id=\"break-with-label-and-loop\"><a class=\"header\" href=\"#break-with-label-and-loop\">break-with-label-and-loop</a></h2>\n<p>The <code class=\"hljs\">break_with_label_and_loop</code> lint detects labeled <code class=\"hljs\">break</code> expressions with\nan unlabeled loop as their value expression.</p>\n<h3 id=\"example-10\"><a class=\"header\" href=\"#example-10\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-symbol\">'label</span>: <span class=\"hljs-keyword\">loop</span> {\n    <span class=\"hljs-keyword\">break</span> <span class=\"hljs-symbol\">'label</span> <span class=\"hljs-keyword\">loop</span> { <span class=\"hljs-keyword\">break</span> <span class=\"hljs-number\">42</span>; };\n};</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: this labeled break expression is easy to confuse with an unlabeled break with a labeled value expression\n --&gt; lint_example.rs:3:5\n  |\n3 |     break 'label loop { break 42; };\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(break_with_label_and_loop)]` on by default\nhelp: wrap this expression in parentheses\n  |\n3 |     break 'label (loop { break 42; });\n  |                  +                  +\n\n</code></pre>\n<h3 id=\"explanation-10\"><a class=\"header\" href=\"#explanation-10\">Explanation</a></h3>\n<p>In Rust, loops can have a label, and <code class=\"hljs\">break</code> expressions can refer to that label to\nbreak out of specific loops (and not necessarily the innermost one). <code class=\"hljs\">break</code> expressions\ncan also carry a value expression, which can be another loop. A labeled <code class=\"hljs\">break</code> with an\nunlabeled loop as its value expression is easy to confuse with an unlabeled break with\na labeled loop and is thus discouraged (but allowed for compatibility); use parentheses\naround the loop expression to silence this warning. Unlabeled <code class=\"hljs\">break</code> expressions with\nlabeled loops yield a hard error, which can also be silenced by wrapping the expression\nin parentheses.</p>\n<h2 id=\"byte-slice-in-packed-struct-with-derive\"><a class=\"header\" href=\"#byte-slice-in-packed-struct-with-derive\">byte-slice-in-packed-struct-with-derive</a></h2>\n<p>The <code class=\"hljs\">byte_slice_in_packed_struct_with_derive</code> lint detects cases where a byte slice field\n(<code class=\"hljs\">[u8]</code>) or string slice field (<code class=\"hljs\">str</code>) is used in a <code class=\"hljs\">packed</code> struct that derives one or\nmore built-in traits.</p>\n<h3 id=\"example-11\"><a class=\"header\" href=\"#example-11\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#[repr(packed)]</span>\n<span class=\"hljs-meta\">#[derive(Hash)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">FlexZeroSlice</span></span> {\n    width: <span class=\"hljs-built_in\">u8</span>,\n    data: [<span class=\"hljs-built_in\">u8</span>],\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: byte slice in a packed struct that derives a built-in trait\n --&gt; lint_example.rs:6:5\n  |\n3 | #[derive(Hash)]\n  |          ---- in this derive macro expansion\n...\n6 |     data: [u8],\n  |     ^^^^^^^^^^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #107457 &lt;https://github.com/rust-lang/rust/issues/107457&gt;\n  = help: consider implementing the trait by hand, or remove the `packed` attribute\n  = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n  = note: this warning originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n</code></pre>\n<h3 id=\"explanation-11\"><a class=\"header\" href=\"#explanation-11\">Explanation</a></h3>\n<p>This was previously accepted but is being phased out, because fields in packed structs are\nnow required to implement <code class=\"hljs\">Copy</code> for <code class=\"hljs\">derive</code> to work. Byte slices and string slices are a\ntemporary exception because certain crates depended on them.</p>\n<h2 id=\"clashing-extern-declarations\"><a class=\"header\" href=\"#clashing-extern-declarations\">clashing-extern-declarations</a></h2>\n<p>The <code class=\"hljs\">clashing_extern_declarations</code> lint detects when an <code class=\"hljs\">extern fn</code>\nhas been declared with the same name but different types.</p>\n<h3 id=\"example-12\"><a class=\"header\" href=\"#example-12\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">mod</span> m {\n    <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>();\n    }\n}\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(_: <span class=\"hljs-built_in\">u32</span>);\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: `foo` redeclared with a different signature\n --&gt; lint_example.rs:9:5\n  |\n4 |         fn foo();\n  |         -------- `foo` previously declared here\n...\n9 |     fn foo(_: u32);\n  |     ^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n  |\n  = note: expected `unsafe extern \"C\" fn()`\n             found `unsafe extern \"C\" fn(u32)`\n  = note: `#[warn(clashing_extern_declarations)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-12\"><a class=\"header\" href=\"#explanation-12\">Explanation</a></h3>\n<p>Because two symbols of the same name cannot be resolved to two\ndifferent functions at link time, and one function cannot possibly\nhave two types, a clashing extern declaration is almost certainly a\nmistake. Check to make sure that the <code class=\"hljs\">extern</code> definitions are correct\nand equivalent, and possibly consider unifying them in one location.</p>\n<p>This lint does not run between crates because a project may have\ndependencies which both rely on the same extern function, but declare\nit in a different (but valid) way. For example, they may both declare\nan opaque type for one or more of the arguments (which would end up\ndistinct types), or use types that are valid conversions in the\nlanguage the <code class=\"hljs\">extern fn</code> is defined in. In these cases, the compiler\ncan't say that the clashing declaration is incorrect.</p>\n<h2 id=\"coherence-leak-check\"><a class=\"header\" href=\"#coherence-leak-check\">coherence-leak-check</a></h2>\n<p>The <code class=\"hljs\">coherence_leak_check</code> lint detects conflicting implementations of\na trait that are only distinguished by the old leak-check code.</p>\n<h3 id=\"example-13\"><a class=\"header\" href=\"#example-13\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">SomeTrait</span></span> { }\n<span class=\"hljs-keyword\">impl</span> SomeTrait <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">for</span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">u8</span>) { }\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; SomeTrait <span class=\"hljs-keyword\">for</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">u8</span>) { }</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: conflicting implementations of trait `SomeTrait` for type `for&lt;'a&gt; fn(&amp;'a u8)`\n --&gt; lint_example.rs:4:1\n  |\n3 | impl SomeTrait for for&lt;'a&gt; fn(&amp;'a u8) { }\n  | ------------------------------------- first implementation here\n4 | impl&lt;'a&gt; SomeTrait for fn(&amp;'a u8) { }\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for&lt;'a&gt; fn(&amp;'a u8)`\n  |\n  = warning: the behavior may change in a future release\n  = note: for more information, see issue #56105 &lt;https://github.com/rust-lang/rust/issues/56105&gt;\n  = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n  = note: `#[warn(coherence_leak_check)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-13\"><a class=\"header\" href=\"#explanation-13\">Explanation</a></h3>\n<p>In the past, the compiler would accept trait implementations for\nidentical functions that differed only in where the lifetime binder\nappeared. Due to a change in the borrow checker implementation to fix\nseveral bugs, this is no longer allowed. However, since this affects\nexisting code, this is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to transition this\nto a hard error in the future.</p>\n<p>Code relying on this pattern should introduce \"<a href=\"https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction\">newtypes</a>\",\nlike <code class=\"hljs\">struct Foo(for&lt;'a&gt; fn(&amp;'a u8))</code>.</p>\n<p>See <a href=\"https://github.com/rust-lang/rust/issues/56105\">issue #56105</a> for more details.</p>\n<h2 id=\"confusable-idents\"><a class=\"header\" href=\"#confusable-idents\">confusable-idents</a></h2>\n<p>The <code class=\"hljs\">confusable_idents</code> lint detects visually confusable pairs between\nidentifiers.</p>\n<h3 id=\"example-14\"><a class=\"header\" href=\"#example-14\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-comment\">// Latin Capital Letter E With Caron</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">const</span> Ě: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">// Latin Capital Letter E With Breve</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">const</span> Ĕ: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">2</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: found both `Ě` and `Ĕ` as identifiers, which look alike\n --&gt; lint_example.rs:5:11\n  |\n3 | pub const Ě: i32 = 1;\n  |           - other identifier used here\n4 | // Latin Capital Letter E With Breve\n5 | pub const Ĕ: i32 = 2;\n  |           ^ this identifier can be confused with `Ě`\n  |\n  = note: `#[warn(confusable_idents)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-14\"><a class=\"header\" href=\"#explanation-14\">Explanation</a></h3>\n<p>This lint warns when different identifiers may appear visually similar,\nwhich can cause confusion.</p>\n<p>The confusable detection algorithm is based on <a href=\"https://www.unicode.org/reports/tr39/#Confusable_Detection\">Unicode® Technical\nStandard #39 Unicode Security Mechanisms Section 4 Confusable\nDetection</a>. For every distinct identifier X execute\nthe function <code class=\"hljs\">skeleton(X)</code>. If there exist two distinct identifiers X\nand Y in the same crate where <code class=\"hljs\">skeleton(X) = skeleton(Y)</code> report it.\nThe compiler uses the same mechanism to check if an identifier is too\nsimilar to a keyword.</p>\n<p>Note that the set of confusable characters may change over time.\nBeware that if you \"forbid\" this lint that existing code may fail in\nthe future.</p>\n<h2 id=\"const-eval-mutable-ptr-in-final-value\"><a class=\"header\" href=\"#const-eval-mutable-ptr-in-final-value\">const-eval-mutable-ptr-in-final-value</a></h2>\n<p>The <code class=\"hljs\">const_eval_mutable_ptr_in_final_value</code> lint detects if a mutable pointer\nhas leaked into the final value of a const expression.</p>\n<h3 id=\"example-15\"><a class=\"header\" href=\"#example-15\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">JsValue</span></span> {\n    Undefined,\n    Object(std::cell::Cell&lt;<span class=\"hljs-built_in\">bool</span>&gt;),\n}\n\n<span class=\"hljs-keyword\">impl</span> ::std::ops::<span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> JsValue {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-keyword\">const</span> UNDEFINED: &amp;JsValue = &amp;JsValue::Undefined;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: encountered mutable pointer in final value of constant\n  --&gt; lint_example.rs:10:1\n   |\n10 | const UNDEFINED: &amp;JsValue = &amp;JsValue::Undefined;\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #122153 &lt;https://github.com/rust-lang/rust/issues/122153&gt;\n   = note: `#[warn(const_eval_mutable_ptr_in_final_value)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-15\"><a class=\"header\" href=\"#explanation-15\">Explanation</a></h3>\n<p>In the 1.77 release, the const evaluation machinery adopted some\nstricter rules to reject expressions with values that could\nend up holding mutable references to state stored in static memory\n(which is inherently immutable).</p>\n<p>This is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to ease the transition to an error.\nSee <a href=\"https://github.com/rust-lang/rust/issues/122153\">issue #122153</a> for more details.</p>\n<h2 id=\"const-evaluatable-unchecked\"><a class=\"header\" href=\"#const-evaluatable-unchecked\">const-evaluatable-unchecked</a></h2>\n<p>The <code class=\"hljs\">const_evaluatable_unchecked</code> lint detects a generic constant used\nin a type.</p>\n<h3 id=\"example-16\"><a class=\"header\" href=\"#example-16\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;T&gt;() -&gt; <span class=\"hljs-built_in\">usize</span> {\n    <span class=\"hljs-keyword\">if</span> std::mem::size_of::&lt;*<span class=\"hljs-keyword\">mut</span> T&gt;() &lt; <span class=\"hljs-number\">8</span> { <span class=\"hljs-comment\">// size of *mut T does not depend on T</span>\n        <span class=\"hljs-number\">4</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-number\">8</span>\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">test</span></span>&lt;T&gt;() {\n    <span class=\"hljs-keyword\">let</span> _ = [<span class=\"hljs-number\">0</span>; foo::&lt;T&gt;()];\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: cannot use constants which depend on generic parameters in types\n  --&gt; lint_example.rs:11:17\n   |\n11 |     let _ = [0; foo::&lt;T&gt;()];\n   |                 ^^^^^^^^^^\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #76200 &lt;https://github.com/rust-lang/rust/issues/76200&gt;\n   = note: `#[warn(const_evaluatable_unchecked)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-16\"><a class=\"header\" href=\"#explanation-16\">Explanation</a></h3>\n<p>In the 1.43 release, some uses of generic parameters in array repeat\nexpressions were accidentally allowed. This is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a>\nlint to transition this to a hard error in the future. See <a href=\"https://github.com/rust-lang/rust/issues/76200\">issue\n#76200</a> for a more detailed description and possible fixes.</p>\n<h2 id=\"const-item-mutation\"><a class=\"header\" href=\"#const-item-mutation\">const-item-mutation</a></h2>\n<p>The <code class=\"hljs\">const_item_mutation</code> lint detects attempts to mutate a <code class=\"hljs\">const</code>\nitem.</p>\n<h3 id=\"example-17\"><a class=\"header\" href=\"#example-17\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">const</span> FOO: [<span class=\"hljs-built_in\">i32</span>; <span class=\"hljs-number\">1</span>] = [<span class=\"hljs-number\">0</span>];\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    FOO[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-comment\">// This will print \"[0]\".</span>\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{:?}\"</span>, FOO);\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: attempting to modify a `const` item\n --&gt; lint_example.rs:4:5\n  |\n4 |     FOO[0] = 1;\n  |     ^^^^^^^^^^\n  |\n  = note: each usage of a `const` item creates a new temporary; the original `const` item will not be modified\nnote: `const` item defined here\n --&gt; lint_example.rs:1:1\n  |\n1 | const FOO: [i32; 1] = [0];\n  | ^^^^^^^^^^^^^^^^^^^\n  = note: `#[warn(const_item_mutation)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-17\"><a class=\"header\" href=\"#explanation-17\">Explanation</a></h3>\n<p>Trying to directly mutate a <code class=\"hljs\">const</code> item is almost always a mistake.\nWhat is happening in the example above is that a temporary copy of the\n<code class=\"hljs\">const</code> is mutated, but the original <code class=\"hljs\">const</code> is not. Each time you\nrefer to the <code class=\"hljs\">const</code> by name (such as <code class=\"hljs\">FOO</code> in the example above), a\nseparate copy of the value is inlined at that location.</p>\n<p>This lint checks for writing directly to a field (<code class=\"hljs\">FOO.field = some_value</code>) or array entry (<code class=\"hljs\">FOO[0] = val</code>), or taking a mutable\nreference to the const item (<code class=\"hljs\">&amp;mut FOO</code>), including through an\nautoderef (<code class=\"hljs\">FOO.some_mut_self_method()</code>).</p>\n<p>There are various alternatives depending on what you are trying to\naccomplish:</p>\n<ul>\n<li>First, always reconsider using mutable globals, as they can be\ndifficult to use correctly, and can make the code more difficult to\nuse or understand.</li>\n<li>If you are trying to perform a one-time initialization of a global:\n<ul>\n<li>If the value can be computed at compile-time, consider using\nconst-compatible values (see <a href=\"https://doc.rust-lang.org/reference/const_eval.html\">Constant Evaluation</a>).</li>\n<li>For more complex single-initialization cases, consider using\n<a href=\"https://doc.rust-lang.org/stable/std/sync/struct.LazyLock.html\"><code class=\"hljs\">std::sync::LazyLock</code></a>.</li>\n</ul>\n</li>\n<li>If you truly need a mutable global, consider using a <a href=\"https://doc.rust-lang.org/reference/items/static-items.html\"><code class=\"hljs\">static</code></a>,\nwhich has a variety of options:\n<ul>\n<li>Simple data types can be directly defined and mutated with an\n<a href=\"https://doc.rust-lang.org/std/sync/atomic/index.html\"><code class=\"hljs\">atomic</code></a> type.</li>\n<li>More complex types can be placed in a synchronization primitive\nlike a <a href=\"https://doc.rust-lang.org/std/sync/struct.Mutex.html\"><code class=\"hljs\">Mutex</code></a>, which can be initialized with one of the options\nlisted above.</li>\n<li>A <a href=\"https://doc.rust-lang.org/reference/items/static-items.html#mutable-statics\">mutable <code class=\"hljs\">static</code></a> is a low-level primitive, requiring unsafe.\nTypically This should be avoided in preference of something\nhigher-level like one of the above.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"dead-code\"><a class=\"header\" href=\"#dead-code\">dead-code</a></h2>\n<p>The <code class=\"hljs\">dead_code</code> lint detects unused, unexported items.</p>\n<h3 id=\"example-18\"><a class=\"header\" href=\"#example-18\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: function `foo` is never used\n --&gt; lint_example.rs:2:4\n  |\n2 | fn foo() {}\n  |    ^^^\n  |\n  = note: `#[warn(dead_code)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-18\"><a class=\"header\" href=\"#explanation-18\">Explanation</a></h3>\n<p>Dead code may signal a mistake or unfinished code. To silence the\nwarning for individual items, prefix the name with an underscore such\nas <code class=\"hljs\">_foo</code>. If it was intended to expose the item outside of the crate,\nconsider adding a visibility modifier like <code class=\"hljs\">pub</code>.</p>\n<p>To preserve the numbering of tuple structs with unused fields,\nchange the unused fields to have unit type or use\n<code class=\"hljs\">PhantomData</code>.</p>\n<p>Otherwise consider removing the unused code.</p>\n<h3 id=\"limitations\"><a class=\"header\" href=\"#limitations\">Limitations</a></h3>\n<p>Removing fields that are only used for side-effects and never\nread will result in behavioral changes. Examples of this\ninclude:</p>\n<ul>\n<li>If a field's value performs an action when it is dropped.</li>\n<li>If a field's type does not implement an auto trait\n(e.g. <code class=\"hljs\">Send</code>, <code class=\"hljs\">Sync</code>, <code class=\"hljs\">Unpin</code>).</li>\n</ul>\n<p>For side-effects from dropping field values, this lint should\nbe allowed on those fields. For side-effects from containing\nfield types, <code class=\"hljs\">PhantomData</code> should be used.</p>\n<h2 id=\"deprecated\"><a class=\"header\" href=\"#deprecated\">deprecated</a></h2>\n<p>The <code class=\"hljs\">deprecated</code> lint detects use of deprecated items.</p>\n<h3 id=\"example-19\"><a class=\"header\" href=\"#example-19\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#[deprecated]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bar</span></span>() {\n    foo();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: use of deprecated function `main::foo`\n --&gt; lint_example.rs:6:5\n  |\n6 |     foo();\n  |     ^^^\n  |\n  = note: `#[warn(deprecated)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-19\"><a class=\"header\" href=\"#explanation-19\">Explanation</a></h3>\n<p>Items may be marked \"deprecated\" with the <a href=\"https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute\"><code class=\"hljs\">deprecated</code> attribute</a> to\nindicate that they should no longer be used. Usually the attribute\nshould include a note on what to use instead, or check the\ndocumentation.</p>\n<h2 id=\"deprecated-where-clause-location\"><a class=\"header\" href=\"#deprecated-where-clause-location\">deprecated-where-clause-location</a></h2>\n<p>The <code class=\"hljs\">deprecated_where_clause_location</code> lint detects when a where clause in front of the equals\nin an associated type.</p>\n<h3 id=\"example-20\"><a class=\"header\" href=\"#example-20\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Assoc</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">Self</span>: <span class=\"hljs-symbol\">'a</span>;\n}\n\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> () {\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Assoc</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">Self</span>: <span class=\"hljs-symbol\">'a</span> = ();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: where clause not allowed here\n --&gt; lint_example.rs:7:18\n  |\n7 |   type Assoc&lt;'a&gt; where Self: 'a = ();\n  |                  ^^^^^^^^^^^^^^\n  |\n  = note: see issue #89122 &lt;https://github.com/rust-lang/rust/issues/89122&gt; for more information\n  = note: `#[warn(deprecated_where_clause_location)]` on by default\nhelp: move it to the end of the type declaration\n  |\n7 -   type Assoc&lt;'a&gt; where Self: 'a = ();\n7 +   type Assoc&lt;'a&gt;  = () where Self: 'a;\n  |\n\n</code></pre>\n<h3 id=\"explanation-20\"><a class=\"header\" href=\"#explanation-20\">Explanation</a></h3>\n<p>The preferred location for where clauses on associated types\nis after the type. However, for most of generic associated types development,\nit was only accepted before the equals. To provide a transition period and\nfurther evaluate this change, both are currently accepted. At some point in\nthe future, this may be disallowed at an edition boundary; but, that is\nundecided currently.</p>\n<h2 id=\"deref-into-dyn-supertrait\"><a class=\"header\" href=\"#deref-into-dyn-supertrait\">deref-into-dyn-supertrait</a></h2>\n<p>The <code class=\"hljs\">deref_into_dyn_supertrait</code> lint is output whenever there is a use of the\n<code class=\"hljs\">Deref</code> implementation with a <code class=\"hljs\">dyn SuperTrait</code> type as <code class=\"hljs\">Output</code>.</p>\n<p>These implementations will become shadowed when the <code class=\"hljs\">trait_upcasting</code> feature is stabilized.\nThe <code class=\"hljs\">deref</code> functions will no longer be called implicitly, so there might be behavior change.</p>\n<h3 id=\"example-21\"><a class=\"header\" href=\"#example-21\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(deref_into_dyn_supertrait)]</span>\n<span class=\"hljs-meta\">#![allow(dead_code)]</span>\n\n<span class=\"hljs-keyword\">use</span> core::ops::Deref;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">A</span></span> {}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">B</span></span>: A {}\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; Deref <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-symbol\">'a</span> + B {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Target</span></span> = <span class=\"hljs-keyword\">dyn</span> A;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">deref</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;Self::Target {\n        todo!()\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">take_a</span></span>(_: &amp;<span class=\"hljs-keyword\">dyn</span> A) { }\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">take_b</span></span>(b: &amp;<span class=\"hljs-keyword\">dyn</span> B) {\n    take_a(b);\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: this `Deref` implementation is covered by an implicit supertrait coercion\n  --&gt; lint_example.rs:9:1\n   |\n9  | impl&lt;'a&gt; Deref for dyn 'a + B {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `dyn B` implements `Deref&lt;Target = dyn A&gt;` which conflicts with supertrait `A`\n10 |     type Target = dyn A;\n   |     -------------------- target type is a supertrait of `dyn B`\n   |\n   = warning: this will change its meaning in a future release!\n   = note: for more information, see issue #89460 &lt;https://github.com/rust-lang/rust/issues/89460&gt;\nnote: the lint level is defined here\n  --&gt; lint_example.rs:1:9\n   |\n1  | #![deny(deref_into_dyn_supertrait)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-21\"><a class=\"header\" href=\"#explanation-21\">Explanation</a></h3>\n<p>The dyn upcasting coercion feature adds new coercion rules, taking priority\nover certain other coercion rules, which will cause some behavior change.</p>\n<h2 id=\"deref-nullptr\"><a class=\"header\" href=\"#deref-nullptr\">deref-nullptr</a></h2>\n<p>The <code class=\"hljs\">deref_nullptr</code> lint detects when an null pointer is dereferenced,\nwhich causes <a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a>.</p>\n<h3 id=\"example-22\"><a class=\"header\" href=\"#example-22\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust no_run hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-keyword\">use</span> std::ptr;\n<span class=\"hljs-keyword\">unsafe</span> {\n    <span class=\"hljs-keyword\">let</span> x = &amp;*ptr::null::&lt;<span class=\"hljs-built_in\">i32</span>&gt;();\n    <span class=\"hljs-keyword\">let</span> x = ptr::addr_of!(*ptr::null::&lt;<span class=\"hljs-built_in\">i32</span>&gt;());\n    <span class=\"hljs-keyword\">let</span> x = *(<span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">i32</span>);\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: dereferencing a null pointer\n --&gt; lint_example.rs:5:14\n  |\n5 |     let x = &amp;*ptr::null::&lt;i32&gt;();\n  |              ^^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed\n  |\n  = note: `#[warn(deref_nullptr)]` on by default\n\n\nwarning: dereferencing a null pointer\n --&gt; lint_example.rs:6:27\n  |\n6 |     let x = ptr::addr_of!(*ptr::null::&lt;i32&gt;());\n  |                           ^^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed\n\n\nwarning: dereferencing a null pointer\n --&gt; lint_example.rs:7:13\n  |\n7 |     let x = *(0 as *const i32);\n  |             ^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed\n\n</code></pre>\n<h3 id=\"explanation-22\"><a class=\"header\" href=\"#explanation-22\">Explanation</a></h3>\n<p>Dereferencing a null pointer causes <a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a> even as a place expression,\nlike <code class=\"hljs\">&amp;*(0 as *const i32)</code> or <code class=\"hljs\">addr_of!(*(0 as *const i32))</code>.</p>\n<h2 id=\"drop-bounds\"><a class=\"header\" href=\"#drop-bounds\">drop-bounds</a></h2>\n<p>The <code class=\"hljs\">drop_bounds</code> lint checks for generics with <code class=\"hljs\">std::ops::Drop</code> as\nbounds.</p>\n<h3 id=\"example-23\"><a class=\"header\" href=\"#example-23\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;T: <span class=\"hljs-built_in\">Drop</span>&gt;() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: bounds on `T: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped\n --&gt; lint_example.rs:2:11\n  |\n2 | fn foo&lt;T: Drop&gt;() {}\n  |           ^^^^\n  |\n  = note: `#[warn(drop_bounds)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-23\"><a class=\"header\" href=\"#explanation-23\">Explanation</a></h3>\n<p>A generic trait bound of the form <code class=\"hljs\">T: Drop</code> is most likely misleading\nand not what the programmer intended (they probably should have used\n<code class=\"hljs\">std::mem::needs_drop</code> instead).</p>\n<p><code class=\"hljs\">Drop</code> bounds do not actually indicate whether a type can be trivially\ndropped or not, because a composite type containing <code class=\"hljs\">Drop</code> types does\nnot necessarily implement <code class=\"hljs\">Drop</code> itself. Naïvely, one might be tempted\nto write an implementation that assumes that a type can be trivially\ndropped while also supplying a specialization for <code class=\"hljs\">T: Drop</code> that\nactually calls the destructor. However, this breaks down e.g. when <code class=\"hljs\">T</code>\nis <code class=\"hljs\">String</code>, which does not implement <code class=\"hljs\">Drop</code> itself but contains a\n<code class=\"hljs\">Vec</code>, which does implement <code class=\"hljs\">Drop</code>, so assuming <code class=\"hljs\">T</code> can be trivially\ndropped would lead to a memory leak here.</p>\n<p>Furthermore, the <code class=\"hljs\">Drop</code> trait only contains one method, <code class=\"hljs\">Drop::drop</code>,\nwhich may not be called explicitly in user code (<code class=\"hljs\">E0040</code>), so there is\nreally no use case for using <code class=\"hljs\">Drop</code> in trait bounds, save perhaps for\nsome obscure corner cases, which can use <code class=\"hljs\">#[allow(drop_bounds)]</code>.</p>\n<h2 id=\"dropping-copy-types\"><a class=\"header\" href=\"#dropping-copy-types\">dropping-copy-types</a></h2>\n<p>The <code class=\"hljs\">dropping_copy_types</code> lint checks for calls to <code class=\"hljs\">std::mem::drop</code> with a value\nthat derives the Copy trait.</p>\n<h3 id=\"example-24\"><a class=\"header\" href=\"#example-24\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> x: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// i32 implements Copy</span>\nstd::mem::<span class=\"hljs-built_in\">drop</span>(x); <span class=\"hljs-comment\">// A copy of x is passed to the function, leaving the</span>\n                   <span class=\"hljs-comment\">// original unaffected</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: calls to `std::mem::drop` with a value that implements `Copy` does nothing\n --&gt; lint_example.rs:3:1\n  |\n3 | std::mem::drop(x); // A copy of x is passed to the function, leaving the\n  | ^^^^^^^^^^^^^^^-^\n  |                |\n  |                argument has type `i32`\n  |\n  = note: `#[warn(dropping_copy_types)]` on by default\nhelp: use `let _ = ...` to ignore the expression or result\n  |\n3 - std::mem::drop(x); // A copy of x is passed to the function, leaving the\n3 + let _ = x; // A copy of x is passed to the function, leaving the\n  |\n\n</code></pre>\n<h3 id=\"explanation-24\"><a class=\"header\" href=\"#explanation-24\">Explanation</a></h3>\n<p>Calling <code class=\"hljs\">std::mem::drop</code> <a href=\"https://doc.rust-lang.org/std/mem/fn.drop.html\">does nothing for types that\nimplement Copy</a>, since the\nvalue will be copied and moved into the function on invocation.</p>\n<h2 id=\"dropping-references\"><a class=\"header\" href=\"#dropping-references\">dropping-references</a></h2>\n<p>The <code class=\"hljs\">dropping_references</code> lint checks for calls to <code class=\"hljs\">std::mem::drop</code> with a reference\ninstead of an owned value.</p>\n<h3 id=\"example-25\"><a class=\"header\" href=\"#example-25\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">operation_that_requires_mutex_to_be_unlocked</span></span>() {} <span class=\"hljs-comment\">// just to make it compile</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> mutex = std::sync::Mutex::new(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// just to make it compile</span>\n</span><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> lock_guard = mutex.lock();\nstd::mem::<span class=\"hljs-built_in\">drop</span>(&amp;lock_guard); <span class=\"hljs-comment\">// Should have been drop(lock_guard), mutex</span>\n<span class=\"hljs-comment\">// still locked</span>\noperation_that_requires_mutex_to_be_unlocked();</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: calls to `std::mem::drop` with a reference instead of an owned value does nothing\n --&gt; lint_example.rs:5:1\n  |\n5 | std::mem::drop(&amp;lock_guard); // Should have been drop(lock_guard), mutex\n  | ^^^^^^^^^^^^^^^-----------^\n  |                |\n  |                argument has type `&amp;Result&lt;MutexGuard&lt;'_, i32&gt;, PoisonError&lt;MutexGuard&lt;'_, i32&gt;&gt;&gt;`\n  |\n  = note: `#[warn(dropping_references)]` on by default\nhelp: use `let _ = ...` to ignore the expression or result\n  |\n5 - std::mem::drop(&amp;lock_guard); // Should have been drop(lock_guard), mutex\n5 + let _ = &amp;lock_guard; // Should have been drop(lock_guard), mutex\n  |\n\n</code></pre>\n<h3 id=\"explanation-25\"><a class=\"header\" href=\"#explanation-25\">Explanation</a></h3>\n<p>Calling <code class=\"hljs\">drop</code> on a reference will only drop the\nreference itself, which is a no-op. It will not call the <code class=\"hljs\">drop</code> method (from\nthe <code class=\"hljs\">Drop</code> trait implementation) on the underlying referenced value, which\nis likely what was intended.</p>\n<h2 id=\"duplicate-macro-attributes\"><a class=\"header\" href=\"#duplicate-macro-attributes\">duplicate-macro-attributes</a></h2>\n<p>The <code class=\"hljs\">duplicate_macro_attributes</code> lint detects when a <code class=\"hljs\">#[test]</code>-like built-in macro\nattribute is duplicated on an item. This lint may trigger on <code class=\"hljs\">bench</code>, <code class=\"hljs\">cfg_eval</code>, <code class=\"hljs\">test</code>\nand <code class=\"hljs\">test_case</code>.</p>\n<h3 id=\"example-26\"><a class=\"header\" href=\"#example-26\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (needs --test) hljs\"><span class=\"hljs-meta\">#[test]</span>\n<span class=\"hljs-meta\">#[test]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: duplicated attribute\n --&gt; src/lib.rs:2:1\n  |\n2 | #[test]\n  | ^^^^^^^\n  |\n  = note: `#[warn(duplicate_macro_attributes)]` on by default\n</code></pre>\n<h3 id=\"explanation-26\"><a class=\"header\" href=\"#explanation-26\">Explanation</a></h3>\n<p>A duplicated attribute may erroneously originate from a copy-paste and the effect of it\nbeing duplicated may not be obvious or desirable.</p>\n<p>For instance, doubling the <code class=\"hljs\">#[test]</code> attributes registers the test to be run twice with no\nchange to its environment.</p>\n<h2 id=\"dyn-drop\"><a class=\"header\" href=\"#dyn-drop\">dyn-drop</a></h2>\n<p>The <code class=\"hljs\">dyn_drop</code> lint checks for trait objects with <code class=\"hljs\">std::ops::Drop</code>.</p>\n<h3 id=\"example-27\"><a class=\"header\" href=\"#example-27\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(_x: <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-built_in\">Drop</span>&gt;) {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: types that do not implement `Drop` can still have drop glue, consider instead using `std::mem::needs_drop` to detect whether a type is trivially dropped\n --&gt; lint_example.rs:2:20\n  |\n2 | fn foo(_x: Box&lt;dyn Drop&gt;) {}\n  |                    ^^^^\n  |\n  = note: `#[warn(dyn_drop)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-27\"><a class=\"header\" href=\"#explanation-27\">Explanation</a></h3>\n<p>A trait object bound of the form <code class=\"hljs\">dyn Drop</code> is most likely misleading\nand not what the programmer intended.</p>\n<p><code class=\"hljs\">Drop</code> bounds do not actually indicate whether a type can be trivially\ndropped or not, because a composite type containing <code class=\"hljs\">Drop</code> types does\nnot necessarily implement <code class=\"hljs\">Drop</code> itself. Naïvely, one might be tempted\nto write a deferred drop system, to pull cleaning up memory out of a\nlatency-sensitive code path, using <code class=\"hljs\">dyn Drop</code> trait objects. However,\nthis breaks down e.g. when <code class=\"hljs\">T</code> is <code class=\"hljs\">String</code>, which does not implement\n<code class=\"hljs\">Drop</code>, but should probably be accepted.</p>\n<p>To write a trait object bound that accepts anything, use a placeholder\ntrait with a blanket implementation.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Placeholder</span></span> {}\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; Placeholder <span class=\"hljs-keyword\">for</span> T {}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(_x: <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Placeholder&gt;) {}</code></pre>\n<h2 id=\"elided-lifetimes-in-associated-constant\"><a class=\"header\" href=\"#elided-lifetimes-in-associated-constant\">elided-lifetimes-in-associated-constant</a></h2>\n<p>The <code class=\"hljs\">elided_lifetimes_in_associated_constant</code> lint detects elided lifetimes\nthat were erroneously allowed in associated constants.</p>\n<h3 id=\"example-28\"><a class=\"header\" href=\"#example-28\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(elided_lifetimes_in_associated_constant)]</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> Foo {\n    <span class=\"hljs-keyword\">const</span> STR: &amp;<span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"hello, world\"</span>;\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: `&amp;` without an explicit lifetime name cannot be used here\n --&gt; lint_example.rs:7:16\n  |\n7 |     const STR: &amp;str = \"hello, world\";\n  |                ^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #115010 &lt;https://github.com/rust-lang/rust/issues/115010&gt;\nnote: the lint level is defined here\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(elided_lifetimes_in_associated_constant)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: use the `'static` lifetime\n  |\n7 |     const STR: &amp;'static str = \"hello, world\";\n  |                 +++++++\n\n</code></pre>\n<h3 id=\"explanation-28\"><a class=\"header\" href=\"#explanation-28\">Explanation</a></h3>\n<p>Previous version of Rust</p>\n<p>Implicit static-in-const behavior was decided <a href=\"https://github.com/rust-lang/rust/issues/38831\">against</a> for associated\nconstants because of ambiguity. This, however, regressed and the compiler\nerroneously treats elided lifetimes in associated constants as lifetime\nparameters on the impl.</p>\n<p>This is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to transition this to a\nhard error in the future.</p>\n<h2 id=\"ellipsis-inclusive-range-patterns\"><a class=\"header\" href=\"#ellipsis-inclusive-range-patterns\">ellipsis-inclusive-range-patterns</a></h2>\n<p>The <code class=\"hljs\">ellipsis_inclusive_range_patterns</code> lint detects the <a href=\"https://doc.rust-lang.org/reference/patterns.html#range-patterns\"><code class=\"hljs\">...</code> range\npattern</a>, which is deprecated.</p>\n<h3 id=\"example-29\"><a class=\"header\" href=\"#example-29\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust edition2018 hljs\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">123</span>;\n<span class=\"hljs-keyword\">match</span> x {\n    <span class=\"hljs-number\">0</span>...<span class=\"hljs-number\">100</span> =&gt; {}\n    _ =&gt; {}\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: `...` range patterns are deprecated\n --&gt; lint_example.rs:4:6\n  |\n4 |     0...100 =&gt; {}\n  |      ^^^ help: use `..=` for an inclusive range\n  |\n  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n  = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html&gt;\n  = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-29\"><a class=\"header\" href=\"#explanation-29\">Explanation</a></h3>\n<p>The <code class=\"hljs\">...</code> range pattern syntax was changed to <code class=\"hljs\">..=</code> to avoid potential\nconfusion with the <a href=\"https://doc.rust-lang.org/reference/expressions/range-expr.html\"><code class=\"hljs\">..</code> range expression</a>. Use the new form instead.</p>\n<h2 id=\"exported-private-dependencies\"><a class=\"header\" href=\"#exported-private-dependencies\">exported-private-dependencies</a></h2>\n<p>The <code class=\"hljs\">exported_private_dependencies</code> lint detects private dependencies\nthat are exposed in a public interface.</p>\n<h3 id=\"example-30\"><a class=\"header\" href=\"#example-30\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (needs-dependency) hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() -&gt; <span class=\"hljs-built_in\">Option</span>&lt;some_private_dependency::Thing&gt; {\n    <span class=\"hljs-literal\">None</span>\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: type `bar::Thing` from private dependency 'bar' in public interface\n --&gt; src/lib.rs:3:1\n  |\n3 | pub fn foo() -&gt; Option&lt;bar::Thing&gt; {\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(exported_private_dependencies)]` on by default\n</code></pre>\n<h3 id=\"explanation-30\"><a class=\"header\" href=\"#explanation-30\">Explanation</a></h3>\n<p>Dependencies can be marked as \"private\" to indicate that they are not\nexposed in the public interface of a crate. This can be used by Cargo\nto independently resolve those dependencies because it can assume it\ndoes not need to unify them with other packages using that same\ndependency. This lint is an indication of a violation of that\ncontract.</p>\n<p>To fix this, avoid exposing the dependency in your public interface.\nOr, switch the dependency to a public dependency.</p>\n<p>Note that support for this is only available on the nightly channel.\nSee <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1977-public-private-dependencies.md\">RFC 1977</a> for more details, as well as the <a href=\"https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#public-dependency\">Cargo documentation</a>.</p>\n<h2 id=\"for-loops-over-fallibles\"><a class=\"header\" href=\"#for-loops-over-fallibles\">for-loops-over-fallibles</a></h2>\n<p>The <code class=\"hljs\">for_loops_over_fallibles</code> lint checks for <code class=\"hljs\">for</code> loops over <code class=\"hljs\">Option</code> or <code class=\"hljs\">Result</code> values.</p>\n<h3 id=\"example-31\"><a class=\"header\" href=\"#example-31\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> opt = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> opt { <span class=\"hljs-comment\">/* ... */</span>}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: for loop over an `Option`. This is more readably written as an `if let` statement\n --&gt; lint_example.rs:3:10\n  |\n3 | for x in opt { /* ... */}\n  |          ^^^\n  |\n  = note: `#[warn(for_loops_over_fallibles)]` on by default\nhelp: to check pattern in a loop use `while let`\n  |\n3 | while let Some(x) = opt { /* ... */}\n  | ~~~~~~~~~~~~~~~ ~~~\nhelp: consider using `if let` to clear intent\n  |\n3 | if let Some(x) = opt { /* ... */}\n  | ~~~~~~~~~~~~ ~~~\n\n</code></pre>\n<h3 id=\"explanation-31\"><a class=\"header\" href=\"#explanation-31\">Explanation</a></h3>\n<p>Both <code class=\"hljs\">Option</code> and <code class=\"hljs\">Result</code> implement <code class=\"hljs\">IntoIterator</code> trait, which allows using them in a <code class=\"hljs\">for</code> loop.\n<code class=\"hljs\">for</code> loop over <code class=\"hljs\">Option</code> or <code class=\"hljs\">Result</code> will iterate either 0 (if the value is <code class=\"hljs\">None</code>/<code class=\"hljs\">Err(_)</code>)\nor 1 time (if the value is <code class=\"hljs\">Some(_)</code>/<code class=\"hljs\">Ok(_)</code>). This is not very useful and is more clearly expressed\nvia <code class=\"hljs\">if let</code>.</p>\n<p><code class=\"hljs\">for</code> loop can also be accidentally written with the intention to call a function multiple times,\nwhile the function returns <code class=\"hljs\">Some(_)</code>, in these cases <code class=\"hljs\">while let</code> loop should be used instead.</p>\n<p>The \"intended\" use of <code class=\"hljs\">IntoIterator</code> implementations for <code class=\"hljs\">Option</code> and <code class=\"hljs\">Result</code> is passing them to\ngeneric code that expects something implementing <code class=\"hljs\">IntoIterator</code>. For example using <code class=\"hljs\">.chain(option)</code>\nto optionally add a value to an iterator.</p>\n<h2 id=\"forbidden-lint-groups\"><a class=\"header\" href=\"#forbidden-lint-groups\">forbidden-lint-groups</a></h2>\n<p>The <code class=\"hljs\">forbidden_lint_groups</code> lint detects violations of\n<code class=\"hljs\">forbid</code> applied to a lint group. Due to a bug in the compiler,\nthese used to be overlooked entirely. They now generate a warning.</p>\n<h3 id=\"example-32\"><a class=\"header\" href=\"#example-32\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![forbid(warnings)]</span>\n<span class=\"hljs-meta\">#![deny(bad_style)]</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: deny(bad_style) incompatible with previous forbid\n --&gt; lint_example.rs:2:9\n  |\n1 | #![forbid(warnings)]\n  |           -------- `forbid` level set here\n2 | #![deny(bad_style)]\n  |         ^^^^^^^^^ overruled by previous forbid\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #81670 &lt;https://github.com/rust-lang/rust/issues/81670&gt;\n  = note: `#[warn(forbidden_lint_groups)]` on by default\n\n</code></pre>\n<h3 id=\"recommended-fix\"><a class=\"header\" href=\"#recommended-fix\">Recommended fix</a></h3>\n<p>If your crate is using <code class=\"hljs\">#![forbid(warnings)]</code>,\nwe recommend that you change to <code class=\"hljs\">#![deny(warnings)]</code>.</p>\n<h3 id=\"explanation-32\"><a class=\"header\" href=\"#explanation-32\">Explanation</a></h3>\n<p>Due to a compiler bug, applying <code class=\"hljs\">forbid</code> to lint groups\npreviously had no effect. The bug is now fixed but instead of\nenforcing <code class=\"hljs\">forbid</code> we issue this future-compatibility warning\nto avoid breaking existing crates.</p>\n<h2 id=\"forgetting-copy-types\"><a class=\"header\" href=\"#forgetting-copy-types\">forgetting-copy-types</a></h2>\n<p>The <code class=\"hljs\">forgetting_copy_types</code> lint checks for calls to <code class=\"hljs\">std::mem::forget</code> with a value\nthat derives the Copy trait.</p>\n<h3 id=\"example-33\"><a class=\"header\" href=\"#example-33\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> x: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// i32 implements Copy</span>\nstd::mem::forget(x); <span class=\"hljs-comment\">// A copy of x is passed to the function, leaving the</span>\n                     <span class=\"hljs-comment\">// original unaffected</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: calls to `std::mem::forget` with a value that implements `Copy` does nothing\n --&gt; lint_example.rs:3:1\n  |\n3 | std::mem::forget(x); // A copy of x is passed to the function, leaving the\n  | ^^^^^^^^^^^^^^^^^-^\n  |                  |\n  |                  argument has type `i32`\n  |\n  = note: `#[warn(forgetting_copy_types)]` on by default\nhelp: use `let _ = ...` to ignore the expression or result\n  |\n3 - std::mem::forget(x); // A copy of x is passed to the function, leaving the\n3 + let _ = x; // A copy of x is passed to the function, leaving the\n  |\n\n</code></pre>\n<h3 id=\"explanation-33\"><a class=\"header\" href=\"#explanation-33\">Explanation</a></h3>\n<p>Calling <code class=\"hljs\">std::mem::forget</code> <a href=\"https://doc.rust-lang.org/std/mem/fn.drop.html\">does nothing for types that\nimplement Copy</a> since the\nvalue will be copied and moved into the function on invocation.</p>\n<p>An alternative, but also valid, explanation is that Copy types do not\nimplement the Drop trait, which means they have no destructors. Without a\ndestructor, there is nothing for <code class=\"hljs\">std::mem::forget</code> to ignore.</p>\n<h2 id=\"forgetting-references\"><a class=\"header\" href=\"#forgetting-references\">forgetting-references</a></h2>\n<p>The <code class=\"hljs\">forgetting_references</code> lint checks for calls to <code class=\"hljs\">std::mem::forget</code> with a reference\ninstead of an owned value.</p>\n<h3 id=\"example-34\"><a class=\"header\" href=\"#example-34\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">1</span>);\nstd::mem::forget(&amp;x); <span class=\"hljs-comment\">// Should have been forget(x), x will still be dropped</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: calls to `std::mem::forget` with a reference instead of an owned value does nothing\n --&gt; lint_example.rs:3:1\n  |\n3 | std::mem::forget(&amp;x); // Should have been forget(x), x will still be dropped\n  | ^^^^^^^^^^^^^^^^^--^\n  |                  |\n  |                  argument has type `&amp;Box&lt;i32&gt;`\n  |\n  = note: `#[warn(forgetting_references)]` on by default\nhelp: use `let _ = ...` to ignore the expression or result\n  |\n3 - std::mem::forget(&amp;x); // Should have been forget(x), x will still be dropped\n3 + let _ = &amp;x; // Should have been forget(x), x will still be dropped\n  |\n\n</code></pre>\n<h3 id=\"explanation-34\"><a class=\"header\" href=\"#explanation-34\">Explanation</a></h3>\n<p>Calling <code class=\"hljs\">forget</code> on a reference will only forget the\nreference itself, which is a no-op. It will not forget the underlying\nreferenced value, which is likely what was intended.</p>\n<h2 id=\"function-item-references\"><a class=\"header\" href=\"#function-item-references\">function-item-references</a></h2>\n<p>The <code class=\"hljs\">function_item_references</code> lint detects function references that are\nformatted with <a href=\"https://doc.rust-lang.org/std/fmt/trait.Pointer.html\"><code class=\"hljs\">fmt::Pointer</code></a> or transmuted.</p>\n<h3 id=\"example-35\"><a class=\"header\" href=\"#example-35\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() { }\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{:p}\"</span>, &amp;foo);\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: taking a reference to a function item does not give a function pointer\n --&gt; lint_example.rs:4:22\n  |\n4 |     println!(\"{:p}\", &amp;foo);\n  |                      ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn()`\n  |\n  = note: `#[warn(function_item_references)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-35\"><a class=\"header\" href=\"#explanation-35\">Explanation</a></h3>\n<p>Taking a reference to a function may be mistaken as a way to obtain a\npointer to that function. This can give unexpected results when\nformatting the reference as a pointer or transmuting it. This lint is\nissued when function references are formatted as pointers, passed as\narguments bound by <a href=\"https://doc.rust-lang.org/std/fmt/trait.Pointer.html\"><code class=\"hljs\">fmt::Pointer</code></a> or transmuted.</p>\n<h2 id=\"hidden-glob-reexports\"><a class=\"header\" href=\"#hidden-glob-reexports\">hidden-glob-reexports</a></h2>\n<p>The <code class=\"hljs\">hidden_glob_reexports</code> lint detects cases where glob re-export items are shadowed by\nprivate items.</p>\n<h3 id=\"example-36\"><a class=\"header\" href=\"#example-36\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(hidden_glob_reexports)]</span>\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">mod</span> upstream {\n    <span class=\"hljs-keyword\">mod</span> inner { <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {}; <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span></span> {}; }\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">use</span> self::inner::*;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {} <span class=\"hljs-comment\">// private item shadows `inner::Foo`</span>\n}\n\n<span class=\"hljs-comment\">// mod downstream {</span>\n<span class=\"hljs-comment\">//     fn test() {</span>\n<span class=\"hljs-comment\">//         let _ = crate::upstream::Foo; // inaccessible</span>\n<span class=\"hljs-comment\">//     }</span>\n<span class=\"hljs-comment\">// }</span>\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: private item shadows public glob re-export\n --&gt; lint_example.rs:6:5\n  |\n6 |     struct Foo {} // private item shadows `inner::Foo`\n  |     ^^^^^^^^^^^^^\n  |\nnote: the name `Foo` in the type namespace is supposed to be publicly re-exported here\n --&gt; lint_example.rs:5:13\n  |\n5 |     pub use self::inner::*;\n  |             ^^^^^^^^^^^^^^\nnote: but the private item here shadows it\n --&gt; lint_example.rs:6:5\n  |\n6 |     struct Foo {} // private item shadows `inner::Foo`\n  |     ^^^^^^^^^^^^^\nnote: the lint level is defined here\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(hidden_glob_reexports)]\n  |         ^^^^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-36\"><a class=\"header\" href=\"#explanation-36\">Explanation</a></h3>\n<p>This was previously accepted without any errors or warnings but it could silently break a\ncrate's downstream user code. If the <code class=\"hljs\">struct Foo</code> was added, <code class=\"hljs\">dep::inner::Foo</code> would\nsilently become inaccessible and trigger a \"<code class=\"hljs\">struct </code>Foo<code class=\"hljs\"> is private</code>\" visibility error at\nthe downstream use site.</p>\n<h2 id=\"impl-trait-redundant-captures\"><a class=\"header\" href=\"#impl-trait-redundant-captures\">impl-trait-redundant-captures</a></h2>\n<p>The <code class=\"hljs\">impl_trait_redundant_captures</code> lint warns against cases where use of the\nprecise capturing <code class=\"hljs\">use&lt;...&gt;</code> syntax is not needed.</p>\n<p>In the 2024 edition, <code class=\"hljs\">impl Trait</code>s will capture all lifetimes in scope.\nIf precise-capturing <code class=\"hljs\">use&lt;...&gt;</code> syntax is used, and the set of parameters\nthat are captures are <em>equal</em> to the set of parameters in scope, then\nthe syntax is redundant, and can be removed.</p>\n<h3 id=\"example-37\"><a class=\"header\" href=\"#example-37\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![feature(precise_capturing, lifetime_capture_rules_2024)]</span>\n</span><span class=\"boring\"><span class=\"hljs-meta\">#![allow(incomplete_features)]</span>\n</span><span class=\"boring\"><span class=\"hljs-meta\">#![deny(impl_trait_redundant_captures)]</span>\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">test</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(x: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">i32</span>) -&gt; <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-keyword\">use</span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; <span class=\"hljs-built_in\">Sized</span> { x }</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: all possible in-scope parameters are already captured, so `use&lt;...&gt;` syntax is redundant\n --&gt; lint_example.rs:5:28\n  |\n5 | fn test&lt;'a&gt;(x: &amp;'a i32) -&gt; impl use&lt;'a&gt; Sized { x }\n  |                            ^^^^^-------^^^^^^\n  |                                 |\n  |                                 help: remove the `use&lt;...&gt;` syntax\n  |\nnote: the lint level is defined here\n --&gt; lint_example.rs:3:9\n  |\n3 | #![deny(impl_trait_redundant_captures)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-37\"><a class=\"header\" href=\"#explanation-37\">Explanation</a></h3>\n<p>To fix this, remove the <code class=\"hljs\">use&lt;'a&gt;</code>, since the lifetime is already captured\nsince it is in scope.</p>\n<h2 id=\"improper-ctypes\"><a class=\"header\" href=\"#improper-ctypes\">improper-ctypes</a></h2>\n<p>The <code class=\"hljs\">improper_ctypes</code> lint detects incorrect use of types in foreign\nmodules.</p>\n<h3 id=\"example-38\"><a class=\"header\" href=\"#example-38\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-keyword\">static</span> STATIC: <span class=\"hljs-built_in\">String</span>;\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: `extern` block uses type `String`, which is not FFI-safe\n --&gt; lint_example.rs:3:20\n  |\n3 |     static STATIC: String;\n  |                    ^^^^^^ not FFI-safe\n  |\n  = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n  = note: this struct has unspecified layout\n  = note: `#[warn(improper_ctypes)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-38\"><a class=\"header\" href=\"#explanation-38\">Explanation</a></h3>\n<p>The compiler has several checks to verify that types used in <code class=\"hljs\">extern</code>\nblocks are safe and follow certain rules to ensure proper\ncompatibility with the foreign interfaces. This lint is issued when it\ndetects a probable mistake in a definition. The lint usually should\nprovide a description of the issue, along with possibly a hint on how\nto resolve it.</p>\n<h2 id=\"improper-ctypes-definitions\"><a class=\"header\" href=\"#improper-ctypes-definitions\">improper-ctypes-definitions</a></h2>\n<p>The <code class=\"hljs\">improper_ctypes_definitions</code> lint detects incorrect use of\n<a href=\"https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\"><code class=\"hljs\">extern</code> function</a> definitions.</p>\n<h3 id=\"example-39\"><a class=\"header\" href=\"#example-39\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">str_type</span></span>(p: &amp;<span class=\"hljs-built_in\">str</span>) { }</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: `extern` fn uses type `str`, which is not FFI-safe\n --&gt; lint_example.rs:3:31\n  |\n3 | pub extern \"C\" fn str_type(p: &amp;str) { }\n  |                               ^^^^ not FFI-safe\n  |\n  = help: consider using `*const u8` and a length instead\n  = note: string slices have no C equivalent\n  = note: `#[warn(improper_ctypes_definitions)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-39\"><a class=\"header\" href=\"#explanation-39\">Explanation</a></h3>\n<p>There are many parameter and return types that may be specified in an\n<code class=\"hljs\">extern</code> function that are not compatible with the given ABI. This\nlint is an alert that these types should not be used. The lint usually\nshould provide a description of the issue, along with possibly a hint\non how to resolve it.</p>\n<h2 id=\"incomplete-features\"><a class=\"header\" href=\"#incomplete-features\">incomplete-features</a></h2>\n<p>The <code class=\"hljs\">incomplete_features</code> lint detects unstable features enabled with\nthe <a href=\"https://doc.rust-lang.org/nightly/unstable-book/\"><code class=\"hljs\">feature</code> attribute</a> that may function improperly in some or all\ncases.</p>\n<h3 id=\"example-40\"><a class=\"header\" href=\"#example-40\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![feature(generic_const_exprs)]</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes\n --&gt; lint_example.rs:1:12\n  |\n1 | #![feature(generic_const_exprs)]\n  |            ^^^^^^^^^^^^^^^^^^^\n  |\n  = note: see issue #76560 &lt;https://github.com/rust-lang/rust/issues/76560&gt; for more information\n  = note: `#[warn(incomplete_features)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-40\"><a class=\"header\" href=\"#explanation-40\">Explanation</a></h3>\n<p>Although it is encouraged for people to experiment with unstable\nfeatures, some of them are known to be incomplete or faulty. This lint\nis a signal that the feature has not yet been finished, and you may\nexperience problems with it.</p>\n<h2 id=\"inline-no-sanitize\"><a class=\"header\" href=\"#inline-no-sanitize\">inline-no-sanitize</a></h2>\n<p>The <code class=\"hljs\">inline_no_sanitize</code> lint detects incompatible use of\n<a href=\"https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute\"><code class=\"hljs\">#[inline(always)]</code></a> and <a href=\"https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html\"><code class=\"hljs\">#[no_sanitize(...)]</code></a>.</p>\n<h3 id=\"example-41\"><a class=\"header\" href=\"#example-41\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![feature(no_sanitize)]</span>\n\n<span class=\"hljs-meta\">#[inline(always)]</span>\n<span class=\"hljs-meta\">#[no_sanitize(address)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">x</span></span>() {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    x()\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: `no_sanitize` will have no effect after inlining\n --&gt; lint_example.rs:4:1\n  |\n4 | #[no_sanitize(address)]\n  | ^^^^^^^^^^^^^^^^^^^^^^^\n  |\nnote: inlining requested here\n --&gt; lint_example.rs:3:1\n  |\n3 | #[inline(always)]\n  | ^^^^^^^^^^^^^^^^^\n  = note: `#[warn(inline_no_sanitize)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-41\"><a class=\"header\" href=\"#explanation-41\">Explanation</a></h3>\n<p>The use of the <a href=\"https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute\"><code class=\"hljs\">#[inline(always)]</code></a> attribute prevents the\nthe <a href=\"https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html\"><code class=\"hljs\">#[no_sanitize(...)]</code></a> attribute from working.\nConsider temporarily removing <code class=\"hljs\">inline</code> attribute.</p>\n<h2 id=\"internal-features\"><a class=\"header\" href=\"#internal-features\">internal-features</a></h2>\n<p>The <code class=\"hljs\">internal_features</code> lint detects unstable features enabled with\nthe <a href=\"https://doc.rust-lang.org/nightly/unstable-book/\"><code class=\"hljs\">feature</code> attribute</a> that are internal to the compiler or standard\nlibrary.</p>\n<h3 id=\"example-42\"><a class=\"header\" href=\"#example-42\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![feature(rustc_attrs)]</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: the feature `rustc_attrs` is internal to the compiler or standard library\n --&gt; lint_example.rs:1:12\n  |\n1 | #![feature(rustc_attrs)]\n  |            ^^^^^^^^^^^\n  |\n  = note: using it is strongly discouraged\n  = note: `#[warn(internal_features)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-42\"><a class=\"header\" href=\"#explanation-42\">Explanation</a></h3>\n<p>These features are an implementation detail of the compiler and standard\nlibrary and are not supposed to be used in user code.</p>\n<h2 id=\"invalid-from-utf8\"><a class=\"header\" href=\"#invalid-from-utf8\">invalid-from-utf8</a></h2>\n<p>The <code class=\"hljs\">invalid_from_utf8</code> lint checks for calls to\n<code class=\"hljs\">std::str::from_utf8</code> and <code class=\"hljs\">std::str::from_utf8_mut</code>\nwith a known invalid UTF-8 value.</p>\n<h3 id=\"example-43\"><a class=\"header\" href=\"#example-43\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#[allow(unused)]</span>\n</span>std::<span class=\"hljs-built_in\">str</span>::from_utf8(<span class=\"hljs-string\">b\"Ru\\x82st\"</span>);</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: calls to `std::str::from_utf8` with a invalid literal always return an error\n --&gt; lint_example.rs:3:1\n  |\n3 | std::str::from_utf8(b\"Ru\\x82st\");\n  | ^^^^^^^^^^^^^^^^^^^^-----------^\n  |                     |\n  |                     the literal was valid UTF-8 up to the 2 bytes\n  |\n  = note: `#[warn(invalid_from_utf8)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-43\"><a class=\"header\" href=\"#explanation-43\">Explanation</a></h3>\n<p>Trying to create such a <code class=\"hljs\">str</code> would always return an error as per documentation\nfor <code class=\"hljs\">std::str::from_utf8</code> and <code class=\"hljs\">std::str::from_utf8_mut</code>.</p>\n<h2 id=\"invalid-macro-export-arguments\"><a class=\"header\" href=\"#invalid-macro-export-arguments\">invalid-macro-export-arguments</a></h2>\n<p>The <code class=\"hljs\">invalid_macro_export_arguments</code> lint detects cases where <code class=\"hljs\">#[macro_export]</code> is being used with invalid arguments.</p>\n<h3 id=\"example-44\"><a class=\"header\" href=\"#example-44\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(invalid_macro_export_arguments)]</span>\n\n<span class=\"hljs-meta\">#[macro_export(invalid_parameter)]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> myMacro {\n   () =&gt; {\n        <span class=\"hljs-comment\">// [...]</span>\n   }\n}\n\n<span class=\"hljs-meta\">#[macro_export(too, many, items)]</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: `invalid_parameter` isn't a valid `#[macro_export]` argument\n --&gt; lint_example.rs:4:16\n  |\n4 | #[macro_export(invalid_parameter)]\n  |                ^^^^^^^^^^^^^^^^^\n  |\nnote: the lint level is defined here\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(invalid_macro_export_arguments)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-44\"><a class=\"header\" href=\"#explanation-44\">Explanation</a></h3>\n<p>The only valid argument is <code class=\"hljs\">#[macro_export(local_inner_macros)]</code> or no argument (<code class=\"hljs\">#[macro_export]</code>).\nYou can't have multiple arguments in a <code class=\"hljs\">#[macro_export(..)]</code>, or mention arguments other than <code class=\"hljs\">local_inner_macros</code>.</p>\n<h2 id=\"invalid-nan-comparisons\"><a class=\"header\" href=\"#invalid-nan-comparisons\">invalid-nan-comparisons</a></h2>\n<p>The <code class=\"hljs\">invalid_nan_comparisons</code> lint checks comparison with <code class=\"hljs\">f32::NAN</code> or <code class=\"hljs\">f64::NAN</code>\nas one of the operand.</p>\n<h3 id=\"example-45\"><a class=\"header\" href=\"#example-45\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">2.3f32</span>;\n<span class=\"hljs-keyword\">if</span> a == <span class=\"hljs-built_in\">f32</span>::NAN {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: incorrect NaN comparison, NaN cannot be directly compared to itself\n --&gt; lint_example.rs:3:4\n  |\n3 | if a == f32::NAN {}\n  |    ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(invalid_nan_comparisons)]` on by default\nhelp: use `f32::is_nan()` or `f64::is_nan()` instead\n  |\n3 - if a == f32::NAN {}\n3 + if a.is_nan() {}\n  |\n\n</code></pre>\n<h3 id=\"explanation-45\"><a class=\"header\" href=\"#explanation-45\">Explanation</a></h3>\n<p>NaN does not compare meaningfully to anything – not\neven itself – so those comparisons are always false.</p>\n<h2 id=\"invalid-value\"><a class=\"header\" href=\"#invalid-value\">invalid-value</a></h2>\n<p>The <code class=\"hljs\">invalid_value</code> lint detects creating a value that is not valid,\nsuch as a null reference.</p>\n<h3 id=\"example-46\"><a class=\"header\" href=\"#example-46\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust no_run hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-keyword\">unsafe</span> {\n    <span class=\"hljs-keyword\">let</span> x: &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">i32</span> = std::mem::zeroed();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: the type `&amp;i32` does not permit zero-initialization\n --&gt; lint_example.rs:4:27\n  |\n4 |     let x: &amp;'static i32 = std::mem::zeroed();\n  |                           ^^^^^^^^^^^^^^^^^^\n  |                           |\n  |                           this code causes undefined behavior when executed\n  |                           help: use `MaybeUninit&lt;T&gt;` instead, and only call `assume_init` after initialization is done\n  |\n  = note: references must be non-null\n  = note: `#[warn(invalid_value)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-46\"><a class=\"header\" href=\"#explanation-46\">Explanation</a></h3>\n<p>In some situations the compiler can detect that the code is creating\nan invalid value, which should be avoided.</p>\n<p>In particular, this lint will check for improper use of\n<a href=\"https://doc.rust-lang.org/std/mem/fn.zeroed.html\"><code class=\"hljs\">mem::zeroed</code></a>, <a href=\"https://doc.rust-lang.org/std/mem/fn.uninitialized.html\"><code class=\"hljs\">mem::uninitialized</code></a>, <a href=\"https://doc.rust-lang.org/std/mem/fn.transmute.html\"><code class=\"hljs\">mem::transmute</code></a>, and\n<a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#method.assume_init\"><code class=\"hljs\">MaybeUninit::assume_init</code></a> that can cause <a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a>. The\nlint should provide extra information to indicate what the problem is\nand a possible solution.</p>\n<h2 id=\"irrefutable-let-patterns\"><a class=\"header\" href=\"#irrefutable-let-patterns\">irrefutable-let-patterns</a></h2>\n<p>The <code class=\"hljs\">irrefutable_let_patterns</code> lint detects <a href=\"https://doc.rust-lang.org/reference/patterns.html#refutability\">irrefutable patterns</a>\nin <a href=\"https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions\"><code class=\"hljs\">if let</code></a>s, <a href=\"https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops\"><code class=\"hljs\">while let</code></a>s, and <code class=\"hljs\">if let</code> guards.</p>\n<h3 id=\"example-47\"><a class=\"header\" href=\"#example-47\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> _ = <span class=\"hljs-number\">123</span> {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"always runs!\"</span>);\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: irrefutable `if let` pattern\n --&gt; lint_example.rs:2:4\n  |\n2 | if let _ = 123 {\n  |    ^^^^^^^^^^^\n  |\n  = note: this pattern will always match, so the `if let` is useless\n  = help: consider replacing the `if let` with a `let`\n  = note: `#[warn(irrefutable_let_patterns)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-47\"><a class=\"header\" href=\"#explanation-47\">Explanation</a></h3>\n<p>There usually isn't a reason to have an irrefutable pattern in an\n<code class=\"hljs\">if let</code> or <code class=\"hljs\">while let</code> statement, because the pattern will always match\nsuccessfully. A <a href=\"https://doc.rust-lang.org/reference/statements.html#let-statements\"><code class=\"hljs\">let</code></a> or <a href=\"https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops\"><code class=\"hljs\">loop</code></a> statement will suffice. However,\nwhen generating code with a macro, forbidding irrefutable patterns\nwould require awkward workarounds in situations where the macro\ndoesn't know if the pattern is refutable or not. This lint allows\nmacros to accept this form, while alerting for a possibly incorrect\nuse in normal code.</p>\n<p>See <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2086-allow-if-let-irrefutables.md\">RFC 2086</a> for more details.</p>\n<h2 id=\"large-assignments\"><a class=\"header\" href=\"#large-assignments\">large-assignments</a></h2>\n<p>The <code class=\"hljs\">large_assignments</code> lint detects when objects of large\ntypes are being moved around.</p>\n<h3 id=\"example-48\"><a class=\"header\" href=\"#example-48\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (can crash on some platforms) hljs\"><span class=\"hljs-keyword\">let</span> x = [<span class=\"hljs-number\">0</span>; <span class=\"hljs-number\">50000</span>];\n<span class=\"hljs-keyword\">let</span> y = x;</code></pre>\n<p>produces:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: moving a large value\n  --&gt; $DIR/move-large.rs:1:3\n  let y = x;\n          - Copied large value here\n</code></pre>\n<h3 id=\"explanation-48\"><a class=\"header\" href=\"#explanation-48\">Explanation</a></h3>\n<p>When using a large type in a plain assignment or in a function\nargument, idiomatic code can be inefficient.\nIdeally appropriate optimizations would resolve this, but such\noptimizations are only done in a best-effort manner.\nThis lint will trigger on all sites of large moves and thus allow the\nuser to resolve them in code.</p>\n<h2 id=\"late-bound-lifetime-arguments\"><a class=\"header\" href=\"#late-bound-lifetime-arguments\">late-bound-lifetime-arguments</a></h2>\n<p>The <code class=\"hljs\">late_bound_lifetime_arguments</code> lint detects generic lifetime\narguments in path segments with late bound lifetime parameters.</p>\n<h3 id=\"example-49\"><a class=\"header\" href=\"#example-49\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">S</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> S {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">late</span></span>(<span class=\"hljs-keyword\">self</span>, _: &amp;<span class=\"hljs-built_in\">u8</span>, _: &amp;<span class=\"hljs-built_in\">u8</span>) {}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    S.late::&lt;<span class=\"hljs-symbol\">'static</span>&gt;(&amp;<span class=\"hljs-number\">0</span>, &amp;<span class=\"hljs-number\">0</span>);\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n --&gt; lint_example.rs:8:14\n  |\n4 |     fn late(self, _: &amp;u8, _: &amp;u8) {}\n  |                      - the late bound lifetime parameter is introduced here\n...\n8 |     S.late::&lt;'static&gt;(&amp;0, &amp;0);\n  |              ^^^^^^^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #42868 &lt;https://github.com/rust-lang/rust/issues/42868&gt;\n  = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-49\"><a class=\"header\" href=\"#explanation-49\">Explanation</a></h3>\n<p>It is not clear how to provide arguments for early-bound lifetime\nparameters if they are intermixed with late-bound parameters in the\nsame list. For now, providing any explicit arguments will trigger this\nlint if late-bound parameters are present, so in the future a solution\ncan be adopted without hitting backward compatibility issues. This is\na <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to transition this to a hard error in the\nfuture. See <a href=\"https://github.com/rust-lang/rust/issues/42868\">issue #42868</a> for more details, along with a description\nof the difference between early and late-bound parameters.</p>\n<h2 id=\"legacy-derive-helpers\"><a class=\"header\" href=\"#legacy-derive-helpers\">legacy-derive-helpers</a></h2>\n<p>The <code class=\"hljs\">legacy_derive_helpers</code> lint detects derive helper attributes\nthat are used before they are introduced.</p>\n<h3 id=\"example-50\"><a class=\"header\" href=\"#example-50\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (needs extern crate) hljs\"><span class=\"hljs-meta\">#[serde(rename_all = <span class=\"hljs-meta-string\">\"camelCase\"</span>)]</span>\n<span class=\"hljs-meta\">#[derive(Deserialize)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">S</span></span> { <span class=\"hljs-comment\">/* fields */</span> }</code></pre>\n<p>produces:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: derive helper attribute is used before it is introduced\n  --&gt; $DIR/legacy-derive-helpers.rs:1:3\n   |\n 1 | #[serde(rename_all = \"camelCase\")]\n   |   ^^^^^\n...\n 2 | #[derive(Deserialize)]\n   |          ----------- the attribute is introduced here\n</code></pre>\n<h3 id=\"explanation-50\"><a class=\"header\" href=\"#explanation-50\">Explanation</a></h3>\n<p>Attributes like this work for historical reasons, but attribute expansion works in\nleft-to-right order in general, so, to resolve <code class=\"hljs\">#[serde]</code>, compiler has to try to \"look\ninto the future\" at not yet expanded part of the item , but such attempts are not always\nreliable.</p>\n<p>To fix the warning place the helper attribute after its corresponding derive.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (needs extern crate) hljs\"><span class=\"hljs-meta\">#[derive(Deserialize)]</span>\n<span class=\"hljs-meta\">#[serde(rename_all = <span class=\"hljs-meta-string\">\"camelCase\"</span>)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">S</span></span> { <span class=\"hljs-comment\">/* fields */</span> }</code></pre>\n<h2 id=\"map-unit-fn\"><a class=\"header\" href=\"#map-unit-fn\">map-unit-fn</a></h2>\n<p>The <code class=\"hljs\">map_unit_fn</code> lint checks for <code class=\"hljs\">Iterator::map</code> receive\na callable that returns <code class=\"hljs\">()</code>.</p>\n<h3 id=\"example-51\"><a class=\"header\" href=\"#example-51\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(items: &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt;) {\n    items.sort();\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt;&gt; = <span class=\"hljs-built_in\">vec!</span>[\n        <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>],\n        <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>],\n    ];\n    x.iter_mut().map(foo);\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: `Iterator::map` call that discard the iterator's values\n  --&gt; lint_example.rs:10:18\n   |\n1  | fn foo(items: &amp;mut Vec&lt;u8&gt;) {\n   | --------------------------- this function returns `()`, which is likely not what you wanted\n...\n10 |     x.iter_mut().map(foo);\n   |                  ^^^^---^\n   |                  |   |\n   |                  |   called `Iterator::map` with callable that returns `()`\n   |                  after this call to map, the resulting iterator is `impl Iterator&lt;Item = ()&gt;`, which means the only information carried by the iterator is the number of items\n   |\n   = note: `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n   = note: `#[warn(map_unit_fn)]` on by default\nhelp: you might have meant to use `Iterator::for_each`\n   |\n10 |     x.iter_mut().for_each(foo);\n   |                  ~~~~~~~~\n\n</code></pre>\n<h3 id=\"explanation-51\"><a class=\"header\" href=\"#explanation-51\">Explanation</a></h3>\n<p>Mapping to <code class=\"hljs\">()</code> is almost always a mistake.</p>\n<h2 id=\"mixed-script-confusables\"><a class=\"header\" href=\"#mixed-script-confusables\">mixed-script-confusables</a></h2>\n<p>The <code class=\"hljs\">mixed_script_confusables</code> lint detects visually confusable\ncharacters in identifiers between different <a href=\"https://en.wikipedia.org/wiki/Script_(Unicode)\">scripts</a>.</p>\n<h3 id=\"example-52\"><a class=\"header\" href=\"#example-52\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-comment\">// The Japanese katakana character エ can be confused with the Han character 工.</span>\n<span class=\"hljs-keyword\">const</span> エ: &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"アイウ\"</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: the usage of Script Group `Japanese, Katakana` in this crate consists solely of mixed script confusables\n --&gt; lint_example.rs:3:7\n  |\n3 | const エ: &amp;'static str = \"アイウ\";\n  |       ^^\n  |\n  = note: the usage includes 'エ' (U+30A8)\n  = note: please recheck to make sure their usages are indeed what you want\n  = note: `#[warn(mixed_script_confusables)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-52\"><a class=\"header\" href=\"#explanation-52\">Explanation</a></h3>\n<p>This lint warns when characters between different scripts may appear\nvisually similar, which can cause confusion.</p>\n<p>If the crate contains other identifiers in the same script that have\nnon-confusable characters, then this lint will <em>not</em> be issued. For\nexample, if the example given above has another identifier with\nkatakana characters (such as <code class=\"hljs\">let カタカナ = 123;</code>), then this indicates\nthat you are intentionally using katakana, and it will not warn about\nit.</p>\n<p>Note that the set of confusable characters may change over time.\nBeware that if you \"forbid\" this lint that existing code may fail in\nthe future.</p>\n<h2 id=\"named-arguments-used-positionally\"><a class=\"header\" href=\"#named-arguments-used-positionally\">named-arguments-used-positionally</a></h2>\n<p>The <code class=\"hljs\">named_arguments_used_positionally</code> lint detects cases where named arguments are only\nused positionally in format strings. This usage is valid but potentially very confusing.</p>\n<h3 id=\"example-53\"><a class=\"header\" href=\"#example-53\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(named_arguments_used_positionally)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> _x = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, _x = <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Prints 1, will trigger lint</span>\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, _x); <span class=\"hljs-comment\">// Prints 5, no lint emitted</span>\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{_x}\"</span>, _x = _x); <span class=\"hljs-comment\">// Prints 5, no lint emitted</span>\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: named argument `_x` is not used by name\n --&gt; lint_example.rs:4:20\n  |\n4 |     println!(\"{}\", _x = 1); // Prints 1, will trigger lint\n  |               --   ^^ this named argument is referred to by position in formatting string\n  |               |\n  |               this formatting argument uses named argument `_x` by position\n  |\nnote: the lint level is defined here\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(named_arguments_used_positionally)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: use the named argument by name to avoid ambiguity\n  |\n4 |     println!(\"{_x}\", _x = 1); // Prints 1, will trigger lint\n  |                ++\n\n</code></pre>\n<h3 id=\"explanation-53\"><a class=\"header\" href=\"#explanation-53\">Explanation</a></h3>\n<p>Rust formatting strings can refer to named arguments by their position, but this usage is\npotentially confusing. In particular, readers can incorrectly assume that the declaration\nof named arguments is an assignment (which would produce the unit type).\nFor backwards compatibility, this is not a hard error.</p>\n<h2 id=\"never-type-fallback-flowing-into-unsafe\"><a class=\"header\" href=\"#never-type-fallback-flowing-into-unsafe\">never-type-fallback-flowing-into-unsafe</a></h2>\n<p>The <code class=\"hljs\">never_type_fallback_flowing_into_unsafe</code> lint detects cases where never type fallback\naffects unsafe function calls.</p>\n<h3 id=\"never-type-fallback\"><a class=\"header\" href=\"#never-type-fallback\">Never type fallback</a></h3>\n<p>When the compiler sees a value of type <a href=\"https://doc.rust-lang.org/core/primitive.never.html\"><code class=\"hljs\">!</code></a> it implicitly inserts a coercion (if possible),\nto allow type check to infer any type:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-ignore (illustrative-and-has-placeholders) hljs\">// this\nlet x: u8 = panic!();\n\n// is (essentially) turned by the compiler into\nlet x: u8 = absurd(panic!());\n\n// where absurd is a function with the following signature\n// (it's sound, because `!` always marks unreachable code):\nfn absurd&lt;T&gt;(never: !) -&gt; T { ... }\n</code></pre>\n<p>While it's convenient to be able to use non-diverging code in one of the branches (like\n<code class=\"hljs\">if a { b } else { return }</code>) this could lead to compilation errors:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-compile_fail hljs\">// this\n{ panic!() };\n\n// gets turned into this\n{ absurd(panic!()) }; // error: can't infer the type of `absurd`\n</code></pre>\n<p>To prevent such errors, compiler remembers where it inserted <code class=\"hljs\">absurd</code> calls, and if it\ncan't infer their type, it sets the type to fallback. <code class=\"hljs\">{ absurd::&lt;Fallback&gt;(panic!()) };</code>.\nThis is what is known as \"never type fallback\".</p>\n<h3 id=\"example-54\"><a class=\"header\" href=\"#example-54\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(never_type_fallback_flowing_into_unsafe)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-literal\">true</span> {\n        <span class=\"hljs-comment\">// return has type `!` which, is some cases, causes never type fallback</span>\n        <span class=\"hljs-keyword\">return</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// `zeroed` is an unsafe function, which returns an unbounded type</span>\n        <span class=\"hljs-keyword\">unsafe</span> { std::mem::zeroed() }\n    };\n    <span class=\"hljs-comment\">// depending on the fallback, `zeroed` may create `()` (which is completely sound),</span>\n    <span class=\"hljs-comment\">// or `!` (which is instant undefined behavior)</span>\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: never type fallback affects this call to an `unsafe` function\n --&gt; lint_example.rs:8:18\n  |\n8 |         unsafe { std::mem::zeroed() }\n  |                  ^^^^^^^^^^^^^^^^^^\n  |\n  = warning: this will change its meaning in a future release!\n  = note: for more information, see issue #123748 &lt;https://github.com/rust-lang/rust/issues/123748&gt;\n  = help: specify the type explicitly\nnote: the lint level is defined here\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(never_type_fallback_flowing_into_unsafe)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-54\"><a class=\"header\" href=\"#explanation-54\">Explanation</a></h3>\n<p>Due to historic reasons never type fallback was <code class=\"hljs\">()</code>, meaning that <code class=\"hljs\">!</code> got spontaneously\ncoerced to <code class=\"hljs\">()</code>. There are plans to change that, but they may make the code such as above\nunsound. Instead of depending on the fallback, you should specify the type explicitly:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"hljs\">if true {\n    return\n} else {\n    // type is explicitly specified, fallback can't hurt us no more\n    unsafe { std::mem::zeroed::&lt;()&gt;() }\n};\n</code></pre>\n<p>See <a href=\"https://github.com/rust-lang/rust/issues/123748\">Tracking Issue for making <code class=\"hljs\">!</code> fall back to <code class=\"hljs\">!</code></a>.</p>\n<h2 id=\"no-mangle-generic-items\"><a class=\"header\" href=\"#no-mangle-generic-items\">no-mangle-generic-items</a></h2>\n<p>The <code class=\"hljs\">no_mangle_generic_items</code> lint detects generic items that must be\nmangled.</p>\n<h3 id=\"example-55\"><a class=\"header\" href=\"#example-55\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#[no_mangle]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;T&gt;(t: T) {\n\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: functions generic over types or consts must be mangled\n --&gt; lint_example.rs:3:1\n  |\n2 |   #[no_mangle]\n  |   ------------ help: remove this attribute\n3 | / fn foo&lt;T&gt;(t: T) {\n4 | |\n5 | | }\n  | |_^\n  |\n  = note: `#[warn(no_mangle_generic_items)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-55\"><a class=\"header\" href=\"#explanation-55\">Explanation</a></h3>\n<p>A function with generics must have its symbol mangled to accommodate\nthe generic parameter. The <a href=\"https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute\"><code class=\"hljs\">no_mangle</code> attribute</a> has no effect in\nthis situation, and should be removed.</p>\n<h2 id=\"non-fmt-panic\"><a class=\"header\" href=\"#non-fmt-panic\">non-fmt-panic</a></h2>\n<p>The lint <code class=\"hljs\">non-fmt-panic</code> has been renamed to <a href=\"#non-fmt-panics\"><code class=\"hljs\">non-fmt-panics</code></a>.</p>\n<h2 id=\"non-camel-case-types\"><a class=\"header\" href=\"#non-camel-case-types\">non-camel-case-types</a></h2>\n<p>The <code class=\"hljs\">non_camel_case_types</code> lint detects types, variants, traits and\ntype parameters that don't have camel case names.</p>\n<h3 id=\"example-56\"><a class=\"header\" href=\"#example-56\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">my_struct</span></span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: type `my_struct` should have an upper camel case name\n --&gt; lint_example.rs:2:8\n  |\n2 | struct my_struct;\n  |        ^^^^^^^^^ help: convert the identifier to upper camel case: `MyStruct`\n  |\n  = note: `#[warn(non_camel_case_types)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-56\"><a class=\"header\" href=\"#explanation-56\">Explanation</a></h3>\n<p>The preferred style for these identifiers is to use \"camel case\", such\nas <code class=\"hljs\">MyStruct</code>, where the first letter should not be lowercase, and\nshould not use underscores between letters. Underscores are allowed at\nthe beginning and end of the identifier, as well as between\nnon-letters (such as <code class=\"hljs\">X86_64</code>).</p>\n<h2 id=\"non-contiguous-range-endpoints\"><a class=\"header\" href=\"#non-contiguous-range-endpoints\">non-contiguous-range-endpoints</a></h2>\n<p>The <code class=\"hljs\">non_contiguous_range_endpoints</code> lint detects likely off-by-one errors when using\nexclusive <a href=\"https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns\">range patterns</a>.</p>\n<h3 id=\"example-57\"><a class=\"header\" href=\"#example-57\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">123u32</span>;\n<span class=\"hljs-keyword\">match</span> x {\n    <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">100</span> =&gt; { <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"small\"</span>); }\n    <span class=\"hljs-number\">101</span>..<span class=\"hljs-number\">1000</span> =&gt; { <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"large\"</span>); }\n    _ =&gt; { <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"larger\"</span>); }\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: multiple ranges are one apart\n --&gt; lint_example.rs:4:5\n  |\n4 |     0..100 =&gt; { println!(\"small\"); }\n  |     ^^^^^^\n  |     |\n  |     this range doesn't match `100_u32` because `..` is an exclusive range\n  |     help: use an inclusive range instead: `0_u32..=100_u32`\n5 |     101..1000 =&gt; { println!(\"large\"); }\n  |     --------- this could appear to continue range `0_u32..100_u32`, but `100_u32` isn't matched by either of them\n  |\n  = note: `#[warn(non_contiguous_range_endpoints)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-57\"><a class=\"header\" href=\"#explanation-57\">Explanation</a></h3>\n<p>It is likely a mistake to have range patterns in a match expression that miss out a single\nnumber. Check that the beginning and end values are what you expect, and keep in mind that\nwith <code class=\"hljs\">..=</code> the right bound is inclusive, and with <code class=\"hljs\">..</code> it is exclusive.</p>\n<h2 id=\"non-fmt-panics\"><a class=\"header\" href=\"#non-fmt-panics\">non-fmt-panics</a></h2>\n<p>The <code class=\"hljs\">non_fmt_panics</code> lint detects <code class=\"hljs\">panic!(..)</code> invocations where the first\nargument is not a formatting string.</p>\n<h3 id=\"example-58\"><a class=\"header\" href=\"#example-58\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust no_run edition2018 hljs\"><span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"{}\"</span>);\n<span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-number\">123</span>);</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: panic message contains an unused formatting placeholder\n --&gt; lint_example.rs:2:9\n  |\n2 | panic!(\"{}\");\n  |         ^^\n  |\n  = note: this message is not used as a format string when given without arguments, but will be in Rust 2021\n  = note: `#[warn(non_fmt_panics)]` on by default\nhelp: add the missing argument\n  |\n2 | panic!(\"{}\", ...);\n  |            +++++\nhelp: or add a \"{}\" format string to use the message literally\n  |\n2 | panic!(\"{}\", \"{}\");\n  |        +++++\n\n\nwarning: panic message is not a string literal\n --&gt; lint_example.rs:3:8\n  |\n3 | panic!(123);\n  |        ^^^\n  |\n  = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n  = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html&gt;\nhelp: add a \"{}\" format string to `Display` the message\n  |\n3 | panic!(\"{}\", 123);\n  |        +++++\nhelp: or use std::panic::panic_any instead\n  |\n3 | std::panic::panic_any(123);\n  | ~~~~~~~~~~~~~~~~~~~~~\n\n</code></pre>\n<h3 id=\"explanation-58\"><a class=\"header\" href=\"#explanation-58\">Explanation</a></h3>\n<p>In Rust 2018 and earlier, <code class=\"hljs\">panic!(x)</code> directly uses <code class=\"hljs\">x</code> as the message.\nThat means that <code class=\"hljs\">panic!(\"{}\")</code> panics with the message <code class=\"hljs\">\"{}\"</code> instead\nof using it as a formatting string, and <code class=\"hljs\">panic!(123)</code> will panic with\nan <code class=\"hljs\">i32</code> as message.</p>\n<p>Rust 2021 always interprets the first argument as format string.</p>\n<h2 id=\"non-shorthand-field-patterns\"><a class=\"header\" href=\"#non-shorthand-field-patterns\">non-shorthand-field-patterns</a></h2>\n<p>The <code class=\"hljs\">non_shorthand_field_patterns</code> lint detects using <code class=\"hljs\">Struct { x: x }</code>\ninstead of <code class=\"hljs\">Struct { x }</code> in a pattern.</p>\n<h3 id=\"example-59\"><a class=\"header\" href=\"#example-59\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n    x: <span class=\"hljs-built_in\">i32</span>,\n    y: <span class=\"hljs-built_in\">i32</span>,\n}\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Point {\n        x: <span class=\"hljs-number\">5</span>,\n        y: <span class=\"hljs-number\">5</span>,\n    };\n\n    <span class=\"hljs-keyword\">match</span> p {\n        Point { x: x, y: y } =&gt; (),\n    }\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: the `x:` in this pattern is redundant\n  --&gt; lint_example.rs:14:17\n   |\n14 |         Point { x: x, y: y } =&gt; (),\n   |                 ^^^^ help: use shorthand field pattern: `x`\n   |\n   = note: `#[warn(non_shorthand_field_patterns)]` on by default\n\n\nwarning: the `y:` in this pattern is redundant\n  --&gt; lint_example.rs:14:23\n   |\n14 |         Point { x: x, y: y } =&gt; (),\n   |                       ^^^^ help: use shorthand field pattern: `y`\n\n</code></pre>\n<h3 id=\"explanation-59\"><a class=\"header\" href=\"#explanation-59\">Explanation</a></h3>\n<p>The preferred style is to avoid the repetition of specifying both the\nfield name and the binding name if both identifiers are the same.</p>\n<h2 id=\"non-snake-case\"><a class=\"header\" href=\"#non-snake-case\">non-snake-case</a></h2>\n<p>The <code class=\"hljs\">non_snake_case</code> lint detects variables, methods, functions,\nlifetime parameters and modules that don't have snake case names.</p>\n<h3 id=\"example-60\"><a class=\"header\" href=\"#example-60\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> MY_VALUE = <span class=\"hljs-number\">5</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: variable `MY_VALUE` should have a snake case name\n --&gt; lint_example.rs:2:5\n  |\n2 | let MY_VALUE = 5;\n  |     ^^^^^^^^ help: convert the identifier to snake case: `my_value`\n  |\n  = note: `#[warn(non_snake_case)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-60\"><a class=\"header\" href=\"#explanation-60\">Explanation</a></h3>\n<p>The preferred style for these identifiers is to use \"snake case\",\nwhere all the characters are in lowercase, with words separated with a\nsingle underscore, such as <code class=\"hljs\">my_value</code>.</p>\n<h2 id=\"non-upper-case-globals\"><a class=\"header\" href=\"#non-upper-case-globals\">non-upper-case-globals</a></h2>\n<p>The <code class=\"hljs\">non_upper_case_globals</code> lint detects static items that don't have\nuppercase identifiers.</p>\n<h3 id=\"example-61\"><a class=\"header\" href=\"#example-61\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">static</span> max_points: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">5</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: static variable `max_points` should have an upper case name\n --&gt; lint_example.rs:2:8\n  |\n2 | static max_points: i32 = 5;\n  |        ^^^^^^^^^^ help: convert the identifier to upper case: `MAX_POINTS`\n  |\n  = note: `#[warn(non_upper_case_globals)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-61\"><a class=\"header\" href=\"#explanation-61\">Explanation</a></h3>\n<p>The preferred style is for static item names to use all uppercase\nletters such as <code class=\"hljs\">MAX_POINTS</code>.</p>\n<h2 id=\"noop-method-call\"><a class=\"header\" href=\"#noop-method-call\">noop-method-call</a></h2>\n<p>The <code class=\"hljs\">noop_method_call</code> lint detects specific calls to noop methods\nsuch as a calling <code class=\"hljs\">&lt;&amp;T as Clone&gt;::clone</code> where <code class=\"hljs\">T: !Clone</code>.</p>\n<h3 id=\"example-62\"><a class=\"header\" href=\"#example-62\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n<span class=\"hljs-keyword\">let</span> foo = &amp;Foo;\n<span class=\"hljs-keyword\">let</span> clone: &amp;Foo = foo.clone();</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: call to `.clone()` on a reference in this situation does nothing\n --&gt; lint_example.rs:5:22\n  |\n5 | let clone: &amp;Foo = foo.clone();\n  |                      ^^^^^^^^\n  |\n  = note: the type `Foo` does not implement `Clone`, so calling `clone` on `&amp;Foo` copies the reference, which does not do anything and can be removed\n  = note: `#[warn(noop_method_call)]` on by default\nhelp: remove this redundant call\n  |\n5 - let clone: &amp;Foo = foo.clone();\n5 + let clone: &amp;Foo = foo;\n  |\nhelp: if you meant to clone `Foo`, implement `Clone` for it\n  |\n3 + #[derive(Clone)]\n4 | struct Foo;\n  |\n\n</code></pre>\n<h3 id=\"explanation-62\"><a class=\"header\" href=\"#explanation-62\">Explanation</a></h3>\n<p>Some method calls are noops meaning that they do nothing. Usually such methods\nare the result of blanket implementations that happen to create some method invocations\nthat end up not doing anything. For instance, <code class=\"hljs\">Clone</code> is implemented on all <code class=\"hljs\">&amp;T</code>, but\ncalling <code class=\"hljs\">clone</code> on a <code class=\"hljs\">&amp;T</code> where <code class=\"hljs\">T</code> does not implement clone, actually doesn't do anything\nas references are copy. This lint detects these calls and warns the user about them.</p>\n<h2 id=\"opaque-hidden-inferred-bound\"><a class=\"header\" href=\"#opaque-hidden-inferred-bound\">opaque-hidden-inferred-bound</a></h2>\n<p>The <code class=\"hljs\">opaque_hidden_inferred_bound</code> lint detects cases in which nested\n<code class=\"hljs\">impl Trait</code> in associated type bounds are not written generally enough\nto satisfy the bounds of the associated type.</p>\n<h3 id=\"explanation-63\"><a class=\"header\" href=\"#explanation-63\">Explanation</a></h3>\n<p>This functionality was removed in #97346, but then rolled back in #99860\nbecause it caused regressions.</p>\n<p>We plan on reintroducing this as a hard error, but in the meantime,\nthis lint serves to warn and suggest fixes for any use-cases which rely\non this behavior.</p>\n<h3 id=\"example-63\"><a class=\"header\" href=\"#example-63\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![feature(type_alias_impl_trait)]</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Duh</span></span> {}\n\n<span class=\"hljs-keyword\">impl</span> Duh <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">i32</span> {}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Assoc</span></span>: Duh;\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;F: Duh&gt; Trait <span class=\"hljs-keyword\">for</span> F {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Assoc</span></span> = F;\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Tait</span></span> = <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Sized</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">test</span></span>() -&gt; <span class=\"hljs-keyword\">impl</span> Trait&lt;Assoc = Tait&gt; {\n    <span class=\"hljs-number\">42</span>\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: opaque type `impl Trait&lt;Assoc = Tait&gt;` does not satisfy its associated type bounds\n  --&gt; lint_example.rs:18:25\n   |\n9  |     type Assoc: Duh;\n   |                 --- this associated type bound is unsatisfied for `Tait`\n...\n18 | fn test() -&gt; impl Trait&lt;Assoc = Tait&gt; {\n   |                         ^^^^^^^^^^^^\n   |\n   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n\n</code></pre>\n<p>In this example, <code class=\"hljs\">test</code> declares that the associated type <code class=\"hljs\">Assoc</code> for\n<code class=\"hljs\">impl Trait</code> is <code class=\"hljs\">impl Sized</code>, which does not satisfy the bound <code class=\"hljs\">Duh</code>\non the associated type.</p>\n<p>Although the hidden type, <code class=\"hljs\">i32</code> does satisfy this bound, we do not\nconsider the return type to be well-formed with this lint. It can be\nfixed by changing <code class=\"hljs\">Tait = impl Sized</code> into <code class=\"hljs\">Tait = impl Sized + Duh</code>.</p>\n<h2 id=\"overlapping-patterns\"><a class=\"header\" href=\"#overlapping-patterns\">overlapping-patterns</a></h2>\n<p>The lint <code class=\"hljs\">overlapping-patterns</code> has been renamed to <a href=\"#overlapping-range-endpoints\"><code class=\"hljs\">overlapping-range-endpoints</code></a>.</p>\n<h2 id=\"overlapping-range-endpoints\"><a class=\"header\" href=\"#overlapping-range-endpoints\">overlapping-range-endpoints</a></h2>\n<p>The <code class=\"hljs\">overlapping_range_endpoints</code> lint detects <code class=\"hljs\">match</code> arms that have <a href=\"https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns\">range patterns</a> that\noverlap on their endpoints.</p>\n<h3 id=\"example-64\"><a class=\"header\" href=\"#example-64\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">123u8</span>;\n<span class=\"hljs-keyword\">match</span> x {\n    <span class=\"hljs-number\">0</span>..=<span class=\"hljs-number\">100</span> =&gt; { <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"small\"</span>); }\n    <span class=\"hljs-number\">100</span>..=<span class=\"hljs-number\">255</span> =&gt; { <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"large\"</span>); }\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: multiple patterns overlap on their endpoints\n --&gt; lint_example.rs:5:5\n  |\n4 |     0..=100 =&gt; { println!(\"small\"); }\n  |     ------- this range overlaps on `100_u8`...\n5 |     100..=255 =&gt; { println!(\"large\"); }\n  |     ^^^^^^^^^ ... with this range\n  |\n  = note: you likely meant to write mutually exclusive ranges\n  = note: `#[warn(overlapping_range_endpoints)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-64\"><a class=\"header\" href=\"#explanation-64\">Explanation</a></h3>\n<p>It is likely a mistake to have range patterns in a match expression that overlap in this\nway. Check that the beginning and end values are what you expect, and keep in mind that\nwith <code class=\"hljs\">..=</code> the left and right bounds are inclusive.</p>\n<h2 id=\"path-statements\"><a class=\"header\" href=\"#path-statements\">path-statements</a></h2>\n<p>The <code class=\"hljs\">path_statements</code> lint detects path statements with no effect.</p>\n<h3 id=\"example-65\"><a class=\"header\" href=\"#example-65\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">42</span>;\n\nx;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: path statement with no effect\n --&gt; lint_example.rs:4:1\n  |\n4 | x;\n  | ^^\n  |\n  = note: `#[warn(path_statements)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-65\"><a class=\"header\" href=\"#explanation-65\">Explanation</a></h3>\n<p>It is usually a mistake to have a statement that has no effect.</p>\n<h2 id=\"private-bounds\"><a class=\"header\" href=\"#private-bounds\">private-bounds</a></h2>\n<p>The <code class=\"hljs\">private_bounds</code> lint detects types in a secondary interface of an item,\nthat are more private than the item itself. Secondary interface of an item consists of\nbounds on generic parameters and where clauses, including supertraits for trait items.</p>\n<h3 id=\"example-66\"><a class=\"header\" href=\"#example-66\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-meta\">#![deny(private_bounds)]</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PrivTy</span></span>;\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">S</span></span>\n    <span class=\"hljs-keyword\">where</span> PrivTy:\n{}\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: type `PrivTy` is more private than the item `S`\n --&gt; lint_example.rs:5:1\n  |\n5 | pub struct S\n  | ^^^^^^^^^^^^ struct `S` is reachable at visibility `pub`\n  |\nnote: but type `PrivTy` is only usable at visibility `pub(crate)`\n --&gt; lint_example.rs:4:1\n  |\n4 | struct PrivTy;\n  | ^^^^^^^^^^^^^\nnote: the lint level is defined here\n --&gt; lint_example.rs:2:9\n  |\n2 | #![deny(private_bounds)]\n  |         ^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-66\"><a class=\"header\" href=\"#explanation-66\">Explanation</a></h3>\n<p>Having private types or traits in item bounds makes it less clear what interface\nthe item actually provides.</p>\n<h2 id=\"private-interfaces\"><a class=\"header\" href=\"#private-interfaces\">private-interfaces</a></h2>\n<p>The <code class=\"hljs\">private_interfaces</code> lint detects types in a primary interface of an item,\nthat are more private than the item itself. Primary interface of an item is all\nits interface except for bounds on generic parameters and where clauses.</p>\n<h3 id=\"example-67\"><a class=\"header\" href=\"#example-67\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-meta\">#![deny(private_interfaces)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SemiPriv</span></span>;\n\n<span class=\"hljs-keyword\">mod</span> m1 {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Priv</span></span>;\n    <span class=\"hljs-keyword\">impl</span> crate::SemiPriv {\n        <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">f</span></span>(_: Priv) {}\n    }\n}\n\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: type `Priv` is more private than the item `m1::&lt;impl SemiPriv&gt;::f`\n --&gt; lint_example.rs:8:9\n  |\n8 |         pub fn f(_: Priv) {}\n  |         ^^^^^^^^^^^^^^^^^ associated function `m1::&lt;impl SemiPriv&gt;::f` is reachable at visibility `pub(crate)`\n  |\nnote: but type `Priv` is only usable at visibility `pub(self)`\n --&gt; lint_example.rs:6:5\n  |\n6 |     struct Priv;\n  |     ^^^^^^^^^^^\nnote: the lint level is defined here\n --&gt; lint_example.rs:2:9\n  |\n2 | #![deny(private_interfaces)]\n  |         ^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-67\"><a class=\"header\" href=\"#explanation-67\">Explanation</a></h3>\n<p>Having something private in primary interface guarantees that\nthe item will be unusable from outer modules due to type privacy.</p>\n<h2 id=\"private-macro-use\"><a class=\"header\" href=\"#private-macro-use\">private-macro-use</a></h2>\n<p>The <code class=\"hljs\">private_macro_use</code> lint detects private macros that are imported\nwith <code class=\"hljs\">#[macro_use]</code>.</p>\n<h3 id=\"example-68\"><a class=\"header\" href=\"#example-68\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (needs extern crate) hljs\"><span class=\"hljs-comment\">// extern_macro.rs</span>\n<span class=\"hljs-built_in\">macro_rules!</span> foo_ { () =&gt; {}; }\n<span class=\"hljs-keyword\">use</span> foo_ <span class=\"hljs-keyword\">as</span> foo;\n\n<span class=\"hljs-comment\">// code.rs</span>\n\n<span class=\"hljs-meta\">#![deny(private_macro_use)]</span>\n\n<span class=\"hljs-meta\">#[macro_use]</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> extern_macro;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    foo!();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: cannot find macro `foo` in this scope\n</code></pre>\n<h3 id=\"explanation-68\"><a class=\"header\" href=\"#explanation-68\">Explanation</a></h3>\n<p>This lint arises from overlooking visibility checks for macros\nin an external crate.</p>\n<p>This is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to transition this to a\nhard error in the future.</p>\n<h2 id=\"redundant-semicolon\"><a class=\"header\" href=\"#redundant-semicolon\">redundant-semicolon</a></h2>\n<p>The lint <code class=\"hljs\">redundant-semicolon</code> has been renamed to <a href=\"#redundant-semicolons\"><code class=\"hljs\">redundant-semicolons</code></a>.</p>\n<h2 id=\"redundant-semicolons\"><a class=\"header\" href=\"#redundant-semicolons\">redundant-semicolons</a></h2>\n<p>The <code class=\"hljs\">redundant_semicolons</code> lint detects unnecessary trailing\nsemicolons.</p>\n<h3 id=\"example-69\"><a class=\"header\" href=\"#example-69\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> _ = <span class=\"hljs-number\">123</span>;;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unnecessary trailing semicolon\n --&gt; lint_example.rs:2:13\n  |\n2 | let _ = 123;;\n  |             ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-69\"><a class=\"header\" href=\"#explanation-69\">Explanation</a></h3>\n<p>Extra semicolons are not needed, and may be removed to avoid confusion\nand visual clutter.</p>\n<h2 id=\"refining-impl-trait-internal\"><a class=\"header\" href=\"#refining-impl-trait-internal\">refining-impl-trait-internal</a></h2>\n<p>The <code class=\"hljs\">refining_impl_trait_internal</code> lint detects <code class=\"hljs\">impl Trait</code> return\ntypes in method signatures that are refined by a trait implementation,\nmeaning the implementation adds information about the return type that\nis not present in the trait.</p>\n<h3 id=\"example-70\"><a class=\"header\" href=\"#example-70\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(refining_impl_trait)]</span>\n\n<span class=\"hljs-keyword\">use</span> std::fmt::Display;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">AsDisplay</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">as_display</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-keyword\">impl</span> Display;\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'s</span>&gt; AsDisplay <span class=\"hljs-keyword\">for</span> &amp;<span class=\"hljs-symbol\">'s</span> <span class=\"hljs-built_in\">str</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">as_display</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        *<span class=\"hljs-keyword\">self</span>\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// users can observe that the return type of</span>\n    <span class=\"hljs-comment\">// `&lt;&amp;str as AsDisplay&gt;::as_display()` is `&amp;str`.</span>\n    <span class=\"hljs-keyword\">let</span> _x: &amp;<span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"\"</span>.as_display();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: impl trait in impl method signature does not match trait method signature\n  --&gt; lint_example.rs:10:29\n   |\n6  |     fn as_display(&amp;self) -&gt; impl Display;\n   |                             ------------ return type from trait method defined here\n...\n10 |     fn as_display(&amp;self) -&gt; Self {\n   |                             ^^^^\n   |\n   = note: add `#[allow(refining_impl_trait)]` if it is intended for this to be part of the public API of this crate\n   = note: we are soliciting feedback, see issue #121718 &lt;https://github.com/rust-lang/rust/issues/121718&gt; for more information\nnote: the lint level is defined here\n  --&gt; lint_example.rs:1:9\n   |\n1  | #![deny(refining_impl_trait)]\n   |         ^^^^^^^^^^^^^^^^^^^\n   = note: `#[deny(refining_impl_trait_internal)]` implied by `#[deny(refining_impl_trait)]`\nhelp: replace the return type so that it matches the trait\n   |\n10 |     fn as_display(&amp;self) -&gt; impl std::fmt::Display {\n   |                             ~~~~~~~~~~~~~~~~~~~~~~\n\n</code></pre>\n<h3 id=\"explanation-70\"><a class=\"header\" href=\"#explanation-70\">Explanation</a></h3>\n<p>Callers of methods for types where the implementation is known are\nable to observe the types written in the impl signature. This may be\nintended behavior, but may also lead to implementation details being\nrevealed unintentionally. In particular, it may pose a semver hazard\nfor authors of libraries who do not wish to make stronger guarantees\nabout the types than what is written in the trait signature.</p>\n<p><code class=\"hljs\">refining_impl_trait</code> is a lint group composed of two lints:</p>\n<ul>\n<li><code class=\"hljs\">refining_impl_trait_reachable</code>, for refinements that are publically\nreachable outside a crate, and</li>\n<li><code class=\"hljs\">refining_impl_trait_internal</code>, for refinements that are only visible\nwithin a crate.</li>\n</ul>\n<p>We are seeking feedback on each of these lints; see issue\n<a href=\"https://github.com/rust-lang/rust/issues/121718\">#121718</a> for more\ninformation.</p>\n<h2 id=\"refining-impl-trait-reachable\"><a class=\"header\" href=\"#refining-impl-trait-reachable\">refining-impl-trait-reachable</a></h2>\n<p>The <code class=\"hljs\">refining_impl_trait_reachable</code> lint detects <code class=\"hljs\">impl Trait</code> return\ntypes in method signatures that are refined by a publically reachable\ntrait implementation, meaning the implementation adds information about\nthe return type that is not present in the trait.</p>\n<h3 id=\"example-71\"><a class=\"header\" href=\"#example-71\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(refining_impl_trait)]</span>\n\n<span class=\"hljs-keyword\">use</span> std::fmt::Display;\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">AsDisplay</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">as_display</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-keyword\">impl</span> Display;\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'s</span>&gt; AsDisplay <span class=\"hljs-keyword\">for</span> &amp;<span class=\"hljs-symbol\">'s</span> <span class=\"hljs-built_in\">str</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">as_display</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        *<span class=\"hljs-keyword\">self</span>\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// users can observe that the return type of</span>\n    <span class=\"hljs-comment\">// `&lt;&amp;str as AsDisplay&gt;::as_display()` is `&amp;str`.</span>\n    <span class=\"hljs-keyword\">let</span> _x: &amp;<span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"\"</span>.as_display();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: impl trait in impl method signature does not match trait method signature\n  --&gt; lint_example.rs:10:29\n   |\n6  |     fn as_display(&amp;self) -&gt; impl Display;\n   |                             ------------ return type from trait method defined here\n...\n10 |     fn as_display(&amp;self) -&gt; Self {\n   |                             ^^^^\n   |\n   = note: add `#[allow(refining_impl_trait)]` if it is intended for this to be part of the public API of this crate\n   = note: we are soliciting feedback, see issue #121718 &lt;https://github.com/rust-lang/rust/issues/121718&gt; for more information\nnote: the lint level is defined here\n  --&gt; lint_example.rs:1:9\n   |\n1  | #![deny(refining_impl_trait)]\n   |         ^^^^^^^^^^^^^^^^^^^\n   = note: `#[deny(refining_impl_trait_reachable)]` implied by `#[deny(refining_impl_trait)]`\nhelp: replace the return type so that it matches the trait\n   |\n10 |     fn as_display(&amp;self) -&gt; impl std::fmt::Display {\n   |                             ~~~~~~~~~~~~~~~~~~~~~~\n\n</code></pre>\n<h3 id=\"explanation-71\"><a class=\"header\" href=\"#explanation-71\">Explanation</a></h3>\n<p>Callers of methods for types where the implementation is known are\nable to observe the types written in the impl signature. This may be\nintended behavior, but may also lead to implementation details being\nrevealed unintentionally. In particular, it may pose a semver hazard\nfor authors of libraries who do not wish to make stronger guarantees\nabout the types than what is written in the trait signature.</p>\n<p><code class=\"hljs\">refining_impl_trait</code> is a lint group composed of two lints:</p>\n<ul>\n<li><code class=\"hljs\">refining_impl_trait_reachable</code>, for refinements that are publically\nreachable outside a crate, and</li>\n<li><code class=\"hljs\">refining_impl_trait_internal</code>, for refinements that are only visible\nwithin a crate.</li>\n</ul>\n<p>We are seeking feedback on each of these lints; see issue\n<a href=\"https://github.com/rust-lang/rust/issues/121718\">#121718</a> for more\ninformation.</p>\n<h2 id=\"renamed-and-removed-lints\"><a class=\"header\" href=\"#renamed-and-removed-lints\">renamed-and-removed-lints</a></h2>\n<p>The <code class=\"hljs\">renamed_and_removed_lints</code> lint detects lints that have been\nrenamed or removed.</p>\n<h3 id=\"example-72\"><a class=\"header\" href=\"#example-72\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![deny(raw_pointer_derive)]</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: lint `raw_pointer_derive` has been removed: using derive with raw pointers is ok\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(raw_pointer_derive)]\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(renamed_and_removed_lints)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-72\"><a class=\"header\" href=\"#explanation-72\">Explanation</a></h3>\n<p>To fix this, either remove the lint or use the new name. This can help\navoid confusion about lints that are no longer valid, and help\nmaintain consistency for renamed lints.</p>\n<h2 id=\"repr-transparent-external-private-fields\"><a class=\"header\" href=\"#repr-transparent-external-private-fields\">repr-transparent-external-private-fields</a></h2>\n<p>The <code class=\"hljs\">repr_transparent_external_private_fields</code> lint\ndetects types marked <code class=\"hljs\">#[repr(transparent)]</code> that (transitively)\ncontain an external ZST type marked <code class=\"hljs\">#[non_exhaustive]</code> or containing\nprivate fields</p>\n<h3 id=\"example-73\"><a class=\"header\" href=\"#example-73\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (needs external crate) hljs\"><span class=\"hljs-meta\">#![deny(repr_transparent_external_private_fields)]</span>\n<span class=\"hljs-keyword\">use</span> foo::NonExhaustiveZst;\n\n<span class=\"hljs-meta\">#[repr(transparent)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span></span>(<span class=\"hljs-built_in\">u32</span>, ([<span class=\"hljs-built_in\">u32</span>; <span class=\"hljs-number\">0</span>], NonExhaustiveZst));</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: zero-sized fields in repr(transparent) cannot contain external non-exhaustive types\n --&gt; src/main.rs:5:28\n  |\n5 | struct Bar(u32, ([u32; 0], NonExhaustiveZst));\n  |                            ^^^^^^^^^^^^^^^^\n  |\nnote: the lint level is defined here\n --&gt; src/main.rs:1:9\n  |\n1 | #![deny(repr_transparent_external_private_fields)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #78586 &lt;https://github.com/rust-lang/rust/issues/78586&gt;\n  = note: this struct contains `NonExhaustiveZst`, which is marked with `#[non_exhaustive]`, and makes it not a breaking change to become non-zero-sized in the future.\n</code></pre>\n<h3 id=\"explanation-73\"><a class=\"header\" href=\"#explanation-73\">Explanation</a></h3>\n<p>Previous, Rust accepted fields that contain external private zero-sized types,\neven though it should not be a breaking change to add a non-zero-sized field to\nthat private type.</p>\n<p>This is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to transition this\nto a hard error in the future. See <a href=\"https://github.com/rust-lang/rust/issues/78586\">issue #78586</a> for more details.</p>\n<h2 id=\"self-constructor-from-outer-item\"><a class=\"header\" href=\"#self-constructor-from-outer-item\">self-constructor-from-outer-item</a></h2>\n<p>The <code class=\"hljs\">self_constructor_from_outer_item</code> lint detects cases where the <code class=\"hljs\">Self</code> constructor\nwas silently allowed due to a bug in the resolver, and which may produce surprising\nand unintended behavior.</p>\n<p>Using a <code class=\"hljs\">Self</code> type alias from an outer item was never intended, but was silently allowed.\nThis is deprecated -- and is a hard error when the <code class=\"hljs\">Self</code> type alias references generics\nthat are not in scope.</p>\n<h3 id=\"example-74\"><a class=\"header\" href=\"#example-74\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(self_constructor_from_outer_item)]</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">S0</span></span>(<span class=\"hljs-built_in\">usize</span>);\n\n<span class=\"hljs-keyword\">impl</span> S0 {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {\n        <span class=\"hljs-keyword\">const</span> C: S0 = <span class=\"hljs-keyword\">Self</span>(<span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bar</span></span>() -&gt; S0 {\n            <span class=\"hljs-keyword\">Self</span>(<span class=\"hljs-number\">0</span>)\n        }\n    }\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: can't reference `Self` constructor from outer item\n --&gt; lint_example.rs:8:23\n  |\n6 | impl S0 {\n  | ------- the inner item doesn't inherit generics from this impl, so `Self` is invalid to reference\n7 |     fn foo() {\n8 |         const C: S0 = Self(0);\n  |                       ^^^^ help: replace `Self` with the actual type: `S0`\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #124186 &lt;https://github.com/rust-lang/rust/issues/124186&gt;\nnote: the lint level is defined here\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(self_constructor_from_outer_item)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nerror: can't reference `Self` constructor from outer item\n  --&gt; lint_example.rs:10:13\n   |\n6  | impl S0 {\n   | ------- the inner item doesn't inherit generics from this impl, so `Self` is invalid to reference\n...\n10 |             Self(0)\n   |             ^^^^ help: replace `Self` with the actual type: `S0`\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #124186 &lt;https://github.com/rust-lang/rust/issues/124186&gt;\n\n</code></pre>\n<h3 id=\"explanation-74\"><a class=\"header\" href=\"#explanation-74\">Explanation</a></h3>\n<p>The <code class=\"hljs\">Self</code> type alias should not be reachable because nested items are not associated with\nthe scope of the parameters from the parent item.</p>\n<h2 id=\"semicolon-in-expressions-from-macros\"><a class=\"header\" href=\"#semicolon-in-expressions-from-macros\">semicolon-in-expressions-from-macros</a></h2>\n<p>The <code class=\"hljs\">semicolon_in_expressions_from_macros</code> lint detects trailing semicolons\nin macro bodies when the macro is invoked in expression position.\nThis was previous accepted, but is being phased out.</p>\n<h3 id=\"example-75\"><a class=\"header\" href=\"#example-75\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![deny(semicolon_in_expressions_from_macros)]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> foo {\n    () =&gt; { <span class=\"hljs-literal\">true</span>; }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> val = <span class=\"hljs-keyword\">match</span> <span class=\"hljs-literal\">true</span> {\n        <span class=\"hljs-literal\">true</span> =&gt; <span class=\"hljs-literal\">false</span>,\n        _ =&gt; foo!()\n    };\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: trailing semicolon in macro used in expression position\n --&gt; lint_example.rs:3:17\n  |\n3 |     () =&gt; { true; }\n  |                 ^\n...\n9 |         _ =&gt; foo!()\n  |              ------ in this macro invocation\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #79813 &lt;https://github.com/rust-lang/rust/issues/79813&gt;\nnote: the lint level is defined here\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(semicolon_in_expressions_from_macros)]\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  = note: this error originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n</code></pre>\n<h3 id=\"explanation-75\"><a class=\"header\" href=\"#explanation-75\">Explanation</a></h3>\n<p>Previous, Rust ignored trailing semicolon in a macro\nbody when a macro was invoked in expression position.\nHowever, this makes the treatment of semicolons in the language\ninconsistent, and could lead to unexpected runtime behavior\nin some circumstances (e.g. if the macro author expects\na value to be dropped).</p>\n<p>This is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to transition this\nto a hard error in the future. See <a href=\"https://github.com/rust-lang/rust/issues/79813\">issue #79813</a> for more details.</p>\n<h2 id=\"special-module-name\"><a class=\"header\" href=\"#special-module-name\">special-module-name</a></h2>\n<p>The <code class=\"hljs\">special_module_name</code> lint detects module\ndeclarations for files that have a special meaning.</p>\n<h3 id=\"example-76\"><a class=\"header\" href=\"#example-76\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-keyword\">mod</span> lib;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    lib::run();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: found module declaration for lib.rs\n --&gt; lint_example.rs:1:1\n  |\n1 | mod lib;\n  | ^^^^^^^^\n  |\n  = note: lib.rs is the root of this crate's library target\n  = help: to refer to it from other targets, use the library's name as the path\n  = note: `#[warn(special_module_name)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-76\"><a class=\"header\" href=\"#explanation-76\">Explanation</a></h3>\n<p>Cargo recognizes <code class=\"hljs\">lib.rs</code> and <code class=\"hljs\">main.rs</code> as the root of a\nlibrary or binary crate, so declaring them as modules\nwill lead to miscompilation of the crate unless configured\nexplicitly.</p>\n<p>To access a library from a binary target within the same crate,\nuse <code class=\"hljs\">your_crate_name::</code> as the path instead of <code class=\"hljs\">lib::</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-comment\">// bar/src/lib.rs</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>() {\n    <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-comment\">// bar/src/main.rs</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    bar::run();\n}</code></pre>\n<p>Binary targets cannot be used as libraries and so declaring\none as a module is not allowed.</p>\n<h2 id=\"stable-features\"><a class=\"header\" href=\"#stable-features\">stable-features</a></h2>\n<p>The <code class=\"hljs\">stable_features</code> lint detects a <a href=\"https://doc.rust-lang.org/nightly/unstable-book/\"><code class=\"hljs\">feature</code> attribute</a> that\nhas since been made stable.</p>\n<h3 id=\"example-77\"><a class=\"header\" href=\"#example-77\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![feature(test_accepted_feature)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: the feature `test_accepted_feature` has been stable since 1.0.0 and no longer requires an attribute to enable\n --&gt; lint_example.rs:1:12\n  |\n1 | #![feature(test_accepted_feature)]\n  |            ^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(stable_features)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-77\"><a class=\"header\" href=\"#explanation-77\">Explanation</a></h3>\n<p>When a feature is stabilized, it is no longer necessary to include a\n<code class=\"hljs\">#![feature]</code> attribute for it. To fix, simply remove the\n<code class=\"hljs\">#![feature]</code> attribute.</p>\n<h2 id=\"static-mut-ref\"><a class=\"header\" href=\"#static-mut-ref\">static-mut-ref</a></h2>\n<p>The lint <code class=\"hljs\">static-mut-ref</code> has been renamed to <a href=\"#static-mut-refs\"><code class=\"hljs\">static-mut-refs</code></a>.</p>\n<h2 id=\"static-mut-refs\"><a class=\"header\" href=\"#static-mut-refs\">static-mut-refs</a></h2>\n<p>The <code class=\"hljs\">static_mut_refs</code> lint checks for shared or mutable references\nof mutable static inside <code class=\"hljs\">unsafe</code> blocks and <code class=\"hljs\">unsafe</code> functions.</p>\n<h3 id=\"example-78\"><a class=\"header\" href=\"#example-78\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">mut</span> X: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">23</span>;\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">mut</span> Y: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">24</span>;\n\n    <span class=\"hljs-keyword\">unsafe</span> {\n        <span class=\"hljs-keyword\">let</span> y = &amp;X;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">ref</span> x = X;\n        <span class=\"hljs-keyword\">let</span> (x, y) = (&amp;X, &amp;Y);\n        foo(&amp;X);\n    }\n}\n\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">_foo</span></span>() {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">mut</span> X: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">23</span>;\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">mut</span> Y: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">24</span>;\n\n    <span class=\"hljs-keyword\">let</span> y = &amp;X;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">ref</span> x = X;\n    <span class=\"hljs-keyword\">let</span> (x, y) = (&amp;X, &amp;Y);\n    foo(&amp;X);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(_x: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">i32</span>) {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: creating a shared reference to mutable static is discouraged\n --&gt; lint_example.rs:6:17\n  |\n6 |         let y = &amp;X;\n  |                 ^^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\n  = note: `#[warn(static_mut_refs)]` on by default\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n6 |         let y = addr_of!(X);\n  |                 ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n --&gt; lint_example.rs:7:21\n  |\n7 |         let ref x = X;\n  |                     ^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n7 |         let ref x = addr_of!(X);\n  |                     ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n --&gt; lint_example.rs:8:23\n  |\n8 |         let (x, y) = (&amp;X, &amp;Y);\n  |                       ^^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n8 |         let (x, y) = (addr_of!(X), &amp;Y);\n  |                       ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n --&gt; lint_example.rs:8:27\n  |\n8 |         let (x, y) = (&amp;X, &amp;Y);\n  |                           ^^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n8 |         let (x, y) = (&amp;X, addr_of!(Y));\n  |                           ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n --&gt; lint_example.rs:9:13\n  |\n9 |         foo(&amp;X);\n  |             ^^ shared reference to mutable static\n  |\n  = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n  = note: this will be a hard error in the 2024 edition\n  = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n  |\n9 |         foo(addr_of!(X));\n  |             ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --&gt; lint_example.rs:17:13\n   |\n17 |     let y = &amp;X;\n   |             ^^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n17 |     let y = addr_of!(X);\n   |             ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --&gt; lint_example.rs:18:17\n   |\n18 |     let ref x = X;\n   |                 ^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n18 |     let ref x = addr_of!(X);\n   |                 ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --&gt; lint_example.rs:19:19\n   |\n19 |     let (x, y) = (&amp;X, &amp;Y);\n   |                   ^^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n19 |     let (x, y) = (addr_of!(X), &amp;Y);\n   |                   ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --&gt; lint_example.rs:19:23\n   |\n19 |     let (x, y) = (&amp;X, &amp;Y);\n   |                       ^^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n19 |     let (x, y) = (&amp;X, addr_of!(Y));\n   |                       ~~~~~~~~~~~\n\n\nwarning: creating a shared reference to mutable static is discouraged\n  --&gt; lint_example.rs:20:9\n   |\n20 |     foo(&amp;X);\n   |         ^^ shared reference to mutable static\n   |\n   = note: for more information, see issue #114447 &lt;https://github.com/rust-lang/rust/issues/114447&gt;\n   = note: this will be a hard error in the 2024 edition\n   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior\nhelp: use `addr_of!` instead to create a raw pointer\n   |\n20 |     foo(addr_of!(X));\n   |         ~~~~~~~~~~~\n\n</code></pre>\n<h3 id=\"explanation-78\"><a class=\"header\" href=\"#explanation-78\">Explanation</a></h3>\n<p>Shared or mutable references of mutable static are almost always a mistake and\ncan lead to undefined behavior and various other problems in your code.</p>\n<p>This lint is \"warn\" by default on editions up to 2021, in 2024 there is\na hard error instead.</p>\n<h2 id=\"suspicious-double-ref-op\"><a class=\"header\" href=\"#suspicious-double-ref-op\">suspicious-double-ref-op</a></h2>\n<p>The <code class=\"hljs\">suspicious_double_ref_op</code> lint checks for usage of <code class=\"hljs\">.clone()</code>/<code class=\"hljs\">.borrow()</code>/<code class=\"hljs\">.deref()</code>\non an <code class=\"hljs\">&amp;&amp;T</code> when <code class=\"hljs\">T: !Deref/Borrow/Clone</code>, which means the call will return the inner <code class=\"hljs\">&amp;T</code>,\ninstead of performing the operation on the underlying <code class=\"hljs\">T</code> and can be confusing.</p>\n<h3 id=\"example-79\"><a class=\"header\" href=\"#example-79\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n<span class=\"hljs-keyword\">let</span> foo = &amp;&amp;Foo;\n<span class=\"hljs-keyword\">let</span> clone: &amp;Foo = foo.clone();</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: using `.clone()` on a double reference, which returns `&amp;Foo` instead of cloning the inner type\n --&gt; lint_example.rs:5:22\n  |\n5 | let clone: &amp;Foo = foo.clone();\n  |                      ^^^^^^^^\n  |\n  = note: `#[warn(suspicious_double_ref_op)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-79\"><a class=\"header\" href=\"#explanation-79\">Explanation</a></h3>\n<p>Since <code class=\"hljs\">Foo</code> doesn't implement <code class=\"hljs\">Clone</code>, running <code class=\"hljs\">.clone()</code> only dereferences the double\nreference, instead of cloning the inner type which should be what was intended.</p>\n<h2 id=\"temporary-cstring-as-ptr\"><a class=\"header\" href=\"#temporary-cstring-as-ptr\">temporary-cstring-as-ptr</a></h2>\n<p>The <code class=\"hljs\">temporary_cstring_as_ptr</code> lint detects getting the inner pointer of\na temporary <code class=\"hljs\">CString</code>.</p>\n<h3 id=\"example-80\"><a class=\"header\" href=\"#example-80\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::ffi::CString;\n</span><span class=\"hljs-keyword\">let</span> c_str = CString::new(<span class=\"hljs-string\">\"foo\"</span>).unwrap().as_ptr();</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: getting the inner pointer of a temporary `CString`\n --&gt; lint_example.rs:4:42\n  |\n4 | let c_str = CString::new(\"foo\").unwrap().as_ptr();\n  |             ---------------------------- ^^^^^^ this pointer will be invalid\n  |             |\n  |             this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n  |\n  = note: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n  = help: for more information, see https://doc.rust-lang.org/reference/destructors.html\n  = note: `#[warn(temporary_cstring_as_ptr)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-80\"><a class=\"header\" href=\"#explanation-80\">Explanation</a></h3>\n<p>The inner pointer of a <code class=\"hljs\">CString</code> lives only as long as the <code class=\"hljs\">CString</code> it\npoints to. Getting the inner pointer of a <em>temporary</em> <code class=\"hljs\">CString</code> allows the <code class=\"hljs\">CString</code>\nto be dropped at the end of the statement, as it is not being referenced as far as the\ntypesystem is concerned. This means outside of the statement the pointer will point to\nfreed memory, which causes undefined behavior if the pointer is later dereferenced.</p>\n<h2 id=\"trivial-bounds\"><a class=\"header\" href=\"#trivial-bounds\">trivial-bounds</a></h2>\n<p>The <code class=\"hljs\">trivial_bounds</code> lint detects trait bounds that don't depend on\nany type parameters.</p>\n<h3 id=\"example-81\"><a class=\"header\" href=\"#example-81\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![feature(trivial_bounds)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">A</span></span> <span class=\"hljs-keyword\">where</span> <span class=\"hljs-built_in\">i32</span>: <span class=\"hljs-built_in\">Copy</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: trait bound i32: Copy does not depend on any type or lifetime parameters\n --&gt; lint_example.rs:3:25\n  |\n3 | pub struct A where i32: Copy;\n  |                         ^^^^\n  |\n  = note: `#[warn(trivial_bounds)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-81\"><a class=\"header\" href=\"#explanation-81\">Explanation</a></h3>\n<p>Usually you would not write a trait bound that you know is always\ntrue, or never true. However, when using macros, the macro may not\nknow whether or not the constraint would hold or not at the time when\ngenerating the code. Currently, the compiler does not alert you if the\nconstraint is always true, and generates an error if it is never true.\nThe <code class=\"hljs\">trivial_bounds</code> feature changes this to be a warning in both\ncases, giving macros more freedom and flexibility to generate code,\nwhile still providing a signal when writing non-macro code that\nsomething is amiss.</p>\n<p>See <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2056-allow-trivial-where-clause-constraints.md\">RFC 2056</a> for more details. This feature is currently only\navailable on the nightly channel, see <a href=\"https://github.com/rust-lang/rust/issues/48214\">tracking issue #48214</a>.</p>\n<h2 id=\"type-alias-bounds\"><a class=\"header\" href=\"#type-alias-bounds\">type-alias-bounds</a></h2>\n<p>The <code class=\"hljs\">type_alias_bounds</code> lint detects bounds in type aliases.</p>\n<h3 id=\"example-82\"><a class=\"header\" href=\"#example-82\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">SendVec</span></span>&lt;T: <span class=\"hljs-built_in\">Send</span>&gt; = <span class=\"hljs-built_in\">Vec</span>&lt;T&gt;;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: bounds on generic parameters are not enforced in type aliases\n --&gt; lint_example.rs:2:17\n  |\n2 | type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;\n  |                 ^^^^\n  |\n  = note: `#[warn(type_alias_bounds)]` on by default\nhelp: the bound will not be checked when the type alias is used, and should be removed\n  |\n2 - type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;\n2 + type SendVec&lt;T&gt; = Vec&lt;T&gt;;\n  |\n\n</code></pre>\n<h3 id=\"explanation-82\"><a class=\"header\" href=\"#explanation-82\">Explanation</a></h3>\n<p>The trait bounds in a type alias are currently ignored, and should not\nbe included to avoid confusion. This was previously allowed\nunintentionally; this may become a hard error in the future.</p>\n<h2 id=\"tyvar-behind-raw-pointer\"><a class=\"header\" href=\"#tyvar-behind-raw-pointer\">tyvar-behind-raw-pointer</a></h2>\n<p>The <code class=\"hljs\">tyvar_behind_raw_pointer</code> lint detects raw pointer to an\ninference variable.</p>\n<h3 id=\"example-83\"><a class=\"header\" href=\"#example-83\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust edition2015 hljs\"><span class=\"hljs-comment\">// edition 2015</span>\n<span class=\"hljs-keyword\">let</span> data = std::ptr::null();\n<span class=\"hljs-keyword\">let</span> _ = &amp;data <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> *<span class=\"hljs-keyword\">const</span> ();\n\n<span class=\"hljs-keyword\">if</span> data.is_null() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: type annotations needed\n --&gt; lint_example.rs:6:9\n  |\n6 | if data.is_null() {}\n  |         ^^^^^^^\n  |\n  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n  = note: for more information, see issue #46906 &lt;https://github.com/rust-lang/rust/issues/46906&gt;\n  = note: `#[warn(tyvar_behind_raw_pointer)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-83\"><a class=\"header\" href=\"#explanation-83\">Explanation</a></h3>\n<p>This kind of inference was previously allowed, but with the future\narrival of <a href=\"https://github.com/rust-lang/rust/issues/44874\">arbitrary self types</a>, this can introduce ambiguity. To\nresolve this, use an explicit type instead of relying on type\ninference.</p>\n<p>This is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to transition this to a hard\nerror in the 2018 edition. See <a href=\"https://github.com/rust-lang/rust/issues/46906\">issue #46906</a> for more details. This\nis currently a hard-error on the 2018 edition, and is \"warn\" by\ndefault in the 2015 edition.</p>\n<h2 id=\"uncommon-codepoints\"><a class=\"header\" href=\"#uncommon-codepoints\">uncommon-codepoints</a></h2>\n<p>The <code class=\"hljs\">uncommon_codepoints</code> lint detects uncommon Unicode codepoints in\nidentifiers.</p>\n<h3 id=\"example-84\"><a class=\"header\" href=\"#example-84\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-keyword\">const</span> µ: <span class=\"hljs-built_in\">f64</span> = <span class=\"hljs-number\">0.000001</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: identifier contains a non normalized (NFKC) character: 'µ'\n --&gt; lint_example.rs:3:7\n  |\n3 | const µ: f64 = 0.000001;\n  |       ^\n  |\n  = note: this character is included in the Not_NFKC Unicode general security profile\n  = note: `#[warn(uncommon_codepoints)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-84\"><a class=\"header\" href=\"#explanation-84\">Explanation</a></h3>\n<p>This lint warns about using characters which are not commonly used, and may\ncause visual confusion.</p>\n<p>This lint is triggered by identifiers that contain a codepoint that is\nnot part of the set of \"Allowed\" codepoints as described by <a href=\"https://www.unicode.org/reports/tr39/#General_Security_Profile\">Unicode®\nTechnical Standard #39 Unicode Security Mechanisms Section 3.1 General\nSecurity Profile for Identifiers</a>.</p>\n<p>Note that the set of uncommon codepoints may change over time. Beware\nthat if you \"forbid\" this lint that existing code may fail in the\nfuture.</p>\n<h2 id=\"unconditional-recursion\"><a class=\"header\" href=\"#unconditional-recursion\">unconditional-recursion</a></h2>\n<p>The <code class=\"hljs\">unconditional_recursion</code> lint detects functions that cannot\nreturn without calling themselves.</p>\n<h3 id=\"example-85\"><a class=\"header\" href=\"#example-85\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {\n    foo();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: function cannot return without recursing\n --&gt; lint_example.rs:2:1\n  |\n2 | fn foo() {\n  | ^^^^^^^^ cannot return without recursing\n3 |     foo();\n  |     ----- recursive call site\n  |\n  = help: a `loop` may express intention better if this is on purpose\n  = note: `#[warn(unconditional_recursion)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-85\"><a class=\"header\" href=\"#explanation-85\">Explanation</a></h3>\n<p>It is usually a mistake to have a recursive call that does not have\nsome condition to cause it to terminate. If you really intend to have\nan infinite loop, using a <code class=\"hljs\">loop</code> expression is recommended.</p>\n<h2 id=\"uncovered-param-in-projection\"><a class=\"header\" href=\"#uncovered-param-in-projection\">uncovered-param-in-projection</a></h2>\n<p>The <code class=\"hljs\">uncovered_param_in_projection</code> lint detects a violation of one of Rust's orphan rules for\nforeign trait implementations that concerns the use of type parameters inside trait associated\ntype paths (\"projections\") whose output may not be a local type that is mistakenly considered\nto \"cover\" said parameters which is <strong>unsound</strong> and which may be rejected by a future version\nof the compiler.</p>\n<p>Originally reported in <a href=\"https://github.com/rust-lang/rust/issues/99554\">#99554</a>.</p>\n<h3 id=\"example-86\"><a class=\"header\" href=\"#example-86\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (dependent) hljs\"><span class=\"hljs-comment\">// dependency.rs</span>\n<span class=\"hljs-meta\">#![crate_type = <span class=\"hljs-meta-string\">\"lib\"</span>]</span>\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span>&lt;T, U&gt; {}</code></pre>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-edition2021 ignore (needs dependency) hljs\">// dependent.rs\ntrait Identity {\n    type Output;\n}\n\nimpl&lt;T&gt; Identity for T {\n    type Output = T;\n}\n\nstruct Local;\n\nimpl&lt;T&gt; dependency::Trait&lt;Local, T&gt; for &lt;T as Identity&gt;::Output {}\n\nfn main() {}\n</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n  --&gt; dependent.rs:11:6\n   |\n11 | impl&lt;T&gt; dependency::Trait&lt;Local, T&gt; for &lt;T as Identity&gt;::Output {}\n   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #124559 &lt;https://github.com/rust-lang/rust/issues/124559&gt;\n   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n   = note: in this case, 'before' refers to the following order: `impl&lt;..&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0`, where `T0` is the first and `Tn` is the last\n   = note: `#[warn(uncovered_param_in_projection)]` on by default\n</code></pre>\n<h3 id=\"explanation-86\"><a class=\"header\" href=\"#explanation-86\">Explanation</a></h3>\n<p>FIXME(fmease): Write explainer.</p>\n<h2 id=\"undefined-naked-function-abi\"><a class=\"header\" href=\"#undefined-naked-function-abi\">undefined-naked-function-abi</a></h2>\n<p>The <code class=\"hljs\">undefined_naked_function_abi</code> lint detects naked function definitions that\neither do not specify an ABI or specify the Rust ABI.</p>\n<h3 id=\"example-87\"><a class=\"header\" href=\"#example-87\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![feature(asm_experimental_arch, naked_functions)]</span>\n\n<span class=\"hljs-keyword\">use</span> std::arch::asm;\n\n<span class=\"hljs-meta\">#[naked]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">default_abi</span></span>() -&gt; <span class=\"hljs-built_in\">u32</span> {\n    <span class=\"hljs-keyword\">unsafe</span> { asm!(<span class=\"hljs-string\">\"\"</span>, options(noreturn)); }\n}\n\n<span class=\"hljs-meta\">#[naked]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"Rust\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">rust_abi</span></span>() -&gt; <span class=\"hljs-built_in\">u32</span> {\n    <span class=\"hljs-keyword\">unsafe</span> { asm!(<span class=\"hljs-string\">\"\"</span>, options(noreturn)); }\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: Rust ABI is unsupported in naked functions\n --&gt; lint_example.rs:7:1\n  |\n7 | pub fn default_abi() -&gt; u32 {\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(undefined_naked_function_abi)]` on by default\n\n\nwarning: Rust ABI is unsupported in naked functions\n  --&gt; lint_example.rs:12:1\n   |\n12 | pub extern \"Rust\" fn rust_abi() -&gt; u32 {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n</code></pre>\n<h3 id=\"explanation-87\"><a class=\"header\" href=\"#explanation-87\">Explanation</a></h3>\n<p>The Rust ABI is currently undefined. Therefore, naked functions should\nspecify a non-Rust ABI.</p>\n<h2 id=\"unexpected-cfgs\"><a class=\"header\" href=\"#unexpected-cfgs\">unexpected-cfgs</a></h2>\n<p>The <code class=\"hljs\">unexpected_cfgs</code> lint detects unexpected conditional compilation conditions.</p>\n<h3 id=\"example-88\"><a class=\"header\" href=\"#example-88\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">rustc --check-cfg 'cfg()'\n</code></pre>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (needs command line option) hljs\"><span class=\"hljs-meta\">#[cfg(widnows)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unexpected `cfg` condition name: `widnows`\n --&gt; lint_example.rs:1:7\n  |\n1 | #[cfg(widnows)]\n  |       ^^^^^^^\n  |\n  = note: `#[warn(unexpected_cfgs)]` on by default\n</code></pre>\n<h3 id=\"explanation-88\"><a class=\"header\" href=\"#explanation-88\">Explanation</a></h3>\n<p>This lint is only active when <a href=\"https://doc.rust-lang.org/nightly/rustc/check-cfg.html\"><code class=\"hljs\">--check-cfg</code></a> arguments are being\npassed to the compiler and triggers whenever an unexpected condition name or value is\nused.</p>\n<p>See the <a href=\"https://doc.rust-lang.org/nightly/rustc/check-cfg.html\">Checking Conditional Configurations</a> section for more\ndetails.</p>\n<h2 id=\"unfulfilled-lint-expectations\"><a class=\"header\" href=\"#unfulfilled-lint-expectations\">unfulfilled-lint-expectations</a></h2>\n<p>The <code class=\"hljs\">unfulfilled_lint_expectations</code> lint detects lint trigger expectations\nthat have not been fulfilled.</p>\n<h3 id=\"example-89\"><a class=\"header\" href=\"#example-89\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![feature(lint_reasons)]</span>\n\n<span class=\"hljs-meta\">#[expect(unused_variables)]</span>\n<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x);</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: this lint expectation is unfulfilled\n --&gt; lint_example.rs:4:10\n  |\n4 | #[expect(unused_variables)]\n  |          ^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unfulfilled_lint_expectations)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-89\"><a class=\"header\" href=\"#explanation-89\">Explanation</a></h3>\n<p>It was expected that the marked code would emit a lint. This expectation\nhas not been fulfilled.</p>\n<p>The <code class=\"hljs\">expect</code> attribute can be removed if this is intended behavior otherwise\nit should be investigated why the expected lint is no longer issued.</p>\n<p>In rare cases, the expectation might be emitted at a different location than\nshown in the shown code snippet. In most cases, the <code class=\"hljs\">#[expect]</code> attribute\nworks when added to the outer scope. A few lints can only be expected\non a crate level.</p>\n<p>Part of RFC 2383. The progress is being tracked in <a href=\"https://github.com/rust-lang/rust/issues/54503\">#54503</a></p>\n<h2 id=\"ungated-async-fn-track-caller\"><a class=\"header\" href=\"#ungated-async-fn-track-caller\">ungated-async-fn-track-caller</a></h2>\n<p>The <code class=\"hljs\">ungated_async_fn_track_caller</code> lint warns when the\n<code class=\"hljs\">#[track_caller]</code> attribute is used on an async function\nwithout enabling the corresponding unstable feature flag.</p>\n<h3 id=\"example-90\"><a class=\"header\" href=\"#example-90\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#[track_caller]</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: `#[track_caller]` on async functions is a no-op\n --&gt; lint_example.rs:2:1\n  |\n2 | #[track_caller]\n  | ^^^^^^^^^^^^^^^\n3 | async fn foo() {}\n  | ----------------- this function will not propagate the caller location\n  |\n  = note: see issue #110011 &lt;https://github.com/rust-lang/rust/issues/110011&gt; for more information\n  = help: add `#![feature(async_fn_track_caller)]` to the crate attributes to enable\n  = note: this compiler was built on 2024-07-21; consider upgrading it if it is out of date\n  = note: `#[warn(ungated_async_fn_track_caller)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-90\"><a class=\"header\" href=\"#explanation-90\">Explanation</a></h3>\n<p>The attribute must be used in conjunction with the\n<a href=\"https://doc.rust-lang.org/beta/unstable-book/language-features/async-fn-track-caller.html\"><code class=\"hljs\">async_fn_track_caller</code> feature flag</a>. Otherwise, the <code class=\"hljs\">#[track_caller]</code>\nannotation will function as a no-op.</p>\n<h2 id=\"uninhabited-static\"><a class=\"header\" href=\"#uninhabited-static\">uninhabited-static</a></h2>\n<p>The <code class=\"hljs\">uninhabited_static</code> lint detects uninhabited statics.</p>\n<h3 id=\"example-91\"><a class=\"header\" href=\"#example-91\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Void</span></span> {}\n<span class=\"hljs-keyword\">extern</span> {\n    <span class=\"hljs-keyword\">static</span> EXTERN: Void;\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: static of uninhabited type\n --&gt; lint_example.rs:4:5\n  |\n4 |     static EXTERN: Void;\n  |     ^^^^^^^^^^^^^^^^^^^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #74840 &lt;https://github.com/rust-lang/rust/issues/74840&gt;\n  = note: uninhabited statics cannot be initialized, and any access would be an immediate error\n  = note: `#[warn(uninhabited_static)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-91\"><a class=\"header\" href=\"#explanation-91\">Explanation</a></h3>\n<p>Statics with an uninhabited type can never be initialized, so they are impossible to define.\nHowever, this can be side-stepped with an <code class=\"hljs\">extern static</code>, leading to problems later in the\ncompiler which assumes that there are no initialized uninhabited places (such as locals or\nstatics). This was accidentally allowed, but is being phased out.</p>\n<h2 id=\"unknown-lints\"><a class=\"header\" href=\"#unknown-lints\">unknown-lints</a></h2>\n<p>The <code class=\"hljs\">unknown_lints</code> lint detects unrecognized lint attributes.</p>\n<h3 id=\"example-92\"><a class=\"header\" href=\"#example-92\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![allow(not_a_real_lint)]</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unknown lint: `not_a_real_lint`\n --&gt; lint_example.rs:1:10\n  |\n1 | #![allow(not_a_real_lint)]\n  |          ^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unknown_lints)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-92\"><a class=\"header\" href=\"#explanation-92\">Explanation</a></h3>\n<p>It is usually a mistake to specify a lint that does not exist. Check\nthe spelling, and check the lint listing for the correct name. Also\nconsider if you are using an old version of the compiler, and the lint\nis only available in a newer version.</p>\n<h2 id=\"unknown-or-malformed-diagnostic-attributes\"><a class=\"header\" href=\"#unknown-or-malformed-diagnostic-attributes\">unknown-or-malformed-diagnostic-attributes</a></h2>\n<p>The <code class=\"hljs\">unknown_or_malformed_diagnostic_attributes</code> lint detects unrecognized or otherwise malformed\ndiagnostic attributes.</p>\n<h3 id=\"example-93\"><a class=\"header\" href=\"#example-93\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![feature(diagnostic_namespace)]</span>\n<span class=\"hljs-meta\">#[diagnostic::does_not_exist]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unknown diagnostic attribute\n --&gt; lint_example.rs:3:15\n  |\n3 | #[diagnostic::does_not_exist]\n  |               ^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unknown_or_malformed_diagnostic_attributes)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-93\"><a class=\"header\" href=\"#explanation-93\">Explanation</a></h3>\n<p>It is usually a mistake to specify a diagnostic attribute that does not exist. Check\nthe spelling, and check the diagnostic attribute listing for the correct name. Also\nconsider if you are using an old version of the compiler, and the attribute\nis only available in a newer version.</p>\n<h2 id=\"unnameable-test-items\"><a class=\"header\" href=\"#unnameable-test-items\">unnameable-test-items</a></h2>\n<p>The <code class=\"hljs\">unnameable_test_items</code> lint detects <a href=\"https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute\"><code class=\"hljs\">#[test]</code></a> functions\nthat are not able to be run by the test harness because they are in a\nposition where they are not nameable.</p>\n<h3 id=\"example-94\"><a class=\"header\" href=\"#example-94\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust test hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {\n        <span class=\"hljs-comment\">// This test will not fail because it does not run.</span>\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n    }\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: cannot test inner items\n --&gt; lint_example.rs:2:5\n  |\n2 |     #[test]\n  |     ^^^^^^^\n  |\n  = note: `#[warn(unnameable_test_items)]` on by default\n  = note: this warning originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n</code></pre>\n<h3 id=\"explanation-94\"><a class=\"header\" href=\"#explanation-94\">Explanation</a></h3>\n<p>In order for the test harness to run a test, the test function must be\nlocated in a position where it can be accessed from the crate root.\nThis generally means it must be defined in a module, and not anywhere\nelse such as inside another function. The compiler previously allowed\nthis without an error, so a lint was added as an alert that a test is\nnot being used. Whether or not this should be allowed has not yet been\ndecided, see <a href=\"https://github.com/rust-lang/rfcs/pull/2471#issuecomment-397414443\">RFC 2471</a> and <a href=\"https://github.com/rust-lang/rust/issues/36629\">issue #36629</a>.</p>\n<h2 id=\"unreachable-code\"><a class=\"header\" href=\"#unreachable-code\">unreachable-code</a></h2>\n<p>The <code class=\"hljs\">unreachable_code</code> lint detects unreachable code paths.</p>\n<h3 id=\"example-95\"><a class=\"header\" href=\"#example-95\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust no_run hljs\"><span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"we never go past here!\"</span>);\n\n<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unreachable statement\n --&gt; lint_example.rs:4:1\n  |\n2 | panic!(\"we never go past here!\");\n  | -------------------------------- any code following this expression is unreachable\n3 |\n4 | let x = 5;\n  | ^^^^^^^^^^ unreachable statement\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-95\"><a class=\"header\" href=\"#explanation-95\">Explanation</a></h3>\n<p>Unreachable code may signal a mistake or unfinished code. If the code\nis no longer in use, consider removing it.</p>\n<h2 id=\"unreachable-patterns\"><a class=\"header\" href=\"#unreachable-patterns\">unreachable-patterns</a></h2>\n<p>The <code class=\"hljs\">unreachable_patterns</code> lint detects unreachable patterns.</p>\n<h3 id=\"example-96\"><a class=\"header\" href=\"#example-96\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">match</span> x {\n    y =&gt; (),\n    <span class=\"hljs-number\">5</span> =&gt; (),\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unreachable pattern\n --&gt; lint_example.rs:5:5\n  |\n4 |     y =&gt; (),\n  |     - matches any value\n5 |     5 =&gt; (),\n  |     ^ unreachable pattern\n  |\n  = note: `#[warn(unreachable_patterns)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-96\"><a class=\"header\" href=\"#explanation-96\">Explanation</a></h3>\n<p>This usually indicates a mistake in how the patterns are specified or\nordered. In this example, the <code class=\"hljs\">y</code> pattern will always match, so the\nfive is impossible to reach. Remember, match arms match in order, you\nprobably wanted to put the <code class=\"hljs\">5</code> case above the <code class=\"hljs\">y</code> case.</p>\n<h2 id=\"unstable-name-collision\"><a class=\"header\" href=\"#unstable-name-collision\">unstable-name-collision</a></h2>\n<p>The lint <code class=\"hljs\">unstable-name-collision</code> has been renamed to <a href=\"#unstable-name-collisions\"><code class=\"hljs\">unstable-name-collisions</code></a>.</p>\n<h2 id=\"unstable-name-collisions\"><a class=\"header\" href=\"#unstable-name-collisions\">unstable-name-collisions</a></h2>\n<p>The <code class=\"hljs\">unstable_name_collisions</code> lint detects that you have used a name\nthat the standard library plans to add in the future.</p>\n<h3 id=\"example-97\"><a class=\"header\" href=\"#example-97\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">MyIterator</span></span> : <span class=\"hljs-built_in\">Iterator</span> {\n    <span class=\"hljs-comment\">// is_sorted is an unstable method that already exists on the Iterator trait</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">is_sorted</span></span>(<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">bool</span> <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">Self</span>: <span class=\"hljs-built_in\">Sized</span> {<span class=\"hljs-literal\">true</span>}\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; MyIterator <span class=\"hljs-keyword\">for</span> T <span class=\"hljs-keyword\">where</span> T: <span class=\"hljs-built_in\">Iterator</span> { }\n\n<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> _ = x.iter().is_sorted();</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: a method with this name may be added to the standard library in the future\n  --&gt; lint_example.rs:10:18\n   |\n10 | let _ = x.iter().is_sorted();\n   |                  ^^^^^^^^^\n   |\n   = warning: once this associated item is added to the standard library, the ambiguity may cause an error or change in behavior!\n   = note: for more information, see issue #48919 &lt;https://github.com/rust-lang/rust/issues/48919&gt;\n   = help: call with fully qualified syntax `MyIterator::is_sorted(...)` to keep using the current method\n   = note: `#[warn(unstable_name_collisions)]` on by default\nhelp: add `#![feature(is_sorted)]` to the crate attributes to enable `is_sorted`\n   |\n1  + #![feature(is_sorted)]\n   |\n\n</code></pre>\n<h3 id=\"explanation-97\"><a class=\"header\" href=\"#explanation-97\">Explanation</a></h3>\n<p>When new methods are added to traits in the standard library, they are\nusually added in an \"unstable\" form which is only available on the\n<a href=\"https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\">nightly channel</a> with a <a href=\"https://doc.rust-lang.org/nightly/unstable-book/\"><code class=\"hljs\">feature</code> attribute</a>. If there is any\npreexisting code which extends a trait to have a method with the same\nname, then the names will collide. In the future, when the method is\nstabilized, this will cause an error due to the ambiguity. This lint\nis an early-warning to let you know that there may be a collision in\nthe future. This can be avoided by adding type annotations to\ndisambiguate which trait method you intend to call, such as\n<code class=\"hljs\">MyIterator::is_sorted(my_iter)</code> or renaming or removing the method.</p>\n<h2 id=\"unstable-syntax-pre-expansion\"><a class=\"header\" href=\"#unstable-syntax-pre-expansion\">unstable-syntax-pre-expansion</a></h2>\n<p>The <code class=\"hljs\">unstable_syntax_pre_expansion</code> lint detects the use of unstable\nsyntax that is discarded during attribute expansion.</p>\n<h3 id=\"example-98\"><a class=\"header\" href=\"#example-98\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#[cfg(FALSE)]</span>\n<span class=\"hljs-keyword\">macro</span> foo() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: `macro` is experimental\n --&gt; lint_example.rs:3:1\n  |\n3 | macro foo() {}\n  | ^^^^^^^^^^^^^^\n  |\n  = note: see issue #39412 &lt;https://github.com/rust-lang/rust/issues/39412&gt; for more information\n  = help: add `#![feature(decl_macro)]` to the crate attributes to enable\n  = note: this compiler was built on 2024-07-21; consider upgrading it if it is out of date\n  = warning: unstable syntax can change at any point in the future, causing a hard error!\n  = note: for more information, see issue #65860 &lt;https://github.com/rust-lang/rust/issues/65860&gt;\n\n</code></pre>\n<h3 id=\"explanation-98\"><a class=\"header\" href=\"#explanation-98\">Explanation</a></h3>\n<p>The input to active attributes such as <code class=\"hljs\">#[cfg]</code> or procedural macro\nattributes is required to be valid syntax. Previously, the compiler only\ngated the use of unstable syntax features after resolving <code class=\"hljs\">#[cfg]</code> gates\nand expanding procedural macros.</p>\n<p>To avoid relying on unstable syntax, move the use of unstable syntax\ninto a position where the compiler does not parse the syntax, such as a\nfunctionlike macro.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![deny(unstable_syntax_pre_expansion)]</span>\n</span>\n<span class=\"hljs-built_in\">macro_rules!</span> identity {\n   ( $($tokens:tt)* ) =&gt; { $($tokens)* }\n}\n\n<span class=\"hljs-meta\">#[cfg(FALSE)]</span>\nidentity! {\n   <span class=\"hljs-keyword\">macro</span> foo() {}\n}</code></pre>\n<p>This is a <a href=\"../index.html#future-incompatible-lints\">future-incompatible</a> lint to transition this\nto a hard error in the future. See <a href=\"https://github.com/rust-lang/rust/issues/65860\">issue #65860</a> for more details.</p>\n<h2 id=\"unsupported-calling-conventions\"><a class=\"header\" href=\"#unsupported-calling-conventions\">unsupported-calling-conventions</a></h2>\n<p>The <code class=\"hljs\">unsupported_calling_conventions</code> lint is output whenever there is a use of the\n<code class=\"hljs\">stdcall</code>, <code class=\"hljs\">fastcall</code>, <code class=\"hljs\">thiscall</code>, <code class=\"hljs\">vectorcall</code> calling conventions (or their unwind\nvariants) on targets that cannot meaningfully be supported for the requested target.</p>\n<p>For example <code class=\"hljs\">stdcall</code> does not make much sense for a x86_64 or, more apparently, powerpc\ncode, because this calling convention was never specified for those targets.</p>\n<p>Historically MSVC toolchains have fallen back to the regular C calling convention for\ntargets other than x86, but Rust doesn't really see a similar need to introduce a similar\nhack across many more targets.</p>\n<h3 id=\"example-99\"><a class=\"header\" href=\"#example-99\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (needs specific targets) hljs\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"stdcall\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">stdcall</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: use of calling convention not supported on this target\n  --&gt; $DIR/unsupported.rs:39:1\n   |\nLL | extern \"stdcall\" fn stdcall() {}\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unsupported_calling_conventions)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out;\n              it will become a hard error in a future release!\n   = note: for more information, see issue ...\n</code></pre>\n<h3 id=\"explanation-99\"><a class=\"header\" href=\"#explanation-99\">Explanation</a></h3>\n<p>On most of the targets the behaviour of <code class=\"hljs\">stdcall</code> and similar calling conventions is not\ndefined at all, but was previously accepted due to a bug in the implementation of the\ncompiler.</p>\n<h2 id=\"unused-doc-comment\"><a class=\"header\" href=\"#unused-doc-comment\">unused-doc-comment</a></h2>\n<p>The lint <code class=\"hljs\">unused-doc-comment</code> has been renamed to <a href=\"#unused-doc-comments\"><code class=\"hljs\">unused-doc-comments</code></a>.</p>\n<h2 id=\"unused-tuple-struct-fields\"><a class=\"header\" href=\"#unused-tuple-struct-fields\">unused-tuple-struct-fields</a></h2>\n<p>The lint <code class=\"hljs\">unused-tuple-struct-fields</code> has been renamed to <a href=\"#dead-code\"><code class=\"hljs\">dead-code</code></a>.</p>\n<h2 id=\"unused-allocation\"><a class=\"header\" href=\"#unused-allocation\">unused-allocation</a></h2>\n<p>The <code class=\"hljs\">unused_allocation</code> lint detects unnecessary allocations that can\nbe eliminated.</p>\n<h3 id=\"example-100\"><a class=\"header\" href=\"#example-100\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-built_in\">Box</span>::new([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]).len();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unnecessary allocation, use `&amp;` instead\n --&gt; lint_example.rs:2:13\n  |\n2 |     let a = Box::new([1, 2, 3]).len();\n  |             ^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_allocation)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-100\"><a class=\"header\" href=\"#explanation-100\">Explanation</a></h3>\n<p>When a <code class=\"hljs\">box</code> expression is immediately coerced to a reference, then\nthe allocation is unnecessary, and a reference (using <code class=\"hljs\">&amp;</code> or <code class=\"hljs\">&amp;mut</code>)\nshould be used instead to avoid the allocation.</p>\n<h2 id=\"unused-assignments\"><a class=\"header\" href=\"#unused-assignments\">unused-assignments</a></h2>\n<p>The <code class=\"hljs\">unused_assignments</code> lint detects assignments that will never be read.</p>\n<h3 id=\"example-101\"><a class=\"header\" href=\"#example-101\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x = <span class=\"hljs-number\">5</span>;\nx = <span class=\"hljs-number\">6</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: value assigned to `x` is never read\n --&gt; lint_example.rs:3:1\n  |\n3 | x = 6;\n  | ^\n  |\n  = help: maybe it is overwritten before being read?\n  = note: `#[warn(unused_assignments)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-101\"><a class=\"header\" href=\"#explanation-101\">Explanation</a></h3>\n<p>Unused assignments may signal a mistake or unfinished code. If the\nvariable is never used after being assigned, then the assignment can\nbe removed. Variables with an underscore prefix such as <code class=\"hljs\">_x</code> will not\ntrigger this lint.</p>\n<h2 id=\"unused-associated-type-bounds\"><a class=\"header\" href=\"#unused-associated-type-bounds\">unused-associated-type-bounds</a></h2>\n<p>The <code class=\"hljs\">unused_associated_type_bounds</code> lint is emitted when an\nassociated type bound is added to a trait object, but the associated\ntype has a <code class=\"hljs\">where Self: Sized</code> bound, and is thus unavailable on the\ntrait object anyway.</p>\n<h3 id=\"example-102\"><a class=\"header\" href=\"#example-102\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Bar</span></span> <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">Self</span>: <span class=\"hljs-built_in\">Sized</span>;\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Mop</span></span> = <span class=\"hljs-keyword\">dyn</span> Foo&lt;Bar = ()&gt;;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unnecessary associated type bound for not object safe associated type\n --&gt; lint_example.rs:5:20\n  |\n5 | type Mop = dyn Foo&lt;Bar = ()&gt;;\n  |                    ^^^^^^^^ help: remove this bound\n  |\n  = note: this associated type has a `where Self: Sized` bound. Thus, while the associated type can be specified, it cannot be used in any way, because trait objects are not `Sized`.\n  = note: `#[warn(unused_associated_type_bounds)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-102\"><a class=\"header\" href=\"#explanation-102\">Explanation</a></h3>\n<p>Just like methods with <code class=\"hljs\">Self: Sized</code> bounds are unavailable on trait\nobjects, associated types can be removed from the trait object.</p>\n<h2 id=\"unused-attributes\"><a class=\"header\" href=\"#unused-attributes\">unused-attributes</a></h2>\n<p>The <code class=\"hljs\">unused_attributes</code> lint detects attributes that were not used by\nthe compiler.</p>\n<h3 id=\"example-103\"><a class=\"header\" href=\"#example-103\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![ignore]</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: `#[ignore]` only has an effect on functions\n --&gt; lint_example.rs:1:1\n  |\n1 | #![ignore]\n  | ^^^^^^^^^^\n  |\n  = note: `#[warn(unused_attributes)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-103\"><a class=\"header\" href=\"#explanation-103\">Explanation</a></h3>\n<p>Unused <a href=\"https://doc.rust-lang.org/reference/attributes.html\">attributes</a> may indicate the attribute is placed in the wrong\nposition. Consider removing it, or placing it in the correct position.\nAlso consider if you intended to use an <em>inner attribute</em> (with a <code class=\"hljs\">!</code>\nsuch as <code class=\"hljs\">#![allow(unused)]</code>) which applies to the item the attribute\nis within, or an <em>outer attribute</em> (without a <code class=\"hljs\">!</code> such as\n<code class=\"hljs\">#[allow(unused)]</code>) which applies to the item <em>following</em> the\nattribute.</p>\n<h2 id=\"unused-braces\"><a class=\"header\" href=\"#unused-braces\">unused-braces</a></h2>\n<p>The <code class=\"hljs\">unused_braces</code> lint detects unnecessary braces around an\nexpression.</p>\n<h3 id=\"example-104\"><a class=\"header\" href=\"#example-104\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">if</span> { <span class=\"hljs-literal\">true</span> } {\n    <span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unnecessary braces around `if` condition\n --&gt; lint_example.rs:2:4\n  |\n2 | if { true } {\n  |    ^^    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n2 - if { true } {\n2 + if true {\n  |\n\n</code></pre>\n<h3 id=\"explanation-104\"><a class=\"header\" href=\"#explanation-104\">Explanation</a></h3>\n<p>The braces are not needed, and should be removed. This is the\npreferred style for writing these expressions.</p>\n<h2 id=\"unused-comparisons\"><a class=\"header\" href=\"#unused-comparisons\">unused-comparisons</a></h2>\n<p>The <code class=\"hljs\">unused_comparisons</code> lint detects comparisons made useless by\nlimits of the types involved.</p>\n<h3 id=\"example-105\"><a class=\"header\" href=\"#example-105\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(x: <span class=\"hljs-built_in\">u8</span>) {\n    x &gt;= <span class=\"hljs-number\">0</span>;\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: comparison is useless due to type limits\n --&gt; lint_example.rs:3:5\n  |\n3 |     x &gt;= 0;\n  |     ^^^^^^\n  |\n  = note: `#[warn(unused_comparisons)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-105\"><a class=\"header\" href=\"#explanation-105\">Explanation</a></h3>\n<p>A useless comparison may indicate a mistake, and should be fixed or\nremoved.</p>\n<h2 id=\"unused-doc-comments\"><a class=\"header\" href=\"#unused-doc-comments\">unused-doc-comments</a></h2>\n<p>The <code class=\"hljs\">unused_doc_comments</code> lint detects doc comments that aren't used\nby <code class=\"hljs\">rustdoc</code>.</p>\n<h3 id=\"example-106\"><a class=\"header\" href=\"#example-106\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-comment\">/// docs for x</span>\n<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">12</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unused doc comment\n --&gt; lint_example.rs:2:1\n  |\n2 | /// docs for x\n  | ^^^^^^^^^^^^^^\n3 | let x = 12;\n  | ----------- rustdoc does not generate documentation for statements\n  |\n  = help: use `//` for a plain comment\n  = note: `#[warn(unused_doc_comments)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-106\"><a class=\"header\" href=\"#explanation-106\">Explanation</a></h3>\n<p><code class=\"hljs\">rustdoc</code> does not use doc comments in all positions, and so the doc\ncomment will be ignored. Try changing it to a normal comment with <code class=\"hljs\">//</code>\nto avoid the warning.</p>\n<h2 id=\"unused-features\"><a class=\"header\" href=\"#unused-features\">unused-features</a></h2>\n<p>The <code class=\"hljs\">unused_features</code> lint detects unused or unknown features found in\ncrate-level <a href=\"https://doc.rust-lang.org/nightly/unstable-book/\"><code class=\"hljs\">feature</code> attributes</a>.</p>\n<p>Note: This lint is currently not functional, see <a href=\"https://github.com/rust-lang/rust/issues/44232\">issue #44232</a> for\nmore details.</p>\n<h2 id=\"unused-imports\"><a class=\"header\" href=\"#unused-imports\">unused-imports</a></h2>\n<p>The <code class=\"hljs\">unused_imports</code> lint detects imports that are never used.</p>\n<h3 id=\"example-107\"><a class=\"header\" href=\"#example-107\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">use</span> std::collections::HashMap;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unused import: `std::collections::HashMap`\n --&gt; lint_example.rs:2:5\n  |\n2 | use std::collections::HashMap;\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-107\"><a class=\"header\" href=\"#explanation-107\">Explanation</a></h3>\n<p>Unused imports may signal a mistake or unfinished code, and clutter\nthe code, and should be removed. If you intended to re-export the item\nto make it available outside of the module, add a visibility modifier\nlike <code class=\"hljs\">pub</code>.</p>\n<h2 id=\"unused-labels\"><a class=\"header\" href=\"#unused-labels\">unused-labels</a></h2>\n<p>The <code class=\"hljs\">unused_labels</code> lint detects <a href=\"https://doc.rust-lang.org/reference/expressions/loop-expr.html#loop-labels\">labels</a> that are never used.</p>\n<h3 id=\"example-108\"><a class=\"header\" href=\"#example-108\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust no_run hljs\"><span class=\"hljs-symbol\">'unused_label</span>: <span class=\"hljs-keyword\">loop</span> {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unused label\n --&gt; lint_example.rs:2:1\n  |\n2 | 'unused_label: loop {}\n  | ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_labels)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-108\"><a class=\"header\" href=\"#explanation-108\">Explanation</a></h3>\n<p>Unused labels may signal a mistake or unfinished code. To silence the\nwarning for the individual label, prefix it with an underscore such as\n<code class=\"hljs\">'_my_label:</code>.</p>\n<h2 id=\"unused-macros\"><a class=\"header\" href=\"#unused-macros\">unused-macros</a></h2>\n<p>The <code class=\"hljs\">unused_macros</code> lint detects macros that were not used.</p>\n<p>Note that this lint is distinct from the <code class=\"hljs\">unused_macro_rules</code> lint,\nwhich checks for single rules that never match of an otherwise used\nmacro, and thus never expand.</p>\n<h3 id=\"example-109\"><a class=\"header\" href=\"#example-109\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-built_in\">macro_rules!</span> unused {\n    () =&gt; {};\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unused macro definition: `unused`\n --&gt; lint_example.rs:1:14\n  |\n1 | macro_rules! unused {\n  |              ^^^^^^\n  |\n  = note: `#[warn(unused_macros)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-109\"><a class=\"header\" href=\"#explanation-109\">Explanation</a></h3>\n<p>Unused macros may signal a mistake or unfinished code. To silence the\nwarning for the individual macro, prefix the name with an underscore\nsuch as <code class=\"hljs\">_my_macro</code>. If you intended to export the macro to make it\navailable outside of the crate, use the <a href=\"https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope\"><code class=\"hljs\">macro_export</code> attribute</a>.</p>\n<h2 id=\"unused-must-use\"><a class=\"header\" href=\"#unused-must-use\">unused-must-use</a></h2>\n<p>The <code class=\"hljs\">unused_must_use</code> lint detects unused result of a type flagged as\n<code class=\"hljs\">#[must_use]</code>.</p>\n<h3 id=\"example-110\"><a class=\"header\" href=\"#example-110\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">returns_result</span></span>() -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), ()&gt; {\n    <span class=\"hljs-literal\">Ok</span>(())\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    returns_result();\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unused `Result` that must be used\n --&gt; lint_example.rs:6:5\n  |\n6 |     returns_result();\n  |     ^^^^^^^^^^^^^^^^\n  |\n  = note: this `Result` may be an `Err` variant, which should be handled\n  = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n  |\n6 |     let _ = returns_result();\n  |     +++++++\n\n</code></pre>\n<h3 id=\"explanation-110\"><a class=\"header\" href=\"#explanation-110\">Explanation</a></h3>\n<p>The <code class=\"hljs\">#[must_use]</code> attribute is an indicator that it is a mistake to\nignore the value. See <a href=\"https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\">the reference</a> for more details.</p>\n<h2 id=\"unused-mut\"><a class=\"header\" href=\"#unused-mut\">unused-mut</a></h2>\n<p>The <code class=\"hljs\">unused_mut</code> lint detects mut variables which don't need to be\nmutable.</p>\n<h3 id=\"example-111\"><a class=\"header\" href=\"#example-111\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x = <span class=\"hljs-number\">5</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: variable does not need to be mutable\n --&gt; lint_example.rs:2:5\n  |\n2 | let mut x = 5;\n  |     ----^\n  |     |\n  |     help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-111\"><a class=\"header\" href=\"#explanation-111\">Explanation</a></h3>\n<p>The preferred style is to only mark variables as <code class=\"hljs\">mut</code> if it is\nrequired.</p>\n<h2 id=\"unused-parens\"><a class=\"header\" href=\"#unused-parens\">unused-parens</a></h2>\n<p>The <code class=\"hljs\">unused_parens</code> lint detects <code class=\"hljs\">if</code>, <code class=\"hljs\">match</code>, <code class=\"hljs\">while</code> and <code class=\"hljs\">return</code>\nwith parentheses; they do not need them.</p>\n<h3 id=\"examples\"><a class=\"header\" href=\"#examples\">Examples</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-literal\">true</span>) {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unnecessary parentheses around `if` condition\n --&gt; lint_example.rs:2:3\n  |\n2 | if(true) {}\n  |   ^    ^\n  |\n  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n  |\n2 - if(true) {}\n2 + if true {}\n  |\n\n</code></pre>\n<h3 id=\"explanation-112\"><a class=\"header\" href=\"#explanation-112\">Explanation</a></h3>\n<p>The parentheses are not needed, and should be removed. This is the\npreferred style for writing these expressions.</p>\n<h2 id=\"unused-unsafe\"><a class=\"header\" href=\"#unused-unsafe\">unused-unsafe</a></h2>\n<p>The <code class=\"hljs\">unused_unsafe</code> lint detects unnecessary use of an <code class=\"hljs\">unsafe</code> block.</p>\n<h3 id=\"example-112\"><a class=\"header\" href=\"#example-112\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">unsafe</span> {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unnecessary `unsafe` block\n --&gt; lint_example.rs:2:1\n  |\n2 | unsafe {}\n  | ^^^^^^ unnecessary `unsafe` block\n  |\n  = note: `#[warn(unused_unsafe)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-113\"><a class=\"header\" href=\"#explanation-113\">Explanation</a></h3>\n<p>If nothing within the block requires <code class=\"hljs\">unsafe</code>, then remove the\n<code class=\"hljs\">unsafe</code> marker because it is not required and may cause confusion.</p>\n<h2 id=\"unused-variables\"><a class=\"header\" href=\"#unused-variables\">unused-variables</a></h2>\n<p>The <code class=\"hljs\">unused_variables</code> lint detects variables which are not used in\nany way.</p>\n<h3 id=\"example-113\"><a class=\"header\" href=\"#example-113\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: unused variable: `x`\n --&gt; lint_example.rs:2:5\n  |\n2 | let x = 5;\n  |     ^ help: if this is intentional, prefix it with an underscore: `_x`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-114\"><a class=\"header\" href=\"#explanation-114\">Explanation</a></h3>\n<p>Unused variables may signal a mistake or unfinished code. To silence\nthe warning for the individual variable, prefix it with an underscore\nsuch as <code class=\"hljs\">_x</code>.</p>\n<h2 id=\"useless-ptr-null-checks\"><a class=\"header\" href=\"#useless-ptr-null-checks\">useless-ptr-null-checks</a></h2>\n<p>The <code class=\"hljs\">useless_ptr_null_checks</code> lint checks for useless null checks against pointers\nobtained from non-null types.</p>\n<h3 id=\"example-114\"><a class=\"header\" href=\"#example-114\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">test</span></span>() {}\n</span><span class=\"hljs-keyword\">let</span> fn_ptr: <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>() = <span class=\"hljs-comment\">/* somehow obtained nullable function pointer */</span>\n<span class=\"boring\">  test;\n</span>\n<span class=\"hljs-keyword\">if</span> (fn_ptr <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> ()).is_null() { <span class=\"hljs-comment\">/* ... */</span> }</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: function pointers are not nullable, so checking them for null will always return false\n --&gt; lint_example.rs:6:4\n  |\n6 | if (fn_ptr as *const ()).is_null() { /* ... */ }\n  |    ^------^^^^^^^^^^^^^^^^^^^^^^^^\n  |     |\n  |     expression has type `fn()`\n  |\n  = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value\n  = note: `#[warn(useless_ptr_null_checks)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-115\"><a class=\"header\" href=\"#explanation-115\">Explanation</a></h3>\n<p>Function pointers and references are assumed to be non-null, checking them for null\nwill always return false.</p>\n<h2 id=\"warnings\"><a class=\"header\" href=\"#warnings\">warnings</a></h2>\n<p>The <code class=\"hljs\">warnings</code> lint allows you to change the level of other\nlints which produce warnings.</p>\n<h3 id=\"example-115\"><a class=\"header\" href=\"#example-115\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#![deny(warnings)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: function `foo` is never used\n --&gt; lint_example.rs:3:4\n  |\n3 | fn foo() {}\n  |    ^^^\n  |\nnote: the lint level is defined here\n --&gt; lint_example.rs:1:9\n  |\n1 | #![deny(warnings)]\n  |         ^^^^^^^^\n  = note: `#[deny(dead_code)]` implied by `#[deny(warnings)]`\n\n</code></pre>\n<h3 id=\"explanation-116\"><a class=\"header\" href=\"#explanation-116\">Explanation</a></h3>\n<p>The <code class=\"hljs\">warnings</code> lint is a bit special; by changing its level, you\nchange every other warning that would produce a warning to whatever\nvalue you'd like. As such, you won't ever trigger this lint in your\ncode directly.</p>\n<h2 id=\"wasm-c-abi\"><a class=\"header\" href=\"#wasm-c-abi\">wasm-c-abi</a></h2>\n<p>The <code class=\"hljs\">wasm_c_abi</code> lint detects crate dependencies that are incompatible\nwith future versions of Rust that will emit spec-compliant C ABI.</p>\n<h3 id=\"example-116\"><a class=\"header\" href=\"#example-116\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore (needs extern crate) hljs\"><span class=\"hljs-meta\">#![deny(wasm_c_abi)]</span></code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error: the following packages contain code that will be rejected by a future version of Rust: wasm-bindgen v0.2.87\n  |\nnote: the lint level is defined here\n --&gt; src/lib.rs:1:9\n  |\n1 | #![deny(wasm_c_abi)]\n  |         ^^^^^^^^^^\n</code></pre>\n<h3 id=\"explanation-117\"><a class=\"header\" href=\"#explanation-117\">Explanation</a></h3>\n<p>Rust has historically emitted non-spec-compliant C ABI. This has caused\nincompatibilities between other compilers and Wasm targets. In a future\nversion of Rust this will be fixed and therefore dependencies relying\non the non-spec-compliant C ABI will stop functioning.</p>\n<h2 id=\"while-true\"><a class=\"header\" href=\"#while-true\">while-true</a></h2>\n<p>The <code class=\"hljs\">while_true</code> lint detects <code class=\"hljs\">while true { }</code>.</p>\n<h3 id=\"example-117\"><a class=\"header\" href=\"#example-117\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust no_run hljs\"><span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">true</span> {\n\n}</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: denote infinite loops with `loop { ... }`\n --&gt; lint_example.rs:2:1\n  |\n2 | while true {\n  | ^^^^^^^^^^ help: use `loop`\n  |\n  = note: `#[warn(while_true)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-118\"><a class=\"header\" href=\"#explanation-118\">Explanation</a></h3>\n<p><code class=\"hljs\">while true</code> should be replaced with <code class=\"hljs\">loop</code>. A <code class=\"hljs\">loop</code> expression is\nthe preferred way to write an infinite loop because it more directly\nexpresses the intent of the loop.</p>\n<h2 id=\"writes-through-immutable-pointer\"><a class=\"header\" href=\"#writes-through-immutable-pointer\">writes-through-immutable-pointer</a></h2>\n<p>The <code class=\"hljs\">writes_through_immutable_pointer</code> lint detects writes through pointers derived from\nshared references.</p>\n<h3 id=\"example-118\"><a class=\"header\" href=\"#example-118\">Example</a></h3>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust compile_fail hljs\"><span class=\"hljs-meta\">#![feature(const_mut_refs)]</span>\n<span class=\"hljs-keyword\">const</span> WRITE_AFTER_CAST: () = <span class=\"hljs-keyword\">unsafe</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">let</span> ptr = &amp;x <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">i32</span> <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>;\n    *ptr = <span class=\"hljs-number\">0</span>;\n};</code></pre>\n<p>This will produce:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: writing through a pointer that was derived from a shared (immutable) reference\n --&gt; lint_example.rs:6:5\n  |\n6 |     *ptr = 0;\n  |     ^^^^^^^^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #X &lt;https://github.com/rust-lang/rust/issues/X&gt;\n  = note: `#[warn(writes_through_immutable_pointer)]` on by default\n\n</code></pre>\n<h3 id=\"explanation-119\"><a class=\"header\" href=\"#explanation-119\">Explanation</a></h3>\n<p>Shared references are immutable (when there is no <code class=\"hljs\">UnsafeCell</code> involved),\nand writing through them or through pointers derived from them is Undefined Behavior.\nThe compiler recently learned to detect such Undefined Behavior during compile-time\nevaluation, and in the future this will raise a hard error.</p>\n<script>\ndocument.addEventListener(\"DOMContentLoaded\", (event) => {\n    var fragments = {\n        \"#bare-trait-object\": \"warn-by-default.html#bare-trait-objects\",\n        \"#unstable-name-collision\": \"warn-by-default.html#unstable-name-collisions\",\n        \"#unused-doc-comment\": \"warn-by-default.html#unused-doc-comments\",\n        \"#redundant-semicolon\": \"warn-by-default.html#redundant-semicolons\",\n        \"#overlapping-patterns\": \"warn-by-default.html#overlapping-range-endpoints\",\n        \"#non-fmt-panic\": \"warn-by-default.html#non-fmt-panics\",\n        \"#unused-tuple-struct-fields\": \"warn-by-default.html#dead-code\",\n        \"#static-mut-ref\": \"warn-by-default.html#static-mut-refs\",\n};\n    var target = fragments[window.location.hash];\n    if (target) {\n        var url = window.location.toString();\n        var base = url.substring(0, url.lastIndexOf('/'));\n        window.location.replace(base + \"/\" + target);\n    }\n});\n</script>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../../lints/listing/allowed-by-default.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../../lints/listing/deny-by-default.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../../lints/listing/allowed-by-default.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../../lints/listing/deny-by-default.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../../elasticlunr.min.js\"></script>\n        <script src=\"../../mark.min.js\"></script>\n        <script src=\"../../searcher.js\"></script>\n\n        <script src=\"../../clipboard.min.js\"></script>\n        <script src=\"../../highlight.js\"></script>\n        <script src=\"../../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:20:40.611Z"
}