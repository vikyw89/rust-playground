{
	"title": "Unchecked - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/unchecked-uninit.html",
	"markdown": "# Unchecked - The Rustonomicon\n\n## [Unchecked Uninitialized Memory](#unchecked-uninitialized-memory)\n\nOne interesting exception to this rule is working with arrays. Safe Rust doesn't permit you to partially initialize an array. When you initialize an array, you can either set every value to the same thing with `let x = [val; N]`, or you can specify each member individually with `let x = [val1, val2, val3]`. Unfortunately this is pretty rigid, especially if you need to initialize your array in a more incremental or dynamic way.\n\nUnsafe Rust gives us a powerful tool to handle this problem: [`MaybeUninit`](../core/mem/union.MaybeUninit.html). This type can be used to handle memory that has not been fully initialized yet.\n\nWith `MaybeUninit`, we can initialize an array element by element as follows:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::mem::{self, MaybeUninit};\n\n// Size of the array is hard-coded but easy to change (meaning, changing just\n// the constant is sufficient). This means we can't use [a, b, c] syntax to\n// initialize the array, though, as we would have to keep that in sync\n// with `SIZE`!\nconst SIZE: usize = 10;\n\nlet x = {\n    // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n    // safe because the type we are claiming to have initialized here is a\n    // bunch of `MaybeUninit`s, which do not require initialization.\n    let mut x: [MaybeUninit<Box<u32>>; SIZE] = unsafe {\n        MaybeUninit::uninit().assume_init()\n    };\n\n    // Dropping a `MaybeUninit` does nothing. Thus using raw pointer\n    // assignment instead of `ptr::write` does not cause the old\n    // uninitialized value to be dropped.\n    // Exception safety is not a concern because Box can't panic\n    for i in 0..SIZE {\n        x[i] = MaybeUninit::new(Box::new(i as u32));\n    }\n\n    // Everything is initialized. Transmute the array to the\n    // initialized type.\n    unsafe { mem::transmute::<_, [Box<u32>; SIZE]>(x) }\n};\n\ndbg!(x);\n}\n```\n\nThis code proceeds in three steps:\n\n1.  Create an array of `MaybeUninit<T>`. With current stable Rust, we have to use unsafe code for this: we take some uninitialized piece of memory (`MaybeUninit::uninit()`) and claim we have fully initialized it ([`assume_init()`](about:blank/core/mem/union.MaybeUninit.html#method.assume_init)). This seems ridiculous, because we didn't! The reason this is correct is that the array consists itself entirely of `MaybeUninit`, which do not actually require initialization. For most other types, doing `MaybeUninit::uninit().assume_init()` produces an invalid instance of said type, so you got yourself some Undefined Behavior.\n    \n2.  Initialize the array. The subtle aspect of this is that usually, when we use `=` to assign to a value that the Rust type checker considers to already be initialized (like `x[i]`), the old value stored on the left-hand side gets dropped. This would be a disaster. However, in this case, the type of the left-hand side is `MaybeUninit<Box<u32>>`, and dropping that does not do anything! See below for some more discussion of this `drop` issue.\n    \n3.  Finally, we have to change the type of our array to remove the `MaybeUninit`. With current stable Rust, this requires a `transmute`. This transmute is legal because in memory, `MaybeUninit<T>` looks the same as `T`.\n    \n    However, note that in general, `Container<MaybeUninit<T>>>` does _not_ look the same as `Container<T>`! Imagine if `Container` was `Option`, and `T` was `bool`, then `Option<bool>` exploits that `bool` only has two valid values, but `Option<MaybeUninit<bool>>` cannot do that because the `bool` does not have to be initialized.\n    \n    So, it depends on `Container` whether transmuting away the `MaybeUninit` is allowed. For arrays, it is (and eventually the standard library will acknowledge that by providing appropriate methods).\n    \n\nIt's worth spending a bit more time on the loop in the middle, and in particular the assignment operator and its interaction with `drop`. If we wrote something like:\n\n```rust\n*x[i].as_mut_ptr() = Box::new(i as u32); // WRONG!\n```\n\nwe would actually overwrite a `Box<u32>`, leading to `drop` of uninitialized data, which would cause much sadness and pain.\n\nThe correct alternative, if for some reason we cannot use `MaybeUninit::new`, is to use the [`ptr`](../core/ptr/index.html) module. In particular, it provides three functions that allow us to assign bytes to a location in memory without dropping the old value: [`write`](../core/ptr/fn.write.html), [`copy`](../std/ptr/fn.copy.html), and [`copy_nonoverlapping`](../std/ptr/fn.copy_nonoverlapping.html).\n\n-   `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed to by `ptr`.\n-   `ptr::copy(src, dest, count)` copies the bits that `count` T items would occupy from src to dest. (this is equivalent to C's memmove -- note that the argument order is reversed!)\n-   `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a little faster on the assumption that the two ranges of memory don't overlap. (this is equivalent to C's memcpy -- note that the argument order is reversed!)\n\nIt should go without saying that these functions, if misused, will cause serious havoc or just straight up Undefined Behavior. The only requirement of these functions _themselves_ is that the locations you want to read and write are allocated and properly aligned. However, the ways writing arbitrary bits to arbitrary locations of memory can break things are basically uncountable!\n\nIt's worth noting that you don't need to worry about `ptr::write`\\-style shenanigans with types which don't implement `Drop` or contain `Drop` types, because Rust knows not to try to drop them. This is what we relied on in the above example.\n\nHowever when working with uninitialized memory you need to be ever-vigilant for Rust trying to drop values you make like this before they're fully initialized. Every control path through that variable's scope must initialize the value before it ends, if it has a destructor. _[This includes code panicking](unwinding.html)_. `MaybeUninit` helps a bit here, because it does not implicitly drop its content - but all this really means in case of a panic is that instead of a double-free of the not yet initialized parts, you end up with a memory leak of the already initialized parts.\n\nNote that, to use the `ptr` methods, you need to first obtain a _raw pointer_ to the data you want to initialize. It is illegal to construct a _reference_ to uninitialized data, which implies that you have to be careful when obtaining said raw pointer:\n\n-   For an array of `T`, you can use `base_ptr.add(idx)` where `base_ptr: *mut T` to compute the address of array index `idx`. This relies on how arrays are laid out in memory.\n-   For a struct, however, in general we do not know how it is laid out, and we also cannot use `&mut base_ptr.field` as that would be creating a reference. So, you must carefully use the [`addr_of_mut`](../core/ptr/macro.addr_of_mut.html) macro. This creates a raw pointer to the field without creating an intermediate reference:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::{ptr, mem::MaybeUninit};\n\nstruct Demo {\n    field: bool,\n}\n\nlet mut uninit = MaybeUninit::<Demo>::uninit();\n// `&uninit.as_mut().field` would create a reference to an uninitialized `bool`,\n// and thus be Undefined Behavior!\nlet f1_ptr = unsafe { ptr::addr_of_mut!((*uninit.as_mut_ptr()).field) };\nunsafe { f1_ptr.write(true); }\n\nlet init = unsafe { uninit.assume_init() };\n}\n```\n\nOne last remark: when reading old Rust code, you might stumble upon the deprecated `mem::uninitialized` function. That function used to be the only way to deal with uninitialized memory on the stack, but it turned out to be impossible to properly integrate with the rest of the language. Always use `MaybeUninit` instead in new code, and port old code over when you get the opportunity.\n\nAnd that's about it for working with uninitialized memory! Basically nothing anywhere expects to be handed uninitialized memory, so if you're going to pass it around at all, be sure to be _really_ careful.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Unchecked - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"unchecked-uninitialized-memory\"><a class=\"header\" href=\"#unchecked-uninitialized-memory\">Unchecked Uninitialized Memory</a></h1>\n<p>One interesting exception to this rule is working with arrays. Safe Rust doesn't\npermit you to partially initialize an array. When you initialize an array, you\ncan either set every value to the same thing with <code class=\"hljs\">let x = [val; N]</code>, or you can\nspecify each member individually with <code class=\"hljs\">let x = [val1, val2, val3]</code>.\nUnfortunately this is pretty rigid, especially if you need to initialize your\narray in a more incremental or dynamic way.</p>\n<p>Unsafe Rust gives us a powerful tool to handle this problem:\n<a href=\"../core/mem/union.MaybeUninit.html\"><code class=\"hljs\">MaybeUninit</code></a>. This type can be used to handle memory that has not been fully\ninitialized yet.</p>\n<p>With <code class=\"hljs\">MaybeUninit</code>, we can initialize an array element by element as follows:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::mem::{<span class=\"hljs-keyword\">self</span>, MaybeUninit};\n\n<span class=\"hljs-comment\">// Size of the array is hard-coded but easy to change (meaning, changing just</span>\n<span class=\"hljs-comment\">// the constant is sufficient). This means we can't use [a, b, c] syntax to</span>\n<span class=\"hljs-comment\">// initialize the array, though, as we would have to keep that in sync</span>\n<span class=\"hljs-comment\">// with `SIZE`!</span>\n<span class=\"hljs-keyword\">const</span> SIZE: <span class=\"hljs-built_in\">usize</span> = <span class=\"hljs-number\">10</span>;\n\n<span class=\"hljs-keyword\">let</span> x = {\n    <span class=\"hljs-comment\">// Create an uninitialized array of `MaybeUninit`. The `assume_init` is</span>\n    <span class=\"hljs-comment\">// safe because the type we are claiming to have initialized here is a</span>\n    <span class=\"hljs-comment\">// bunch of `MaybeUninit`s, which do not require initialization.</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x: [MaybeUninit&lt;<span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-built_in\">u32</span>&gt;&gt;; SIZE] = <span class=\"hljs-keyword\">unsafe</span> {\n        MaybeUninit::uninit().assume_init()\n    };\n\n    <span class=\"hljs-comment\">// Dropping a `MaybeUninit` does nothing. Thus using raw pointer</span>\n    <span class=\"hljs-comment\">// assignment instead of `ptr::write` does not cause the old</span>\n    <span class=\"hljs-comment\">// uninitialized value to be dropped.</span>\n    <span class=\"hljs-comment\">// Exception safety is not a concern because Box can't panic</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..SIZE {\n        x[i] = MaybeUninit::new(<span class=\"hljs-built_in\">Box</span>::new(i <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">u32</span>));\n    }\n\n    <span class=\"hljs-comment\">// Everything is initialized. Transmute the array to the</span>\n    <span class=\"hljs-comment\">// initialized type.</span>\n    <span class=\"hljs-keyword\">unsafe</span> { mem::transmute::&lt;_, [<span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-built_in\">u32</span>&gt;; SIZE]&gt;(x) }\n};\n\ndbg!(x);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code proceeds in three steps:</p>\n<ol>\n<li>\n<p>Create an array of <code class=\"hljs\">MaybeUninit&lt;T&gt;</code>. With current stable Rust, we have to use\nunsafe code for this: we take some uninitialized piece of memory\n(<code class=\"hljs\">MaybeUninit::uninit()</code>) and claim we have fully initialized it\n(<a href=\"../core/mem/union.MaybeUninit.html#method.assume_init\"><code class=\"hljs\">assume_init()</code></a>). This seems ridiculous, because we didn't!\nThe reason this is correct is that the array consists itself entirely of\n<code class=\"hljs\">MaybeUninit</code>, which do not actually require initialization. For most other\ntypes, doing <code class=\"hljs\">MaybeUninit::uninit().assume_init()</code> produces an invalid\ninstance of said type, so you got yourself some Undefined Behavior.</p>\n</li>\n<li>\n<p>Initialize the array. The subtle aspect of this is that usually, when we use\n<code class=\"hljs\">=</code> to assign to a value that the Rust type checker considers to already be\ninitialized (like <code class=\"hljs\">x[i]</code>), the old value stored on the left-hand side gets\ndropped. This would be a disaster. However, in this case, the type of the\nleft-hand side is <code class=\"hljs\">MaybeUninit&lt;Box&lt;u32&gt;&gt;</code>, and dropping that does not do\nanything! See below for some more discussion of this <code class=\"hljs\">drop</code> issue.</p>\n</li>\n<li>\n<p>Finally, we have to change the type of our array to remove the\n<code class=\"hljs\">MaybeUninit</code>. With current stable Rust, this requires a <code class=\"hljs\">transmute</code>.\nThis transmute is legal because in memory, <code class=\"hljs\">MaybeUninit&lt;T&gt;</code> looks the same as <code class=\"hljs\">T</code>.</p>\n<p>However, note that in general, <code class=\"hljs\">Container&lt;MaybeUninit&lt;T&gt;&gt;&gt;</code> does <em>not</em> look\nthe same as <code class=\"hljs\">Container&lt;T&gt;</code>! Imagine if <code class=\"hljs\">Container</code> was <code class=\"hljs\">Option</code>, and <code class=\"hljs\">T</code> was\n<code class=\"hljs\">bool</code>, then <code class=\"hljs\">Option&lt;bool&gt;</code> exploits that <code class=\"hljs\">bool</code> only has two valid values,\nbut <code class=\"hljs\">Option&lt;MaybeUninit&lt;bool&gt;&gt;</code> cannot do that because the <code class=\"hljs\">bool</code> does not\nhave to be initialized.</p>\n<p>So, it depends on <code class=\"hljs\">Container</code> whether transmuting away the <code class=\"hljs\">MaybeUninit</code> is\nallowed. For arrays, it is (and eventually the standard library will\nacknowledge that by providing appropriate methods).</p>\n</li>\n</ol>\n<p>It's worth spending a bit more time on the loop in the middle, and in particular\nthe assignment operator and its interaction with <code class=\"hljs\">drop</code>. If we wrote something like:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">*x[i].as_mut_ptr() = <span class=\"hljs-built_in\">Box</span>::new(i <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">u32</span>); <span class=\"hljs-comment\">// WRONG!</span></code></pre>\n<p>we would actually overwrite a <code class=\"hljs\">Box&lt;u32&gt;</code>, leading to <code class=\"hljs\">drop</code> of uninitialized\ndata, which would cause much sadness and pain.</p>\n<p>The correct alternative, if for some reason we cannot use <code class=\"hljs\">MaybeUninit::new</code>, is\nto use the <a href=\"../core/ptr/index.html\"><code class=\"hljs\">ptr</code></a> module. In particular, it provides three functions that allow\nus to assign bytes to a location in memory without dropping the old value:\n<a href=\"../core/ptr/fn.write.html\"><code class=\"hljs\">write</code></a>, <a href=\"../std/ptr/fn.copy.html\"><code class=\"hljs\">copy</code></a>, and <a href=\"../std/ptr/fn.copy_nonoverlapping.html\"><code class=\"hljs\">copy_nonoverlapping</code></a>.</p>\n<ul>\n<li><code class=\"hljs\">ptr::write(ptr, val)</code> takes a <code class=\"hljs\">val</code> and moves it into the address pointed\nto by <code class=\"hljs\">ptr</code>.</li>\n<li><code class=\"hljs\">ptr::copy(src, dest, count)</code> copies the bits that <code class=\"hljs\">count</code> T items would occupy\nfrom src to dest. (this is equivalent to C's memmove -- note that the argument\norder is reversed!)</li>\n<li><code class=\"hljs\">ptr::copy_nonoverlapping(src, dest, count)</code> does what <code class=\"hljs\">copy</code> does, but a\nlittle faster on the assumption that the two ranges of memory don't overlap.\n(this is equivalent to C's memcpy -- note that the argument order is reversed!)</li>\n</ul>\n<p>It should go without saying that these functions, if misused, will cause serious\nhavoc or just straight up Undefined Behavior. The only requirement of these\nfunctions <em>themselves</em> is that the locations you want to read and write\nare allocated and properly aligned. However, the ways writing arbitrary bits to\narbitrary locations of memory can break things are basically uncountable!</p>\n<p>It's worth noting that you don't need to worry about <code class=\"hljs\">ptr::write</code>-style\nshenanigans with types which don't implement <code class=\"hljs\">Drop</code> or contain <code class=\"hljs\">Drop</code> types,\nbecause Rust knows not to try to drop them. This is what we relied on in the\nabove example.</p>\n<p>However when working with uninitialized memory you need to be ever-vigilant for\nRust trying to drop values you make like this before they're fully initialized.\nEvery control path through that variable's scope must initialize the value\nbefore it ends, if it has a destructor.\n<em><a href=\"unwinding.html\">This includes code panicking</a></em>. <code class=\"hljs\">MaybeUninit</code> helps a bit\nhere, because it does not implicitly drop its content - but all this really\nmeans in case of a panic is that instead of a double-free of the not yet\ninitialized parts, you end up with a memory leak of the already initialized\nparts.</p>\n<p>Note that, to use the <code class=\"hljs\">ptr</code> methods, you need to first obtain a <em>raw pointer</em> to\nthe data you want to initialize. It is illegal to construct a <em>reference</em> to\nuninitialized data, which implies that you have to be careful when obtaining\nsaid raw pointer:</p>\n<ul>\n<li>For an array of <code class=\"hljs\">T</code>, you can use <code class=\"hljs\">base_ptr.add(idx)</code> where <code class=\"hljs\">base_ptr: *mut T</code>\nto compute the address of array index <code class=\"hljs\">idx</code>. This relies on\nhow arrays are laid out in memory.</li>\n<li>For a struct, however, in general we do not know how it is laid out, and we\nalso cannot use <code class=\"hljs\">&amp;mut base_ptr.field</code> as that would be creating a\nreference. So, you must carefully use the <a href=\"../core/ptr/macro.addr_of_mut.html\"><code class=\"hljs\">addr_of_mut</code></a> macro. This creates\na raw pointer to the field without creating an intermediate reference:</li>\n</ul>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::{ptr, mem::MaybeUninit};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Demo</span></span> {\n    field: <span class=\"hljs-built_in\">bool</span>,\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> uninit = MaybeUninit::&lt;Demo&gt;::uninit();\n<span class=\"hljs-comment\">// `&amp;uninit.as_mut().field` would create a reference to an uninitialized `bool`,</span>\n<span class=\"hljs-comment\">// and thus be Undefined Behavior!</span>\n<span class=\"hljs-keyword\">let</span> f1_ptr = <span class=\"hljs-keyword\">unsafe</span> { ptr::addr_of_mut!((*uninit.as_mut_ptr()).field) };\n<span class=\"hljs-keyword\">unsafe</span> { f1_ptr.write(<span class=\"hljs-literal\">true</span>); }\n\n<span class=\"hljs-keyword\">let</span> init = <span class=\"hljs-keyword\">unsafe</span> { uninit.assume_init() };\n<span class=\"boring\">}</span></code></pre></pre>\n<p>One last remark: when reading old Rust code, you might stumble upon the\ndeprecated <code class=\"hljs\">mem::uninitialized</code> function.  That function used to be the only way\nto deal with uninitialized memory on the stack, but it turned out to be\nimpossible to properly integrate with the rest of the language.  Always use\n<code class=\"hljs\">MaybeUninit</code> instead in new code, and port old code over when you get the\nopportunity.</p>\n<p>And that's about it for working with uninitialized memory! Basically nothing\nanywhere expects to be handed uninitialized memory, so if you're going to pass\nit around at all, be sure to be <em>really</em> careful.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"drop-flags.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"obrm.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"drop-flags.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"obrm.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:07.559Z"
}