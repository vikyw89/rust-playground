{
	"title": "Reference Cycles Can Leak Memory - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch15-06-reference-cycles.html",
	"markdown": "# Reference Cycles Can Leak Memory\n\nRust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a _memory leak_). Preventing memory leaks entirely is not one of Rust’s guarantees, meaning memory leaks are memory safe in Rust. We can see that Rust allows memory leaks by using `Rc<T>` and `RefCell<T>`: it’s possible to create references where items refer to each other in a cycle. This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.\n\n### [Creating a Reference Cycle](#creating-a-reference-cycle)\n\nLet’s look at how a reference cycle might happen and how to prevent it, starting with the definition of the `List` enum and a `tail` method in Listing 15-25:\n\nFilename: src/main.rs\n\n```rust\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\nfn main() {}\n```\n\nListing 15-25: A cons list definition that holds a `RefCell<T>` so we can modify what a `Cons` variant is referring to\n\nWe’re using another variation of the `List` definition from Listing 15-5. The second element in the `Cons` variant is now `RefCell<Rc<List>>`, meaning that instead of having the ability to modify the `i32` value as we did in Listing 15-24, we want to modify the `List` value a `Cons` variant is pointing to. We’re also adding a `tail` method to make it convenient for us to access the second item if we have a `Cons` variant.\n\nIn Listing 15-26, we’re adding a `main` function that uses the definitions in Listing 15-25. This code creates a list in `a` and a list in `b` that points to the list in `a`. Then it modifies the list in `a` to point to `b`, creating a reference cycle. There are `println!` statements along the way to show what the reference counts are at various points in this process.\n\nFilename: src/main.rs\n\n```rust\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&b);\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!(\"a next item = {:?}\", a.tail());\n}\n```\n\nListing 15-26: Creating a reference cycle of two `List` values pointing to each other\n\nWe create an `Rc<List>` instance holding a `List` value in the variable `a` with an initial list of `5, Nil`. We then create an `Rc<List>` instance holding another `List` value in the variable `b` that contains the value 10 and points to the list in `a`.\n\nWe modify `a` so it points to `b` instead of `Nil`, creating a cycle. We do that by using the `tail` method to get a reference to the `RefCell<Rc<List>>` in `a`, which we put in the variable `link`. Then we use the `borrow_mut` method on the `RefCell<Rc<List>>` to change the value inside from an `Rc<List>` that holds a `Nil` value to the `Rc<List>` in `b`.\n\nWhen we run this code, keeping the last `println!` commented out for the moment, we’ll get this output:\n\n```console\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s\n     Running `target/debug/cons-list`\na initial rc count = 1\na next item = Some(RefCell { value: Nil })\na rc count after b creation = 2\nb initial rc count = 1\nb next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })\nb rc count after changing a = 2\na rc count after changing a = 2\n\n```\n\nThe reference count of the `Rc<List>` instances in both `a` and `b` are 2 after we change the list in `a` to point to `b`. At the end of `main`, Rust drops the variable `b`, which decreases the reference count of the `b` `Rc<List>` instance from 2 to 1. The memory that `Rc<List>` has on the heap won’t be dropped at this point, because its reference count is 1, not 0. Then Rust drops `a`, which decreases the reference count of the `a` `Rc<List>` instance from 2 to 1 as well. This instance’s memory can’t be dropped either, because the other `Rc<List>` instance still refers to it. The memory allocated to the list will remain uncollected forever. To visualize this reference cycle, we’ve created a diagram in Figure 15-4.\n\n![Reference cycle of lists](img/trpl15-04.svg)\n\nFigure 15-4: A reference cycle of lists `a` and `b` pointing to each other\n\nIf you uncomment the last `println!` and run the program, Rust will try to print this cycle with `a` pointing to `b` pointing to `a` and so forth until it overflows the stack.\n\nCompared to a real-world program, the consequences of creating a reference cycle in this example aren’t very dire: right after we create the reference cycle, the program ends. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.\n\nCreating reference cycles is not easily done, but it’s not impossible either. If you have `RefCell<T>` values that contain `Rc<T>` values or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don’t create cycles; you can’t rely on Rust to catch them. Creating a reference cycle would be a logic bug in your program that you should use automated tests, code reviews, and other software development practices to minimize.\n\nAnother solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don’t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want `Cons` variants to own their list, so reorganizing the data structure isn’t possible. Let’s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.\n\n### [Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>`](#preventing-reference-cycles-turning-an-rct-into-a-weakt)\n\nSo far, we’ve demonstrated that calling `Rc::clone` increases the `strong_count` of an `Rc<T>` instance, and an `Rc<T>` instance is only cleaned up if its `strong_count` is 0. You can also create a _weak reference_ to the value within an `Rc<T>` instance by calling `Rc::downgrade` and passing a reference to the `Rc<T>`. Strong references are how you can share ownership of an `Rc<T>` instance. Weak references don’t express an ownership relationship, and their count doesn’t affect when an `Rc<T>` instance is cleaned up. They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.\n\nWhen you call `Rc::downgrade`, you get a smart pointer of type `Weak<T>`. Instead of increasing the `strong_count` in the `Rc<T>` instance by 1, calling `Rc::downgrade` increases the `weak_count` by 1. The `Rc<T>` type uses `weak_count` to keep track of how many `Weak<T>` references exist, similar to `strong_count`. The difference is the `weak_count` doesn’t need to be 0 for the `Rc<T>` instance to be cleaned up.\n\nBecause the value that `Weak<T>` references might have been dropped, to do anything with the value that a `Weak<T>` is pointing to, you must make sure the value still exists. Do this by calling the `upgrade` method on a `Weak<T>` instance, which will return an `Option<Rc<T>>`. You’ll get a result of `Some` if the `Rc<T>` value has not been dropped yet and a result of `None` if the `Rc<T>` value has been dropped. Because `upgrade` returns an `Option<Rc<T>>`, Rust will ensure that the `Some` case and the `None` case are handled, and there won’t be an invalid pointer.\n\nAs an example, rather than using a list whose items know only about the next item, we’ll create a tree whose items know about their children items _and_ their parent items.\n\n#### [Creating a Tree Data Structure: a `Node` with Child Nodes](#creating-a-tree-data-structure-a-node-with-child-nodes)\n\nTo start, we’ll build a tree with nodes that know about their child nodes. We’ll create a struct named `Node` that holds its own `i32` value as well as references to its children `Node` values:\n\nFilename: src/main.rs\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        children: RefCell::new(vec![]),\n    });\n\n    let branch = Rc::new(Node {\n        value: 5,\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n}\n```\n\nWe want a `Node` to own its children, and we want to share that ownership with variables so we can access each `Node` in the tree directly. To do this, we define the `Vec<T>` items to be values of type `Rc<Node>`. We also want to modify which nodes are children of another node, so we have a `RefCell<T>` in `children` around the `Vec<Rc<Node>>`.\n\nNext, we’ll use our struct definition and create one `Node` instance named `leaf` with the value 3 and no children, and another instance named `branch` with the value 5 and `leaf` as one of its children, as shown in Listing 15-27:\n\nFilename: src/main.rs\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        children: RefCell::new(vec![]),\n    });\n\n    let branch = Rc::new(Node {\n        value: 5,\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n}\n```\n\nListing 15-27: Creating a `leaf` node with no children and a `branch` node with `leaf` as one of its children\n\nWe clone the `Rc<Node>` in `leaf` and store that in `branch`, meaning the `Node` in `leaf` now has two owners: `leaf` and `branch`. We can get from `branch` to `leaf` through `branch.children`, but there’s no way to get from `leaf` to `branch`. The reason is that `leaf` has no reference to `branch` and doesn’t know they’re related. We want `leaf` to know that `branch` is its parent. We’ll do that next.\n\n#### [Adding a Reference from a Child to Its Parent](#adding-a-reference-from-a-child-to-its-parent)\n\nTo make the child node aware of its parent, we need to add a `parent` field to our `Node` struct definition. The trouble is in deciding what the type of `parent` should be. We know it can’t contain an `Rc<T>`, because that would create a reference cycle with `leaf.parent` pointing to `branch` and `branch.children` pointing to `leaf`, which would cause their `strong_count` values to never be 0.\n\nThinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!\n\nSo instead of `Rc<T>`, we’ll make the type of `parent` use `Weak<T>`, specifically a `RefCell<Weak<Node>>`. Now our `Node` struct definition looks like this:\n\nFilename: src/main.rs\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n}\n```\n\nA node will be able to refer to its parent node but doesn’t own its parent. In Listing 15-28, we update `main` to use this new definition so the `leaf` node will have a way to refer to its parent, `branch`:\n\nFilename: src/main.rs\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n}\n```\n\nListing 15-28: A `leaf` node with a weak reference to its parent node `branch`\n\nCreating the `leaf` node looks similar to Listing 15-27 with the exception of the `parent` field: `leaf` starts out without a parent, so we create a new, empty `Weak<Node>` reference instance.\n\nAt this point, when we try to get a reference to the parent of `leaf` by using the `upgrade` method, we get a `None` value. We see this in the output from the first `println!` statement:\n\n```text\nleaf parent = None\n\n```\n\nWhen we create the `branch` node, it will also have a new `Weak<Node>` reference in the `parent` field, because `branch` doesn’t have a parent node. We still have `leaf` as one of the children of `branch`. Once we have the `Node` instance in `branch`, we can modify `leaf` to give it a `Weak<Node>` reference to its parent. We use the `borrow_mut` method on the `RefCell<Weak<Node>>` in the `parent` field of `leaf`, and then we use the `Rc::downgrade` function to create a `Weak<Node>` reference to `branch` from the `Rc<Node>` in `branch.`\n\nWhen we print the parent of `leaf` again, this time we’ll get a `Some` variant holding `branch`: now `leaf` can access its parent! When we print `leaf`, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the `Weak<Node>` references are printed as `(Weak)`:\n\n```text\nleaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [] } }] } })\n\n```\n\nThe lack of infinite output indicates that this code didn’t create a reference cycle. We can also tell this by looking at the values we get from calling `Rc::strong_count` and `Rc::weak_count`.\n\n#### [Visualizing Changes to `strong_count` and `weak_count`](#visualizing-changes-to-strong_count-and-weak_count)\n\nLet’s look at how the `strong_count` and `weak_count` values of the `Rc<Node>` instances change by creating a new inner scope and moving the creation of `branch` into that scope. By doing so, we can see what happens when `branch` is created and then dropped when it goes out of scope. The modifications are shown in Listing 15-29:\n\nFilename: src/main.rs\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\n            \"branch strong = {}, weak = {}\",\n            Rc::strong_count(&branch),\n            Rc::weak_count(&branch),\n        );\n\n        println!(\n            \"leaf strong = {}, weak = {}\",\n            Rc::strong_count(&leaf),\n            Rc::weak_count(&leaf),\n        );\n    }\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}\n```\n\nListing 15-29: Creating `branch` in an inner scope and examining strong and weak reference counts\n\nAfter `leaf` is created, its `Rc<Node>` has a strong count of 1 and a weak count of 0. In the inner scope, we create `branch` and associate it with `leaf`, at which point when we print the counts, the `Rc<Node>` in `branch` will have a strong count of 1 and a weak count of 1 (for `leaf.parent` pointing to `branch` with a `Weak<Node>`). When we print the counts in `leaf`, we’ll see it will have a strong count of 2, because `branch` now has a clone of the `Rc<Node>` of `leaf` stored in `branch.children`, but will still have a weak count of 0.\n\nWhen the inner scope ends, `branch` goes out of scope and the strong count of the `Rc<Node>` decreases to 0, so its `Node` is dropped. The weak count of 1 from `leaf.parent` has no bearing on whether or not `Node` is dropped, so we don’t get any memory leaks!\n\nIf we try to access the parent of `leaf` after the end of the scope, we’ll get `None` again. At the end of the program, the `Rc<Node>` in `leaf` has a strong count of 1 and a weak count of 0, because the variable `leaf` is now the only reference to the `Rc<Node>` again.\n\nAll of the logic that manages the counts and value dropping is built into `Rc<T>` and `Weak<T>` and their implementations of the `Drop` trait. By specifying that the relationship from a child to its parent should be a `Weak<T>` reference in the definition of `Node`, you’re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.\n\n## [Summary](#summary)\n\nThis chapter covered how to use smart pointers to make different guarantees and trade-offs from those Rust makes by default with regular references. The `Box<T>` type has a known size and points to data allocated on the heap. The `Rc<T>` type keeps track of the number of references to data on the heap so that data can have multiple owners. The `RefCell<T>` type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.\n\nAlso discussed were the `Deref` and `Drop` traits, which enable a lot of the functionality of smart pointers. We explored reference cycles that can cause memory leaks and how to prevent them using `Weak<T>`.\n\nIf this chapter has piqued your interest and you want to implement your own smart pointers, check out [“The Rustonomicon”](../nomicon/index.html) for more useful information.\n\nNext, we’ll talk about concurrency in Rust. You’ll even learn about a few new smart pointers.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Reference Cycles Can Leak Memory - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"reference-cycles-can-leak-memory\"><a class=\"header\" href=\"#reference-cycles-can-leak-memory\">Reference Cycles Can Leak Memory</a></h2>\n<p>Rust’s memory safety guarantees make it difficult, but not impossible, to\naccidentally create memory that is never cleaned up (known as a <em>memory leak</em>).\nPreventing memory leaks entirely is not one of Rust’s guarantees, meaning\nmemory leaks are memory safe in Rust. We can see that Rust allows memory leaks\nby using <code class=\"hljs\">Rc&lt;T&gt;</code> and <code class=\"hljs\">RefCell&lt;T&gt;</code>: it’s possible to create references where\nitems refer to each other in a cycle. This creates memory leaks because the\nreference count of each item in the cycle will never reach 0, and the values\nwill never be dropped.</p>\n<h3 id=\"creating-a-reference-cycle\"><a class=\"header\" href=\"#creating-a-reference-cycle\">Creating a Reference Cycle</a></h3>\n<p>Let’s look at how a reference cycle might happen and how to prevent it,\nstarting with the definition of the <code class=\"hljs\">List</code> enum and a <code class=\"hljs\">tail</code> method in Listing\n15-25:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">use</span> crate::List::{Cons, Nil};\n<span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n<span class=\"hljs-keyword\">use</span> std::rc::Rc;\n\n<span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">List</span></span> {\n    Cons(<span class=\"hljs-built_in\">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),\n    Nil,\n}\n\n<span class=\"hljs-keyword\">impl</span> List {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">tail</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            Cons(_, item) =&gt; <span class=\"hljs-literal\">Some</span>(item),\n            Nil =&gt; <span class=\"hljs-literal\">None</span>,\n        }\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</code></pre></pre>\n<p><span class=\"caption\">Listing 15-25: A cons list definition that holds a\n<code class=\"hljs\">RefCell&lt;T&gt;</code> so we can modify what a <code class=\"hljs\">Cons</code> variant is referring to</span></p>\n<p>We’re using another variation of the <code class=\"hljs\">List</code> definition from Listing 15-5. The\nsecond element in the <code class=\"hljs\">Cons</code> variant is now <code class=\"hljs\">RefCell&lt;Rc&lt;List&gt;&gt;</code>, meaning that\ninstead of having the ability to modify the <code class=\"hljs\">i32</code> value as we did in Listing\n15-24, we want to modify the <code class=\"hljs\">List</code> value a <code class=\"hljs\">Cons</code> variant is pointing to.\nWe’re also adding a <code class=\"hljs\">tail</code> method to make it convenient for us to access the\nsecond item if we have a <code class=\"hljs\">Cons</code> variant.</p>\n<p>In Listing 15-26, we’re adding a <code class=\"hljs\">main</code> function that uses the definitions in\nListing 15-25. This code creates a list in <code class=\"hljs\">a</code> and a list in <code class=\"hljs\">b</code> that points to\nthe list in <code class=\"hljs\">a</code>. Then it modifies the list in <code class=\"hljs\">a</code> to point to <code class=\"hljs\">b</code>, creating a\nreference cycle. There are <code class=\"hljs\">println!</code> statements along the way to show what the\nreference counts are at various points in this process.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> crate::List::{Cons, Nil};\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::rc::Rc;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">List</span></span> {\n</span><span class=\"boring\">    Cons(<span class=\"hljs-built_in\">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),\n</span><span class=\"boring\">    Nil,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> List {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">tail</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n</span><span class=\"boring\">            Cons(_, item) =&gt; <span class=\"hljs-literal\">Some</span>(item),\n</span><span class=\"boring\">            Nil =&gt; <span class=\"hljs-literal\">None</span>,\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> a = Rc::new(Cons(<span class=\"hljs-number\">5</span>, RefCell::new(Rc::new(Nil))));\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a initial rc count = {}\"</span>, Rc::strong_count(&amp;a));\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a next item = {:?}\"</span>, a.tail());\n\n    <span class=\"hljs-keyword\">let</span> b = Rc::new(Cons(<span class=\"hljs-number\">10</span>, RefCell::new(Rc::clone(&amp;a))));\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a rc count after b creation = {}\"</span>, Rc::strong_count(&amp;a));\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"b initial rc count = {}\"</span>, Rc::strong_count(&amp;b));\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"b next item = {:?}\"</span>, b.tail());\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&amp;b);\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"b rc count after changing a = {}\"</span>, Rc::strong_count(&amp;b));\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a rc count after changing a = {}\"</span>, Rc::strong_count(&amp;a));\n\n    <span class=\"hljs-comment\">// Uncomment the next line to see that we have a cycle;</span>\n    <span class=\"hljs-comment\">// it will overflow the stack</span>\n    <span class=\"hljs-comment\">// println!(\"a next item = {:?}\", a.tail());</span>\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 15-26: Creating a reference cycle of two <code class=\"hljs\">List</code>\nvalues pointing to each other</span></p>\n<p>We create an <code class=\"hljs\">Rc&lt;List&gt;</code> instance holding a <code class=\"hljs\">List</code> value in the variable <code class=\"hljs\">a</code>\nwith an initial list of <code class=\"hljs\">5, Nil</code>. We then create an <code class=\"hljs\">Rc&lt;List&gt;</code> instance holding\nanother <code class=\"hljs\">List</code> value in the variable <code class=\"hljs\">b</code> that contains the value 10 and points\nto the list in <code class=\"hljs\">a</code>.</p>\n<p>We modify <code class=\"hljs\">a</code> so it points to <code class=\"hljs\">b</code> instead of <code class=\"hljs\">Nil</code>, creating a cycle. We do\nthat by using the <code class=\"hljs\">tail</code> method to get a reference to the <code class=\"hljs\">RefCell&lt;Rc&lt;List&gt;&gt;</code>\nin <code class=\"hljs\">a</code>, which we put in the variable <code class=\"hljs\">link</code>. Then we use the <code class=\"hljs\">borrow_mut</code>\nmethod on the <code class=\"hljs\">RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside from an <code class=\"hljs\">Rc&lt;List&gt;</code>\nthat holds a <code class=\"hljs\">Nil</code> value to the <code class=\"hljs\">Rc&lt;List&gt;</code> in <code class=\"hljs\">b</code>.</p>\n<p>When we run this code, keeping the last <code class=\"hljs\">println!</code> commented out for the\nmoment, we’ll get this output:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s\n     Running `target/debug/cons-list`\na initial rc count = 1\na next item = Some(RefCell { value: Nil })\na rc count after b creation = 2\nb initial rc count = 1\nb next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })\nb rc count after changing a = 2\na rc count after changing a = 2\n</code></pre>\n<p>The reference count of the <code class=\"hljs\">Rc&lt;List&gt;</code> instances in both <code class=\"hljs\">a</code> and <code class=\"hljs\">b</code> are 2 after\nwe change the list in <code class=\"hljs\">a</code> to point to <code class=\"hljs\">b</code>. At the end of <code class=\"hljs\">main</code>, Rust drops the\nvariable <code class=\"hljs\">b</code>, which decreases the reference count of the <code class=\"hljs\">b</code> <code class=\"hljs\">Rc&lt;List&gt;</code> instance\nfrom 2 to 1. The memory that <code class=\"hljs\">Rc&lt;List&gt;</code> has on the heap won’t be dropped at\nthis point, because its reference count is 1, not 0. Then Rust drops <code class=\"hljs\">a</code>, which\ndecreases the reference count of the <code class=\"hljs\">a</code> <code class=\"hljs\">Rc&lt;List&gt;</code> instance from 2 to 1 as\nwell. This instance’s memory can’t be dropped either, because the other\n<code class=\"hljs\">Rc&lt;List&gt;</code> instance still refers to it. The memory allocated to the list will\nremain uncollected forever. To visualize this reference cycle, we’ve created a\ndiagram in Figure 15-4.</p>\n<img alt=\"Reference cycle of lists\" src=\"img/trpl15-04.svg\" class=\"center\">\n<p><span class=\"caption\">Figure 15-4: A reference cycle of lists <code class=\"hljs\">a</code> and <code class=\"hljs\">b</code>\npointing to each other</span></p>\n<p>If you uncomment the last <code class=\"hljs\">println!</code> and run the program, Rust will try to\nprint this cycle with <code class=\"hljs\">a</code> pointing to <code class=\"hljs\">b</code> pointing to <code class=\"hljs\">a</code> and so forth until it\noverflows the stack.</p>\n<p>Compared to a real-world program, the consequences of creating a reference cycle\nin this example aren’t very dire: right after we create the reference cycle,\nthe program ends. However, if a more complex program allocated lots of memory\nin a cycle and held onto it for a long time, the program would use more memory\nthan it needed and might overwhelm the system, causing it to run out of\navailable memory.</p>\n<p>Creating reference cycles is not easily done, but it’s not impossible either.\nIf you have <code class=\"hljs\">RefCell&lt;T&gt;</code> values that contain <code class=\"hljs\">Rc&lt;T&gt;</code> values or similar nested\ncombinations of types with interior mutability and reference counting, you must\nensure that you don’t create cycles; you can’t rely on Rust to catch them.\nCreating a reference cycle would be a logic bug in your program that you should\nuse automated tests, code reviews, and other software development practices to\nminimize.</p>\n<p>Another solution for avoiding reference cycles is reorganizing your data\nstructures so that some references express ownership and some references don’t.\nAs a result, you can have cycles made up of some ownership relationships and\nsome non-ownership relationships, and only the ownership relationships affect\nwhether or not a value can be dropped. In Listing 15-25, we always want <code class=\"hljs\">Cons</code>\nvariants to own their list, so reorganizing the data structure isn’t possible.\nLet’s look at an example using graphs made up of parent nodes and child nodes\nto see when non-ownership relationships are an appropriate way to prevent\nreference cycles.</p>\n<h3 id=\"preventing-reference-cycles-turning-an-rct-into-a-weakt\"><a class=\"header\" href=\"#preventing-reference-cycles-turning-an-rct-into-a-weakt\">Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></a></h3>\n<p>So far, we’ve demonstrated that calling <code class=\"hljs\">Rc::clone</code> increases the\n<code class=\"hljs\">strong_count</code> of an <code class=\"hljs\">Rc&lt;T&gt;</code> instance, and an <code class=\"hljs\">Rc&lt;T&gt;</code> instance is only cleaned\nup if its <code class=\"hljs\">strong_count</code> is 0. You can also create a <em>weak reference</em> to the\nvalue within an <code class=\"hljs\">Rc&lt;T&gt;</code> instance by calling <code class=\"hljs\">Rc::downgrade</code> and passing a\nreference to the <code class=\"hljs\">Rc&lt;T&gt;</code>. Strong references are how you can share ownership of\nan <code class=\"hljs\">Rc&lt;T&gt;</code> instance. Weak references don’t express an ownership relationship,\nand their count doesn’t affect when an <code class=\"hljs\">Rc&lt;T&gt;</code> instance is cleaned up. They\nwon’t cause a reference cycle because any cycle involving some weak references\nwill be broken once the strong reference count of values involved is 0.</p>\n<p>When you call <code class=\"hljs\">Rc::downgrade</code>, you get a smart pointer of type <code class=\"hljs\">Weak&lt;T&gt;</code>.\nInstead of increasing the <code class=\"hljs\">strong_count</code> in the <code class=\"hljs\">Rc&lt;T&gt;</code> instance by 1, calling\n<code class=\"hljs\">Rc::downgrade</code> increases the <code class=\"hljs\">weak_count</code> by 1. The <code class=\"hljs\">Rc&lt;T&gt;</code> type uses\n<code class=\"hljs\">weak_count</code> to keep track of how many <code class=\"hljs\">Weak&lt;T&gt;</code> references exist, similar to\n<code class=\"hljs\">strong_count</code>. The difference is the <code class=\"hljs\">weak_count</code> doesn’t need to be 0 for the\n<code class=\"hljs\">Rc&lt;T&gt;</code> instance to be cleaned up.</p>\n<p>Because the value that <code class=\"hljs\">Weak&lt;T&gt;</code> references might have been dropped, to do\nanything with the value that a <code class=\"hljs\">Weak&lt;T&gt;</code> is pointing to, you must make sure the\nvalue still exists. Do this by calling the <code class=\"hljs\">upgrade</code> method on a <code class=\"hljs\">Weak&lt;T&gt;</code>\ninstance, which will return an <code class=\"hljs\">Option&lt;Rc&lt;T&gt;&gt;</code>. You’ll get a result of <code class=\"hljs\">Some</code>\nif the <code class=\"hljs\">Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code class=\"hljs\">None</code> if the\n<code class=\"hljs\">Rc&lt;T&gt;</code> value has been dropped. Because <code class=\"hljs\">upgrade</code> returns an <code class=\"hljs\">Option&lt;Rc&lt;T&gt;&gt;</code>,\nRust will ensure that the <code class=\"hljs\">Some</code> case and the <code class=\"hljs\">None</code> case are handled, and\nthere won’t be an invalid pointer.</p>\n<p>As an example, rather than using a list whose items know only about the next\nitem, we’ll create a tree whose items know about their children items <em>and</em>\ntheir parent items.</p>\n<h4 id=\"creating-a-tree-data-structure-a-node-with-child-nodes\"><a class=\"header\" href=\"#creating-a-tree-data-structure-a-node-with-child-nodes\">Creating a Tree Data Structure: a <code>Node</code> with Child Nodes</a></h4>\n<p>To start, we’ll build a tree with nodes that know about their child nodes.\nWe’ll create a struct named <code class=\"hljs\">Node</code> that holds its own <code class=\"hljs\">i32</code> value as well as\nreferences to its children <code class=\"hljs\">Node</code> values:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n<span class=\"hljs-keyword\">use</span> std::rc::Rc;\n\n<span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Node</span></span> {\n    value: <span class=\"hljs-built_in\">i32</span>,\n    children: RefCell&lt;<span class=\"hljs-built_in\">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> leaf = Rc::new(Node {\n</span><span class=\"boring\">        value: <span class=\"hljs-number\">3</span>,\n</span><span class=\"boring\">        children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[]),\n</span><span class=\"boring\">    });\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> branch = Rc::new(Node {\n</span><span class=\"boring\">        value: <span class=\"hljs-number\">5</span>,\n</span><span class=\"boring\">        children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[Rc::clone(&amp;leaf)]),\n</span><span class=\"boring\">    });\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p>We want a <code class=\"hljs\">Node</code> to own its children, and we want to share that ownership with\nvariables so we can access each <code class=\"hljs\">Node</code> in the tree directly. To do this, we\ndefine the <code class=\"hljs\">Vec&lt;T&gt;</code> items to be values of type <code class=\"hljs\">Rc&lt;Node&gt;</code>. We also want to\nmodify which nodes are children of another node, so we have a <code class=\"hljs\">RefCell&lt;T&gt;</code> in\n<code class=\"hljs\">children</code> around the <code class=\"hljs\">Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>\n<p>Next, we’ll use our struct definition and create one <code class=\"hljs\">Node</code> instance named\n<code class=\"hljs\">leaf</code> with the value 3 and no children, and another instance named <code class=\"hljs\">branch</code>\nwith the value 5 and <code class=\"hljs\">leaf</code> as one of its children, as shown in Listing 15-27:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::rc::Rc;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Node</span></span> {\n</span><span class=\"boring\">    value: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">    children: RefCell&lt;<span class=\"hljs-built_in\">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> leaf = Rc::new(Node {\n        value: <span class=\"hljs-number\">3</span>,\n        children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[]),\n    });\n\n    <span class=\"hljs-keyword\">let</span> branch = Rc::new(Node {\n        value: <span class=\"hljs-number\">5</span>,\n        children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[Rc::clone(&amp;leaf)]),\n    });\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 15-27: Creating a <code class=\"hljs\">leaf</code> node with no children\nand a <code class=\"hljs\">branch</code> node with <code class=\"hljs\">leaf</code> as one of its children</span></p>\n<p>We clone the <code class=\"hljs\">Rc&lt;Node&gt;</code> in <code class=\"hljs\">leaf</code> and store that in <code class=\"hljs\">branch</code>, meaning the\n<code class=\"hljs\">Node</code> in <code class=\"hljs\">leaf</code> now has two owners: <code class=\"hljs\">leaf</code> and <code class=\"hljs\">branch</code>. We can get from\n<code class=\"hljs\">branch</code> to <code class=\"hljs\">leaf</code> through <code class=\"hljs\">branch.children</code>, but there’s no way to get from\n<code class=\"hljs\">leaf</code> to <code class=\"hljs\">branch</code>. The reason is that <code class=\"hljs\">leaf</code> has no reference to <code class=\"hljs\">branch</code> and\ndoesn’t know they’re related. We want <code class=\"hljs\">leaf</code> to know that <code class=\"hljs\">branch</code> is its\nparent. We’ll do that next.</p>\n<h4 id=\"adding-a-reference-from-a-child-to-its-parent\"><a class=\"header\" href=\"#adding-a-reference-from-a-child-to-its-parent\">Adding a Reference from a Child to Its Parent</a></h4>\n<p>To make the child node aware of its parent, we need to add a <code class=\"hljs\">parent</code> field to\nour <code class=\"hljs\">Node</code> struct definition. The trouble is in deciding what the type of\n<code class=\"hljs\">parent</code> should be. We know it can’t contain an <code class=\"hljs\">Rc&lt;T&gt;</code>, because that would\ncreate a reference cycle with <code class=\"hljs\">leaf.parent</code> pointing to <code class=\"hljs\">branch</code> and\n<code class=\"hljs\">branch.children</code> pointing to <code class=\"hljs\">leaf</code>, which would cause their <code class=\"hljs\">strong_count</code>\nvalues to never be 0.</p>\n<p>Thinking about the relationships another way, a parent node should own its\nchildren: if a parent node is dropped, its child nodes should be dropped as\nwell. However, a child should not own its parent: if we drop a child node, the\nparent should still exist. This is a case for weak references!</p>\n<p>So instead of <code class=\"hljs\">Rc&lt;T&gt;</code>, we’ll make the type of <code class=\"hljs\">parent</code> use <code class=\"hljs\">Weak&lt;T&gt;</code>,\nspecifically a <code class=\"hljs\">RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code class=\"hljs\">Node</code> struct definition looks\nlike this:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n<span class=\"hljs-keyword\">use</span> std::rc::{Rc, Weak};\n\n<span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Node</span></span> {\n    value: <span class=\"hljs-built_in\">i32</span>,\n    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,\n    children: RefCell&lt;<span class=\"hljs-built_in\">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> leaf = Rc::new(Node {\n</span><span class=\"boring\">        value: <span class=\"hljs-number\">3</span>,\n</span><span class=\"boring\">        parent: RefCell::new(Weak::new()),\n</span><span class=\"boring\">        children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[]),\n</span><span class=\"boring\">    });\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"leaf parent = {:?}\"</span>, leaf.parent.borrow().upgrade());\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> branch = Rc::new(Node {\n</span><span class=\"boring\">        value: <span class=\"hljs-number\">5</span>,\n</span><span class=\"boring\">        parent: RefCell::new(Weak::new()),\n</span><span class=\"boring\">        children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[Rc::clone(&amp;leaf)]),\n</span><span class=\"boring\">    });\n</span><span class=\"boring\">\n</span><span class=\"boring\">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"leaf parent = {:?}\"</span>, leaf.parent.borrow().upgrade());\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p>A node will be able to refer to its parent node but doesn’t own its parent.\nIn Listing 15-28, we update <code class=\"hljs\">main</code> to use this new definition so the <code class=\"hljs\">leaf</code>\nnode will have a way to refer to its parent, <code class=\"hljs\">branch</code>:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::rc::{Rc, Weak};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Node</span></span> {\n</span><span class=\"boring\">    value: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,\n</span><span class=\"boring\">    children: RefCell&lt;<span class=\"hljs-built_in\">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> leaf = Rc::new(Node {\n        value: <span class=\"hljs-number\">3</span>,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[]),\n    });\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"leaf parent = {:?}\"</span>, leaf.parent.borrow().upgrade());\n\n    <span class=\"hljs-keyword\">let</span> branch = Rc::new(Node {\n        value: <span class=\"hljs-number\">5</span>,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[Rc::clone(&amp;leaf)]),\n    });\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"leaf parent = {:?}\"</span>, leaf.parent.borrow().upgrade());\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 15-28: A <code class=\"hljs\">leaf</code> node with a weak reference to its\nparent node <code class=\"hljs\">branch</code></span></p>\n<p>Creating the <code class=\"hljs\">leaf</code> node looks similar to Listing 15-27 with the exception of\nthe <code class=\"hljs\">parent</code> field: <code class=\"hljs\">leaf</code> starts out without a parent, so we create a new,\nempty <code class=\"hljs\">Weak&lt;Node&gt;</code> reference instance.</p>\n<p>At this point, when we try to get a reference to the parent of <code class=\"hljs\">leaf</code> by using\nthe <code class=\"hljs\">upgrade</code> method, we get a <code class=\"hljs\">None</code> value. We see this in the output from the\nfirst <code class=\"hljs\">println!</code> statement:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">leaf parent = None\n</code></pre>\n<p>When we create the <code class=\"hljs\">branch</code> node, it will also have a new <code class=\"hljs\">Weak&lt;Node&gt;</code>\nreference in the <code class=\"hljs\">parent</code> field, because <code class=\"hljs\">branch</code> doesn’t have a parent node.\nWe still have <code class=\"hljs\">leaf</code> as one of the children of <code class=\"hljs\">branch</code>. Once we have the\n<code class=\"hljs\">Node</code> instance in <code class=\"hljs\">branch</code>, we can modify <code class=\"hljs\">leaf</code> to give it a <code class=\"hljs\">Weak&lt;Node&gt;</code>\nreference to its parent. We use the <code class=\"hljs\">borrow_mut</code> method on the\n<code class=\"hljs\">RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code class=\"hljs\">parent</code> field of <code class=\"hljs\">leaf</code>, and then we use the\n<code class=\"hljs\">Rc::downgrade</code> function to create a <code class=\"hljs\">Weak&lt;Node&gt;</code> reference to <code class=\"hljs\">branch</code> from\nthe <code class=\"hljs\">Rc&lt;Node&gt;</code> in <code class=\"hljs\">branch.</code></p>\n<p>When we print the parent of <code class=\"hljs\">leaf</code> again, this time we’ll get a <code class=\"hljs\">Some</code> variant\nholding <code class=\"hljs\">branch</code>: now <code class=\"hljs\">leaf</code> can access its parent! When we print <code class=\"hljs\">leaf</code>, we\nalso avoid the cycle that eventually ended in a stack overflow like we had in\nListing 15-26; the <code class=\"hljs\">Weak&lt;Node&gt;</code> references are printed as <code class=\"hljs\">(Weak)</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [] } }] } })\n</code></pre>\n<p>The lack of infinite output indicates that this code didn’t create a reference\ncycle. We can also tell this by looking at the values we get from calling\n<code class=\"hljs\">Rc::strong_count</code> and <code class=\"hljs\">Rc::weak_count</code>.</p>\n<h4 id=\"visualizing-changes-to-strong_count-and-weak_count\"><a class=\"header\" href=\"#visualizing-changes-to-strong_count-and-weak_count\">Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></a></h4>\n<p>Let’s look at how the <code class=\"hljs\">strong_count</code> and <code class=\"hljs\">weak_count</code> values of the <code class=\"hljs\">Rc&lt;Node&gt;</code>\ninstances change by creating a new inner scope and moving the creation of\n<code class=\"hljs\">branch</code> into that scope. By doing so, we can see what happens when <code class=\"hljs\">branch</code> is\ncreated and then dropped when it goes out of scope. The modifications are shown\nin Listing 15-29:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::rc::{Rc, Weak};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Node</span></span> {\n</span><span class=\"boring\">    value: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,\n</span><span class=\"boring\">    children: RefCell&lt;<span class=\"hljs-built_in\">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> leaf = Rc::new(Node {\n        value: <span class=\"hljs-number\">3</span>,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[]),\n    });\n\n    <span class=\"hljs-built_in\">println!</span>(\n        <span class=\"hljs-string\">\"leaf strong = {}, weak = {}\"</span>,\n        Rc::strong_count(&amp;leaf),\n        Rc::weak_count(&amp;leaf),\n    );\n\n    {\n        <span class=\"hljs-keyword\">let</span> branch = Rc::new(Node {\n            value: <span class=\"hljs-number\">5</span>,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(<span class=\"hljs-built_in\">vec!</span>[Rc::clone(&amp;leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);\n\n        <span class=\"hljs-built_in\">println!</span>(\n            <span class=\"hljs-string\">\"branch strong = {}, weak = {}\"</span>,\n            Rc::strong_count(&amp;branch),\n            Rc::weak_count(&amp;branch),\n        );\n\n        <span class=\"hljs-built_in\">println!</span>(\n            <span class=\"hljs-string\">\"leaf strong = {}, weak = {}\"</span>,\n            Rc::strong_count(&amp;leaf),\n            Rc::weak_count(&amp;leaf),\n        );\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"leaf parent = {:?}\"</span>, leaf.parent.borrow().upgrade());\n    <span class=\"hljs-built_in\">println!</span>(\n        <span class=\"hljs-string\">\"leaf strong = {}, weak = {}\"</span>,\n        Rc::strong_count(&amp;leaf),\n        Rc::weak_count(&amp;leaf),\n    );\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 15-29: Creating <code class=\"hljs\">branch</code> in an inner scope and\nexamining strong and weak reference counts</span></p>\n<p>After <code class=\"hljs\">leaf</code> is created, its <code class=\"hljs\">Rc&lt;Node&gt;</code> has a strong count of 1 and a weak\ncount of 0. In the inner scope, we create <code class=\"hljs\">branch</code> and associate it with\n<code class=\"hljs\">leaf</code>, at which point when we print the counts, the <code class=\"hljs\">Rc&lt;Node&gt;</code> in <code class=\"hljs\">branch</code>\nwill have a strong count of 1 and a weak count of 1 (for <code class=\"hljs\">leaf.parent</code> pointing\nto <code class=\"hljs\">branch</code> with a <code class=\"hljs\">Weak&lt;Node&gt;</code>). When we print the counts in <code class=\"hljs\">leaf</code>, we’ll see\nit will have a strong count of 2, because <code class=\"hljs\">branch</code> now has a clone of the\n<code class=\"hljs\">Rc&lt;Node&gt;</code> of <code class=\"hljs\">leaf</code> stored in <code class=\"hljs\">branch.children</code>, but will still have a weak\ncount of 0.</p>\n<p>When the inner scope ends, <code class=\"hljs\">branch</code> goes out of scope and the strong count of\nthe <code class=\"hljs\">Rc&lt;Node&gt;</code> decreases to 0, so its <code class=\"hljs\">Node</code> is dropped. The weak count of 1\nfrom <code class=\"hljs\">leaf.parent</code> has no bearing on whether or not <code class=\"hljs\">Node</code> is dropped, so we\ndon’t get any memory leaks!</p>\n<p>If we try to access the parent of <code class=\"hljs\">leaf</code> after the end of the scope, we’ll get\n<code class=\"hljs\">None</code> again. At the end of the program, the <code class=\"hljs\">Rc&lt;Node&gt;</code> in <code class=\"hljs\">leaf</code> has a strong\ncount of 1 and a weak count of 0, because the variable <code class=\"hljs\">leaf</code> is now the only\nreference to the <code class=\"hljs\">Rc&lt;Node&gt;</code> again.</p>\n<p>All of the logic that manages the counts and value dropping is built into\n<code class=\"hljs\">Rc&lt;T&gt;</code> and <code class=\"hljs\">Weak&lt;T&gt;</code> and their implementations of the <code class=\"hljs\">Drop</code> trait. By\nspecifying that the relationship from a child to its parent should be a\n<code class=\"hljs\">Weak&lt;T&gt;</code> reference in the definition of <code class=\"hljs\">Node</code>, you’re able to have parent\nnodes point to child nodes and vice versa without creating a reference cycle\nand memory leaks.</p>\n<h2 id=\"summary\"><a class=\"header\" href=\"#summary\">Summary</a></h2>\n<p>This chapter covered how to use smart pointers to make different guarantees and\ntrade-offs from those Rust makes by default with regular references. The\n<code class=\"hljs\">Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The\n<code class=\"hljs\">Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so\nthat data can have multiple owners. The <code class=\"hljs\">RefCell&lt;T&gt;</code> type with its interior\nmutability gives us a type that we can use when we need an immutable type but\nneed to change an inner value of that type; it also enforces the borrowing\nrules at runtime instead of at compile time.</p>\n<p>Also discussed were the <code class=\"hljs\">Deref</code> and <code class=\"hljs\">Drop</code> traits, which enable a lot of the\nfunctionality of smart pointers. We explored reference cycles that can cause\nmemory leaks and how to prevent them using <code class=\"hljs\">Weak&lt;T&gt;</code>.</p>\n<p>If this chapter has piqued your interest and you want to implement your own\nsmart pointers, check out <a href=\"../nomicon/index.html\">“The Rustonomicon”</a> for more useful\ninformation.</p>\n<p>Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new\nsmart pointers.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch15-05-interior-mutability.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch16-00-concurrency.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch15-05-interior-mutability.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch16-00-concurrency.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:29.819Z"
}