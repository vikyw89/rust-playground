{
	"title": "Building a Single-Threaded Web Server - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch20-01-single-threaded.html",
	"markdown": "# Building a Single-Threaded Web Server\n\nWe’ll start by getting a single-threaded web server working. Before we begin, let’s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.\n\nThe two main protocols involved in web servers are _Hypertext Transfer Protocol_ _(HTTP)_ and _Transmission Control Protocol_ _(TCP)_. Both protocols are _request-response_ protocols, meaning a _client_ initiates requests and a _server_ listens to the requests and provides a response to the client. The contents of those requests and responses are defined by the protocols.\n\nTCP is the lower-level protocol that describes the details of how information gets from one server to another but doesn’t specify what that information is. HTTP builds on top of TCP by defining the contents of the requests and responses. It’s technically possible to use HTTP with other protocols, but in the vast majority of cases, HTTP sends its data over TCP. We’ll work with the raw bytes of TCP and HTTP requests and responses.\n\n### [Listening to the TCP Connection](#listening-to-the-tcp-connection)\n\nOur web server needs to listen to a TCP connection, so that’s the first part we’ll work on. The standard library offers a `std::net` module that lets us do this. Let’s make a new project in the usual fashion:\n\n```console\n$ cargo new hello\n     Created binary (application) `hello` project\n$ cd hello\n\n```\n\nNow enter the code in Listing 20-1 in _src/main.rs_ to start. This code will listen at the local address `127.0.0.1:7878` for incoming TCP streams. When it gets an incoming stream, it will print `Connection established!`.\n\nFilename: src/main.rs\n\n```rust\nuse std::net::TcpListener;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        println!(\"Connection established!\");\n    }\n}\n```\n\nListing 20-1: Listening for incoming streams and printing a message when we receive a stream\n\nUsing `TcpListener`, we can listen for TCP connections at the address `127.0.0.1:7878`. In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn’t represent the authors’ computer specifically), and `7878` is the port. We’ve chosen this port for two reasons: HTTP isn’t normally accepted on this port so our server is unlikely to conflict with any other web server you might have running on your machine, and 7878 is _rust_ typed on a telephone.\n\nThe `bind` function in this scenario works like the `new` function in that it will return a new `TcpListener` instance. The function is called `bind` because, in networking, connecting to a port to listen to is known as “binding to a port.”\n\nThe `bind` function returns a `Result<T, E>`, which indicates that it’s possible for binding to fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1023), so if we tried to connect to port 80 without being an administrator, binding wouldn’t work. Binding also wouldn’t work, for example, if we ran two instances of our program and so had two programs listening to the same port. Because we’re writing a basic server just for learning purposes, we won’t worry about handling these kinds of errors; instead, we use `unwrap` to stop the program if errors happen.\n\nThe `incoming` method on `TcpListener` returns an iterator that gives us a sequence of streams (more specifically, streams of type `TcpStream`). A single _stream_ represents an open connection between the client and the server. A _connection_ is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, we will read from the `TcpStream` to see what the client sent and then write our response to the stream to send data back to the client. Overall, this `for` loop will process each connection in turn and produce a series of streams for us to handle.\n\nFor now, our handling of the stream consists of calling `unwrap` to terminate our program if the stream has any errors; if there aren’t any errors, the program prints a message. We’ll add more functionality for the success case in the next listing. The reason we might receive errors from the `incoming` method when a client connects to the server is that we’re not actually iterating over connections. Instead, we’re iterating over _connection attempts_. The connection might not be successful for a number of reasons, many of them operating system specific. For example, many operating systems have a limit to the number of simultaneous open connections they can support; new connection attempts beyond that number will produce an error until some of the open connections are closed.\n\nLet’s try running this code! Invoke `cargo run` in the terminal and then load _127.0.0.1:7878_ in a web browser. The browser should show an error message like “Connection reset,” because the server isn’t currently sending back any data. But when you look at your terminal, you should see several messages that were printed when the browser connected to the server!\n\n```text\n     Running `target/debug/hello`\nConnection established!\nConnection established!\nConnection established!\n\n```\n\nSometimes, you’ll see multiple messages printed for one browser request; the reason might be that the browser is making a request for the page as well as a request for other resources, like the _favicon.ico_ icon that appears in the browser tab.\n\nIt could also be that the browser is trying to connect to the server multiple times because the server isn’t responding with any data. When `stream` goes out of scope and is dropped at the end of the loop, the connection is closed as part of the `drop` implementation. Browsers sometimes deal with closed connections by retrying, because the problem might be temporary. The important factor is that we’ve successfully gotten a handle to a TCP connection!\n\nRemember to stop the program by pressing ctrl\\-c when you’re done running a particular version of the code. Then restart the program by invoking the `cargo run` command after you’ve made each set of code changes to make sure you’re running the newest code.\n\n### [Reading the Request](#reading-the-request)\n\nLet’s implement the functionality to read the request from the browser! To separate the concerns of first getting a connection and then taking some action with the connection, we’ll start a new function for processing connections. In this new `handle_connection` function, we’ll read data from the TCP stream and print it so we can see the data being sent from the browser. Change the code to look like Listing 20-2.\n\nFilename: src/main.rs\n\n```rust\nuse std::{\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {http_request:#?}\");\n}\n```\n\nListing 20-2: Reading from the `TcpStream` and printing the data\n\nWe bring `std::io::prelude` and `std::io::BufReader` into scope to get access to traits and types that let us read from and write to the stream. In the `for` loop in the `main` function, instead of printing a message that says we made a connection, we now call the new `handle_connection` function and pass the `stream` to it.\n\nIn the `handle_connection` function, we create a new `BufReader` instance that wraps a mutable reference to the `stream`. `BufReader` adds buffering by managing calls to the `std::io::Read` trait methods for us.\n\nWe create a variable named `http_request` to collect the lines of the request the browser sends to our server. We indicate that we want to collect these lines in a vector by adding the `Vec<_>` type annotation.\n\n`BufReader` implements the `std::io::BufRead` trait, which provides the `lines` method. The `lines` method returns an iterator of `Result<String, std::io::Error>` by splitting the stream of data whenever it sees a newline byte. To get each `String`, we map and `unwrap` each `Result`. The `Result` might be an error if the data isn’t valid UTF-8 or if there was a problem reading from the stream. Again, a production program should handle these errors more gracefully, but we’re choosing to stop the program in the error case for simplicity.\n\nThe browser signals the end of an HTTP request by sending two newline characters in a row, so to get one request from the stream, we take lines until we get a line that is the empty string. Once we’ve collected the lines into the vector, we’re printing them out using pretty debug formatting so we can take a look at the instructions the web browser is sending to our server.\n\nLet’s try this code! Start the program and make a request in a web browser again. Note that we’ll still get an error page in the browser, but our program’s output in the terminal will now look similar to this:\n\n```console\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running `target/debug/hello`\nRequest: [\n    \"GET / HTTP/1.1\",\n    \"Host: 127.0.0.1:7878\",\n    \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0\",\n    \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n    \"Accept-Language: en-US,en;q=0.5\",\n    \"Accept-Encoding: gzip, deflate, br\",\n    \"DNT: 1\",\n    \"Connection: keep-alive\",\n    \"Upgrade-Insecure-Requests: 1\",\n    \"Sec-Fetch-Dest: document\",\n    \"Sec-Fetch-Mode: navigate\",\n    \"Sec-Fetch-Site: none\",\n    \"Sec-Fetch-User: ?1\",\n    \"Cache-Control: max-age=0\",\n]\n\n```\n\nDepending on your browser, you might get slightly different output. Now that we’re printing the request data, we can see why we get multiple connections from one browser request by looking at the path after `GET` in the first line of the request. If the repeated connections are all requesting _/_, we know the browser is trying to fetch _/_ repeatedly because it’s not getting a response from our program.\n\nLet’s break down this request data to understand what the browser is asking of our program.\n\n### [A Closer Look at an HTTP Request](#a-closer-look-at-an-http-request)\n\nHTTP is a text-based protocol, and a request takes this format:\n\n```text\nMethod Request-URI HTTP-Version CRLF\nheaders CRLF\nmessage-body\n\n```\n\nThe first line is the _request line_ that holds information about what the client is requesting. The first part of the request line indicates the _method_ being used, such as `GET` or `POST`, which describes how the client is making this request. Our client used a `GET` request, which means it is asking for information.\n\nThe next part of the request line is _/_, which indicates the _Uniform Resource Identifier_ _(URI)_ the client is requesting: a URI is almost, but not quite, the same as a _Uniform Resource Locator_ _(URL)_. The difference between URIs and URLs isn’t important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for URI here.\n\nThe last part is the HTTP version the client uses, and then the request line ends in a _CRLF sequence_. (CRLF stands for _carriage return_ and _line feed_, which are terms from the typewriter days!) The CRLF sequence can also be written as `\\r\\n`, where `\\r` is a carriage return and `\\n` is a line feed. The CRLF sequence separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than `\\r\\n`.\n\nLooking at the request line data we received from running our program so far, we see that `GET` is the method, _/_ is the request URI, and `HTTP/1.1` is the version.\n\nAfter the request line, the remaining lines starting from `Host:` onward are headers. `GET` requests have no body.\n\nTry making a request from a different browser or asking for a different address, such as _127.0.0.1:7878/test_, to see how the request data changes.\n\nNow that we know what the browser is asking for, let’s send back some data!\n\n### [Writing a Response](#writing-a-response)\n\nWe’re going to implement sending data in response to a client request. Responses have the following format:\n\n```text\nHTTP-Version Status-Code Reason-Phrase CRLF\nheaders CRLF\nmessage-body\n\n```\n\nThe first line is a _status line_ that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.\n\nHere is an example response that uses HTTP version 1.1, has a status code of 200, an OK reason phrase, no headers, and no body:\n\n```text\nHTTP/1.1 200 OK\\r\\n\\r\\n\n\n```\n\nThe status code 200 is the standard success response. The text is a tiny successful HTTP response. Let’s write this to the stream as our response to a successful request! From the `handle_connection` function, remove the `println!` that was printing the request data and replace it with the code in Listing 20-3.\n\nFilename: src/main.rs\n\n```rust\nuse std::{\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let response = \"HTTP/1.1 200 OK\\r\\n\\r\\n\";\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\nListing 20-3: Writing a tiny successful HTTP response to the stream\n\nThe first new line defines the `response` variable that holds the success message’s data. Then we call `as_bytes` on our `response` to convert the string data to bytes. The `write_all` method on `stream` takes a `&[u8]` and sends those bytes directly down the connection. Because the `write_all` operation could fail, we use `unwrap` on any error result as before. Again, in a real application you would add error handling here.\n\nWith these changes, let’s run our code and make a request. We’re no longer printing any data to the terminal, so we won’t see any output other than the output from Cargo. When you load _127.0.0.1:7878_ in a web browser, you should get a blank page instead of an error. You’ve just hand-coded receiving an HTTP request and sending a response!\n\n### [Returning Real HTML](#returning-real-html)\n\nLet’s implement the functionality for returning more than a blank page. Create the new file _hello.html_ in the root of your project directory, not in the _src_ directory. You can input any HTML you want; Listing 20-4 shows one possibility.\n\nFilename: hello.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>Hello!</h1>\n    <p>Hi from Rust</p>\n  </body>\n</html>\n\n```\n\nListing 20-4: A sample HTML file to return in a response\n\nThis is a minimal HTML5 document with a heading and some text. To return this from the server when a request is received, we’ll modify `handle_connection` as shown in Listing 20-5 to read the HTML file, add it to the response as a body, and send it.\n\nFilename: src/main.rs\n\n```rust\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n// --snip--\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\nListing 20-5: Sending the contents of _hello.html_ as the body of the response\n\nWe’ve added `fs` to the `use` statement to bring the standard library’s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.\n\nNext, we use `format!` to add the file’s contents as the body of the success response. To ensure a valid HTTP response, we add the `Content-Length` header which is set to the size of our response body, in this case the size of `hello.html`.\n\nRun this code with `cargo run` and load _127.0.0.1:7878_ in your browser; you should see your HTML rendered!\n\nCurrently, we’re ignoring the request data in `http_request` and just sending back the contents of the HTML file unconditionally. That means if you try requesting _127.0.0.1:7878/something-else_ in your browser, you’ll still get back this same HTML response. At the moment, our server is very limited and does not do what most web servers do. We want to customize our responses depending on the request and only send back the HTML file for a well-formed request to _/_.\n\n### [Validating the Request and Selectively Responding](#validating-the-request-and-selectively-responding)\n\nRight now, our web server will return the HTML in the file no matter what the client requested. Let’s add functionality to check that the browser is requesting _/_ before returning the HTML file and return an error if the browser requests anything else. For this we need to modify `handle_connection`, as shown in Listing 20-6. This new code checks the content of the request received against what we know a request for _/_ looks like and adds `if` and `else` blocks to treat requests differently.\n\nFilename: src/main.rs\n\n```rust\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        // some other request\n    }\n}\n```\n\nListing 20-6: Handling requests to _/_ differently from other requests\n\nWe’re only going to be looking at the first line of the HTTP request, so rather than reading the entire request into a vector, we’re calling `next` to get the first item from the iterator. The first `unwrap` takes care of the `Option` and stops the program if the iterator has no items. The second `unwrap` handles the `Result` and has the same effect as the `unwrap` that was in the `map` added in Listing 20-2.\n\nNext, we check the `request_line` to see if it equals the request line of a GET request to the _/_ path. If it does, the `if` block returns the contents of our HTML file.\n\nIf the `request_line` does _not_ equal the GET request to the _/_ path, it means we’ve received some other request. We’ll add code to the `else` block in a moment to respond to all other requests.\n\nRun this code now and request _127.0.0.1:7878_; you should get the HTML in _hello.html_. If you make any other request, such as _127.0.0.1:7878/something-else_, you’ll get a connection error like those you saw when running the code in Listing 20-1 and Listing 20-2.\n\nNow let’s add the code in Listing 20-7 to the `else` block to return a response with the status code 404, which signals that the content for the request was not found. We’ll also return some HTML for a page to render in the browser indicating the response to the end user.\n\nFilename: src/main.rs\n\n```rust\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    // --snip--\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n}\n```\n\nListing 20-7: Responding with status code 404 and an error page if anything other than _/_ was requested\n\nHere, our response has a status line with status code 404 and the reason phrase `NOT FOUND`. The body of the response will be the HTML in the file _404.html_. You’ll need to create a _404.html_ file next to _hello.html_ for the error page; again feel free to use any HTML you want or use the example HTML in Listing 20-8.\n\nFilename: 404.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>Oops!</h1>\n    <p>Sorry, I don't know what you're asking for.</p>\n  </body>\n</html>\n\n```\n\nListing 20-8: Sample content for the page to send back with any 404 response\n\nWith these changes, run your server again. Requesting _127.0.0.1:7878_ should return the contents of _hello.html_, and any other request, like _127.0.0.1:7878/foo_, should return the error HTML from _404.html_.\n\n### [A Touch of Refactoring](#a-touch-of-refactoring)\n\nAt the moment the `if` and `else` blocks have a lot of repetition: they’re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let’s make the code more concise by pulling out those differences into separate `if` and `else` lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large `if` and `else` blocks.\n\nFilename: src/main.rs\n\n```rust\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    // --snip--\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    let (status_line, filename) = if request_line == \"GET / HTTP/1.1\" {\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\nListing 20-9: Refactoring the `if` and `else` blocks to contain only the code that differs between the two cases\n\nNow the `if` and `else` blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to `status_line` and `filename` using a pattern in the `let` statement, as discussed in Chapter 18.\n\nThe previously duplicated code is now outside the `if` and `else` blocks and uses the `status_line` and `filename` variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 20-9 will be the same as that in Listing 20-7.\n\nAwesome! We now have a simple web server in approximately 40 lines of Rust code that responds to one request with a page of content and responds to all other requests with a 404 response.\n\nCurrently, our server runs in a single thread, meaning it can only serve one request at a time. Let’s examine how that can be a problem by simulating some slow requests. Then we’ll fix it so our server can handle multiple requests at once.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Building a Single-Threaded Web Server - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"building-a-single-threaded-web-server\"><a class=\"header\" href=\"#building-a-single-threaded-web-server\">Building a Single-Threaded Web Server</a></h2>\n<p>We’ll start by getting a single-threaded web server working. Before we begin,\nlet’s look at a quick overview of the protocols involved in building web\nservers. The details of these protocols are beyond the scope of this book, but\na brief overview will give you the information you need.</p>\n<p>The two main protocols involved in web servers are <em>Hypertext Transfer\nProtocol</em> <em>(HTTP)</em> and <em>Transmission Control Protocol</em> <em>(TCP)</em>. Both protocols\nare <em>request-response</em> protocols, meaning a <em>client</em> initiates requests and a\n<em>server</em> listens to the requests and provides a response to the client. The\ncontents of those requests and responses are defined by the protocols.</p>\n<p>TCP is the lower-level protocol that describes the details of how information\ngets from one server to another but doesn’t specify what that information is.\nHTTP builds on top of TCP by defining the contents of the requests and\nresponses. It’s technically possible to use HTTP with other protocols, but in\nthe vast majority of cases, HTTP sends its data over TCP. We’ll work with the\nraw bytes of TCP and HTTP requests and responses.</p>\n<h3 id=\"listening-to-the-tcp-connection\"><a class=\"header\" href=\"#listening-to-the-tcp-connection\">Listening to the TCP Connection</a></h3>\n<p>Our web server needs to listen to a TCP connection, so that’s the first part\nwe’ll work on. The standard library offers a <code class=\"hljs\">std::net</code> module that lets us do\nthis. Let’s make a new project in the usual fashion:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo new hello</span>\n     Created binary (application) `hello` project\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> <span class=\"hljs-built_in\">cd</span> hello</span>\n</code></pre>\n<p>Now enter the code in Listing 20-1 in <em>src/main.rs</em> to start. This code will\nlisten at the local address <code class=\"hljs\">127.0.0.1:7878</code> for incoming TCP streams. When it\ngets an incoming stream, it will print <code class=\"hljs\">Connection established!</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust no_run hljs\"><span class=\"hljs-keyword\">use</span> std::net::TcpListener;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(<span class=\"hljs-string\">\"127.0.0.1:7878\"</span>).unwrap();\n\n    <span class=\"hljs-keyword\">for</span> stream <span class=\"hljs-keyword\">in</span> listener.incoming() {\n        <span class=\"hljs-keyword\">let</span> stream = stream.unwrap();\n\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Connection established!\"</span>);\n    }\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 20-1: Listening for incoming streams and printing\na message when we receive a stream</span></p>\n<p>Using <code class=\"hljs\">TcpListener</code>, we can listen for TCP connections at the address\n<code class=\"hljs\">127.0.0.1:7878</code>. In the address, the section before the colon is an IP address\nrepresenting your computer (this is the same on every computer and doesn’t\nrepresent the authors’ computer specifically), and <code class=\"hljs\">7878</code> is the port. We’ve\nchosen this port for two reasons: HTTP isn’t normally accepted on this port so\nour server is unlikely to conflict with any other web server you might have\nrunning on your machine, and 7878 is <em>rust</em> typed on a telephone.</p>\n<p>The <code class=\"hljs\">bind</code> function in this scenario works like the <code class=\"hljs\">new</code> function in that it\nwill return a new <code class=\"hljs\">TcpListener</code> instance. The function is called <code class=\"hljs\">bind</code>\nbecause, in networking, connecting to a port to listen to is known as “binding\nto a port.”</p>\n<p>The <code class=\"hljs\">bind</code> function returns a <code class=\"hljs\">Result&lt;T, E&gt;</code>, which indicates that it’s\npossible for binding to fail. For example, connecting to port 80 requires\nadministrator privileges (nonadministrators can listen only on ports higher\nthan 1023), so if we tried to connect to port 80 without being an\nadministrator, binding wouldn’t work. Binding also wouldn’t work, for example,\nif we ran two instances of our program and so had two programs listening to the\nsame port. Because we’re writing a basic server just for learning purposes, we\nwon’t worry about handling these kinds of errors; instead, we use <code class=\"hljs\">unwrap</code> to\nstop the program if errors happen.</p>\n<p>The <code class=\"hljs\">incoming</code> method on <code class=\"hljs\">TcpListener</code> returns an iterator that gives us a\nsequence of streams (more specifically, streams of type <code class=\"hljs\">TcpStream</code>). A single\n<em>stream</em> represents an open connection between the client and the server. A\n<em>connection</em> is the name for the full request and response process in which a\nclient connects to the server, the server generates a response, and the server\ncloses the connection. As such, we will read from the <code class=\"hljs\">TcpStream</code> to see what\nthe client sent and then write our response to the stream to send data back to\nthe client. Overall, this <code class=\"hljs\">for</code> loop will process each connection in turn and\nproduce a series of streams for us to handle.</p>\n<p>For now, our handling of the stream consists of calling <code class=\"hljs\">unwrap</code> to terminate\nour program if the stream has any errors; if there aren’t any errors, the\nprogram prints a message. We’ll add more functionality for the success case in\nthe next listing. The reason we might receive errors from the <code class=\"hljs\">incoming</code> method\nwhen a client connects to the server is that we’re not actually iterating over\nconnections. Instead, we’re iterating over <em>connection attempts</em>. The\nconnection might not be successful for a number of reasons, many of them\noperating system specific. For example, many operating systems have a limit to\nthe number of simultaneous open connections they can support; new connection\nattempts beyond that number will produce an error until some of the open\nconnections are closed.</p>\n<p>Let’s try running this code! Invoke <code class=\"hljs\">cargo run</code> in the terminal and then load\n<em>127.0.0.1:7878</em> in a web browser. The browser should show an error message\nlike “Connection reset,” because the server isn’t currently sending back any\ndata. But when you look at your terminal, you should see several messages that\nwere printed when the browser connected to the server!</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">     Running `target/debug/hello`\nConnection established!\nConnection established!\nConnection established!\n</code></pre>\n<p>Sometimes, you’ll see multiple messages printed for one browser request; the\nreason might be that the browser is making a request for the page as well as a\nrequest for other resources, like the <em>favicon.ico</em> icon that appears in the\nbrowser tab.</p>\n<p>It could also be that the browser is trying to connect to the server multiple\ntimes because the server isn’t responding with any data. When <code class=\"hljs\">stream</code> goes out\nof scope and is dropped at the end of the loop, the connection is closed as\npart of the <code class=\"hljs\">drop</code> implementation. Browsers sometimes deal with closed\nconnections by retrying, because the problem might be temporary. The important\nfactor is that we’ve successfully gotten a handle to a TCP connection!</p>\n<p>Remember to stop the program by pressing <kbd>ctrl</kbd>-<kbd>c</kbd> when\nyou’re done running a particular version of the code. Then restart the program\nby invoking the <code class=\"hljs\">cargo run</code> command after you’ve made each set of code changes\nto make sure you’re running the newest code.</p>\n<h3 id=\"reading-the-request\"><a class=\"header\" href=\"#reading-the-request\">Reading the Request</a></h3>\n<p>Let’s implement the functionality to read the request from the browser! To\nseparate the concerns of first getting a connection and then taking some action\nwith the connection, we’ll start a new function for processing connections. In\nthis new <code class=\"hljs\">handle_connection</code> function, we’ll read data from the TCP stream and\nprint it so we can see the data being sent from the browser. Change the code to\nlook like Listing 20-2.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust no_run hljs\"><span class=\"hljs-keyword\">use</span> std::{\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(<span class=\"hljs-string\">\"127.0.0.1:7878\"</span>).unwrap();\n\n    <span class=\"hljs-keyword\">for</span> stream <span class=\"hljs-keyword\">in</span> listener.incoming() {\n        <span class=\"hljs-keyword\">let</span> stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">handle_connection</span></span>(<span class=\"hljs-keyword\">mut</span> stream: TcpStream) {\n    <span class=\"hljs-keyword\">let</span> buf_reader = BufReader::new(&amp;<span class=\"hljs-keyword\">mut</span> stream);\n    <span class=\"hljs-keyword\">let</span> http_request: <span class=\"hljs-built_in\">Vec</span>&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Request: {http_request:#?}\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 20-2: Reading from the <code class=\"hljs\">TcpStream</code> and printing\nthe data</span></p>\n<p>We bring <code class=\"hljs\">std::io::prelude</code> and <code class=\"hljs\">std::io::BufReader</code> into scope to get access\nto traits and types that let us read from and write to the stream. In the <code class=\"hljs\">for</code>\nloop in the <code class=\"hljs\">main</code> function, instead of printing a message that says we made a\nconnection, we now call the new <code class=\"hljs\">handle_connection</code> function and pass the\n<code class=\"hljs\">stream</code> to it.</p>\n<p>In the <code class=\"hljs\">handle_connection</code> function, we create a new <code class=\"hljs\">BufReader</code> instance that\nwraps a mutable reference to the <code class=\"hljs\">stream</code>. <code class=\"hljs\">BufReader</code> adds buffering by\nmanaging calls to the <code class=\"hljs\">std::io::Read</code> trait methods for us.</p>\n<p>We create a variable named <code class=\"hljs\">http_request</code> to collect the lines of the request\nthe browser sends to our server. We indicate that we want to collect these\nlines in a vector by adding the <code class=\"hljs\">Vec&lt;_&gt;</code> type annotation.</p>\n<p><code class=\"hljs\">BufReader</code> implements the <code class=\"hljs\">std::io::BufRead</code> trait, which provides the <code class=\"hljs\">lines</code>\nmethod. The <code class=\"hljs\">lines</code> method returns an iterator of <code class=\"hljs\">Result&lt;String, std::io::Error&gt;</code> by splitting the stream of data whenever it sees a newline\nbyte. To get each <code class=\"hljs\">String</code>, we map and <code class=\"hljs\">unwrap</code> each <code class=\"hljs\">Result</code>. The <code class=\"hljs\">Result</code>\nmight be an error if the data isn’t valid UTF-8 or if there was a problem\nreading from the stream. Again, a production program should handle these errors\nmore gracefully, but we’re choosing to stop the program in the error case for\nsimplicity.</p>\n<p>The browser signals the end of an HTTP request by sending two newline\ncharacters in a row, so to get one request from the stream, we take lines until\nwe get a line that is the empty string. Once we’ve collected the lines into the\nvector, we’re printing them out using pretty debug formatting so we can take a\nlook at the instructions the web browser is sending to our server.</p>\n<p>Let’s try this code! Start the program and make a request in a web browser\nagain. Note that we’ll still get an error page in the browser, but our\nprogram’s output in the terminal will now look similar to this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running `target/debug/hello`\nRequest: [\n    \"GET / HTTP/1.1\",\n    \"Host: 127.0.0.1:7878\",\n    \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0\",\n    \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n    \"Accept-Language: en-US,en;q=0.5\",\n    \"Accept-Encoding: gzip, deflate, br\",\n    \"DNT: 1\",\n    \"Connection: keep-alive\",\n    \"Upgrade-Insecure-Requests: 1\",\n    \"Sec-Fetch-Dest: document\",\n    \"Sec-Fetch-Mode: navigate\",\n    \"Sec-Fetch-Site: none\",\n    \"Sec-Fetch-User: ?1\",\n    \"Cache-Control: max-age=0\",\n]\n</code></pre>\n<p>Depending on your browser, you might get slightly different output. Now that\nwe’re printing the request data, we can see why we get multiple connections\nfrom one browser request by looking at the path after <code class=\"hljs\">GET</code> in the first line\nof the request. If the repeated connections are all requesting <em>/</em>, we know the\nbrowser is trying to fetch <em>/</em> repeatedly because it’s not getting a response\nfrom our program.</p>\n<p>Let’s break down this request data to understand what the browser is asking of\nour program.</p>\n<h3 id=\"a-closer-look-at-an-http-request\"><a class=\"header\" href=\"#a-closer-look-at-an-http-request\">A Closer Look at an HTTP Request</a></h3>\n<p>HTTP is a text-based protocol, and a request takes this format:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">Method Request-URI HTTP-Version CRLF\nheaders CRLF\nmessage-body\n</code></pre>\n<p>The first line is the <em>request line</em> that holds information about what the\nclient is requesting. The first part of the request line indicates the <em>method</em>\nbeing used, such as <code class=\"hljs\">GET</code> or <code class=\"hljs\">POST</code>, which describes how the client is making\nthis request. Our client used a <code class=\"hljs\">GET</code> request, which means it is asking for\ninformation.</p>\n<p>The next part of the request line is <em>/</em>, which indicates the <em>Uniform Resource\nIdentifier</em> <em>(URI)</em> the client is requesting: a URI is almost, but not quite,\nthe same as a <em>Uniform Resource Locator</em> <em>(URL)</em>. The difference between URIs\nand URLs isn’t important for our purposes in this chapter, but the HTTP spec\nuses the term URI, so we can just mentally substitute URL for URI here.</p>\n<p>The last part is the HTTP version the client uses, and then the request line\nends in a <em>CRLF sequence</em>. (CRLF stands for <em>carriage return</em> and <em>line feed</em>,\nwhich are terms from the typewriter days!) The CRLF sequence can also be\nwritten as <code class=\"hljs\">\\r\\n</code>, where <code class=\"hljs\">\\r</code> is a carriage return and <code class=\"hljs\">\\n</code> is a line feed. The\nCRLF sequence separates the request line from the rest of the request data.\nNote that when the CRLF is printed, we see a new line start rather than <code class=\"hljs\">\\r\\n</code>.</p>\n<p>Looking at the request line data we received from running our program so far,\nwe see that <code class=\"hljs\">GET</code> is the method, <em>/</em> is the request URI, and <code class=\"hljs\">HTTP/1.1</code> is the\nversion.</p>\n<p>After the request line, the remaining lines starting from <code class=\"hljs\">Host:</code> onward are\nheaders. <code class=\"hljs\">GET</code> requests have no body.</p>\n<p>Try making a request from a different browser or asking for a different\naddress, such as <em>127.0.0.1:7878/test</em>, to see how the request data changes.</p>\n<p>Now that we know what the browser is asking for, let’s send back some data!</p>\n<h3 id=\"writing-a-response\"><a class=\"header\" href=\"#writing-a-response\">Writing a Response</a></h3>\n<p>We’re going to implement sending data in response to a client request.\nResponses have the following format:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">HTTP-Version Status-Code Reason-Phrase CRLF\nheaders CRLF\nmessage-body\n</code></pre>\n<p>The first line is a <em>status line</em> that contains the HTTP version used in the\nresponse, a numeric status code that summarizes the result of the request, and\na reason phrase that provides a text description of the status code. After the\nCRLF sequence are any headers, another CRLF sequence, and the body of the\nresponse.</p>\n<p>Here is an example response that uses HTTP version 1.1, has a status code of\n200, an OK reason phrase, no headers, and no body:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">HTTP/1.1 200 OK\\r\\n\\r\\n\n</code></pre>\n<p>The status code 200 is the standard success response. The text is a tiny\nsuccessful HTTP response. Let’s write this to the stream as our response to a\nsuccessful request! From the <code class=\"hljs\">handle_connection</code> function, remove the\n<code class=\"hljs\">println!</code> that was printing the request data and replace it with the code in\nListing 20-3.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust no_run hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    io::{prelude::*, BufReader},\n</span><span class=\"boring\">    net::{TcpListener, TcpStream},\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(<span class=\"hljs-string\">\"127.0.0.1:7878\"</span>).unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">for</span> stream <span class=\"hljs-keyword\">in</span> listener.incoming() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> stream = stream.unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        handle_connection(stream);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">handle_connection</span></span>(<span class=\"hljs-keyword\">mut</span> stream: TcpStream) {\n    <span class=\"hljs-keyword\">let</span> buf_reader = BufReader::new(&amp;<span class=\"hljs-keyword\">mut</span> stream);\n    <span class=\"hljs-keyword\">let</span> http_request: <span class=\"hljs-built_in\">Vec</span>&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    <span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-string\">\"HTTP/1.1 200 OK\\r\\n\\r\\n\"</span>;\n\n    stream.write_all(response.as_bytes()).unwrap();\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 20-3: Writing a tiny successful HTTP response to\nthe stream</span></p>\n<p>The first new line defines the <code class=\"hljs\">response</code> variable that holds the success\nmessage’s data. Then we call <code class=\"hljs\">as_bytes</code> on our <code class=\"hljs\">response</code> to convert the string\ndata to bytes. The <code class=\"hljs\">write_all</code> method on <code class=\"hljs\">stream</code> takes a <code class=\"hljs\">&amp;[u8]</code> and sends\nthose bytes directly down the connection. Because the <code class=\"hljs\">write_all</code> operation\ncould fail, we use <code class=\"hljs\">unwrap</code> on any error result as before. Again, in a real\napplication you would add error handling here.</p>\n<p>With these changes, let’s run our code and make a request. We’re no longer\nprinting any data to the terminal, so we won’t see any output other than the\noutput from Cargo. When you load <em>127.0.0.1:7878</em> in a web browser, you should\nget a blank page instead of an error. You’ve just hand-coded receiving an HTTP\nrequest and sending a response!</p>\n<h3 id=\"returning-real-html\"><a class=\"header\" href=\"#returning-real-html\">Returning Real HTML</a></h3>\n<p>Let’s implement the functionality for returning more than a blank page. Create\nthe new file <em>hello.html</em> in the root of your project directory, not in the\n<em>src</em> directory. You can input any HTML you want; Listing 20-4 shows one\npossibility.</p>\n<p><span class=\"filename\">Filename: hello.html</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-html hljs xml\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hi from Rust<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p><span class=\"caption\">Listing 20-4: A sample HTML file to return in a\nresponse</span></p>\n<p>This is a minimal HTML5 document with a heading and some text. To return this\nfrom the server when a request is received, we’ll modify <code class=\"hljs\">handle_connection</code> as\nshown in Listing 20-5 to read the HTML file, add it to the response as a body,\nand send it.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust no_run hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n<span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(<span class=\"hljs-string\">\"127.0.0.1:7878\"</span>).unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">for</span> stream <span class=\"hljs-keyword\">in</span> listener.incoming() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> stream = stream.unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        handle_connection(stream);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">handle_connection</span></span>(<span class=\"hljs-keyword\">mut</span> stream: TcpStream) {\n    <span class=\"hljs-keyword\">let</span> buf_reader = BufReader::new(&amp;<span class=\"hljs-keyword\">mut</span> stream);\n    <span class=\"hljs-keyword\">let</span> http_request: <span class=\"hljs-built_in\">Vec</span>&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    <span class=\"hljs-keyword\">let</span> status_line = <span class=\"hljs-string\">\"HTTP/1.1 200 OK\"</span>;\n    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(<span class=\"hljs-string\">\"hello.html\"</span>).unwrap();\n    <span class=\"hljs-keyword\">let</span> length = contents.len();\n\n    <span class=\"hljs-keyword\">let</span> response =\n        <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"</span>);\n\n    stream.write_all(response.as_bytes()).unwrap();\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 20-5: Sending the contents of <em>hello.html</em> as the\nbody of the response</span></p>\n<p>We’ve added <code class=\"hljs\">fs</code> to the <code class=\"hljs\">use</code> statement to bring the standard library’s\nfilesystem module into scope. The code for reading the contents of a file to a\nstring should look familiar; we used it in Chapter 12 when we read the contents\nof a file for our I/O project in Listing 12-4.</p>\n<p>Next, we use <code class=\"hljs\">format!</code> to add the file’s contents as the body of the success\nresponse. To ensure a valid HTTP response, we add the <code class=\"hljs\">Content-Length</code> header\nwhich is set to the size of our response body, in this case the size of\n<code class=\"hljs\">hello.html</code>.</p>\n<p>Run this code with <code class=\"hljs\">cargo run</code> and load <em>127.0.0.1:7878</em> in your browser; you\nshould see your HTML rendered!</p>\n<p>Currently, we’re ignoring the request data in <code class=\"hljs\">http_request</code> and just sending\nback the contents of the HTML file unconditionally. That means if you try\nrequesting <em>127.0.0.1:7878/something-else</em> in your browser, you’ll still get\nback this same HTML response. At the moment, our server is very limited and\ndoes not do what most web servers do. We want to customize our responses\ndepending on the request and only send back the HTML file for a well-formed\nrequest to <em>/</em>.</p>\n<h3 id=\"validating-the-request-and-selectively-responding\"><a class=\"header\" href=\"#validating-the-request-and-selectively-responding\">Validating the Request and Selectively Responding</a></h3>\n<p>Right now, our web server will return the HTML in the file no matter what the\nclient requested. Let’s add functionality to check that the browser is\nrequesting <em>/</em> before returning the HTML file and return an error if the\nbrowser requests anything else. For this we need to modify <code class=\"hljs\">handle_connection</code>,\nas shown in Listing 20-6. This new code checks the content of the request\nreceived against what we know a request for <em>/</em> looks like and adds <code class=\"hljs\">if</code> and\n<code class=\"hljs\">else</code> blocks to treat requests differently.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust no_run hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    fs,\n</span><span class=\"boring\">    io::{prelude::*, BufReader},\n</span><span class=\"boring\">    net::{TcpListener, TcpStream},\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(<span class=\"hljs-string\">\"127.0.0.1:7878\"</span>).unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">for</span> stream <span class=\"hljs-keyword\">in</span> listener.incoming() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> stream = stream.unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        handle_connection(stream);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">handle_connection</span></span>(<span class=\"hljs-keyword\">mut</span> stream: TcpStream) {\n    <span class=\"hljs-keyword\">let</span> buf_reader = BufReader::new(&amp;<span class=\"hljs-keyword\">mut</span> stream);\n    <span class=\"hljs-keyword\">let</span> request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    <span class=\"hljs-keyword\">if</span> request_line == <span class=\"hljs-string\">\"GET / HTTP/1.1\"</span> {\n        <span class=\"hljs-keyword\">let</span> status_line = <span class=\"hljs-string\">\"HTTP/1.1 200 OK\"</span>;\n        <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(<span class=\"hljs-string\">\"hello.html\"</span>).unwrap();\n        <span class=\"hljs-keyword\">let</span> length = contents.len();\n\n        <span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-built_in\">format!</span>(\n            <span class=\"hljs-string\">\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"</span>\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// some other request</span>\n    }\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 20-6: Handling requests to <em>/</em> differently from\nother requests</span></p>\n<p>We’re only going to be looking at the first line of the HTTP request, so rather\nthan reading the entire request into a vector, we’re calling <code class=\"hljs\">next</code> to get the\nfirst item from the iterator. The first <code class=\"hljs\">unwrap</code> takes care of the <code class=\"hljs\">Option</code> and\nstops the program if the iterator has no items. The second <code class=\"hljs\">unwrap</code> handles the\n<code class=\"hljs\">Result</code> and has the same effect as the <code class=\"hljs\">unwrap</code> that was in the <code class=\"hljs\">map</code> added in\nListing 20-2.</p>\n<p>Next, we check the <code class=\"hljs\">request_line</code> to see if it equals the request line of a GET\nrequest to the <em>/</em> path. If it does, the <code class=\"hljs\">if</code> block returns the contents of our\nHTML file.</p>\n<p>If the <code class=\"hljs\">request_line</code> does <em>not</em> equal the GET request to the <em>/</em> path, it\nmeans we’ve received some other request. We’ll add code to the <code class=\"hljs\">else</code> block in\na moment to respond to all other requests.</p>\n<p>Run this code now and request <em>127.0.0.1:7878</em>; you should get the HTML in\n<em>hello.html</em>. If you make any other request, such as\n<em>127.0.0.1:7878/something-else</em>, you’ll get a connection error like those you\nsaw when running the code in Listing 20-1 and Listing 20-2.</p>\n<p>Now let’s add the code in Listing 20-7 to the <code class=\"hljs\">else</code> block to return a response\nwith the status code 404, which signals that the content for the request was\nnot found. We’ll also return some HTML for a page to render in the browser\nindicating the response to the end user.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust no_run hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    fs,\n</span><span class=\"boring\">    io::{prelude::*, BufReader},\n</span><span class=\"boring\">    net::{TcpListener, TcpStream},\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(<span class=\"hljs-string\">\"127.0.0.1:7878\"</span>).unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">for</span> stream <span class=\"hljs-keyword\">in</span> listener.incoming() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> stream = stream.unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        handle_connection(stream);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">handle_connection</span></span>(<span class=\"hljs-keyword\">mut</span> stream: TcpStream) {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> buf_reader = BufReader::new(&amp;<span class=\"hljs-keyword\">mut</span> stream);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> request_line = buf_reader.lines().next().unwrap().unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">if</span> request_line == <span class=\"hljs-string\">\"GET / HTTP/1.1\"</span> {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> status_line = <span class=\"hljs-string\">\"HTTP/1.1 200 OK\"</span>;\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(<span class=\"hljs-string\">\"hello.html\"</span>).unwrap();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> length = contents.len();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-built_in\">format!</span>(\n</span><span class=\"boring\">            <span class=\"hljs-string\">\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"</span>\n</span><span class=\"boring\">        );\n</span><span class=\"boring\">\n</span><span class=\"boring\">        stream.write_all(response.as_bytes()).unwrap();\n</span>    <span class=\"hljs-comment\">// --snip--</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">let</span> status_line = <span class=\"hljs-string\">\"HTTP/1.1 404 NOT FOUND\"</span>;\n        <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(<span class=\"hljs-string\">\"404.html\"</span>).unwrap();\n        <span class=\"hljs-keyword\">let</span> length = contents.len();\n\n        <span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-built_in\">format!</span>(\n            <span class=\"hljs-string\">\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"</span>\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 20-7: Responding with status code 404 and an\nerror page if anything other than <em>/</em> was requested</span></p>\n<p>Here, our response has a status line with status code 404 and the reason phrase\n<code class=\"hljs\">NOT FOUND</code>. The body of the response will be the HTML in the file <em>404.html</em>.\nYou’ll need to create a <em>404.html</em> file next to <em>hello.html</em> for the error\npage; again feel free to use any HTML you want or use the example HTML in\nListing 20-8.</p>\n<p><span class=\"filename\">Filename: 404.html</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-html hljs xml\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Oops!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Sorry, I don't know what you're asking for.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p><span class=\"caption\">Listing 20-8: Sample content for the page to send back\nwith any 404 response</span></p>\n<p>With these changes, run your server again. Requesting <em>127.0.0.1:7878</em> should\nreturn the contents of <em>hello.html</em>, and any other request, like\n<em>127.0.0.1:7878/foo</em>, should return the error HTML from <em>404.html</em>.</p>\n<h3 id=\"a-touch-of-refactoring\"><a class=\"header\" href=\"#a-touch-of-refactoring\">A Touch of Refactoring</a></h3>\n<p>At the moment the <code class=\"hljs\">if</code> and <code class=\"hljs\">else</code> blocks have a lot of repetition: they’re both\nreading files and writing the contents of the files to the stream. The only\ndifferences are the status line and the filename. Let’s make the code more\nconcise by pulling out those differences into separate <code class=\"hljs\">if</code> and <code class=\"hljs\">else</code> lines\nthat will assign the values of the status line and the filename to variables;\nwe can then use those variables unconditionally in the code to read the file\nand write the response. Listing 20-9 shows the resulting code after replacing\nthe large <code class=\"hljs\">if</code> and <code class=\"hljs\">else</code> blocks.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust no_run hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    fs,\n</span><span class=\"boring\">    io::{prelude::*, BufReader},\n</span><span class=\"boring\">    net::{TcpListener, TcpStream},\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(<span class=\"hljs-string\">\"127.0.0.1:7878\"</span>).unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">for</span> stream <span class=\"hljs-keyword\">in</span> listener.incoming() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> stream = stream.unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        handle_connection(stream);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">handle_connection</span></span>(<span class=\"hljs-keyword\">mut</span> stream: TcpStream) {\n    <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">    <span class=\"hljs-keyword\">let</span> buf_reader = BufReader::new(&amp;<span class=\"hljs-keyword\">mut</span> stream);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> request_line = buf_reader.lines().next().unwrap().unwrap();\n</span>\n    <span class=\"hljs-keyword\">let</span> (status_line, filename) = <span class=\"hljs-keyword\">if</span> request_line == <span class=\"hljs-string\">\"GET / HTTP/1.1\"</span> {\n        (<span class=\"hljs-string\">\"HTTP/1.1 200 OK\"</span>, <span class=\"hljs-string\">\"hello.html\"</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        (<span class=\"hljs-string\">\"HTTP/1.1 404 NOT FOUND\"</span>, <span class=\"hljs-string\">\"404.html\"</span>)\n    };\n\n    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(filename).unwrap();\n    <span class=\"hljs-keyword\">let</span> length = contents.len();\n\n    <span class=\"hljs-keyword\">let</span> response =\n        <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"</span>);\n\n    stream.write_all(response.as_bytes()).unwrap();\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 20-9: Refactoring the <code class=\"hljs\">if</code> and <code class=\"hljs\">else</code> blocks to\ncontain only the code that differs between the two cases</span></p>\n<p>Now the <code class=\"hljs\">if</code> and <code class=\"hljs\">else</code> blocks only return the appropriate values for the\nstatus line and filename in a tuple; we then use destructuring to assign these\ntwo values to <code class=\"hljs\">status_line</code> and <code class=\"hljs\">filename</code> using a pattern in the <code class=\"hljs\">let</code>\nstatement, as discussed in Chapter 18.</p>\n<p>The previously duplicated code is now outside the <code class=\"hljs\">if</code> and <code class=\"hljs\">else</code> blocks and\nuses the <code class=\"hljs\">status_line</code> and <code class=\"hljs\">filename</code> variables. This makes it easier to see\nthe difference between the two cases, and it means we have only one place to\nupdate the code if we want to change how the file reading and response writing\nwork. The behavior of the code in Listing 20-9 will be the same as that in\nListing 20-7.</p>\n<p>Awesome! We now have a simple web server in approximately 40 lines of Rust code\nthat responds to one request with a page of content and responds to all other\nrequests with a 404 response.</p>\n<p>Currently, our server runs in a single thread, meaning it can only serve one\nrequest at a time. Let’s examine how that can be a problem by simulating some\nslow requests. Then we’ll fix it so our server can handle multiple requests at\nonce.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch20-00-final-project-a-web-server.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch20-02-multithreaded.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch20-00-final-project-a-web-server.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch20-02-multithreaded.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:34.567Z"
}