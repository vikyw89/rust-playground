{
	"title": "core::arch - Rust",
	"url": "https://doc.rust-lang.org/1.80.0/core/arch/index.html",
	"markdown": "# core::arch - Rust\n\n## Module [core](../index.html)::[arch](#)\n\n1.27.0 · [source](about:blank/src/core/arch.rs.html#1-31) ·\n\nExpand description\n\nSIMD and vendor intrinsics module.\n\nThis module is intended to be the gateway to architecture-specific intrinsic functions, typically related to SIMD (but not always!). Each architecture that Rust compiles to may contain a submodule here, which means that this is not a portable module! If you’re writing a portable library take care when using these APIs!\n\nUnder this module you’ll find an architecture-named module, such as `x86_64`. Each `#[cfg(target_arch)]` that Rust can compile to may have a module entry here, only present on that particular target. For example the `i686-pc-windows-msvc` target will have an `x86` module here, whereas `x86_64-pc-windows-msvc` has `x86_64`.\n\n## [§](#overview)Overview\n\nThis module exposes vendor-specific intrinsics that typically correspond to a single machine instruction. These intrinsics are not portable: their availability is architecture-dependent, and not all machines of that architecture might provide the intrinsic.\n\nThe `arch` module is intended to be a low-level implementation detail for higher-level APIs. Using it correctly can be quite tricky as you need to ensure at least a few guarantees are upheld:\n\n-   The correct architecture’s module is used. For example the `arm` module isn’t available on the `x86_64-unknown-linux-gnu` target. This is typically done by ensuring that `#[cfg]` is used appropriately when using this module.\n-   The CPU the program is currently running on supports the function being called. For example it is unsafe to call an AVX2 function on a CPU that doesn’t actually support AVX2.\n\nAs a result of the latter of these guarantees all intrinsics in this module are `unsafe` and extra care needs to be taken when calling them!\n\n## [§](#cpu-feature-detection)CPU Feature Detection\n\nIn order to call these APIs in a safe fashion there’s a number of mechanisms available to ensure that the correct CPU feature is available to call an intrinsic. Let’s consider, for example, the `_mm256_add_epi64` intrinsics on the `x86` and `x86_64` architectures. This function requires the AVX2 feature as [documented by Intel](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_add_epi64&expand=100) so to correctly call this function we need to (a) guarantee we only call it on `x86`/`x86_64` and (b) ensure that the CPU feature is available\n\n### [§](#static-cpu-feature-detection)Static CPU Feature Detection\n\nThe first option available to us is to conditionally compile code via the `#[cfg]` attribute. CPU features correspond to the `target_feature` cfg available, and can be used like so:\n\n[ⓘ](# \"This example is not tested\")\n\n```\n#[cfg(\n    all(\n        any(target_arch = \"x86\", target_arch = \"x86_64\"),\n        target_feature = \"avx2\"\n    )\n)]\nfn foo() {\n    #[cfg(target_arch = \"x86\")]\n    use std::arch::x86::_mm256_add_epi64;\n    #[cfg(target_arch = \"x86_64\")]\n    use std::arch::x86_64::_mm256_add_epi64;\n\n    unsafe {\n        _mm256_add_epi64(...);\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(%0A++++++++all(%0A++++++++++++any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22),%0A++++++++++++target_feature+=+%22avx2%22%0A++++++++)%0A++++)%5D%0A++++fn+foo()+%7B%0A++++++++%23%5Bcfg(target_arch+=+%22x86%22)%5D%0A++++++++use+std::arch::x86::_mm256_add_epi64;%0A++++++++%23%5Bcfg(target_arch+=+%22x86_64%22)%5D%0A++++++++use+std::arch::x86_64::_mm256_add_epi64;%0A++++%0A++++++++unsafe+%7B%0A++++++++++++_mm256_add_epi64(...);%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\nHere we’re using `#[cfg(target_feature = \"avx2\")]` to conditionally compile this function into our module. This means that if the `avx2` feature is _enabled statically_ then we’ll use the `_mm256_add_epi64` function at runtime. The `unsafe` block here can be justified through the usage of `#[cfg]` to only compile the code in situations where the safety guarantees are upheld.\n\nStatically enabling a feature is typically done with the `-C target-feature` or `-C target-cpu` flags to the compiler. For example if your local CPU supports AVX2 then you can compile the above function with:\n\n```sh\n$ RUSTFLAGS='-C target-cpu=native' cargo build\n\n```\n\nOr otherwise you can specifically enable just the AVX2 feature:\n\n```sh\n$ RUSTFLAGS='-C target-feature=+avx2' cargo build\n\n```\n\nNote that when you compile a binary with a particular feature enabled it’s important to ensure that you only run the binary on systems which satisfy the required feature set.\n\n### [§](#dynamic-cpu-feature-detection)Dynamic CPU Feature Detection\n\nSometimes statically dispatching isn’t quite what you want. Instead you might want to build a portable binary that runs across a variety of CPUs, but at runtime it selects the most optimized implementation available. This allows you to build a “least common denominator” binary which has certain sections more optimized for different CPUs.\n\nTaking our previous example from before, we’re going to compile our binary _without_ AVX2 support, but we’d like to enable it for just one function. We can do that in a manner like:\n\n[ⓘ](# \"This example is not tested\")\n\n```\nfn foo() {\n    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        if is_x86_feature_detected!(\"avx2\") {\n            return unsafe { foo_avx2() };\n        }\n    }\n\n    // fallback implementation without using AVX2\n}\n\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n#[target_feature(enable = \"avx2\")]\nunsafe fn foo_avx2() {\n    #[cfg(target_arch = \"x86\")]\n    use std::arch::x86::_mm256_add_epi64;\n    #[cfg(target_arch = \"x86_64\")]\n    use std::arch::x86_64::_mm256_add_epi64;\n\n    _mm256_add_epi64(...);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+foo()+%7B%0A++++++++%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A++++++++%7B%0A++++++++++++if+is_x86_feature_detected!(%22avx2%22)+%7B%0A++++++++++++++++return+unsafe+%7B+foo_avx2()+%7D;%0A++++++++++++%7D%0A++++++++%7D%0A++++%0A++++++++//+fallback+implementation+without+using+AVX2%0A++++%7D%0A++++%0A++++%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A++++%23%5Btarget_feature(enable+=+%22avx2%22)%5D%0A++++unsafe+fn+foo_avx2()+%7B%0A++++++++%23%5Bcfg(target_arch+=+%22x86%22)%5D%0A++++++++use+std::arch::x86::_mm256_add_epi64;%0A++++++++%23%5Bcfg(target_arch+=+%22x86_64%22)%5D%0A++++++++use+std::arch::x86_64::_mm256_add_epi64;%0A++++%0A++++++++_mm256_add_epi64(...);%0A++++%7D%0A%7D&edition=2021)\n\nThere’s a couple of components in play here, so let’s go through them in detail!\n\n-   First up we notice the `is_x86_feature_detected!` macro. Provided by the standard library, this macro will perform necessary runtime detection to determine whether the CPU the program is running on supports the specified feature. In this case the macro will expand to a boolean expression evaluating to whether the local CPU has the AVX2 feature or not.\n    \n    Note that this macro, like the `arch` module, is platform-specific. For example calling `is_x86_feature_detected!(\"avx2\")` on ARM will be a compile time error. To ensure we don’t hit this error a statement level `#[cfg]` is used to only compile usage of the macro on `x86`/`x86_64`.\n    \n-   Next up we see our AVX2-enabled function, `foo_avx2`. This function is decorated with the `#[target_feature]` attribute which enables a CPU feature for just this one function. Using a compiler flag like `-C target-feature=+avx2` will enable AVX2 for the entire program, but using an attribute will only enable it for the one function. Usage of the `#[target_feature]` attribute currently requires the function to also be `unsafe`, as we see here. This is because the function can only be correctly called on systems which have the AVX2 (like the intrinsics themselves).\n    \n\nAnd with all that we should have a working program! This program will run across all machines and it’ll use the optimized AVX2 implementation on machines where support is detected.\n\n## [§](#ergonomics)Ergonomics\n\nIt’s important to note that using the `arch` module is not the easiest thing in the world, so if you’re curious to try it out you may want to brace yourself for some wordiness!\n\nThe primary purpose of this module is to enable stable crates on crates.io to build up much more ergonomic abstractions which end up using SIMD under the hood. Over time these abstractions may also move into the standard library itself, but for now this module is tasked with providing the bare minimum necessary to use vendor intrinsics on stable Rust.\n\n## [§](#other-architectures)Other architectures\n\nThis documentation is only for one particular architecture, you can find others at:\n\n-   [`x86`](../../core/arch/x86/index.html)\n-   [`x86_64`](../../core/arch/x86_64/index.html)\n-   [`arm`](../../core/arch/arm/index.html)\n-   [`aarch64`](../../core/arch/aarch64/index.html)\n-   [`riscv32`](../../core/arch/riscv32/index.html)\n-   [`riscv64`](../../core/arch/riscv64/index.html)\n-   [`mips`](../../core/arch/mips/index.html)\n-   [`mips64`](../../core/arch/mips64/index.html)\n-   [`powerpc`](../../core/arch/powerpc/index.html)\n-   [`powerpc64`](../../core/arch/powerpc64/index.html)\n-   [`nvptx`](../../core/arch/nvptx/index.html)\n-   [`wasm32`](../../core/arch/wasm32/index.html)\n\n## [§](#examples)Examples\n\nFirst let’s take a look at not actually using any intrinsics but instead using LLVM’s auto-vectorization to produce optimized vectorized code for AVX2 and also for the default platform.\n\n```\nfn main() {\n    let mut dst = [0];\n    add_quickly(&[1], &[2], &mut dst);\n    assert_eq!(dst[0], 3);\n}\n\nfn add_quickly(a: &[u8], b: &[u8], c: &mut [u8]) {\n    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        // Note that this `unsafe` block is safe because we're testing\n        // that the `avx2` feature is indeed available on our CPU.\n        if is_x86_feature_detected!(\"avx2\") {\n            return unsafe { add_quickly_avx2(a, b, c) };\n        }\n    }\n\n    add_quickly_fallback(a, b, c)\n}\n\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n#[target_feature(enable = \"avx2\")]\nunsafe fn add_quickly_avx2(a: &[u8], b: &[u8], c: &mut [u8]) {\n    add_quickly_fallback(a, b, c) // the function below is inlined here\n}\n\nfn add_quickly_fallback(a: &[u8], b: &[u8], c: &mut [u8]) {\n    for ((a, b), c) in a.iter().zip(b).zip(c) {\n        *c = *a + *b;\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+dst+=+%5B0%5D;%0A++++add_quickly(%26%5B1%5D,+%26%5B2%5D,+%26mut+dst);%0A++++assert_eq!(dst%5B0%5D,+3);%0A%7D%0A%0Afn+add_quickly(a:+%26%5Bu8%5D,+b:+%26%5Bu8%5D,+c:+%26mut+%5Bu8%5D)+%7B%0A++++%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A++++%7B%0A++++++++//+Note+that+this+%60unsafe%60+block+is+safe+because+we%27re+testing%0A++++++++//+that+the+%60avx2%60+feature+is+indeed+available+on+our+CPU.%0A++++++++if+is_x86_feature_detected!(%22avx2%22)+%7B%0A++++++++++++return+unsafe+%7B+add_quickly_avx2(a,+b,+c)+%7D;%0A++++++++%7D%0A++++%7D%0A%0A++++add_quickly_fallback(a,+b,+c)%0A%7D%0A%0A%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A%23%5Btarget_feature(enable+=+%22avx2%22)%5D%0Aunsafe+fn+add_quickly_avx2(a:+%26%5Bu8%5D,+b:+%26%5Bu8%5D,+c:+%26mut+%5Bu8%5D)+%7B%0A++++add_quickly_fallback(a,+b,+c)+//+the+function+below+is+inlined+here%0A%7D%0A%0Afn+add_quickly_fallback(a:+%26%5Bu8%5D,+b:+%26%5Bu8%5D,+c:+%26mut+%5Bu8%5D)+%7B%0A++++for+((a,+b),+c)+in+a.iter().zip(b).zip(c)+%7B%0A++++++++*c+=+*a+%2B+*b;%0A++++%7D%0A%7D&edition=2021)\n\nNext up let’s take a look at an example of manually using intrinsics. Here we’ll be using SSE4.1 features to implement hex encoding.\n\n```\nfn main() {\n    let mut dst = [0; 32];\n    hex_encode(b\"\\x01\\x02\\x03\", &mut dst);\n    assert_eq!(&dst[..6], b\"010203\");\n\n    let mut src = [0; 16];\n    for i in 0..16 {\n        src[i] = (i + 1) as u8;\n    }\n    hex_encode(&src, &mut dst);\n    assert_eq!(&dst, b\"0102030405060708090a0b0c0d0e0f10\");\n}\n\npub fn hex_encode(src: &[u8], dst: &mut [u8]) {\n    let len = src.len().checked_mul(2).unwrap();\n    assert!(dst.len() >= len);\n\n    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        if is_x86_feature_detected!(\"sse4.1\") {\n            return unsafe { hex_encode_sse41(src, dst) };\n        }\n    }\n\n    hex_encode_fallback(src, dst)\n}\n\n// translated from\n// <https://github.com/Matherunner/bin2hex-sse/blob/master/base16_sse4.cpp>\n#[target_feature(enable = \"sse4.1\")]\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\nunsafe fn hex_encode_sse41(mut src: &[u8], dst: &mut [u8]) {\n    #[cfg(target_arch = \"x86\")]\n    use std::arch::x86::*;\n    #[cfg(target_arch = \"x86_64\")]\n    use std::arch::x86_64::*;\n\n    let ascii_zero = _mm_set1_epi8(b'0' as i8);\n    let nines = _mm_set1_epi8(9);\n    let ascii_a = _mm_set1_epi8((b'a' - 9 - 1) as i8);\n    let and4bits = _mm_set1_epi8(0xf);\n\n    let mut i = 0_isize;\n    while src.len() >= 16 {\n        let invec = _mm_loadu_si128(src.as_ptr() as *const _);\n\n        let masked1 = _mm_and_si128(invec, and4bits);\n        let masked2 = _mm_and_si128(_mm_srli_epi64(invec, 4), and4bits);\n\n        // return 0xff corresponding to the elements > 9, or 0x00 otherwise\n        let cmpmask1 = _mm_cmpgt_epi8(masked1, nines);\n        let cmpmask2 = _mm_cmpgt_epi8(masked2, nines);\n\n        // add '0' or the offset depending on the masks\n        let masked1 = _mm_add_epi8(\n            masked1,\n            _mm_blendv_epi8(ascii_zero, ascii_a, cmpmask1),\n        );\n        let masked2 = _mm_add_epi8(\n            masked2,\n            _mm_blendv_epi8(ascii_zero, ascii_a, cmpmask2),\n        );\n\n        // interleave masked1 and masked2 bytes\n        let res1 = _mm_unpacklo_epi8(masked2, masked1);\n        let res2 = _mm_unpackhi_epi8(masked2, masked1);\n\n        _mm_storeu_si128(dst.as_mut_ptr().offset(i * 2) as *mut _, res1);\n        _mm_storeu_si128(\n            dst.as_mut_ptr().offset(i * 2 + 16) as *mut _,\n            res2,\n        );\n        src = &src[16..];\n        i += 16;\n    }\n\n    let i = i as usize;\n    hex_encode_fallback(src, &mut dst[i * 2..]);\n}\n\nfn hex_encode_fallback(src: &[u8], dst: &mut [u8]) {\n    fn hex(byte: u8) -> u8 {\n        static TABLE: &[u8] = b\"0123456789abcdef\";\n        TABLE[byte as usize]\n    }\n\n    for (byte, slots) in src.iter().zip(dst.chunks_mut(2)) {\n        slots[0] = hex((*byte >> 4) & 0xf);\n        slots[1] = hex(*byte & 0xf);\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+dst+=+%5B0;+32%5D;%0A++++hex_encode(b%22%5Cx01%5Cx02%5Cx03%22,+%26mut+dst);%0A++++assert_eq!(%26dst%5B..6%5D,+b%22010203%22);%0A%0A++++let+mut+src+=+%5B0;+16%5D;%0A++++for+i+in+0..16+%7B%0A++++++++src%5Bi%5D+=+(i+%2B+1)+as+u8;%0A++++%7D%0A++++hex_encode(%26src,+%26mut+dst);%0A++++assert_eq!(%26dst,+b%220102030405060708090a0b0c0d0e0f10%22);%0A%7D%0A%0Apub+fn+hex_encode(src:+%26%5Bu8%5D,+dst:+%26mut+%5Bu8%5D)+%7B%0A++++let+len+=+src.len().checked_mul(2).unwrap();%0A++++assert!(dst.len()+%3E=+len);%0A%0A++++%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A++++%7B%0A++++++++if+is_x86_feature_detected!(%22sse4.1%22)+%7B%0A++++++++++++return+unsafe+%7B+hex_encode_sse41(src,+dst)+%7D;%0A++++++++%7D%0A++++%7D%0A%0A++++hex_encode_fallback(src,+dst)%0A%7D%0A%0A//+translated+from%0A//+%3Chttps://github.com/Matherunner/bin2hex-sse/blob/master/base16_sse4.cpp%3E%0A%23%5Btarget_feature(enable+=+%22sse4.1%22)%5D%0A%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0Aunsafe+fn+hex_encode_sse41(mut+src:+%26%5Bu8%5D,+dst:+%26mut+%5Bu8%5D)+%7B%0A++++%23%5Bcfg(target_arch+=+%22x86%22)%5D%0A++++use+std::arch::x86::*;%0A++++%23%5Bcfg(target_arch+=+%22x86_64%22)%5D%0A++++use+std::arch::x86_64::*;%0A%0A++++let+ascii_zero+=+_mm_set1_epi8(b%270%27+as+i8);%0A++++let+nines+=+_mm_set1_epi8(9);%0A++++let+ascii_a+=+_mm_set1_epi8((b%27a%27+-+9+-+1)+as+i8);%0A++++let+and4bits+=+_mm_set1_epi8(0xf);%0A%0A++++let+mut+i+=+0_isize;%0A++++while+src.len()+%3E=+16+%7B%0A++++++++let+invec+=+_mm_loadu_si128(src.as_ptr()+as+*const+_);%0A%0A++++++++let+masked1+=+_mm_and_si128(invec,+and4bits);%0A++++++++let+masked2+=+_mm_and_si128(_mm_srli_epi64(invec,+4),+and4bits);%0A%0A++++++++//+return+0xff+corresponding+to+the+elements+%3E+9,+or+0x00+otherwise%0A++++++++let+cmpmask1+=+_mm_cmpgt_epi8(masked1,+nines);%0A++++++++let+cmpmask2+=+_mm_cmpgt_epi8(masked2,+nines);%0A%0A++++++++//+add+%270%27+or+the+offset+depending+on+the+masks%0A++++++++let+masked1+=+_mm_add_epi8(%0A++++++++++++masked1,%0A++++++++++++_mm_blendv_epi8(ascii_zero,+ascii_a,+cmpmask1),%0A++++++++);%0A++++++++let+masked2+=+_mm_add_epi8(%0A++++++++++++masked2,%0A++++++++++++_mm_blendv_epi8(ascii_zero,+ascii_a,+cmpmask2),%0A++++++++);%0A%0A++++++++//+interleave+masked1+and+masked2+bytes%0A++++++++let+res1+=+_mm_unpacklo_epi8(masked2,+masked1);%0A++++++++let+res2+=+_mm_unpackhi_epi8(masked2,+masked1);%0A%0A++++++++_mm_storeu_si128(dst.as_mut_ptr().offset(i+*+2)+as+*mut+_,+res1);%0A++++++++_mm_storeu_si128(%0A++++++++++++dst.as_mut_ptr().offset(i+*+2+%2B+16)+as+*mut+_,%0A++++++++++++res2,%0A++++++++);%0A++++++++src+=+%26src%5B16..%5D;%0A++++++++i+%2B=+16;%0A++++%7D%0A%0A++++let+i+=+i+as+usize;%0A++++hex_encode_fallback(src,+%26mut+dst%5Bi+*+2..%5D);%0A%7D%0A%0Afn+hex_encode_fallback(src:+%26%5Bu8%5D,+dst:+%26mut+%5Bu8%5D)+%7B%0A++++fn+hex(byte:+u8)+-%3E+u8+%7B%0A++++++++static+TABLE:+%26%5Bu8%5D+=+b%220123456789abcdef%22;%0A++++++++TABLE%5Bbyte+as+usize%5D%0A++++%7D%0A%0A++++for+(byte,+slots)+in+src.iter().zip(dst.chunks_mut(2))+%7B%0A++++++++slots%5B0%5D+=+hex((*byte+%3E%3E+4)+%26+0xf);%0A++++++++slots%5B1%5D+=+hex(*byte+%26+0xf);%0A++++%7D%0A%7D&edition=2021)\n\n-   [aarch64](aarch64/index.html \"mod core::arch::aarch64\")AArch64 or `target_arch=\"arm64ec\"`\n    \n    Platform-specific intrinsics for the `aarch64` platform.\n    \n-   Platform-specific intrinsics for the `wasm32` platform.\n    \n-   Platform-specific intrinsics for the `x86` platform.\n    \n-   Platform-specific intrinsics for the `x86_64` platform.\n    \n-   [arm](arm/index.html \"mod core::arch::arm\")ExperimentalARM\n    \n    Platform-specific intrinsics for the `arm` platform.\n    \n-   Platform-specific intrinsics for the `loongarch` platform.\n    \n-   [mips](mips/index.html \"mod core::arch::mips\")ExperimentalMIPS\n    \n    Platform-specific intrinsics for the `mips` platform.\n    \n-   [mips64](mips64/index.html \"mod core::arch::mips64\")ExperimentalMIPS-64\n    \n    Platform-specific intrinsics for the `mips64` platform.\n    \n-   [nvptx](nvptx/index.html \"mod core::arch::nvptx\")Experimental`target_arch=\"nvptx64\"`\n    \n    Platform-specific intrinsics for the `NVPTX` platform.\n    \n-   Platform-specific intrinsics for the `PowerPC` platform.\n    \n-   Platform-specific intrinsics for the `PowerPC64` platform.\n    \n-   [riscv32](riscv32/index.html \"mod core::arch::riscv32\")ExperimentalRISC-V RV32\n    \n    Platform-specific intrinsics for the `riscv32` platform.\n    \n-   [riscv64](riscv64/index.html \"mod core::arch::riscv64\")ExperimentalRISC-V RV64\n    \n    Platform-specific intrinsics for the `riscv64` platform.\n    \n-   [wasm](wasm/index.html \"mod core::arch::wasm\")Experimental`target_family=\"wasm\"`\n    \n    Platform-specific intrinsics for the `wasm` target family.\n    \n-   [wasm64](wasm64/index.html \"mod core::arch::wasm64\")ExperimentalWebAssembly\n    \n    Platform-specific intrinsics for the `wasm64` platform.\n    \n\n-   Inline assembly.\n    \n-   Module-level inline assembly.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"SIMD and vendor intrinsics module.\"><title>core::arch - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"core\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../core/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module arch</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../core/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../core/index.html\">core</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module arch</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#modules\">Modules</a></li><li><a href=\"#macros\">Macros</a></li></ul></section><h2><a href=\"../index.html\">In crate core</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../panicking/index.html\">panicking</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../ub_checks/index.html\">ub_checks</a></li><li><a href=\"../unicode/index.html\">unicode</a></li><li><a href=\"../usize/index.html\">usize</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.assert_unsafe_precondition.html\">assert_unsafe_precondition</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.pattern_type.html\">pattern_type</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../core/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">core</a>::<wbr><a class=\"mod\" href=\"#\">arch</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> · <a class=\"src\" href=\"../../src/core/arch.rs.html#1-31\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>SIMD and vendor intrinsics module.</p>\n<p>This module is intended to be the gateway to architecture-specific\nintrinsic functions, typically related to SIMD (but not always!). Each\narchitecture that Rust compiles to may contain a submodule here, which\nmeans that this is not a portable module! If you’re writing a portable\nlibrary take care when using these APIs!</p>\n<p>Under this module you’ll find an architecture-named module, such as\n<code>x86_64</code>. Each <code>#[cfg(target_arch)]</code> that Rust can compile to may have a\nmodule entry here, only present on that particular target. For example the\n<code>i686-pc-windows-msvc</code> target will have an <code>x86</code> module here, whereas\n<code>x86_64-pc-windows-msvc</code> has <code>x86_64</code>.</p>\n<h2 id=\"overview\"><a class=\"doc-anchor\" href=\"#overview\">§</a>Overview</h2>\n<p>This module exposes vendor-specific intrinsics that typically correspond to\na single machine instruction. These intrinsics are not portable: their\navailability is architecture-dependent, and not all machines of that\narchitecture might provide the intrinsic.</p>\n<p>The <code>arch</code> module is intended to be a low-level implementation detail for\nhigher-level APIs. Using it correctly can be quite tricky as you need to\nensure at least a few guarantees are upheld:</p>\n<ul>\n<li>The correct architecture’s module is used. For example the <code>arm</code> module\nisn’t available on the <code>x86_64-unknown-linux-gnu</code> target. This is\ntypically done by ensuring that <code>#[cfg]</code> is used appropriately when using\nthis module.</li>\n<li>The CPU the program is currently running on supports the function being\ncalled. For example it is unsafe to call an AVX2 function on a CPU that\ndoesn’t actually support AVX2.</li>\n</ul>\n<p>As a result of the latter of these guarantees all intrinsics in this module\nare <code>unsafe</code> and extra care needs to be taken when calling them!</p>\n<h2 id=\"cpu-feature-detection\"><a class=\"doc-anchor\" href=\"#cpu-feature-detection\">§</a>CPU Feature Detection</h2>\n<p>In order to call these APIs in a safe fashion there’s a number of\nmechanisms available to ensure that the correct CPU feature is available\nto call an intrinsic. Let’s consider, for example, the <code>_mm256_add_epi64</code>\nintrinsics on the <code>x86</code> and <code>x86_64</code> architectures. This function requires\nthe AVX2 feature as <a href=\"https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_add_epi64&amp;expand=100\">documented by Intel</a> so to correctly call\nthis function we need to (a) guarantee we only call it on <code>x86</code>/<code>x86_64</code>\nand (b) ensure that the CPU feature is available</p>\n<h3 id=\"static-cpu-feature-detection\"><a class=\"doc-anchor\" href=\"#static-cpu-feature-detection\">§</a>Static CPU Feature Detection</h3>\n<p>The first option available to us is to conditionally compile code via the\n<code>#[cfg]</code> attribute. CPU features correspond to the <code>target_feature</code> cfg\navailable, and can be used like so:</p>\n\n<div class=\"example-wrap ignore\"><a href=\"#\" class=\"tooltip\" title=\"This example is not tested\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[cfg(\n    all(\n        any(target_arch = <span class=\"string\">\"x86\"</span>, target_arch = <span class=\"string\">\"x86_64\"</span>),\n        target_feature = <span class=\"string\">\"avx2\"\n    </span>)\n)]\n</span><span class=\"kw\">fn </span>foo() {\n    <span class=\"attr\">#[cfg(target_arch = <span class=\"string\">\"x86\"</span>)]\n    </span><span class=\"kw\">use </span>std::arch::x86::_mm256_add_epi64;\n    <span class=\"attr\">#[cfg(target_arch = <span class=\"string\">\"x86_64\"</span>)]\n    </span><span class=\"kw\">use </span>std::arch::x86_64::_mm256_add_epi64;\n\n    <span class=\"kw\">unsafe </span>{\n        _mm256_add_epi64(...);\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(%0A++++++++all(%0A++++++++++++any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22),%0A++++++++++++target_feature+=+%22avx2%22%0A++++++++)%0A++++)%5D%0A++++fn+foo()+%7B%0A++++++++%23%5Bcfg(target_arch+=+%22x86%22)%5D%0A++++++++use+std::arch::x86::_mm256_add_epi64;%0A++++++++%23%5Bcfg(target_arch+=+%22x86_64%22)%5D%0A++++++++use+std::arch::x86_64::_mm256_add_epi64;%0A++++%0A++++++++unsafe+%7B%0A++++++++++++_mm256_add_epi64(...);%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Here we’re using <code>#[cfg(target_feature = \"avx2\")]</code> to conditionally compile\nthis function into our module. This means that if the <code>avx2</code> feature is\n<em>enabled statically</em> then we’ll use the <code>_mm256_add_epi64</code> function at\nruntime. The <code>unsafe</code> block here can be justified through the usage of\n<code>#[cfg]</code> to only compile the code in situations where the safety guarantees\nare upheld.</p>\n<p>Statically enabling a feature is typically done with the <code>-C target-feature</code> or <code>-C target-cpu</code> flags to the compiler. For example if\nyour local CPU supports AVX2 then you can compile the above function with:</p>\n<div class=\"example-wrap\"><pre class=\"language-sh\"><code>$ RUSTFLAGS='-C target-cpu=native' cargo build\n</code></pre></div>\n<p>Or otherwise you can specifically enable just the AVX2 feature:</p>\n<div class=\"example-wrap\"><pre class=\"language-sh\"><code>$ RUSTFLAGS='-C target-feature=+avx2' cargo build\n</code></pre></div>\n<p>Note that when you compile a binary with a particular feature enabled it’s\nimportant to ensure that you only run the binary on systems which satisfy\nthe required feature set.</p>\n<h3 id=\"dynamic-cpu-feature-detection\"><a class=\"doc-anchor\" href=\"#dynamic-cpu-feature-detection\">§</a>Dynamic CPU Feature Detection</h3>\n<p>Sometimes statically dispatching isn’t quite what you want. Instead you\nmight want to build a portable binary that runs across a variety of CPUs,\nbut at runtime it selects the most optimized implementation available. This\nallows you to build a “least common denominator” binary which has certain\nsections more optimized for different CPUs.</p>\n<p>Taking our previous example from before, we’re going to compile our binary\n<em>without</em> AVX2 support, but we’d like to enable it for just one function.\nWe can do that in a manner like:</p>\n\n<div class=\"example-wrap ignore\"><a href=\"#\" class=\"tooltip\" title=\"This example is not tested\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>foo() {\n    <span class=\"attr\">#[cfg(any(target_arch = <span class=\"string\">\"x86\"</span>, target_arch = <span class=\"string\">\"x86_64\"</span>))]\n    </span>{\n        <span class=\"kw\">if </span><span class=\"macro\">is_x86_feature_detected!</span>(<span class=\"string\">\"avx2\"</span>) {\n            <span class=\"kw\">return unsafe </span>{ foo_avx2() };\n        }\n    }\n\n    <span class=\"comment\">// fallback implementation without using AVX2\n</span>}\n\n<span class=\"attr\">#[cfg(any(target_arch = <span class=\"string\">\"x86\"</span>, target_arch = <span class=\"string\">\"x86_64\"</span>))]\n#[target_feature(enable = <span class=\"string\">\"avx2\"</span>)]\n</span><span class=\"kw\">unsafe fn </span>foo_avx2() {\n    <span class=\"attr\">#[cfg(target_arch = <span class=\"string\">\"x86\"</span>)]\n    </span><span class=\"kw\">use </span>std::arch::x86::_mm256_add_epi64;\n    <span class=\"attr\">#[cfg(target_arch = <span class=\"string\">\"x86_64\"</span>)]\n    </span><span class=\"kw\">use </span>std::arch::x86_64::_mm256_add_epi64;\n\n    _mm256_add_epi64(...);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+foo()+%7B%0A++++++++%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A++++++++%7B%0A++++++++++++if+is_x86_feature_detected!(%22avx2%22)+%7B%0A++++++++++++++++return+unsafe+%7B+foo_avx2()+%7D;%0A++++++++++++%7D%0A++++++++%7D%0A++++%0A++++++++//+fallback+implementation+without+using+AVX2%0A++++%7D%0A++++%0A++++%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A++++%23%5Btarget_feature(enable+=+%22avx2%22)%5D%0A++++unsafe+fn+foo_avx2()+%7B%0A++++++++%23%5Bcfg(target_arch+=+%22x86%22)%5D%0A++++++++use+std::arch::x86::_mm256_add_epi64;%0A++++++++%23%5Bcfg(target_arch+=+%22x86_64%22)%5D%0A++++++++use+std::arch::x86_64::_mm256_add_epi64;%0A++++%0A++++++++_mm256_add_epi64(...);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>There’s a couple of components in play here, so let’s go through them in\ndetail!</p>\n<ul>\n<li>\n<p>First up we notice the <code>is_x86_feature_detected!</code> macro. Provided by\nthe standard library, this macro will perform necessary runtime detection\nto determine whether the CPU the program is running on supports the\nspecified feature. In this case the macro will expand to a boolean\nexpression evaluating to whether the local CPU has the AVX2 feature or\nnot.</p>\n<p>Note that this macro, like the <code>arch</code> module, is platform-specific. For\nexample calling <code>is_x86_feature_detected!(\"avx2\")</code> on ARM will be a\ncompile time error. To ensure we don’t hit this error a statement level\n<code>#[cfg]</code> is used to only compile usage of the macro on <code>x86</code>/<code>x86_64</code>.</p>\n</li>\n<li>\n<p>Next up we see our AVX2-enabled function, <code>foo_avx2</code>. This function is\ndecorated with the <code>#[target_feature]</code> attribute which enables a CPU\nfeature for just this one function. Using a compiler flag like <code>-C target-feature=+avx2</code> will enable AVX2 for the entire program, but using\nan attribute will only enable it for the one function. Usage of the\n<code>#[target_feature]</code> attribute currently requires the function to also be\n<code>unsafe</code>, as we see here. This is because the function can only be\ncorrectly called on systems which have the AVX2 (like the intrinsics\nthemselves).</p>\n</li>\n</ul>\n<p>And with all that we should have a working program! This program will run\nacross all machines and it’ll use the optimized AVX2 implementation on\nmachines where support is detected.</p>\n<h2 id=\"ergonomics\"><a class=\"doc-anchor\" href=\"#ergonomics\">§</a>Ergonomics</h2>\n<p>It’s important to note that using the <code>arch</code> module is not the easiest\nthing in the world, so if you’re curious to try it out you may want to\nbrace yourself for some wordiness!</p>\n<p>The primary purpose of this module is to enable stable crates on crates.io\nto build up much more ergonomic abstractions which end up using SIMD under\nthe hood. Over time these abstractions may also move into the standard\nlibrary itself, but for now this module is tasked with providing the bare\nminimum necessary to use vendor intrinsics on stable Rust.</p>\n<h2 id=\"other-architectures\"><a class=\"doc-anchor\" href=\"#other-architectures\">§</a>Other architectures</h2>\n<p>This documentation is only for one particular architecture, you can find\nothers at:</p>\n<ul>\n<li><a href=\"../../core/arch/x86/index.html\"><code>x86</code></a></li>\n<li><a href=\"../../core/arch/x86_64/index.html\"><code>x86_64</code></a></li>\n<li><a href=\"../../core/arch/arm/index.html\"><code>arm</code></a></li>\n<li><a href=\"../../core/arch/aarch64/index.html\"><code>aarch64</code></a></li>\n<li><a href=\"../../core/arch/riscv32/index.html\"><code>riscv32</code></a></li>\n<li><a href=\"../../core/arch/riscv64/index.html\"><code>riscv64</code></a></li>\n<li><a href=\"../../core/arch/mips/index.html\"><code>mips</code></a></li>\n<li><a href=\"../../core/arch/mips64/index.html\"><code>mips64</code></a></li>\n<li><a href=\"../../core/arch/powerpc/index.html\"><code>powerpc</code></a></li>\n<li><a href=\"../../core/arch/powerpc64/index.html\"><code>powerpc64</code></a></li>\n<li><a href=\"../../core/arch/nvptx/index.html\"><code>nvptx</code></a></li>\n<li><a href=\"../../core/arch/wasm32/index.html\"><code>wasm32</code></a></li>\n</ul>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>First let’s take a look at not actually using any intrinsics but instead\nusing LLVM’s auto-vectorization to produce optimized vectorized code for\nAVX2 and also for the default platform.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>dst = [<span class=\"number\">0</span>];\n    add_quickly(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>], <span class=\"kw-2\">&amp;</span>[<span class=\"number\">2</span>], <span class=\"kw-2\">&amp;mut </span>dst);\n    <span class=\"macro\">assert_eq!</span>(dst[<span class=\"number\">0</span>], <span class=\"number\">3</span>);\n}\n\n<span class=\"kw\">fn </span>add_quickly(a: <span class=\"kw-2\">&amp;</span>[u8], b: <span class=\"kw-2\">&amp;</span>[u8], c: <span class=\"kw-2\">&amp;mut </span>[u8]) {\n    <span class=\"attr\">#[cfg(any(target_arch = <span class=\"string\">\"x86\"</span>, target_arch = <span class=\"string\">\"x86_64\"</span>))]\n    </span>{\n        <span class=\"comment\">// Note that this `unsafe` block is safe because we're testing\n        // that the `avx2` feature is indeed available on our CPU.\n        </span><span class=\"kw\">if </span><span class=\"macro\">is_x86_feature_detected!</span>(<span class=\"string\">\"avx2\"</span>) {\n            <span class=\"kw\">return unsafe </span>{ add_quickly_avx2(a, b, c) };\n        }\n    }\n\n    add_quickly_fallback(a, b, c)\n}\n\n<span class=\"attr\">#[cfg(any(target_arch = <span class=\"string\">\"x86\"</span>, target_arch = <span class=\"string\">\"x86_64\"</span>))]\n#[target_feature(enable = <span class=\"string\">\"avx2\"</span>)]\n</span><span class=\"kw\">unsafe fn </span>add_quickly_avx2(a: <span class=\"kw-2\">&amp;</span>[u8], b: <span class=\"kw-2\">&amp;</span>[u8], c: <span class=\"kw-2\">&amp;mut </span>[u8]) {\n    add_quickly_fallback(a, b, c) <span class=\"comment\">// the function below is inlined here\n</span>}\n\n<span class=\"kw\">fn </span>add_quickly_fallback(a: <span class=\"kw-2\">&amp;</span>[u8], b: <span class=\"kw-2\">&amp;</span>[u8], c: <span class=\"kw-2\">&amp;mut </span>[u8]) {\n    <span class=\"kw\">for </span>((a, b), c) <span class=\"kw\">in </span>a.iter().zip(b).zip(c) {\n        <span class=\"kw-2\">*</span>c = <span class=\"kw-2\">*</span>a + <span class=\"kw-2\">*</span>b;\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+dst+=+%5B0%5D;%0A++++add_quickly(%26%5B1%5D,+%26%5B2%5D,+%26mut+dst);%0A++++assert_eq!(dst%5B0%5D,+3);%0A%7D%0A%0Afn+add_quickly(a:+%26%5Bu8%5D,+b:+%26%5Bu8%5D,+c:+%26mut+%5Bu8%5D)+%7B%0A++++%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A++++%7B%0A++++++++//+Note+that+this+%60unsafe%60+block+is+safe+because+we're+testing%0A++++++++//+that+the+%60avx2%60+feature+is+indeed+available+on+our+CPU.%0A++++++++if+is_x86_feature_detected!(%22avx2%22)+%7B%0A++++++++++++return+unsafe+%7B+add_quickly_avx2(a,+b,+c)+%7D;%0A++++++++%7D%0A++++%7D%0A%0A++++add_quickly_fallback(a,+b,+c)%0A%7D%0A%0A%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A%23%5Btarget_feature(enable+=+%22avx2%22)%5D%0Aunsafe+fn+add_quickly_avx2(a:+%26%5Bu8%5D,+b:+%26%5Bu8%5D,+c:+%26mut+%5Bu8%5D)+%7B%0A++++add_quickly_fallback(a,+b,+c)+//+the+function+below+is+inlined+here%0A%7D%0A%0Afn+add_quickly_fallback(a:+%26%5Bu8%5D,+b:+%26%5Bu8%5D,+c:+%26mut+%5Bu8%5D)+%7B%0A++++for+((a,+b),+c)+in+a.iter().zip(b).zip(c)+%7B%0A++++++++*c+=+*a+%2B+*b;%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Next up let’s take a look at an example of manually using intrinsics. Here\nwe’ll be using SSE4.1 features to implement hex encoding.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>dst = [<span class=\"number\">0</span>; <span class=\"number\">32</span>];\n    hex_encode(<span class=\"string\">b\"\\x01\\x02\\x03\"</span>, <span class=\"kw-2\">&amp;mut </span>dst);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>dst[..<span class=\"number\">6</span>], <span class=\"string\">b\"010203\"</span>);\n\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>src = [<span class=\"number\">0</span>; <span class=\"number\">16</span>];\n    <span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..<span class=\"number\">16 </span>{\n        src[i] = (i + <span class=\"number\">1</span>) <span class=\"kw\">as </span>u8;\n    }\n    hex_encode(<span class=\"kw-2\">&amp;</span>src, <span class=\"kw-2\">&amp;mut </span>dst);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>dst, <span class=\"string\">b\"0102030405060708090a0b0c0d0e0f10\"</span>);\n}\n\n<span class=\"kw\">pub fn </span>hex_encode(src: <span class=\"kw-2\">&amp;</span>[u8], dst: <span class=\"kw-2\">&amp;mut </span>[u8]) {\n    <span class=\"kw\">let </span>len = src.len().checked_mul(<span class=\"number\">2</span>).unwrap();\n    <span class=\"macro\">assert!</span>(dst.len() &gt;= len);\n\n    <span class=\"attr\">#[cfg(any(target_arch = <span class=\"string\">\"x86\"</span>, target_arch = <span class=\"string\">\"x86_64\"</span>))]\n    </span>{\n        <span class=\"kw\">if </span><span class=\"macro\">is_x86_feature_detected!</span>(<span class=\"string\">\"sse4.1\"</span>) {\n            <span class=\"kw\">return unsafe </span>{ hex_encode_sse41(src, dst) };\n        }\n    }\n\n    hex_encode_fallback(src, dst)\n}\n\n<span class=\"comment\">// translated from\n// &lt;https://github.com/Matherunner/bin2hex-sse/blob/master/base16_sse4.cpp&gt;\n</span><span class=\"attr\">#[target_feature(enable = <span class=\"string\">\"sse4.1\"</span>)]\n#[cfg(any(target_arch = <span class=\"string\">\"x86\"</span>, target_arch = <span class=\"string\">\"x86_64\"</span>))]\n</span><span class=\"kw\">unsafe fn </span>hex_encode_sse41(<span class=\"kw-2\">mut </span>src: <span class=\"kw-2\">&amp;</span>[u8], dst: <span class=\"kw-2\">&amp;mut </span>[u8]) {\n    <span class=\"attr\">#[cfg(target_arch = <span class=\"string\">\"x86\"</span>)]\n    </span><span class=\"kw\">use </span>std::arch::x86::<span class=\"kw-2\">*</span>;\n    <span class=\"attr\">#[cfg(target_arch = <span class=\"string\">\"x86_64\"</span>)]\n    </span><span class=\"kw\">use </span>std::arch::x86_64::<span class=\"kw-2\">*</span>;\n\n    <span class=\"kw\">let </span>ascii_zero = _mm_set1_epi8(<span class=\"string\">b'0' </span><span class=\"kw\">as </span>i8);\n    <span class=\"kw\">let </span>nines = _mm_set1_epi8(<span class=\"number\">9</span>);\n    <span class=\"kw\">let </span>ascii_a = _mm_set1_epi8((<span class=\"string\">b'a' </span>- <span class=\"number\">9 </span>- <span class=\"number\">1</span>) <span class=\"kw\">as </span>i8);\n    <span class=\"kw\">let </span>and4bits = _mm_set1_epi8(<span class=\"number\">0xf</span>);\n\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>i = <span class=\"number\">0_isize</span>;\n    <span class=\"kw\">while </span>src.len() &gt;= <span class=\"number\">16 </span>{\n        <span class=\"kw\">let </span>invec = _mm_loadu_si128(src.as_ptr() <span class=\"kw\">as </span><span class=\"kw-2\">*const </span><span class=\"kw\">_</span>);\n\n        <span class=\"kw\">let </span>masked1 = _mm_and_si128(invec, and4bits);\n        <span class=\"kw\">let </span>masked2 = _mm_and_si128(_mm_srli_epi64(invec, <span class=\"number\">4</span>), and4bits);\n\n        <span class=\"comment\">// return 0xff corresponding to the elements &gt; 9, or 0x00 otherwise\n        </span><span class=\"kw\">let </span>cmpmask1 = _mm_cmpgt_epi8(masked1, nines);\n        <span class=\"kw\">let </span>cmpmask2 = _mm_cmpgt_epi8(masked2, nines);\n\n        <span class=\"comment\">// add '0' or the offset depending on the masks\n        </span><span class=\"kw\">let </span>masked1 = _mm_add_epi8(\n            masked1,\n            _mm_blendv_epi8(ascii_zero, ascii_a, cmpmask1),\n        );\n        <span class=\"kw\">let </span>masked2 = _mm_add_epi8(\n            masked2,\n            _mm_blendv_epi8(ascii_zero, ascii_a, cmpmask2),\n        );\n\n        <span class=\"comment\">// interleave masked1 and masked2 bytes\n        </span><span class=\"kw\">let </span>res1 = _mm_unpacklo_epi8(masked2, masked1);\n        <span class=\"kw\">let </span>res2 = _mm_unpackhi_epi8(masked2, masked1);\n\n        _mm_storeu_si128(dst.as_mut_ptr().offset(i * <span class=\"number\">2</span>) <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span><span class=\"kw\">_</span>, res1);\n        _mm_storeu_si128(\n            dst.as_mut_ptr().offset(i * <span class=\"number\">2 </span>+ <span class=\"number\">16</span>) <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span><span class=\"kw\">_</span>,\n            res2,\n        );\n        src = <span class=\"kw-2\">&amp;</span>src[<span class=\"number\">16</span>..];\n        i += <span class=\"number\">16</span>;\n    }\n\n    <span class=\"kw\">let </span>i = i <span class=\"kw\">as </span>usize;\n    hex_encode_fallback(src, <span class=\"kw-2\">&amp;mut </span>dst[i * <span class=\"number\">2</span>..]);\n}\n\n<span class=\"kw\">fn </span>hex_encode_fallback(src: <span class=\"kw-2\">&amp;</span>[u8], dst: <span class=\"kw-2\">&amp;mut </span>[u8]) {\n    <span class=\"kw\">fn </span>hex(byte: u8) -&gt; u8 {\n        <span class=\"kw\">static </span>TABLE: <span class=\"kw-2\">&amp;</span>[u8] = <span class=\"string\">b\"0123456789abcdef\"</span>;\n        TABLE[byte <span class=\"kw\">as </span>usize]\n    }\n\n    <span class=\"kw\">for </span>(byte, slots) <span class=\"kw\">in </span>src.iter().zip(dst.chunks_mut(<span class=\"number\">2</span>)) {\n        slots[<span class=\"number\">0</span>] = hex((<span class=\"kw-2\">*</span>byte &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0xf</span>);\n        slots[<span class=\"number\">1</span>] = hex(<span class=\"kw-2\">*</span>byte &amp; <span class=\"number\">0xf</span>);\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+dst+=+%5B0;+32%5D;%0A++++hex_encode(b%22%5Cx01%5Cx02%5Cx03%22,+%26mut+dst);%0A++++assert_eq!(%26dst%5B..6%5D,+b%22010203%22);%0A%0A++++let+mut+src+=+%5B0;+16%5D;%0A++++for+i+in+0..16+%7B%0A++++++++src%5Bi%5D+=+(i+%2B+1)+as+u8;%0A++++%7D%0A++++hex_encode(%26src,+%26mut+dst);%0A++++assert_eq!(%26dst,+b%220102030405060708090a0b0c0d0e0f10%22);%0A%7D%0A%0Apub+fn+hex_encode(src:+%26%5Bu8%5D,+dst:+%26mut+%5Bu8%5D)+%7B%0A++++let+len+=+src.len().checked_mul(2).unwrap();%0A++++assert!(dst.len()+%3E=+len);%0A%0A++++%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0A++++%7B%0A++++++++if+is_x86_feature_detected!(%22sse4.1%22)+%7B%0A++++++++++++return+unsafe+%7B+hex_encode_sse41(src,+dst)+%7D;%0A++++++++%7D%0A++++%7D%0A%0A++++hex_encode_fallback(src,+dst)%0A%7D%0A%0A//+translated+from%0A//+%3Chttps://github.com/Matherunner/bin2hex-sse/blob/master/base16_sse4.cpp%3E%0A%23%5Btarget_feature(enable+=+%22sse4.1%22)%5D%0A%23%5Bcfg(any(target_arch+=+%22x86%22,+target_arch+=+%22x86_64%22))%5D%0Aunsafe+fn+hex_encode_sse41(mut+src:+%26%5Bu8%5D,+dst:+%26mut+%5Bu8%5D)+%7B%0A++++%23%5Bcfg(target_arch+=+%22x86%22)%5D%0A++++use+std::arch::x86::*;%0A++++%23%5Bcfg(target_arch+=+%22x86_64%22)%5D%0A++++use+std::arch::x86_64::*;%0A%0A++++let+ascii_zero+=+_mm_set1_epi8(b'0'+as+i8);%0A++++let+nines+=+_mm_set1_epi8(9);%0A++++let+ascii_a+=+_mm_set1_epi8((b'a'+-+9+-+1)+as+i8);%0A++++let+and4bits+=+_mm_set1_epi8(0xf);%0A%0A++++let+mut+i+=+0_isize;%0A++++while+src.len()+%3E=+16+%7B%0A++++++++let+invec+=+_mm_loadu_si128(src.as_ptr()+as+*const+_);%0A%0A++++++++let+masked1+=+_mm_and_si128(invec,+and4bits);%0A++++++++let+masked2+=+_mm_and_si128(_mm_srli_epi64(invec,+4),+and4bits);%0A%0A++++++++//+return+0xff+corresponding+to+the+elements+%3E+9,+or+0x00+otherwise%0A++++++++let+cmpmask1+=+_mm_cmpgt_epi8(masked1,+nines);%0A++++++++let+cmpmask2+=+_mm_cmpgt_epi8(masked2,+nines);%0A%0A++++++++//+add+'0'+or+the+offset+depending+on+the+masks%0A++++++++let+masked1+=+_mm_add_epi8(%0A++++++++++++masked1,%0A++++++++++++_mm_blendv_epi8(ascii_zero,+ascii_a,+cmpmask1),%0A++++++++);%0A++++++++let+masked2+=+_mm_add_epi8(%0A++++++++++++masked2,%0A++++++++++++_mm_blendv_epi8(ascii_zero,+ascii_a,+cmpmask2),%0A++++++++);%0A%0A++++++++//+interleave+masked1+and+masked2+bytes%0A++++++++let+res1+=+_mm_unpacklo_epi8(masked2,+masked1);%0A++++++++let+res2+=+_mm_unpackhi_epi8(masked2,+masked1);%0A%0A++++++++_mm_storeu_si128(dst.as_mut_ptr().offset(i+*+2)+as+*mut+_,+res1);%0A++++++++_mm_storeu_si128(%0A++++++++++++dst.as_mut_ptr().offset(i+*+2+%2B+16)+as+*mut+_,%0A++++++++++++res2,%0A++++++++);%0A++++++++src+=+%26src%5B16..%5D;%0A++++++++i+%2B=+16;%0A++++%7D%0A%0A++++let+i+=+i+as+usize;%0A++++hex_encode_fallback(src,+%26mut+dst%5Bi+*+2..%5D);%0A%7D%0A%0Afn+hex_encode_fallback(src:+%26%5Bu8%5D,+dst:+%26mut+%5Bu8%5D)+%7B%0A++++fn+hex(byte:+u8)+-%3E+u8+%7B%0A++++++++static+TABLE:+%26%5Bu8%5D+=+b%220123456789abcdef%22;%0A++++++++TABLE%5Bbyte+as+usize%5D%0A++++%7D%0A%0A++++for+(byte,+slots)+in+src.iter().zip(dst.chunks_mut(2))+%7B%0A++++++++slots%5B0%5D+=+hex((*byte+%3E%3E+4)+%26+0xf);%0A++++++++slots%5B1%5D+=+hex(*byte+%26+0xf);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"modules\" class=\"section-header\">Modules<a href=\"#modules\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"mod\" href=\"aarch64/index.html\" title=\"mod core::arch::aarch64\">aarch64</a><span class=\"stab portability\" title=\"Available on AArch64 or `target_arch=&quot;arm64ec&quot;` only\">AArch64 or <code>target_arch=\"arm64ec\"</code></span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>aarch64</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"wasm32/index.html\" title=\"mod core::arch::wasm32\">wasm32</a><span class=\"stab portability\" title=\"Available on WebAssembly only\">WebAssembly</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>wasm32</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"x86/index.html\" title=\"mod core::arch::x86\">x86</a><span class=\"stab portability\" title=\"Available on x86 only\">x86</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>x86</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"x86_64/index.html\" title=\"mod core::arch::x86_64\">x86_64</a><span class=\"stab portability\" title=\"Available on x86-64 only\">x86-64</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>x86_64</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"arm/index.html\" title=\"mod core::arch::arm\">arm</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on ARM only\">ARM</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>arm</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"loongarch64/index.html\" title=\"mod core::arch::loongarch64\">loongarch64</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on LoongArch LA64 only\">LoongArch LA64</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>loongarch</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"mips/index.html\" title=\"mod core::arch::mips\">mips</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on MIPS only\">MIPS</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>mips</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"mips64/index.html\" title=\"mod core::arch::mips64\">mips64</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on MIPS-64 only\">MIPS-64</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>mips64</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"nvptx/index.html\" title=\"mod core::arch::nvptx\">nvptx</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on `target_arch=&quot;nvptx64&quot;` only\"><code>target_arch=\"nvptx64\"</code></span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>NVPTX</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"powerpc/index.html\" title=\"mod core::arch::powerpc\">powerpc</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on PowerPC only\">PowerPC</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>PowerPC</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"powerpc64/index.html\" title=\"mod core::arch::powerpc64\">powerpc64</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on PowerPC-64 only\">PowerPC-64</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>PowerPC64</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"riscv32/index.html\" title=\"mod core::arch::riscv32\">riscv32</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on RISC-V RV32 only\">RISC-V RV32</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>riscv32</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"riscv64/index.html\" title=\"mod core::arch::riscv64\">riscv64</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on RISC-V RV64 only\">RISC-V RV64</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>riscv64</code> platform.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"wasm/index.html\" title=\"mod core::arch::wasm\">wasm</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on `target_family=&quot;wasm&quot;` only\"><code>target_family=\"wasm\"</code></span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>wasm</code> target family.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"wasm64/index.html\" title=\"mod core::arch::wasm64\">wasm64</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on WebAssembly only\">WebAssembly</span></div><div class=\"desc docblock-short\">Platform-specific intrinsics for the <code>wasm64</code> platform.</div></li></ul><h2 id=\"macros\" class=\"section-header\">Macros<a href=\"#macros\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"macro\" href=\"macro.asm.html\" title=\"macro core::arch::asm\">asm</a></div><div class=\"desc docblock-short\">Inline assembly.</div></li><li><div class=\"item-name\"><a class=\"macro\" href=\"macro.global_asm.html\" title=\"macro core::arch::global_asm\">global_asm</a></div><div class=\"desc docblock-short\">Module-level inline assembly.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:22:46.064Z"
}