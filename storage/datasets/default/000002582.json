{
	"title": "Other reprs - The Rustonomicon",
	"url": "https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked",
	"markdown": "# Other reprs - The Rustonomicon\n\n## [Alternative representations](#alternative-representations)\n\nRust allows you to specify alternative data layout strategies from the default. There's also the [unsafe code guidelines](https://rust-lang.github.io/unsafe-code-guidelines/layout.html) (note that it's **NOT** normative).\n\n## [repr(C)](#reprc)\n\nThis is the most important `repr`. It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C or C++. Any type you expect to pass through an FFI boundary should have `repr(C)`, as C is the lingua-franca of the programming world. This is also necessary to soundly do more elaborate tricks with data layout such as reinterpreting values as a different type.\n\nWe strongly recommend using [rust-bindgen](https://rust-lang.github.io/rust-bindgen/) and/or [cbindgen](https://github.com/eqrion/cbindgen) to manage your FFI boundaries for you. The Rust team works closely with those projects to ensure that they work robustly and are compatible with current and future guarantees about type layouts and `repr`s.\n\nThe interaction of `repr(C)` with Rust's more exotic data layout features must be kept in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\", `repr(C)` can be applied to types that will be nonsensical or problematic if passed through the FFI boundary.\n\n-   ZSTs are still zero-sized, even though this is not a standard behavior in C, and is explicitly contrary to the behavior of an empty type in C++, which says they should still consume a byte of space.\n    \n-   DST pointers (wide pointers) and tuples are not a concept in C, and as such are never FFI-safe.\n    \n-   Enums with fields also aren't a concept in C or C++, but a valid bridging of the types [is defined](https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md).\n    \n-   If `T` is an [FFI-safe non-nullable pointer type](about:blank/ffi.html#the-nullable-pointer-optimization), `Option<T>` is guaranteed to have the same layout and ABI as `T` and is therefore also FFI-safe. As of this writing, this covers `&`, `&mut`, and function pointers, all of which can never be null.\n    \n-   Tuple structs are like structs with regards to `repr(C)`, as the only difference from a struct is that the fields arenâ€™t named.\n    \n-   `repr(C)` is equivalent to one of `repr(u*)` (see the next section) for fieldless enums. The chosen size is the default enum size for the target platform's C application binary interface (ABI). Note that enum representation in C is implementation defined, so this is really a \"best guess\". In particular, this may be incorrect when the C code of interest is compiled with certain flags.\n    \n-   Fieldless enums with `repr(C)` or `repr(u*)` still may not be set to an integer value without a corresponding variant, even though this is permitted behavior in C or C++. It is undefined behavior to (unsafely) construct an instance of an enum that does not match one of its variants. (This allows exhaustive matches to continue to be written and compiled as normal.)\n    \n\n## [repr(transparent)](#reprtransparent)\n\n`#[repr(transparent)]` can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields). The effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.\n\n> NOTE: There's a `transparent_unions` nightly feature to apply `repr(transparent)` to unions, but it hasn't been stabilized due to design concerns. See the [tracking issue](https://github.com/rust-lang/rust/issues/60405) for more details.\n\nThe goal is to make it possible to transmute between the single field and the struct/enum. An example of that is [`UnsafeCell`](../std/cell/struct.UnsafeCell.html), which can be transmuted into the type it wraps ([`UnsafeCell`](../std/cell/struct.UnsafeCell.html) also uses the unstable [no\\_niche](https://github.com/rust-lang/rust/pull/68491), so its ABI is not actually guaranteed to be the same when nested in other types).\n\nAlso, passing the struct/enum through FFI where the inner field type is expected on the other side is guaranteed to work. In particular, this is necessary for `struct Foo(f32)` or `enum Foo { Bar(f32) }` to always have the same ABI as `f32`.\n\nThis repr is only considered part of the public ABI of a type if either the single field is `pub`, or if its layout is documented in prose. Otherwise, the layout should not be relied upon by other crates.\n\nMore details are in the [RFC 1758](https://github.com/rust-lang/rfcs/blob/master/text/1758-repr-transparent.md) and the [RFC 2645](https://rust-lang.github.io/rfcs/2645-transparent-unions.html).\n\n## [repr(u\\*), repr(i\\*)](#repru-repri)\n\nThese specify the size to make a fieldless enum. If the discriminant overflows the integer it has to fit in, it will produce a compile-time error. You can manually ask Rust to allow this by setting the overflowing element to explicitly be 0. However Rust will not allow you to create an enum where two variants have the same discriminant.\n\nThe term \"fieldless enum\" only means that the enum doesn't have data in any of its variants. A fieldless enum without a `repr(u*)` or `repr(C)` is still a Rust native type, and does not have a stable ABI representation. Adding a `repr` causes it to be treated exactly like the specified integer size for ABI purposes.\n\nIf the enum has fields, the effect is similar to the effect of `repr(C)` in that there is a defined layout of the type. This makes it possible to pass the enum to C code, or access the type's raw representation and directly manipulate its tag and fields. See [the RFC](https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md) for details.\n\nThese `repr`s have no effect on a struct.\n\nAdding an explicit `repr(u*)`, `repr(i*)`, or `repr(C)` to an enum with fields suppresses the null-pointer optimization, like:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::mem::size_of;\nenum MyOption<T> {\n    Some(T),\n    None,\n}\n\n#[repr(u8)]\nenum MyReprOption<T> {\n    Some(T),\n    None,\n}\n\nassert_eq!(8, size_of::<MyOption<&u16>>());\nassert_eq!(16, size_of::<MyReprOption<&u16>>());\n}\n```\n\nThis optimization still applies to fieldless enums with an explicit `repr(u*)`, `repr(i*)`, or `repr(C)`.\n\n## [repr(packed)](#reprpacked)\n\n`repr(packed)` forces Rust to strip any padding, and only align the type to a byte. This may improve the memory footprint, but will likely have other negative side-effects.\n\nIn particular, most architectures _strongly_ prefer values to be aligned. This may mean the unaligned loads are penalized (x86), or even fault (some ARM chips). For simple cases like directly loading or storing a packed field, the compiler might be able to paper over alignment issues with shifts and masks. However if you take a reference to a packed field, it's unlikely that the compiler will be able to emit code to avoid an unaligned load.\n\n[As this can cause undefined behavior](https://github.com/rust-lang/rust/issues/27060), the lint has been implemented and it will become a hard error.\n\n`repr(packed)` is not to be used lightly. Unless you have extreme requirements, this should not be used.\n\nThis repr is a modifier on `repr(C)` and `repr(Rust)`.\n\n## [repr(align(n))](#repralignn)\n\n`repr(align(n))` (where `n` is a power of two) forces the type to have an alignment of _at least_ n.\n\nThis enables several tricks, like making sure neighboring elements of an array never share the same cache line with each other (which may speed up certain kinds of concurrent code).\n\nThis is a modifier on `repr(C)` and `repr(Rust)`. It is incompatible with `repr(packed)`.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Other reprs - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar bordered\" style=\"top: 2424px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"alternative-representations\"><a class=\"header\" href=\"#alternative-representations\">Alternative representations</a></h1>\n<p>Rust allows you to specify alternative data layout strategies from the default.\nThere's also the <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout.html\">unsafe code guidelines</a> (note that it's <strong>NOT</strong> normative).</p>\n<h2 id=\"reprc\"><a class=\"header\" href=\"#reprc\">repr(C)</a></h2>\n<p>This is the most important <code class=\"hljs\">repr</code>. It has fairly simple intent: do what C does.\nThe order, size, and alignment of fields is exactly what you would expect from C\nor C++. Any type you expect to pass through an FFI boundary should have\n<code class=\"hljs\">repr(C)</code>, as C is the lingua-franca of the programming world. This is also\nnecessary to soundly do more elaborate tricks with data layout such as\nreinterpreting values as a different type.</p>\n<p>We strongly recommend using <a href=\"https://rust-lang.github.io/rust-bindgen/\">rust-bindgen</a> and/or <a href=\"https://github.com/eqrion/cbindgen\">cbindgen</a> to manage your FFI\nboundaries for you. The Rust team works closely with those projects to ensure\nthat they work robustly and are compatible with current and future guarantees\nabout type layouts and <code class=\"hljs\">repr</code>s.</p>\n<p>The interaction of <code class=\"hljs\">repr(C)</code> with Rust's more exotic data layout features must be\nkept in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\",\n<code class=\"hljs\">repr(C)</code> can be applied to types that will be nonsensical or problematic if\npassed through the FFI boundary.</p>\n<ul>\n<li>\n<p>ZSTs are still zero-sized, even though this is not a standard behavior in\nC, and is explicitly contrary to the behavior of an empty type in C++, which\nsays they should still consume a byte of space.</p>\n</li>\n<li>\n<p>DST pointers (wide pointers) and tuples are not a concept\nin C, and as such are never FFI-safe.</p>\n</li>\n<li>\n<p>Enums with fields also aren't a concept in C or C++, but a valid bridging\nof the types <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md\">is defined</a>.</p>\n</li>\n<li>\n<p>If <code class=\"hljs\">T</code> is an <a href=\"ffi.html#the-nullable-pointer-optimization\">FFI-safe non-nullable pointer\ntype</a>,\n<code class=\"hljs\">Option&lt;T&gt;</code> is guaranteed to have the same layout and ABI as <code class=\"hljs\">T</code> and is\ntherefore also FFI-safe. As of this writing, this covers <code class=\"hljs\">&amp;</code>, <code class=\"hljs\">&amp;mut</code>,\nand function pointers, all of which can never be null.</p>\n</li>\n<li>\n<p>Tuple structs are like structs with regards to <code class=\"hljs\">repr(C)</code>, as the only\ndifference from a struct is that the fields arenâ€™t named.</p>\n</li>\n<li>\n<p><code class=\"hljs\">repr(C)</code> is equivalent to one of <code class=\"hljs\">repr(u*)</code> (see the next section) for\nfieldless enums. The chosen size is the default enum size for the target platform's C\napplication binary interface (ABI). Note that enum representation in C is implementation\ndefined, so this is really a \"best guess\". In particular, this may be incorrect\nwhen the C code of interest is compiled with certain flags.</p>\n</li>\n<li>\n<p>Fieldless enums with <code class=\"hljs\">repr(C)</code> or <code class=\"hljs\">repr(u*)</code> still may not be set to an\ninteger value without a corresponding variant, even though this is\npermitted behavior in C or C++. It is undefined behavior to (unsafely)\nconstruct an instance of an enum that does not match one of its\nvariants. (This allows exhaustive matches to continue to be written and\ncompiled as normal.)</p>\n</li>\n</ul>\n<h2 id=\"reprtransparent\"><a class=\"header\" href=\"#reprtransparent\">repr(transparent)</a></h2>\n<p><code class=\"hljs\">#[repr(transparent)]</code> can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields).\nThe effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.</p>\n<blockquote>\n<p>NOTE: There's a <code class=\"hljs\">transparent_unions</code> nightly feature to apply <code class=\"hljs\">repr(transparent)</code> to unions,\nbut it hasn't been stabilized due to design concerns. See the <a href=\"https://github.com/rust-lang/rust/issues/60405\">tracking issue</a> for more details.</p>\n</blockquote>\n<p>The goal is to make it possible to transmute between the single field and the\nstruct/enum. An example of that is <a href=\"../std/cell/struct.UnsafeCell.html\"><code class=\"hljs\">UnsafeCell</code></a>, which can be transmuted into\nthe type it wraps (<a href=\"../std/cell/struct.UnsafeCell.html\"><code class=\"hljs\">UnsafeCell</code></a> also uses the unstable <a href=\"https://github.com/rust-lang/rust/pull/68491\">no_niche</a>,\nso its ABI is not actually guaranteed to be the same when nested in other types).</p>\n<p>Also, passing the struct/enum through FFI where the inner field type is expected on\nthe other side is guaranteed to work. In particular, this is necessary for\n<code class=\"hljs\">struct Foo(f32)</code> or <code class=\"hljs\">enum Foo { Bar(f32) }</code> to always have the same ABI as <code class=\"hljs\">f32</code>.</p>\n<p>This repr is only considered part of the public ABI of a type if either the single\nfield is <code class=\"hljs\">pub</code>, or if its layout is documented in prose. Otherwise, the layout should\nnot be relied upon by other crates.</p>\n<p>More details are in the <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1758-repr-transparent.md\">RFC 1758</a> and the <a href=\"https://rust-lang.github.io/rfcs/2645-transparent-unions.html\">RFC 2645</a>.</p>\n<h2 id=\"repru-repri\"><a class=\"header\" href=\"#repru-repri\">repr(u*), repr(i*)</a></h2>\n<p>These specify the size to make a fieldless enum. If the discriminant overflows\nthe integer it has to fit in, it will produce a compile-time error. You can\nmanually ask Rust to allow this by setting the overflowing element to explicitly\nbe 0. However Rust will not allow you to create an enum where two variants have\nthe same discriminant.</p>\n<p>The term \"fieldless enum\" only means that the enum doesn't have data in any\nof its variants. A fieldless enum without a <code class=\"hljs\">repr(u*)</code> or <code class=\"hljs\">repr(C)</code> is\nstill a Rust native type, and does not have a stable ABI representation.\nAdding a <code class=\"hljs\">repr</code> causes it to be treated exactly like the specified\ninteger size for ABI purposes.</p>\n<p>If the enum has fields, the effect is similar to the effect of <code class=\"hljs\">repr(C)</code>\nin that there is a defined layout of the type. This makes it possible to\npass the enum to C code, or access the type's raw representation and directly\nmanipulate its tag and fields. See <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md\">the RFC</a> for details.</p>\n<p>These <code class=\"hljs\">repr</code>s have no effect on a struct.</p>\n<p>Adding an explicit <code class=\"hljs\">repr(u*)</code>, <code class=\"hljs\">repr(i*)</code>, or <code class=\"hljs\">repr(C)</code> to an enum with fields suppresses the null-pointer optimization, like:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::mem::size_of;\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">MyOption</span></span>&lt;T&gt; {\n    <span class=\"hljs-literal\">Some</span>(T),\n    <span class=\"hljs-literal\">None</span>,\n}\n\n<span class=\"hljs-meta\">#[repr(u8)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">MyReprOption</span></span>&lt;T&gt; {\n    <span class=\"hljs-literal\">Some</span>(T),\n    <span class=\"hljs-literal\">None</span>,\n}\n\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">8</span>, size_of::&lt;MyOption&lt;&amp;<span class=\"hljs-built_in\">u16</span>&gt;&gt;());\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">16</span>, size_of::&lt;MyReprOption&lt;&amp;<span class=\"hljs-built_in\">u16</span>&gt;&gt;());\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This optimization still applies to fieldless enums with an explicit <code class=\"hljs\">repr(u*)</code>, <code class=\"hljs\">repr(i*)</code>, or <code class=\"hljs\">repr(C)</code>.</p>\n<h2 id=\"reprpacked\"><a class=\"header\" href=\"#reprpacked\">repr(packed)</a></h2>\n<p><code class=\"hljs\">repr(packed)</code> forces Rust to strip any padding, and only align the type to a\nbyte. This may improve the memory footprint, but will likely have other negative\nside-effects.</p>\n<p>In particular, most architectures <em>strongly</em> prefer values to be aligned. This\nmay mean the unaligned loads are penalized (x86), or even fault (some ARM\nchips). For simple cases like directly loading or storing a packed field, the\ncompiler might be able to paper over alignment issues with shifts and masks.\nHowever if you take a reference to a packed field, it's unlikely that the\ncompiler will be able to emit code to avoid an unaligned load.</p>\n<p><a href=\"https://github.com/rust-lang/rust/issues/27060\">As this can cause undefined behavior</a>, the lint has been implemented\nand it will become a hard error.</p>\n<p><code class=\"hljs\">repr(packed)</code> is not to be used lightly. Unless you have extreme requirements,\nthis should not be used.</p>\n<p>This repr is a modifier on <code class=\"hljs\">repr(C)</code> and <code class=\"hljs\">repr(Rust)</code>.</p>\n<h2 id=\"repralignn\"><a class=\"header\" href=\"#repralignn\">repr(align(n))</a></h2>\n<p><code class=\"hljs\">repr(align(n))</code> (where <code class=\"hljs\">n</code> is a power of two) forces the type to have an\nalignment of <em>at least</em> n.</p>\n<p>This enables several tricks, like making sure neighboring elements of an array\nnever share the same cache line with each other (which may speed up certain\nkinds of concurrent code).</p>\n<p>This is a modifier on <code class=\"hljs\">repr(C)</code> and <code class=\"hljs\">repr(Rust)</code>. It is incompatible with\n<code class=\"hljs\">repr(packed)</code>.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"exotic-sizes.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ownership.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"exotic-sizes.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ownership.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:24:09.350Z"
}