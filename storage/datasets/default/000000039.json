{
	"title": "To panic! or Not to panic! - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch09-03-to-panic-or-not-to-panic.html",
	"markdown": "# To panic! or Not to panic!\n\nSo how do you decide when you should call `panic!` and when you should return `Result`? When code panics, there’s no way to recover. You could call `panic!` for any error situation, whether there’s a possible way to recover or not, but then you’re making the decision that a situation is unrecoverable on behalf of the calling code. When you choose to return a `Result` value, you give the calling code options. The calling code could choose to attempt to recover in a way that’s appropriate for its situation, or it could decide that an `Err` value in this case is unrecoverable, so it can call `panic!` and turn your recoverable error into an unrecoverable one. Therefore, returning `Result` is a good default choice when you’re defining a function that might fail.\n\nIn situations such as examples, prototype code, and tests, it’s more appropriate to write code that panics instead of returning a `Result`. Let’s explore why, then discuss situations in which the compiler can’t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.\n\n### [Examples, Prototype Code, and Tests](#examples-prototype-code-and-tests)\n\nWhen you’re writing an example to illustrate some concept, also including robust error-handling code can make the example less clear. In examples, it’s understood that a call to a method like `unwrap` that could panic is meant as a placeholder for the way you’d want your application to handle errors, which can differ based on what the rest of your code is doing.\n\nSimilarly, the `unwrap` and `expect` methods are very handy when prototyping, before you’re ready to decide how to handle errors. They leave clear markers in your code for when you’re ready to make your program more robust.\n\nIf a method call fails in a test, you’d want the whole test to fail, even if that method isn’t the functionality under test. Because `panic!` is how a test is marked as a failure, calling `unwrap` or `expect` is exactly what should happen.\n\n### [Cases in Which You Have More Information Than the Compiler](#cases-in-which-you-have-more-information-than-the-compiler)\n\nIt would also be appropriate to call `unwrap` or `expect` when you have some other logic that ensures the `Result` will have an `Ok` value, but the logic isn’t something the compiler understands. You’ll still have a `Result` value that you need to handle: whatever operation you’re calling still has the possibility of failing in general, even though it’s logically impossible in your particular situation. If you can ensure by manually inspecting the code that you’ll never have an `Err` variant, it’s perfectly acceptable to call `unwrap`, and even better to document the reason you think you’ll never have an `Err` variant in the `expect` text. Here’s an example:\n\n```rust\nfn main() {\n    use std::net::IpAddr;\n\n    let home: IpAddr = \"127.0.0.1\"\n        .parse()\n        .expect(\"Hardcoded IP address should be valid\");\n}\n```\n\nWe’re creating an `IpAddr` instance by parsing a hardcoded string. We can see that `127.0.0.1` is a valid IP address, so it’s acceptable to use `expect` here. However, having a hardcoded, valid string doesn’t change the return type of the `parse` method: we still get a `Result` value, and the compiler will still make us handle the `Result` as if the `Err` variant is a possibility because the compiler isn’t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore _did_ have a possibility of failure, we’d definitely want to handle the `Result` in a more robust way instead. Mentioning the assumption that this IP address is hardcoded will prompt us to change `expect` to better error-handling code if, in the future, we need to get the IP address from some other source instead.\n\n### [Guidelines for Error Handling](#guidelines-for-error-handling)\n\nIt’s advisable to have your code panic when it’s possible that your code could end up in a bad state. In this context, a _bad state_ is when some assumption, guarantee, contract, or invariant has been broken, such as when invalid values, contradictory values, or missing values are passed to your code—plus one or more of the following:\n\n-   The bad state is something that is unexpected, as opposed to something that will likely happen occasionally, like a user entering data in the wrong format.\n-   Your code after this point needs to rely on not being in this bad state, rather than checking for the problem at every step.\n-   There’s not a good way to encode this information in the types you use. We’ll work through an example of what we mean in the [“Encoding States and Behavior as Types”](about:blank/ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types) section of Chapter 17.\n\nIf someone calls your code and passes in values that don’t make sense, it’s best to return an error if you can so the user of the library can decide what they want to do in that case. However, in cases where continuing could be insecure or harmful, the best choice might be to call `panic!` and alert the person using your library to the bug in their code so they can fix it during development. Similarly, `panic!` is often appropriate if you’re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.\n\nHowever, when failure is expected, it’s more appropriate to return a `Result` than to make a `panic!` call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a `Result` indicates that failure is an expected possibility that the calling code must decide how to handle.\n\nWhen your code performs an operation that could put a user at risk if it’s called using invalid values, your code should verify the values are valid first and panic if the values aren’t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call `panic!` if you attempt an out-of-bounds memory access: trying to access memory that doesn’t belong to the current data structure is a common security problem. Functions often have _contracts_: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug, and it’s not a kind of error you want the calling code to have to explicitly handle. In fact, there’s no reasonable way for calling code to recover; the calling _programmers_ need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.\n\nHowever, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust’s type system (and thus the type checking done by the compiler) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code’s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an `Option`, your program expects to have _something_ rather than _nothing_. Your code then doesn’t have to handle two cases for the `Some` and `None` variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won’t even compile, so your function doesn’t have to check for that case at runtime. Another example is using an unsigned integer type such as `u32`, which ensures the parameter is never negative.\n\n### [Creating Custom Types for Validation](#creating-custom-types-for-validation)\n\nLet’s take the idea of using Rust’s type system to ensure we have a valid value one step further and look at creating a custom type for validation. Recall the guessing game in Chapter 2 in which our code asked the user to guess a number between 1 and 100. We never validated that the user’s guess was between those numbers before checking it against our secret number; we only validated that the guess was positive. In this case, the consequences were not very dire: our output of “Too high” or “Too low” would still be correct. But it would be a useful enhancement to guide the user toward valid guesses and have different behavior when the user guesses a number that’s out of range versus when the user types, for example, letters instead.\n\nOne way to do this would be to parse the guess as an `i32` instead of only a `u32` to allow potentially negative numbers, and then add a check for the number being in range, like so:\n\nFilename: src/main.rs\n\n```rust\nuse rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n\n    loop {\n        // --snip--\n\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: i32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        if guess < 1 || guess > 100 {\n            println!(\"The secret number will be between 1 and 100.\");\n            continue;\n        }\n\n        match guess.cmp(&secret_number) {\n            // --snip--\n            Ordering::Less => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n```\n\nThe `if` expression checks whether our value is out of range, tells the user about the problem, and calls `continue` to start the next iteration of the loop and ask for another guess. After the `if` expression, we can proceed with the comparisons between `guess` and the secret number knowing that `guess` is between 1 and 100.\n\nHowever, this is not an ideal solution: if it were absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).\n\nInstead, we can make a new type and put the validations in a function to create an instance of the type rather than repeating the validations everywhere. That way, it’s safe for functions to use the new type in their signatures and confidently use the values they receive. Listing 9-13 shows one way to define a `Guess` type that will only create an instance of `Guess` if the `new` function receives a value between 1 and 100.\n\nFilename: src/lib.rs\n\n```rust\n#![allow(unused)]\nfn main() {\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 || value > 100 {\n            panic!(\"Guess value must be between 1 and 100, got {value}.\");\n        }\n\n        Guess { value }\n    }\n\n    pub fn value(&self) -> i32 {\n        self.value\n    }\n}\n}\n```\n\nListing 9-13: A `Guess` type that will only continue with values between 1 and 100\n\nFirst we define a struct named `Guess` that has a field named `value` that holds an `i32`. This is where the number will be stored.\n\nThen we implement an associated function named `new` on `Guess` that creates instances of `Guess` values. The `new` function is defined to have one parameter named `value` of type `i32` and to return a `Guess`. The code in the body of the `new` function tests `value` to make sure it’s between 1 and 100. If `value` doesn’t pass this test, we make a `panic!` call, which will alert the programmer who is writing the calling code that they have a bug they need to fix, because creating a `Guess` with a `value` outside this range would violate the contract that `Guess::new` is relying on. The conditions in which `Guess::new` might panic should be discussed in its public-facing API documentation; we’ll cover documentation conventions indicating the possibility of a `panic!` in the API documentation that you create in Chapter 14. If `value` does pass the test, we create a new `Guess` with its `value` field set to the `value` parameter and return the `Guess`.\n\nNext, we implement a method named `value` that borrows `self`, doesn’t have any other parameters, and returns an `i32`. This kind of method is sometimes called a _getter_ because its purpose is to get some data from its fields and return it. This public method is necessary because the `value` field of the `Guess` struct is private. It’s important that the `value` field be private so code using the `Guess` struct is not allowed to set `value` directly: code outside the module _must_ use the `Guess::new` function to create an instance of `Guess`, thereby ensuring there’s no way for a `Guess` to have a `value` that hasn’t been checked by the conditions in the `Guess::new` function.\n\nA function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a `Guess` rather than an `i32` and wouldn’t need to do any additional checks in its body.\n\n## [Summary](#summary)\n\nRust’s error-handling features are designed to help you write more robust code. The `panic!` macro signals that your program is in a state it can’t handle and lets you tell the process to stop instead of trying to proceed with invalid or incorrect values. The `Result` enum uses Rust’s type system to indicate that operations might fail in a way that your code could recover from. You can use `Result` to tell code that calls your code that it needs to handle potential success or failure as well. Using `panic!` and `Result` in the appropriate situations will make your code more reliable in the face of inevitable problems.\n\nNow that you’ve seen useful ways that the standard library uses generics with the `Option` and `Result` enums, we’ll talk about how generics work and how you can use them in your code.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>To panic! or Not to panic! - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"to-panic-or-not-to-panic\"><a class=\"header\" href=\"#to-panic-or-not-to-panic\">To <code>panic!</code> or Not to <code>panic!</code></a></h2>\n<p>So how do you decide when you should call <code class=\"hljs\">panic!</code> and when you should return\n<code class=\"hljs\">Result</code>? When code panics, there’s no way to recover. You could call <code class=\"hljs\">panic!</code>\nfor any error situation, whether there’s a possible way to recover or not, but\nthen you’re making the decision that a situation is unrecoverable on behalf of\nthe calling code. When you choose to return a <code class=\"hljs\">Result</code> value, you give the\ncalling code options. The calling code could choose to attempt to recover in a\nway that’s appropriate for its situation, or it could decide that an <code class=\"hljs\">Err</code>\nvalue in this case is unrecoverable, so it can call <code class=\"hljs\">panic!</code> and turn your\nrecoverable error into an unrecoverable one. Therefore, returning <code class=\"hljs\">Result</code> is a\ngood default choice when you’re defining a function that might fail.</p>\n<p>In situations such as examples, prototype code, and tests, it’s more\nappropriate to write code that panics instead of returning a <code class=\"hljs\">Result</code>. Let’s\nexplore why, then discuss situations in which the compiler can’t tell that\nfailure is impossible, but you as a human can. The chapter will conclude with\nsome general guidelines on how to decide whether to panic in library code.</p>\n<h3 id=\"examples-prototype-code-and-tests\"><a class=\"header\" href=\"#examples-prototype-code-and-tests\">Examples, Prototype Code, and Tests</a></h3>\n<p>When you’re writing an example to illustrate some concept, also including\nrobust error-handling code can make the example less clear. In examples, it’s\nunderstood that a call to a method like <code class=\"hljs\">unwrap</code> that could panic is meant as a\nplaceholder for the way you’d want your application to handle errors, which can\ndiffer based on what the rest of your code is doing.</p>\n<p>Similarly, the <code class=\"hljs\">unwrap</code> and <code class=\"hljs\">expect</code> methods are very handy when prototyping,\nbefore you’re ready to decide how to handle errors. They leave clear markers in\nyour code for when you’re ready to make your program more robust.</p>\n<p>If a method call fails in a test, you’d want the whole test to fail, even if\nthat method isn’t the functionality under test. Because <code class=\"hljs\">panic!</code> is how a test\nis marked as a failure, calling <code class=\"hljs\">unwrap</code> or <code class=\"hljs\">expect</code> is exactly what should\nhappen.</p>\n<h3 id=\"cases-in-which-you-have-more-information-than-the-compiler\"><a class=\"header\" href=\"#cases-in-which-you-have-more-information-than-the-compiler\">Cases in Which You Have More Information Than the Compiler</a></h3>\n<p>It would also be appropriate to call <code class=\"hljs\">unwrap</code> or <code class=\"hljs\">expect</code> when you have some\nother logic that ensures the <code class=\"hljs\">Result</code> will have an <code class=\"hljs\">Ok</code> value, but the logic\nisn’t something the compiler understands. You’ll still have a <code class=\"hljs\">Result</code> value\nthat you need to handle: whatever operation you’re calling still has the\npossibility of failing in general, even though it’s logically impossible in\nyour particular situation. If you can ensure by manually inspecting the code\nthat you’ll never have an <code class=\"hljs\">Err</code> variant, it’s perfectly acceptable to call\n<code class=\"hljs\">unwrap</code>, and even better to document the reason you think you’ll never have an\n<code class=\"hljs\">Err</code> variant in the <code class=\"hljs\">expect</code> text. Here’s an example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">use</span> std::net::IpAddr;\n\n    <span class=\"hljs-keyword\">let</span> home: IpAddr = <span class=\"hljs-string\">\"127.0.0.1\"</span>\n        .parse()\n        .expect(<span class=\"hljs-string\">\"Hardcoded IP address should be valid\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>We’re creating an <code class=\"hljs\">IpAddr</code> instance by parsing a hardcoded string. We can see\nthat <code class=\"hljs\">127.0.0.1</code> is a valid IP address, so it’s acceptable to use <code class=\"hljs\">expect</code>\nhere. However, having a hardcoded, valid string doesn’t change the return type\nof the <code class=\"hljs\">parse</code> method: we still get a <code class=\"hljs\">Result</code> value, and the compiler will\nstill make us handle the <code class=\"hljs\">Result</code> as if the <code class=\"hljs\">Err</code> variant is a possibility\nbecause the compiler isn’t smart enough to see that this string is always a\nvalid IP address. If the IP address string came from a user rather than being\nhardcoded into the program and therefore <em>did</em> have a possibility of failure,\nwe’d definitely want to handle the <code class=\"hljs\">Result</code> in a more robust way instead.\nMentioning the assumption that this IP address is hardcoded will prompt us to\nchange <code class=\"hljs\">expect</code> to better error-handling code if, in the future, we need to get\nthe IP address from some other source instead.</p>\n<h3 id=\"guidelines-for-error-handling\"><a class=\"header\" href=\"#guidelines-for-error-handling\">Guidelines for Error Handling</a></h3>\n<p>It’s advisable to have your code panic when it’s possible that your code could\nend up in a bad state. In this context, a <em>bad state</em> is when some assumption,\nguarantee, contract, or invariant has been broken, such as when invalid values,\ncontradictory values, or missing values are passed to your code—plus one or\nmore of the following:</p>\n<ul>\n<li>The bad state is something that is unexpected, as opposed to something that\nwill likely happen occasionally, like a user entering data in the wrong\nformat.</li>\n<li>Your code after this point needs to rely on not being in this bad state,\nrather than checking for the problem at every step.</li>\n<li>There’s not a good way to encode this information in the types you use. We’ll\nwork through an example of what we mean in the <a href=\"ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types\">“Encoding States and Behavior\nas Types”</a><!-- ignore --> section of Chapter 17.</li>\n</ul>\n<p>If someone calls your code and passes in values that don’t make sense, it’s\nbest to return an error if you can so the user of the library can decide what\nthey want to do in that case. However, in cases where continuing could be\ninsecure or harmful, the best choice might be to call <code class=\"hljs\">panic!</code> and alert the\nperson using your library to the bug in their code so they can fix it during\ndevelopment. Similarly, <code class=\"hljs\">panic!</code> is often appropriate if you’re calling\nexternal code that is out of your control and it returns an invalid state that\nyou have no way of fixing.</p>\n<p>However, when failure is expected, it’s more appropriate to return a <code class=\"hljs\">Result</code>\nthan to make a <code class=\"hljs\">panic!</code> call. Examples include a parser being given malformed\ndata or an HTTP request returning a status that indicates you have hit a rate\nlimit. In these cases, returning a <code class=\"hljs\">Result</code> indicates that failure is an\nexpected possibility that the calling code must decide how to handle.</p>\n<p>When your code performs an operation that could put a user at risk if it’s\ncalled using invalid values, your code should verify the values are valid first\nand panic if the values aren’t valid. This is mostly for safety reasons:\nattempting to operate on invalid data can expose your code to vulnerabilities.\nThis is the main reason the standard library will call <code class=\"hljs\">panic!</code> if you attempt\nan out-of-bounds memory access: trying to access memory that doesn’t belong to\nthe current data structure is a common security problem. Functions often have\n<em>contracts</em>: their behavior is only guaranteed if the inputs meet particular\nrequirements. Panicking when the contract is violated makes sense because a\ncontract violation always indicates a caller-side bug, and it’s not a kind of\nerror you want the calling code to have to explicitly handle. In fact, there’s\nno reasonable way for calling code to recover; the calling <em>programmers</em> need\nto fix the code. Contracts for a function, especially when a violation will\ncause a panic, should be explained in the API documentation for the function.</p>\n<p>However, having lots of error checks in all of your functions would be verbose\nand annoying. Fortunately, you can use Rust’s type system (and thus the type\nchecking done by the compiler) to do many of the checks for you. If your\nfunction has a particular type as a parameter, you can proceed with your code’s\nlogic knowing that the compiler has already ensured you have a valid value. For\nexample, if you have a type rather than an <code class=\"hljs\">Option</code>, your program expects to\nhave <em>something</em> rather than <em>nothing</em>. Your code then doesn’t have to handle\ntwo cases for the <code class=\"hljs\">Some</code> and <code class=\"hljs\">None</code> variants: it will only have one case for\ndefinitely having a value. Code trying to pass nothing to your function won’t\neven compile, so your function doesn’t have to check for that case at runtime.\nAnother example is using an unsigned integer type such as <code class=\"hljs\">u32</code>, which ensures\nthe parameter is never negative.</p>\n<h3 id=\"creating-custom-types-for-validation\"><a class=\"header\" href=\"#creating-custom-types-for-validation\">Creating Custom Types for Validation</a></h3>\n<p>Let’s take the idea of using Rust’s type system to ensure we have a valid value\none step further and look at creating a custom type for validation. Recall the\nguessing game in Chapter 2 in which our code asked the user to guess a number\nbetween 1 and 100. We never validated that the user’s guess was between those\nnumbers before checking it against our secret number; we only validated that\nthe guess was positive. In this case, the consequences were not very dire: our\noutput of “Too high” or “Too low” would still be correct. But it would be a\nuseful enhancement to guide the user toward valid guesses and have different\nbehavior when the user guesses a number that’s out of range versus when the\nuser types, for example, letters instead.</p>\n<p>One way to do this would be to parse the guess as an <code class=\"hljs\">i32</code> instead of only a\n<code class=\"hljs\">u32</code> to allow potentially negative numbers, and then add a check for the\nnumber being in range, like so:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> rand::Rng;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::cmp::Ordering;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::io;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Guess the number!\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> secret_number = rand::thread_rng().gen_range(<span class=\"hljs-number\">1</span>..=<span class=\"hljs-number\">100</span>);\n</span><span class=\"boring\">\n</span>    <span class=\"hljs-keyword\">loop</span> {\n        <span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Please input your guess.\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> guess = <span class=\"hljs-built_in\">String</span>::new();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        io::stdin()\n</span><span class=\"boring\">            .read_line(&amp;<span class=\"hljs-keyword\">mut</span> guess)\n</span><span class=\"boring\">            .expect(<span class=\"hljs-string\">\"Failed to read line\"</span>);\n</span><span class=\"boring\">\n</span>        <span class=\"hljs-keyword\">let</span> guess: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-keyword\">match</span> guess.trim().parse() {\n            <span class=\"hljs-literal\">Ok</span>(num) =&gt; num,\n            <span class=\"hljs-literal\">Err</span>(_) =&gt; <span class=\"hljs-keyword\">continue</span>,\n        };\n\n        <span class=\"hljs-keyword\">if</span> guess &lt; <span class=\"hljs-number\">1</span> || guess &gt; <span class=\"hljs-number\">100</span> {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The secret number will be between 1 and 100.\"</span>);\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n\n        <span class=\"hljs-keyword\">match</span> guess.cmp(&amp;secret_number) {\n            <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">            Ordering::Less =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Too small!\"</span>),\n</span><span class=\"boring\">            Ordering::Greater =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Too big!\"</span>),\n</span><span class=\"boring\">            Ordering::Equal =&gt; {\n</span><span class=\"boring\">                <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"You win!\"</span>);\n</span><span class=\"boring\">                <span class=\"hljs-keyword\">break</span>;\n</span><span class=\"boring\">            }\n</span><span class=\"boring\">        }\n</span>    }\n<span class=\"boring\">}</span></code></pre>\n<p>The <code class=\"hljs\">if</code> expression checks whether our value is out of range, tells the user\nabout the problem, and calls <code class=\"hljs\">continue</code> to start the next iteration of the loop\nand ask for another guess. After the <code class=\"hljs\">if</code> expression, we can proceed with the\ncomparisons between <code class=\"hljs\">guess</code> and the secret number knowing that <code class=\"hljs\">guess</code> is\nbetween 1 and 100.</p>\n<p>However, this is not an ideal solution: if it were absolutely critical that the\nprogram only operated on values between 1 and 100, and it had many functions\nwith this requirement, having a check like this in every function would be\ntedious (and might impact performance).</p>\n<p>Instead, we can make a new type and put the validations in a function to create\nan instance of the type rather than repeating the validations everywhere. That\nway, it’s safe for functions to use the new type in their signatures and\nconfidently use the values they receive. Listing 9-13 shows one way to define a\n<code class=\"hljs\">Guess</code> type that will only create an instance of <code class=\"hljs\">Guess</code> if the <code class=\"hljs\">new</code> function\nreceives a value between 1 and 100.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Guess</span></span> {\n    value: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> Guess {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(value: <span class=\"hljs-built_in\">i32</span>) -&gt; Guess {\n        <span class=\"hljs-keyword\">if</span> value &lt; <span class=\"hljs-number\">1</span> || value &gt; <span class=\"hljs-number\">100</span> {\n            <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"Guess value must be between 1 and 100, got {value}.\"</span>);\n        }\n\n        Guess { value }\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">value</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">i32</span> {\n        <span class=\"hljs-keyword\">self</span>.value\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 9-13: A <code class=\"hljs\">Guess</code> type that will only continue with\nvalues between 1 and 100</span></p>\n<p>First we define a struct named <code class=\"hljs\">Guess</code> that has a field named <code class=\"hljs\">value</code> that\nholds an <code class=\"hljs\">i32</code>. This is where the number will be stored.</p>\n<p>Then we implement an associated function named <code class=\"hljs\">new</code> on <code class=\"hljs\">Guess</code> that creates\ninstances of <code class=\"hljs\">Guess</code> values. The <code class=\"hljs\">new</code> function is defined to have one\nparameter named <code class=\"hljs\">value</code> of type <code class=\"hljs\">i32</code> and to return a <code class=\"hljs\">Guess</code>. The code in the\nbody of the <code class=\"hljs\">new</code> function tests <code class=\"hljs\">value</code> to make sure it’s between 1 and 100.\nIf <code class=\"hljs\">value</code> doesn’t pass this test, we make a <code class=\"hljs\">panic!</code> call, which will alert\nthe programmer who is writing the calling code that they have a bug they need\nto fix, because creating a <code class=\"hljs\">Guess</code> with a <code class=\"hljs\">value</code> outside this range would\nviolate the contract that <code class=\"hljs\">Guess::new</code> is relying on. The conditions in which\n<code class=\"hljs\">Guess::new</code> might panic should be discussed in its public-facing API\ndocumentation; we’ll cover documentation conventions indicating the possibility\nof a <code class=\"hljs\">panic!</code> in the API documentation that you create in Chapter 14. If\n<code class=\"hljs\">value</code> does pass the test, we create a new <code class=\"hljs\">Guess</code> with its <code class=\"hljs\">value</code> field set\nto the <code class=\"hljs\">value</code> parameter and return the <code class=\"hljs\">Guess</code>.</p>\n<p>Next, we implement a method named <code class=\"hljs\">value</code> that borrows <code class=\"hljs\">self</code>, doesn’t have any\nother parameters, and returns an <code class=\"hljs\">i32</code>. This kind of method is sometimes called\na <em>getter</em> because its purpose is to get some data from its fields and return\nit. This public method is necessary because the <code class=\"hljs\">value</code> field of the <code class=\"hljs\">Guess</code>\nstruct is private. It’s important that the <code class=\"hljs\">value</code> field be private so code\nusing the <code class=\"hljs\">Guess</code> struct is not allowed to set <code class=\"hljs\">value</code> directly: code outside\nthe module <em>must</em> use the <code class=\"hljs\">Guess::new</code> function to create an instance of\n<code class=\"hljs\">Guess</code>, thereby ensuring there’s no way for a <code class=\"hljs\">Guess</code> to have a <code class=\"hljs\">value</code> that\nhasn’t been checked by the conditions in the <code class=\"hljs\">Guess::new</code> function.</p>\n<p>A function that has a parameter or returns only numbers between 1 and 100 could\nthen declare in its signature that it takes or returns a <code class=\"hljs\">Guess</code> rather than an\n<code class=\"hljs\">i32</code> and wouldn’t need to do any additional checks in its body.</p>\n<h2 id=\"summary\"><a class=\"header\" href=\"#summary\">Summary</a></h2>\n<p>Rust’s error-handling features are designed to help you write more robust code.\nThe <code class=\"hljs\">panic!</code> macro signals that your program is in a state it can’t handle and\nlets you tell the process to stop instead of trying to proceed with invalid or\nincorrect values. The <code class=\"hljs\">Result</code> enum uses Rust’s type system to indicate that\noperations might fail in a way that your code could recover from. You can use\n<code class=\"hljs\">Result</code> to tell code that calls your code that it needs to handle potential\nsuccess or failure as well. Using <code class=\"hljs\">panic!</code> and <code class=\"hljs\">Result</code> in the appropriate\nsituations will make your code more reliable in the face of inevitable problems.</p>\n<p>Now that you’ve seen useful ways that the standard library uses generics with\nthe <code class=\"hljs\">Option</code> and <code class=\"hljs\">Result</code> enums, we’ll talk about how generics work and how you\ncan use them in your code.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch09-02-recoverable-errors-with-result.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch10-00-generics.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch09-02-recoverable-errors-with-result.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch10-00-generics.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:21.140Z"
}