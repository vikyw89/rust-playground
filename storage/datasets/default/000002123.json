{
	"title": "catch_unwind in std::panic - Rust",
	"url": "https://doc.rust-lang.org/stable/std/panic/fn.catch_unwind.html",
	"markdown": "# catch\\_unwind in std::panic - Rust\n\n```\npub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R>\n```\n\nExpand description\n\nInvokes a closure, capturing the cause of an unwinding panic if one occurs.\n\nThis function will return `Ok` with the closure’s result if the closure does not panic, and will return `Err(cause)` if the closure panics. The `cause` returned is the object with which panic was originally invoked.\n\nIt is currently undefined behavior to unwind from Rust code into foreign code, so this function is particularly useful when Rust is called from another language (normally C). This can run arbitrary Rust code, capturing a panic and allowing a graceful handling of the error.\n\nIt is **not** recommended to use this function for a general try/catch mechanism. The [`Result`](../thread/type.Result.html \"type std::thread::Result\") type is more appropriate to use for functions that can fail on a regular basis. Additionally, this function is not guaranteed to catch all panics, see the “Notes” section below.\n\nThe closure provided is required to adhere to the [`UnwindSafe`](trait.UnwindSafe.html \"trait std::panic::UnwindSafe\") trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of [exception safety](https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md) in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without `unsafe` code. If it becomes a problem the [`AssertUnwindSafe`](struct.AssertUnwindSafe.html \"struct std::panic::AssertUnwindSafe\") wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.\n\n## [§](#notes)Notes\n\nNote that this function **might not catch all panics** in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function _only_ catches unwinding panics, not those that abort the process.\n\nNote that if a custom panic hook has been set, it will be invoked before the panic is caught, before unwinding.\n\nAlso note that unwinding into Rust code with a foreign exception (e.g. an exception thrown from C++ code) is undefined behavior.\n\nFinally, be **careful in how you drop the result of this function**. If it is `Err`, it contains the panic payload, and dropping that may in turn panic!\n\n## [§](#examples)Examples\n\n```\nuse std::panic;\n\nlet result = panic::catch_unwind(|| {\n    println!(\"hello!\");\n});\nassert!(result.is_ok());\n\nlet result = panic::catch_unwind(|| {\n    panic!(\"oh no!\");\n});\nassert!(result.is_err());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::panic;%0A++++%0A++++let+result+=+panic::catch_unwind(%7C%7C+%7B%0A++++++++println!(%22hello!%22);%0A++++%7D);%0A++++assert!(result.is_ok());%0A++++%0A++++let+result+=+panic::catch_unwind(%7C%7C+%7B%0A++++++++panic!(%22oh+no!%22);%0A++++%7D);%0A++++assert!(result.is_err());%0A%7D&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Invokes a closure, capturing the cause of an unwinding panic if one occurs.\"><title>catch_unwind in std::panic - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::panic</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.AssertUnwindSafe.html\">AssertUnwindSafe</a></li><li><a href=\"struct.Location.html\">Location</a></li><li><a href=\"struct.PanicInfo.html\">PanicInfo</a></li></ul><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.BacktraceStyle.html\">BacktraceStyle</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.RefUnwindSafe.html\">RefUnwindSafe</a></li><li><a href=\"trait.UnwindSafe.html\">UnwindSafe</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.always_abort.html\">always_abort</a></li><li><a href=\"fn.catch_unwind.html\">catch_unwind</a></li><li><a href=\"fn.get_backtrace_style.html\">get_backtrace_style</a></li><li><a href=\"fn.panic_any.html\">panic_any</a></li><li><a href=\"fn.resume_unwind.html\">resume_unwind</a></li><li><a href=\"fn.set_backtrace_style.html\">set_backtrace_style</a></li><li><a href=\"fn.set_hook.html\">set_hook</a></li><li><a href=\"fn.take_hook.html\">take_hook</a></li><li><a href=\"fn.update_hook.html\">update_hook</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">panic</a>::<wbr><a class=\"fn\" href=\"#\">catch_unwind</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.9.0\">1.9.0</span> · <a class=\"src\" href=\"../../src/std/panic.rs.html#148-150\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub fn catch_unwind&lt;F: <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>() -&gt; R + <a class=\"trait\" href=\"trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a>, R&gt;(f: F) -&gt; <a class=\"type\" href=\"../thread/type.Result.html\" title=\"type std::thread::Result\">Result</a>&lt;R&gt;</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Invokes a closure, capturing the cause of an unwinding panic if one occurs.</p>\n<p>This function will return <code>Ok</code> with the closure’s result if the closure\ndoes not panic, and will return <code>Err(cause)</code> if the closure panics. The\n<code>cause</code> returned is the object with which panic was originally invoked.</p>\n<p>It is currently undefined behavior to unwind from Rust code into foreign\ncode, so this function is particularly useful when Rust is called from\nanother language (normally C). This can run arbitrary Rust code, capturing a\npanic and allowing a graceful handling of the error.</p>\n<p>It is <strong>not</strong> recommended to use this function for a general try/catch\nmechanism. The <a href=\"../thread/type.Result.html\" title=\"type std::thread::Result\"><code>Result</code></a> type is more appropriate to use for functions that\ncan fail on a regular basis. Additionally, this function is not guaranteed\nto catch all panics, see the “Notes” section below.</p>\n<p>The closure provided is required to adhere to the <a href=\"trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\"><code>UnwindSafe</code></a> trait to ensure\nthat all captured variables are safe to cross this boundary. The purpose of\nthis bound is to encode the concept of <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\">exception safety</a> in the type\nsystem. Most usage of this function should not need to worry about this\nbound as programs are naturally unwind safe without <code>unsafe</code> code. If it\nbecomes a problem the <a href=\"struct.AssertUnwindSafe.html\" title=\"struct std::panic::AssertUnwindSafe\"><code>AssertUnwindSafe</code></a> wrapper struct can be used to quickly\nassert that the usage here is indeed unwind safe.</p>\n<h2 id=\"notes\"><a class=\"doc-anchor\" href=\"#notes\">§</a>Notes</h2>\n<p>Note that this function <strong>might not catch all panics</strong> in Rust. A panic in\nRust is not always implemented via unwinding, but can be implemented by\naborting the process as well. This function <em>only</em> catches unwinding panics,\nnot those that abort the process.</p>\n<p>Note that if a custom panic hook has been set, it will be invoked before\nthe panic is caught, before unwinding.</p>\n<p>Also note that unwinding into Rust code with a foreign exception (e.g.\nan exception thrown from C++ code) is undefined behavior.</p>\n<p>Finally, be <strong>careful in how you drop the result of this function</strong>.\nIf it is <code>Err</code>, it contains the panic payload, and dropping that may in turn panic!</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::panic;\n\n<span class=\"kw\">let </span>result = panic::catch_unwind(|| {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"hello!\"</span>);\n});\n<span class=\"macro\">assert!</span>(result.is_ok());\n\n<span class=\"kw\">let </span>result = panic::catch_unwind(|| {\n    <span class=\"macro\">panic!</span>(<span class=\"string\">\"oh no!\"</span>);\n});\n<span class=\"macro\">assert!</span>(result.is_err());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::panic;%0A++++%0A++++let+result+=+panic::catch_unwind(%7C%7C+%7B%0A++++++++println!(%22hello!%22);%0A++++%7D);%0A++++assert!(result.is_ok());%0A++++%0A++++let+result+=+panic::catch_unwind(%7C%7C+%7B%0A++++++++panic!(%22oh+no!%22);%0A++++%7D);%0A++++assert!(result.is_err());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:22:59.608Z"
}