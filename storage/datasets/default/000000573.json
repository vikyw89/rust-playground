{
	"title": "Rc in std::rc - Rust",
	"url": "https://doc.rust-lang.org/stable/std/rc/struct.Rc.html",
	"markdown": "# Rc in std::rc - Rust\n\n## Struct [std](../index.html)::[rc](index.html)::[Rc](#)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#315-318) Â·\n\n```\npub struct Rc<T, A = Global>where\n    A: Allocator,\n    T: ?Sized,{ /* private fields */ }\n```\n\nExpand description\n\nA single-threaded reference-counting pointer. â€˜Rcâ€™ stands for â€˜Reference Countedâ€™.\n\nSee the [module-level documentation](./index.html) for more details.\n\nThe inherent methods of `Rc` are all associated functions, which means that you have to call them as e.g., [`Rc::get_mut(&mut value)`](about:blank/struct.Rc.html#method.get_mut \"associated function std::rc::Rc::get_mut\") instead of `value.get_mut()`. This avoids conflicts with methods of the inner type `T`.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#383)[Â§](#impl-Rc%3CT%3E)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#395)\n\nConstructs a new `Rc<T>`.\n\n##### [Â§](#examples)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A%7D&edition=2021)\n\n1.60.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#461-463)\n\nConstructs a new `Rc<T>` while giving you a `Weak<T>` to the allocation, to allow you to construct a `T` which holds a weak pointer to itself.\n\nGenerally, a structure circularly referencing itself, either directly or indirectly, should not hold a strong reference to itself to prevent a memory leak. Using this function, you get access to the weak pointer during the initialization of `T`, before the `Rc<T>` is created, such that you can clone and store it inside the `T`.\n\n`new_cyclic` first allocates the managed allocation for the `Rc<T>`, then calls your closure, giving it a `Weak<T>` to this allocation, and only afterwards completes the construction of the `Rc<T>` by placing the `T` returned from your closure into the allocation.\n\nSince the new `Rc<T>` is not fully-constructed until `Rc<T>::new_cyclic` returns, calling [`upgrade`](about:blank/struct.Weak.html#method.upgrade \"method std::rc::Weak::upgrade\") on the weak reference inside your closure will fail and result in a `None` value.\n\n##### [Â§](#panics)Panics\n\nIf `data_fn` panics, the panic is propagated to the caller, and the temporary [`Weak<T>`](struct.Weak.html \"struct std::rc::Weak\") is dropped normally.\n\n##### [Â§](#examples-1)Examples\n\n```\nuse std::rc::{Rc, Weak};\n\nstruct Gadget {\n    me: Weak<Gadget>,\n}\n\nimpl Gadget {\n    /// Construct a reference counted Gadget.\n    fn new() -> Rc<Self> {\n        // `me` is a `Weak<Gadget>` pointing at the new allocation of the\n        // `Rc` we're constructing.\n        Rc::new_cyclic(|me| {\n            // Create the actual struct here.\n            Gadget { me: me.clone() }\n        })\n    }\n\n    /// Return a reference counted pointer to Self.\n    fn me(&self) -> Rc<Self> {\n        self.me.upgrade().unwrap()\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::rc::%7BRc,+Weak%7D;%0A++++%0A++++struct+Gadget+%7B%0A++++++++me:+Weak%3CGadget%3E,%0A++++%7D%0A++++%0A++++impl+Gadget+%7B%0A++++++++///+Construct+a+reference+counted+Gadget.%0A++++++++fn+new()+-%3E+Rc%3CSelf%3E+%7B%0A++++++++++++//+%60me%60+is+a+%60Weak%3CGadget%3E%60+pointing+at+the+new+allocation+of+the%0A++++++++++++//+%60Rc%60+we%27re+constructing.%0A++++++++++++Rc::new_cyclic(%7Cme%7C+%7B%0A++++++++++++++++//+Create+the+actual+struct+here.%0A++++++++++++++++Gadget+%7B+me:+me.clone()+%7D%0A++++++++++++%7D)%0A++++++++%7D%0A++++%0A++++++++///+Return+a+reference+counted+pointer+to+Self.%0A++++++++fn+me(%26self)+-%3E+Rc%3CSelf%3E+%7B%0A++++++++++++self.me.upgrade().unwrap()%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#525)\n\nðŸ”¬This is a nightly-only experimental API. (`new_uninit`Â [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new `Rc` with uninitialized contents.\n\n##### [Â§](#examples-2)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::rc::Rc;\n\nlet mut five = Rc::<u32>::new_uninit();\n\n// Deferred initialization:\nRc::get_mut(&mut five).unwrap().write(5);\n\nlet five = unsafe { five.assume_init() };\n\nassert_eq!(*five, 5)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32%3E::new_uninit();%0A++++%0A++++//+Deferred+initialization:%0A++++Rc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#558)\n\nðŸ”¬This is a nightly-only experimental API. (`new_uninit`Â [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new `Rc` with uninitialized contents, with the memory being filled with `0` bytes.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [Â§](#examples-3)Examples\n\n```\n#![feature(new_uninit)]\n\nuse std::rc::Rc;\n\nlet zero = Rc::<u32>::new_zeroed();\nlet zero = unsafe { zero.assume_init() };\n\nassert_eq!(*zero, 0)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+zero+=+Rc::%3Cu32%3E::new_zeroed();%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#580)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Rc<T>`, returning an error if the allocation fails\n\n##### [Â§](#examples-4)Examples\n\n```\n#![feature(allocator_api)]\nuse std::rc::Rc;\n\nlet five = Rc::try_new(5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::try_new(5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#615)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Rc` with uninitialized contents, returning an error if the allocation fails\n\n##### [Â§](#examples-5)Examples\n\n```\n#![feature(allocator_api, new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::rc::Rc;\n\nlet mut five = Rc::<u32>::try_new_uninit()?;\n\n// Deferred initialization:\nRc::get_mut(&mut five).unwrap().write(5);\n\nlet five = unsafe { five.assume_init() };\n\nassert_eq!(*five, 5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api,+new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32%3E::try_new_uninit()?;%0A++++%0A++++//+Deferred+initialization:%0A++++Rc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#648)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Rc` with uninitialized contents, with the memory being filled with `0` bytes, returning an error if the allocation fails\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [Â§](#examples-6)Examples\n\n```\n#![feature(allocator_api, new_uninit)]\n\nuse std::rc::Rc;\n\nlet zero = Rc::<u32>::try_new_zeroed()?;\nlet zero = unsafe { zero.assume_init() };\n\nassert_eq!(*zero, 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api,+new_uninit)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+zero+=+Rc::%3Cu32%3E::try_new_zeroed()?;%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n1.33.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#662)\n\nConstructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then `value` will be pinned in memory and unable to be moved.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#667)[Â§](#impl-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#675)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nReturns a reference to the underlying allocator.\n\nNote: this is an associated function, which means that you have to call it as `Rc::allocator(&r)` instead of `r.allocator()`. This is so that there is no conflict with a method on the inner type.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#692)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Rc` in the provided allocator.\n\n##### [Â§](#examples-7)Examples\n\n```\n#![feature(allocator_api)]\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet five = Rc::new_in(5, System);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Rc::new_in(5,+System);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#728)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Rc` with uninitialized contents in the provided allocator.\n\n##### [Â§](#examples-8)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n#![feature(allocator_api)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet mut five = Rc::<u32, _>::new_uninit_in(System);\n\nlet five = unsafe {\n    // Deferred initialization:\n    Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n\n    five.assume_init()\n};\n\nassert_eq!(*five, 5)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32,+_%3E::new_uninit_in(System);%0A++++%0A++++let+five+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Rc::get_mut_unchecked(%26mut+five).as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#767)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Rc` with uninitialized contents, with the memory being filled with `0` bytes, in the provided allocator.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [Â§](#examples-9)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(allocator_api)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet zero = Rc::<u32, _>::new_zeroed_in(System);\nlet zero = unsafe { zero.assume_init() };\n\nassert_eq!(*zero, 0)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+zero+=+Rc::%3Cu32,+_%3E::new_zeroed_in(System);%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#795)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Rc<T>` in the provided allocator, returning an error if the allocation fails\n\n##### [Â§](#examples-10)Examples\n\n```\n#![feature(allocator_api)]\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet five = Rc::try_new_in(5, System);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Rc::try_new_in(5,+System);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#834)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Rc` with uninitialized contents, in the provided allocator, returning an error if the allocation fails\n\n##### [Â§](#examples-11)Examples\n\n```\n#![feature(allocator_api, new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet mut five = Rc::<u32, _>::try_new_uninit_in(System)?;\n\nlet five = unsafe {\n    // Deferred initialization:\n    Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n\n    five.assume_init()\n};\n\nassert_eq!(*five, 5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api,+new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32,+_%3E::try_new_uninit_in(System)?;%0A++++%0A++++let+five+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Rc::get_mut_unchecked(%26mut+five).as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#873)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Rc` with uninitialized contents, with the memory being filled with `0` bytes, in the provided allocator, returning an error if the allocation fails\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [Â§](#examples-12)Examples\n\n```\n#![feature(allocator_api, new_uninit)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet zero = Rc::<u32, _>::try_new_zeroed_in(System)?;\nlet zero = unsafe { zero.assume_init() };\n\nassert_eq!(*zero, 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api,+new_uninit)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+zero+=+Rc::%3Cu32,+_%3E::try_new_zeroed_in(System)?;%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#891-893)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Pin<Rc<T>>` in the provided allocator. If `T` does not implement `Unpin`, then `value` will be pinned in memory and unable to be moved.\n\n1.4.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#919)\n\nReturns the inner value, if the `Rc` has exactly one strong reference.\n\nOtherwise, an [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") is returned with the same `Rc` that was passed in.\n\nThis will succeed even if there are outstanding weak references.\n\n##### [Â§](#examples-13)Examples\n\n```\nuse std::rc::Rc;\n\nlet x = Rc::new(3);\nassert_eq!(Rc::try_unwrap(x), Ok(3));\n\nlet x = Rc::new(4);\nlet _y = Rc::clone(&x);\nassert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(3);%0A++++assert_eq!(Rc::try_unwrap(x),+Ok(3));%0A++++%0A++++let+x+=+Rc::new(4);%0A++++let+_y+=+Rc::clone(%26x);%0A++++assert_eq!(*Rc::try_unwrap(x).unwrap_err(),+4);%0A%7D&edition=2021)\n\n1.70.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#971)\n\nReturns the inner value, if the `Rc` has exactly one strong reference.\n\nOtherwise, [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned and the `Rc` is dropped.\n\nThis will succeed even if there are outstanding weak references.\n\nIf `Rc::into_inner` is called on every clone of this `Rc`, it is guaranteed that exactly one of the calls returns the inner value. This means in particular that the inner value is not dropped.\n\n[`Rc::try_unwrap`](about:blank/struct.Rc.html#method.try_unwrap \"associated function std::rc::Rc::try_unwrap\") is conceptually similar to `Rc::into_inner`. And while they are meant for different use-cases, `Rc::into_inner(this)` is in fact equivalent to `[Rc::try_unwrap](about:blank/struct.Rc.html#method.try_unwrap \"associated function std::rc::Rc::try_unwrap\")(this).[ok](about:blank/result/enum.Result.html#method.ok \"method std::result::Result::ok\")()`. (Note that the same kind of equivalence does **not** hold true for [`Arc`](../sync/struct.Arc.html \"struct std::sync::Arc\"), due to race conditions that do not apply to `Rc`!)\n\n##### [Â§](#examples-14)Examples\n\n```\nuse std::rc::Rc;\n\nlet x = Rc::new(3);\nassert_eq!(Rc::into_inner(x), Some(3));\n\nlet x = Rc::new(4);\nlet y = Rc::clone(&x);\n\nassert_eq!(Rc::into_inner(y), None);\nassert_eq!(Rc::into_inner(x), Some(4));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(3);%0A++++assert_eq!(Rc::into_inner(x),+Some(3));%0A++++%0A++++let+x+=+Rc::new(4);%0A++++let+y+=+Rc::clone(%26x);%0A++++%0A++++assert_eq!(Rc::into_inner(y),+None);%0A++++assert_eq!(Rc::into_inner(x),+Some(4));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#976)[Â§](#impl-Rc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1002)\n\nðŸ”¬This is a nightly-only experimental API. (`new_uninit`Â [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new reference-counted slice with uninitialized contents.\n\n##### [Â§](#examples-15)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::rc::Rc;\n\nlet mut values = Rc::<[u32]>::new_uninit_slice(3);\n\n// Deferred initialization:\nlet data = Rc::get_mut(&mut values).unwrap();\ndata[0].write(1);\ndata[1].write(2);\ndata[2].write(3);\n\nlet values = unsafe { values.assume_init() };\n\nassert_eq!(*values, [1, 2, 3])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+values+=+Rc::%3C%5Bu32%5D%3E::new_uninit_slice(3);%0A++++%0A++++//+Deferred+initialization:%0A++++let+data+=+Rc::get_mut(%26mut+values).unwrap();%0A++++data%5B0%5D.write(1);%0A++++data%5B1%5D.write(2);%0A++++data%5B2%5D.write(3);%0A++++%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1029)\n\nðŸ”¬This is a nightly-only experimental API. (`new_uninit`Â [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new reference-counted slice with uninitialized contents, with the memory being filled with `0` bytes.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [Â§](#examples-16)Examples\n\n```\n#![feature(new_uninit)]\n\nuse std::rc::Rc;\n\nlet values = Rc::<[u32]>::new_zeroed_slice(3);\nlet values = unsafe { values.assume_init() };\n\nassert_eq!(*values, [0, 0, 0])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+values+=+Rc::%3C%5Bu32%5D%3E::new_zeroed_slice(3);%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B0,+0,+0%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1043)[Â§](#impl-Rc%3C%5BT%5D,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1073)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new reference-counted slice with uninitialized contents.\n\n##### [Â§](#examples-17)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n#![feature(allocator_api)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet mut values = Rc::<[u32], _>::new_uninit_slice_in(3, System);\n\nlet values = unsafe {\n    // Deferred initialization:\n    Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n    Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n    Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n\n    values.assume_init()\n};\n\nassert_eq!(*values, [1, 2, 3])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+values+=+Rc::%3C%5Bu32%5D,+_%3E::new_uninit_slice_in(3,+System);%0A++++%0A++++let+values+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Rc::get_mut_unchecked(%26mut+values)%5B0%5D.as_mut_ptr().write(1);%0A++++++++Rc::get_mut_unchecked(%26mut+values)%5B1%5D.as_mut_ptr().write(2);%0A++++++++Rc::get_mut_unchecked(%26mut+values)%5B2%5D.as_mut_ptr().write(3);%0A++++%0A++++++++values.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1103)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new reference-counted slice with uninitialized contents, with the memory being filled with `0` bytes.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [Â§](#examples-18)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(allocator_api)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet values = Rc::<[u32], _>::new_zeroed_slice_in(3, System);\nlet values = unsafe { values.assume_init() };\n\nassert_eq!(*values, [0, 0, 0])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+values+=+Rc::%3C%5Bu32%5D,+_%3E::new_zeroed_slice_in(3,+System);%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B0,+0,+0%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1120)[Â§](#impl-Rc%3CMaybeUninit%3CT%3E,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1152)\n\nðŸ”¬This is a nightly-only experimental API. (`new_uninit`Â [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConverts to `Rc<T>`.\n\n##### [Â§](#safety)Safety\n\nAs with [`MaybeUninit::assume_init`](about:blank/mem/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\"), it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.\n\n##### [Â§](#examples-19)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::rc::Rc;\n\nlet mut five = Rc::<u32>::new_uninit();\n\n// Deferred initialization:\nRc::get_mut(&mut five).unwrap().write(5);\n\nlet five = unsafe { five.assume_init() };\n\nassert_eq!(*five, 5)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32%3E::new_uninit();%0A++++%0A++++//+Deferred+initialization:%0A++++Rc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1158)[Â§](#impl-Rc%3C%5BMaybeUninit%3CT%3E%5D,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1193)\n\nðŸ”¬This is a nightly-only experimental API. (`new_uninit`Â [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConverts to `Rc<[T]>`.\n\n##### [Â§](#safety-1)Safety\n\nAs with [`MaybeUninit::assume_init`](about:blank/mem/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\"), it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.\n\n##### [Â§](#examples-20)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::rc::Rc;\n\nlet mut values = Rc::<[u32]>::new_uninit_slice(3);\n\n// Deferred initialization:\nlet data = Rc::get_mut(&mut values).unwrap();\ndata[0].write(1);\ndata[1].write(2);\ndata[2].write(3);\n\nlet values = unsafe { values.assume_init() };\n\nassert_eq!(*values, [1, 2, 3])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+values+=+Rc::%3C%5Bu32%5D%3E::new_uninit_slice(3);%0A++++%0A++++//+Deferred+initialization:%0A++++let+data+=+Rc::get_mut(%26mut+values).unwrap();%0A++++data%5B0%5D.write(1);%0A++++data%5B1%5D.write(2);%0A++++data%5B2%5D.write(3);%0A++++%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1199)[Â§](#impl-Rc%3CT%3E-1)\n\n1.17.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1263)\n\nConstructs an `Rc<T>` from a raw pointer.\n\nThe raw pointer must have been previously returned by a call to [`Rc<U>::into_raw`](about:blank/struct.Rc.html#method.into_raw \"associated function std::rc::Rc::into_raw\") with the following requirements:\n\n-   If `U` is sized, it must have the same size and alignment as `T`. This is trivially true if `U` is `T`.\n-   If `U` is unsized, its data pointer must have the same size and alignment as `T`. This is trivially true if `Rc<U>` was constructed through `Rc<T>` and then converted to `Rc<U>` through an [unsized coercion](https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions).\n\nNote that if `U` or `U`â€™s data pointer is not `T` but has the same size and alignment, this is basically like transmuting references of different types. See [`mem::transmute`](../mem/fn.transmute.html \"fn std::mem::transmute\") for more information on what restrictions apply in this case.\n\nThe raw pointer must point to a block of memory allocated by the global allocator\n\nThe user of `from_raw` has to make sure a specific value of `T` is only dropped once.\n\nThis function is unsafe because improper use may lead to memory unsafety, even if the returned `Rc<T>` is never accessed.\n\n##### [Â§](#examples-21)Examples\n\n```\nuse std::rc::Rc;\n\nlet x = Rc::new(\"hello\".to_owned());\nlet x_ptr = Rc::into_raw(x);\n\nunsafe {\n    // Convert back to an `Rc` to prevent leak.\n    let x = Rc::from_raw(x_ptr);\n    assert_eq!(&*x, \"hello\");\n\n    // Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.\n}\n\n// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(%22hello%22.to_owned());%0A++++let+x_ptr+=+Rc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++//+Convert+back+to+an+%60Rc%60+to+prevent+leak.%0A++++++++let+x+=+Rc::from_raw(x_ptr);%0A++++++++assert_eq!(%26*x,+%22hello%22);%0A++++%0A++++++++//+Further+calls+to+%60Rc::from_raw(x_ptr)%60+would+be+memory-unsafe.%0A++++%7D%0A++++%0A++++//+The+memory+was+freed+when+%60x%60+went+out+of+scope+above,+so+%60x_ptr%60+is+now+dangling!%0A%7D&edition=2021)\n\nConvert a slice back into its original array:\n\n```\nuse std::rc::Rc;\n\nlet x: Rc<[u32]> = Rc::new([1, 2, 3]);\nlet x_ptr: *const [u32] = Rc::into_raw(x);\n\nunsafe {\n    let x: Rc<[u32; 3]> = Rc::from_raw(x_ptr.cast::<[u32; 3]>());\n    assert_eq!(&*x, &[1, 2, 3]);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3C%5Bu32%5D%3E+=+Rc::new(%5B1,+2,+3%5D);%0A++++let+x_ptr:+*const+%5Bu32%5D+=+Rc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++let+x:+Rc%3C%5Bu32;+3%5D%3E+=+Rc::from_raw(x_ptr.cast::%3C%5Bu32;+3%5D%3E());%0A++++++++assert_eq!(%26*x,+%26%5B1,+2,+3%5D);%0A++++%7D%0A%7D&edition=2021)\n\n1.53.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1294)\n\nIncrements the strong reference count on the `Rc<T>` associated with the provided pointer by one.\n\n##### [Â§](#safety-2)Safety\n\nThe pointer must have been obtained through `Rc::into_raw`, the associated `Rc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method, and `ptr` must point to a block of memory allocated by the global allocator.\n\n##### [Â§](#examples-22)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nunsafe {\n    let ptr = Rc::into_raw(five);\n    Rc::increment_strong_count(ptr);\n\n    let five = Rc::from_raw(ptr);\n    assert_eq!(2, Rc::strong_count(&five));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Rc::into_raw(five);%0A++++++++Rc::increment_strong_count(ptr);%0A++++%0A++++++++let+five+=+Rc::from_raw(ptr);%0A++++++++assert_eq!(2,+Rc::strong_count(%26five));%0A++++%7D%0A%7D&edition=2021)\n\n1.53.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1328)\n\nDecrements the strong reference count on the `Rc<T>` associated with the provided pointer by one.\n\n##### [Â§](#safety-3)Safety\n\nThe pointer must have been obtained through `Rc::into_raw`, the associated `Rc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method, and `ptr` must point to a block of memory allocated by the global allocator. This method can be used to release the final `Rc` and backing storage, but **should not** be called after the final `Rc` has been released.\n\n##### [Â§](#examples-23)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nunsafe {\n    let ptr = Rc::into_raw(five);\n    Rc::increment_strong_count(ptr);\n\n    let five = Rc::from_raw(ptr);\n    assert_eq!(2, Rc::strong_count(&five));\n    Rc::decrement_strong_count(ptr);\n    assert_eq!(1, Rc::strong_count(&five));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Rc::into_raw(five);%0A++++++++Rc::increment_strong_count(ptr);%0A++++%0A++++++++let+five+=+Rc::from_raw(ptr);%0A++++++++assert_eq!(2,+Rc::strong_count(%26five));%0A++++++++Rc::decrement_strong_count(ptr);%0A++++++++assert_eq!(1,+Rc::strong_count(%26five));%0A++++%7D%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1333)[Â§](#impl-Rc%3CT,+A%3E-1)\n\n1.17.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1351)\n\nConsumes the `Rc`, returning the wrapped pointer.\n\nTo avoid a memory leak the pointer must be converted back to an `Rc` using [`Rc::from_raw`](about:blank/struct.Rc.html#method.from_raw \"associated function std::rc::Rc::from_raw\").\n\n##### [Â§](#examples-24)Examples\n\n```\nuse std::rc::Rc;\n\nlet x = Rc::new(\"hello\".to_owned());\nlet x_ptr = Rc::into_raw(x);\nassert_eq!(unsafe { &*x_ptr }, \"hello\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(%22hello%22.to_owned());%0A++++let+x_ptr+=+Rc::into_raw(x);%0A++++assert_eq!(unsafe+%7B+%26*x_ptr+%7D,+%22hello%22);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1376)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConsumes the `Rc`, returning the wrapped pointer and allocator.\n\nTo avoid a memory leak the pointer must be converted back to an `Rc` using [`Rc::from_raw_in`](about:blank/struct.Rc.html#method.from_raw_in \"associated function std::rc::Rc::from_raw_in\").\n\n##### [Â§](#examples-25)Examples\n\n```\n#![feature(allocator_api)]\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet x = Rc::new_in(\"hello\".to_owned(), System);\nlet (ptr, alloc) = Rc::into_raw_with_allocator(x);\nassert_eq!(unsafe { &*ptr }, \"hello\");\nlet x = unsafe { Rc::from_raw_in(ptr, alloc) };\nassert_eq!(&*x, \"hello\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x+=+Rc::new_in(%22hello%22.to_owned(),+System);%0A++++let+(ptr,+alloc)+=+Rc::into_raw_with_allocator(x);%0A++++assert_eq!(unsafe+%7B+%26*ptr+%7D,+%22hello%22);%0A++++let+x+=+unsafe+%7B+Rc::from_raw_in(ptr,+alloc)+%7D;%0A++++assert_eq!(%26*x,+%22hello%22);%0A%7D&version=nightly&edition=2021)\n\n1.45.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1402)\n\nProvides a raw pointer to the data.\n\nThe counts are not affected in any way and the `Rc` is not consumed. The pointer is valid for as long there are strong counts in the `Rc`.\n\n##### [Â§](#examples-26)Examples\n\n```\nuse std::rc::Rc;\n\nlet x = Rc::new(\"hello\".to_owned());\nlet y = Rc::clone(&x);\nlet x_ptr = Rc::as_ptr(&x);\nassert_eq!(x_ptr, Rc::as_ptr(&y));\nassert_eq!(unsafe { &*x_ptr }, \"hello\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(%22hello%22.to_owned());%0A++++let+y+=+Rc::clone(%26x);%0A++++let+x_ptr+=+Rc::as_ptr(%26x);%0A++++assert_eq!(x_ptr,+Rc::as_ptr(%26y));%0A++++assert_eq!(unsafe+%7B+%26*x_ptr+%7D,+%22hello%22);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1479)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs an `Rc<T, A>` from a raw pointer in the provided allocator.\n\nThe raw pointer must have been previously returned by a call to [`Rc<U, A>::into_raw`](about:blank/struct.Rc.html#method.into_raw \"associated function std::rc::Rc::into_raw\") with the following requirements:\n\n-   If `U` is sized, it must have the same size and alignment as `T`. This is trivially true if `U` is `T`.\n-   If `U` is unsized, its data pointer must have the same size and alignment as `T`. This is trivially true if `Rc<U>` was constructed through `Rc<T>` and then converted to `Rc<U>` through an [unsized coercion](https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions).\n\nNote that if `U` or `U`â€™s data pointer is not `T` but has the same size and alignment, this is basically like transmuting references of different types. See [`mem::transmute`](../mem/fn.transmute.html \"fn std::mem::transmute\") for more information on what restrictions apply in this case.\n\nThe raw pointer must point to a block of memory allocated by `alloc`\n\nThe user of `from_raw` has to make sure a specific value of `T` is only dropped once.\n\nThis function is unsafe because improper use may lead to memory unsafety, even if the returned `Rc<T>` is never accessed.\n\n##### [Â§](#examples-27)Examples\n\n```\n#![feature(allocator_api)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet x = Rc::new_in(\"hello\".to_owned(), System);\nlet x_ptr = Rc::into_raw(x);\n\nunsafe {\n    // Convert back to an `Rc` to prevent leak.\n    let x = Rc::from_raw_in(x_ptr, System);\n    assert_eq!(&*x, \"hello\");\n\n    // Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.\n}\n\n// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x+=+Rc::new_in(%22hello%22.to_owned(),+System);%0A++++let+x_ptr+=+Rc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++//+Convert+back+to+an+%60Rc%60+to+prevent+leak.%0A++++++++let+x+=+Rc::from_raw_in(x_ptr,+System);%0A++++++++assert_eq!(%26*x,+%22hello%22);%0A++++%0A++++++++//+Further+calls+to+%60Rc::from_raw(x_ptr)%60+would+be+memory-unsafe.%0A++++%7D%0A++++%0A++++//+The+memory+was+freed+when+%60x%60+went+out+of+scope+above,+so+%60x_ptr%60+is+now+dangling!%0A%7D&version=nightly&edition=2021)\n\nConvert a slice back into its original array:\n\n```\n#![feature(allocator_api)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet x: Rc<[u32], _> = Rc::new_in([1, 2, 3], System);\nlet x_ptr: *const [u32] = Rc::into_raw(x);\n\nunsafe {\n    let x: Rc<[u32; 3], _> = Rc::from_raw_in(x_ptr.cast::<[u32; 3]>(), System);\n    assert_eq!(&*x, &[1, 2, 3]);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x:+Rc%3C%5Bu32%5D,+_%3E+=+Rc::new_in(%5B1,+2,+3%5D,+System);%0A++++let+x_ptr:+*const+%5Bu32%5D+=+Rc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++let+x:+Rc%3C%5Bu32;+3%5D,+_%3E+=+Rc::from_raw_in(x_ptr.cast::%3C%5Bu32;+3%5D%3E(),+System);%0A++++++++assert_eq!(%26*x,+%26%5B1,+2,+3%5D);%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n1.4.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1502-1504)\n\nCreates a new [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointer to this allocation.\n\n##### [Â§](#examples-28)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nlet weak_five = Rc::downgrade(&five);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++let+weak_five+=+Rc::downgrade(%26five);%0A%7D&edition=2021)\n\n1.15.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1526)\n\nGets the number of [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointers to this allocation.\n\n##### [Â§](#examples-29)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\nlet _weak_five = Rc::downgrade(&five);\n\nassert_eq!(1, Rc::weak_count(&five));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++let+_weak_five+=+Rc::downgrade(%26five);%0A++++%0A++++assert_eq!(1,+Rc::weak_count(%26five));%0A%7D&edition=2021)\n\n1.15.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1544)\n\nGets the number of strong (`Rc`) pointers to this allocation.\n\n##### [Â§](#examples-30)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\nlet _also_five = Rc::clone(&five);\n\nassert_eq!(2, Rc::strong_count(&five));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++let+_also_five+=+Rc::clone(%26five);%0A++++%0A++++assert_eq!(2,+Rc::strong_count(%26five));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1578-1580)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nIncrements the strong reference count on the `Rc<T>` associated with the provided pointer by one.\n\n##### [Â§](#safety-4)Safety\n\nThe pointer must have been obtained through `Rc::into_raw`, the associated `Rc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method, and `ptr` must point to a block of memory allocated by `alloc`\n\n##### [Â§](#examples-31)Examples\n\n```\n#![feature(allocator_api)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet five = Rc::new_in(5, System);\n\nunsafe {\n    let ptr = Rc::into_raw(five);\n    Rc::increment_strong_count_in(ptr, System);\n\n    let five = Rc::from_raw_in(ptr, System);\n    assert_eq!(2, Rc::strong_count(&five));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Rc::new_in(5,+System);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Rc::into_raw(five);%0A++++++++Rc::increment_strong_count_in(ptr,+System);%0A++++%0A++++++++let+five+=+Rc::from_raw_in(ptr,+System);%0A++++++++assert_eq!(2,+Rc::strong_count(%26five));%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1621)\n\nðŸ”¬This is a nightly-only experimental API. (`allocator_api`Â [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nDecrements the strong reference count on the `Rc<T>` associated with the provided pointer by one.\n\n##### [Â§](#safety-5)Safety\n\nThe pointer must have been obtained through `Rc::into_raw`, the associated `Rc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method, and `ptr` must point to a block of memory allocated by `alloc`. This method can be used to release the final `Rc` and backing storage, but **should not** be called after the final `Rc` has been released.\n\n##### [Â§](#examples-32)Examples\n\n```\n#![feature(allocator_api)]\n\nuse std::rc::Rc;\nuse std::alloc::System;\n\nlet five = Rc::new_in(5, System);\n\nunsafe {\n    let ptr = Rc::into_raw(five);\n    Rc::increment_strong_count_in(ptr, System);\n\n    let five = Rc::from_raw_in(ptr, System);\n    assert_eq!(2, Rc::strong_count(&five));\n    Rc::decrement_strong_count_in(ptr, System);\n    assert_eq!(1, Rc::strong_count(&five));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Rc::new_in(5,+System);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Rc::into_raw(five);%0A++++++++Rc::increment_strong_count_in(ptr,+System);%0A++++%0A++++++++let+five+=+Rc::from_raw_in(ptr,+System);%0A++++++++assert_eq!(2,+Rc::strong_count(%26five));%0A++++++++Rc::decrement_strong_count_in(ptr,+System);%0A++++++++assert_eq!(1,+Rc::strong_count(%26five));%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n1.4.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1658)\n\nReturns a mutable reference into the given `Rc`, if there are no other `Rc` or [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointers to the same allocation.\n\nReturns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") otherwise, because it is not safe to mutate a shared value.\n\nSee also [`make_mut`](about:blank/struct.Rc.html#method.make_mut \"associated function std::rc::Rc::make_mut\"), which will [`clone`](about:blank/clone/trait.Clone.html#tymethod.clone \"method std::clone::Clone::clone\") the inner value when there are other `Rc` pointers.\n\n##### [Â§](#examples-33)Examples\n\n```\nuse std::rc::Rc;\n\nlet mut x = Rc::new(3);\n*Rc::get_mut(&mut x).unwrap() = 4;\nassert_eq!(*x, 4);\n\nlet _y = Rc::clone(&x);\nassert!(Rc::get_mut(&mut x).is_none());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+x+=+Rc::new(3);%0A++++*Rc::get_mut(%26mut+x).unwrap()+=+4;%0A++++assert_eq!(*x,+4);%0A++++%0A++++let+_y+=+Rc::clone(%26x);%0A++++assert!(Rc::get_mut(%26mut+x).is_none());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1724)\n\nðŸ”¬This is a nightly-only experimental API. (`get_mut_unchecked`Â [#63292](https://github.com/rust-lang/rust/issues/63292))\n\nReturns a mutable reference into the given `Rc`, without any check.\n\nSee also [`get_mut`](about:blank/struct.Rc.html#method.get_mut \"associated function std::rc::Rc::get_mut\"), which is safe and does appropriate checks.\n\n##### [Â§](#safety-6)Safety\n\nIf any other `Rc` or [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointers to the same allocation exist, then they must not be dereferenced or have active borrows for the duration of the returned borrow, and their inner type must be exactly the same as the inner type of this Rc (including lifetimes). This is trivially the case if no such pointers exist, for example immediately after `Rc::new`.\n\n##### [Â§](#examples-34)Examples\n\n```\n#![feature(get_mut_unchecked)]\n\nuse std::rc::Rc;\n\nlet mut x = Rc::new(String::new());\nunsafe {\n    Rc::get_mut_unchecked(&mut x).push_str(\"foo\")\n}\nassert_eq!(*x, \"foo\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+x+=+Rc::new(String::new());%0A++++unsafe+%7B%0A++++++++Rc::get_mut_unchecked(%26mut+x).push_str(%22foo%22)%0A++++%7D%0A++++assert_eq!(*x,+%22foo%22);%0A%7D&version=nightly&edition=2021)\n\nOther `Rc` pointers to the same allocation must be to the same type.\n\n```\n#![feature(get_mut_unchecked)]\n\nuse std::rc::Rc;\n\nlet x: Rc<str> = Rc::from(\"Hello, world!\");\nlet mut y: Rc<[u8]> = x.clone().into();\nunsafe {\n    // this is Undefined Behavior, because x's inner type is str, not [u8]\n    Rc::get_mut_unchecked(&mut y).fill(0xff); // 0xff is invalid in UTF-8\n}\nprintln!(\"{}\", &*x); // Invalid UTF-8 in a str\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3Cstr%3E+=+Rc::from(%22Hello,+world!%22);%0A++++let+mut+y:+Rc%3C%5Bu8%5D%3E+=+x.clone().into();%0A++++unsafe+%7B%0A++++++++//+this+is+Undefined+Behavior,+because+x%27s+inner+type+is+str,+not+%5Bu8%5D%0A++++++++Rc::get_mut_unchecked(%26mut+y).fill(0xff);+//+0xff+is+invalid+in+UTF-8%0A++++%7D%0A++++println!(%22%7B%7D%22,+%26*x);+//+Invalid+UTF-8+in+a+str%0A%7D&version=nightly&edition=2021)\n\nOther `Rc` pointers to the same allocation must be to the exact same type, including lifetimes.\n\n```\n#![feature(get_mut_unchecked)]\n\nuse std::rc::Rc;\n\nlet x: Rc<&str> = Rc::new(\"Hello, world!\");\n{\n    let s = String::from(\"Oh, no!\");\n    let mut y: Rc<&str> = x.clone().into();\n    unsafe {\n        // this is Undefined Behavior, because x's inner type\n        // is &'long str, not &'short str\n        *Rc::get_mut_unchecked(&mut y) = &s;\n    }\n}\nprintln!(\"{}\", &*x); // Use-after-free\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3C%26str%3E+=+Rc::new(%22Hello,+world!%22);%0A++++%7B%0A++++++++let+s+=+String::from(%22Oh,+no!%22);%0A++++++++let+mut+y:+Rc%3C%26str%3E+=+x.clone().into();%0A++++++++unsafe+%7B%0A++++++++++++//+this+is+Undefined+Behavior,+because+x%27s+inner+type%0A++++++++++++//+is+%26%27long+str,+not+%26%27short+str%0A++++++++++++*Rc::get_mut_unchecked(%26mut+y)+=+%26s;%0A++++++++%7D%0A++++%7D%0A++++println!(%22%7B%7D%22,+%26*x);+//+Use-after-free%0A%7D&version=nightly&edition=2021)\n\n1.17.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1747)\n\nReturns `true` if the two `Rc`s point to the same allocation in a vein similar to [`ptr::eq`](../ptr/fn.eq.html \"fn std::ptr::eq\"). This function ignores the metadata of `dyn Trait` pointers.\n\n##### [Â§](#examples-35)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\nlet same_five = Rc::clone(&five);\nlet other_five = Rc::new(5);\n\nassert!(Rc::ptr_eq(&five, &same_five));\nassert!(!Rc::ptr_eq(&five, &other_five));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++let+same_five+=+Rc::clone(%26five);%0A++++let+other_five+=+Rc::new(5);%0A++++%0A++++assert!(Rc::ptr_eq(%26five,+%26same_five));%0A++++assert!(!Rc::ptr_eq(%26five,+%26other_five));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1752)[Â§](#impl-Rc%3CT,+A%3E-2)\n\n1.4.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1806)\n\nMakes a mutable reference into the given `Rc`.\n\nIf there are other `Rc` pointers to the same allocation, then `make_mut` will [`clone`](about:blank/clone/trait.Clone.html#tymethod.clone \"method std::clone::Clone::clone\") the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.\n\nHowever, if there are no other `Rc` pointers to this allocation, but some [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointers, then the [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointers will be disassociated and the inner value will not be cloned.\n\nSee also [`get_mut`](about:blank/struct.Rc.html#method.get_mut \"associated function std::rc::Rc::get_mut\"), which will fail rather than cloning the inner value or disassociating [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointers.\n\n##### [Â§](#examples-36)Examples\n\n```\nuse std::rc::Rc;\n\nlet mut data = Rc::new(5);\n\n*Rc::make_mut(&mut data) += 1;         // Won't clone anything\nlet mut other_data = Rc::clone(&data); // Won't clone inner data\n*Rc::make_mut(&mut data) += 1;         // Clones inner data\n*Rc::make_mut(&mut data) += 1;         // Won't clone anything\n*Rc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n\n// Now `data` and `other_data` point to different allocations.\nassert_eq!(*data, 8);\nassert_eq!(*other_data, 12);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+data+=+Rc::new(5);%0A++++%0A++++*Rc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Won%27t+clone+anything%0A++++let+mut+other_data+=+Rc::clone(%26data);+//+Won%27t+clone+inner+data%0A++++*Rc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Clones+inner+data%0A++++*Rc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Won%27t+clone+anything%0A++++*Rc::make_mut(%26mut+other_data)+*=+2;+++//+Won%27t+clone+anything%0A++++%0A++++//+Now+%60data%60+and+%60other_data%60+point+to+different+allocations.%0A++++assert_eq!(*data,+8);%0A++++assert_eq!(*other_data,+12);%0A%7D&edition=2021)\n\n[`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointers will be disassociated:\n\n```\nuse std::rc::Rc;\n\nlet mut data = Rc::new(75);\nlet weak = Rc::downgrade(&data);\n\nassert!(75 == *data);\nassert!(75 == *weak.upgrade().unwrap());\n\n*Rc::make_mut(&mut data) += 1;\n\nassert!(76 == *data);\nassert!(weak.upgrade().is_none());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+data+=+Rc::new(75);%0A++++let+weak+=+Rc::downgrade(%26data);%0A++++%0A++++assert!(75+==+*data);%0A++++assert!(75+==+*weak.upgrade().unwrap());%0A++++%0A++++*Rc::make_mut(%26mut+data)+%2B=+1;%0A++++%0A++++assert!(76+==+*data);%0A++++assert!(weak.upgrade().is_none());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1839)[Â§](#impl-Rc%3CT,+A%3E-3)\n\n1.76.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1870)\n\nIf we have the only reference to `T` then unwrap it. Otherwise, clone `T` and return the clone.\n\nAssuming `rc_t` is of type `Rc<T>`, this function is functionally equivalent to `(*rc_t).clone()`, but will avoid cloning the inner value where possible.\n\n##### [Â§](#examples-37)Examples\n\n```\nlet inner = String::from(\"test\");\nlet ptr = inner.as_ptr();\n\nlet rc = Rc::new(inner);\nlet inner = Rc::unwrap_or_clone(rc);\n// The inner value was not cloned\nassert!(ptr::eq(ptr, inner.as_ptr()));\n\nlet rc = Rc::new(inner);\nlet rc2 = rc.clone();\nlet inner = Rc::unwrap_or_clone(rc);\n// Because there were 2 references, we had to clone the inner value.\nassert!(!ptr::eq(ptr, inner.as_ptr()));\n// `rc2` is the last reference, so when we unwrap it we get back\n// the original `String`.\nlet inner = Rc::unwrap_or_clone(rc2);\nassert!(ptr::eq(ptr, inner.as_ptr()));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bptr,+rc::Rc%7D;%0A++++let+inner+=+String::from(%22test%22);%0A++++let+ptr+=+inner.as_ptr();%0A++++%0A++++let+rc+=+Rc::new(inner);%0A++++let+inner+=+Rc::unwrap_or_clone(rc);%0A++++//+The+inner+value+was+not+cloned%0A++++assert!(ptr::eq(ptr,+inner.as_ptr()));%0A++++%0A++++let+rc+=+Rc::new(inner);%0A++++let+rc2+=+rc.clone();%0A++++let+inner+=+Rc::unwrap_or_clone(rc);%0A++++//+Because+there+were+2+references,+we+had+to+clone+the+inner+value.%0A++++assert!(!ptr::eq(ptr,+inner.as_ptr()));%0A++++//+%60rc2%60+is+the+last+reference,+so+when+we+unwrap+it+we+get+back%0A++++//+the+original+%60String%60.%0A++++let+inner+=+Rc::unwrap_or_clone(rc2);%0A++++assert!(ptr::eq(ptr,+inner.as_ptr()));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1875)[Â§](#impl-Rc%3Cdyn+Any,+A%3E)\n\n1.29.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1896)\n\nAttempt to downcast the `Rc<dyn Any>` to a concrete type.\n\n##### [Â§](#examples-38)Examples\n\n```\nuse std::any::Any;\nuse std::rc::Rc;\n\nfn print_if_string(value: Rc<dyn Any>) {\n    if let Ok(string) = value.downcast::<String>() {\n        println!(\"String ({}): {}\", string.len(), string);\n    }\n}\n\nlet my_string = \"Hello World\".to_string();\nprint_if_string(Rc::new(my_string));\nprint_if_string(Rc::new(0i8));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::any::Any;%0A++++use+std::rc::Rc;%0A++++%0A++++fn+print_if_string(value:+Rc%3Cdyn+Any%3E)+%7B%0A++++++++if+let+Ok(string)+=+value.downcast::%3CString%3E()+%7B%0A++++++++++++println!(%22String+(%7B%7D):+%7B%7D%22,+string.len(),+string);%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+my_string+=+%22Hello+World%22.to_string();%0A++++print_if_string(Rc::new(my_string));%0A++++print_if_string(Rc::new(0i8));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1935)\n\nðŸ”¬This is a nightly-only experimental API. (`downcast_unchecked`Â [#90850](https://github.com/rust-lang/rust/issues/90850))\n\nDowncasts the `Rc<dyn Any>` to a concrete type.\n\nFor a safe alternative see [`downcast`](about:blank/struct.Rc.html#method.downcast \"method std::rc::Rc::downcast\").\n\n##### [Â§](#examples-39)Examples\n\n```\n#![feature(downcast_unchecked)]\n\nuse std::any::Any;\nuse std::rc::Rc;\n\nlet x: Rc<dyn Any> = Rc::new(1_usize);\n\nunsafe {\n    assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(downcast_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::any::Any;%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3Cdyn+Any%3E+=+Rc::new(1_usize);%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(*x.downcast_unchecked::%3Cusize%3E(),+1);%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n##### [Â§](#safety-7)Safety\n\nThe contained value must be of type `T`. Calling this method with the incorrect type is _undefined behavior_.\n\n1.69.0 Â· [source](about:blank/src/std/os/fd/owned.rs.html#415-420)[Â§](#impl-AsFd-for-Rc%3CT%3E)\n\n1.71.0 Â· [source](about:blank/src/std/os/windows/io/handle.rs.html#487-492)[Â§](#impl-AsHandle-for-Rc%3CT%3E)\n\nAvailable on **Windows** only.\n\n1.69.0 Â· [source](about:blank/src/std/os/fd/raw.rs.html#261-266)[Â§](#impl-AsRawFd-for-Rc%3CT%3E)\n\n1.5.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3488)[Â§](#impl-AsRef%3CT%3E-for-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3489)[Â§](#method.as_ref)\n\nConverts this type into a shared reference of the (usually inferred) input type.\n\n1.71.0 Â· [source](about:blank/src/std/os/windows/io/socket.rs.html#278-283)[Â§](#impl-AsSocket-for-Rc%3CT%3E)\n\nAvailable on **Windows** only.\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3481)[Â§](#impl-Borrow%3CT%3E-for-Rc%3CT,+A%3E)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2209)[Â§](#impl-Clone-for-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2225)[Â§](#method.clone)\n\nMakes a clone of the `Rc` pointer.\n\nThis creates another pointer to the same allocation, increasing the strong reference count.\n\n##### [Â§](#examples-40)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nlet _ = Rc::clone(&five);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++let+_+=+Rc::clone(%26five);%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#169)[Â§](#method.clone_from)\n\nPerforms copy-assignment from `source`. [Read more](about:blank/clone/trait.Clone.html#method.clone_from)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2504)[Â§](#impl-Debug-for-Rc%3CT,+A%3E)\n\n1.80.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2266)[Â§](#impl-Default-for-Rc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2271)[Â§](#method.default-1)\n\nCreates an empty `[T]` inside an Rc\n\nThis may or may not share an allocation with other Rcs on the same thread.\n\n1.80.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#915)[Â§](#impl-Default-for-Rc%3CCStr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#920)[Â§](#method.default-2)\n\nCreates an empty CStr inside an Rc\n\nThis may or may not share an allocation with other Rcs on the same thread.\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2235)[Â§](#impl-Default-for-Rc%3CT%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2247)[Â§](#method.default)\n\nCreates a new `Rc<T>`, with the `Default` value for `T`.\n\n##### [Â§](#examples-43)Examples\n\n```\nuse std::rc::Rc;\n\nlet x: Rc<i32> = Default::default();\nassert_eq!(*x, 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3Ci32%3E+=+Default::default();%0A++++assert_eq!(*x,+0);%0A%7D&edition=2021)\n\n1.80.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2254)[Â§](#impl-Default-for-Rc%3Cstr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2259)[Â§](#method.default-3)\n\nCreates an empty str inside an Rc\n\nThis may or may not share an allocation with other Rcs on the same thread.\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2146)[Â§](#impl-Deref-for-Rc%3CT,+A%3E)\n\n[Â§](#associatedtype.Target)\n\nThe resulting type after dereferencing.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2150)[Â§](#method.deref)\n\nDereferences the value.\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2497)[Â§](#impl-Display-for-Rc%3CT,+A%3E)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2162)[Â§](#impl-Drop-for-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2188)[Â§](#method.drop)\n\nDrops the `Rc`.\n\nThis will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are [`Weak`](struct.Weak.html \"struct std::rc::Weak\"), so we `drop` the inner value.\n\n##### [Â§](#examples-44)Examples\n\n```\nuse std::rc::Rc;\n\nstruct Foo;\n\nimpl Drop for Foo {\n    fn drop(&mut self) {\n        println!(\"dropped!\");\n    }\n}\n\nlet foo  = Rc::new(Foo);\nlet foo2 = Rc::clone(&foo);\n\ndrop(foo);    // Doesn't print anything\ndrop(foo2);   // Prints \"dropped!\"\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++struct+Foo;%0A++++%0A++++impl+Drop+for+Foo+%7B%0A++++++++fn+drop(%26mut+self)+%7B%0A++++++++++++println!(%22dropped!%22);%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+foo++=+Rc::new(Foo);%0A++++let+foo2+=+Rc::clone(%26foo);%0A++++%0A++++drop(foo);++++//+Doesn%27t+print+anything%0A++++drop(foo2);+++//+Prints+%22dropped!%22%0A%7D&edition=2021)\n\n1.21.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2561)[Â§](#impl-From%3C%26%5BT%5D%3E-for-Rc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2573)[Â§](#method.from-3)\n\nAllocate a reference-counted slice and fill it by cloning `v`â€™s items.\n\n##### [Â§](#example-2)Example\n\n```\nlet original: &[i32] = &[1, 2, 3];\nlet shared: Rc<[i32]> = Rc::from(original);\nassert_eq!(&[1, 2, 3], &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+%26%5Bi32%5D+=+%26%5B1,+2,+3%5D;%0A++++let+shared:+Rc%3C%5Bi32%5D%3E+=+Rc::from(original);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.24.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#903)[Â§](#impl-From%3C%26CStr%3E-for-Rc%3CCStr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#907)[Â§](#method.from-8)\n\nConverts a `&CStr` into a `Rc<CStr>`, by copying the contents into a newly allocated [`Rc`](struct.Rc.html \"struct std::rc::Rc\").\n\n1.24.0 Â· [source](about:blank/src/std/ffi/os_str.rs.html#1273-1280)[Â§](#impl-From%3C%26OsStr%3E-for-Rc%3COsStr%3E)\n\n1.24.0 Â· [source](about:blank/src/std/path.rs.html#1900-1907)[Â§](#impl-From%3C%26Path%3E-for-Rc%3CPath%3E)\n\n1.21.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2580)[Â§](#impl-From%3C%26str%3E-for-Rc%3Cstr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2591)[Â§](#method.from-1)\n\nAllocate a reference-counted string slice and copy `v` into it.\n\n##### [Â§](#example)Example\n\n```\nlet shared: Rc<str> = Rc::from(\"statue\");\nassert_eq!(\"statue\", &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+shared:+Rc%3Cstr%3E+=+Rc::from(%22statue%22);%0A++++assert_eq!(%22statue%22,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.74.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2540)[Â§](#impl-From%3C%5BT;+N%5D%3E-for-Rc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2554)[Â§](#method.from-6)\n\nConverts a [`[T; N]`](../primitive.array.html \"primitive array\") into an `Rc<[T]>`.\n\nThe conversion moves the array into a newly allocated `Rc`.\n\n##### [Â§](#example-4)Example\n\n```\nlet original: [i32; 3] = [1, 2, 3];\nlet shared: Rc<[i32]> = Rc::from(original);\nassert_eq!(&[1, 2, 3], &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+%5Bi32;+3%5D+=+%5B1,+2,+3%5D;%0A++++let+shared:+Rc%3C%5Bi32%5D%3E+=+Rc::from(original);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.21.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2618)[Â§](#impl-From%3CBox%3CT,+A%3E%3E-for-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2630)[Â§](#method.from-9)\n\nMove a boxed object to a new, reference counted, allocation.\n\n##### [Â§](#example-5)Example\n\n```\nlet original: Box<i32> = Box::new(1);\nlet shared: Rc<i32> = Rc::from(original);\nassert_eq!(1, *shared);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+Box%3Ci32%3E+=+Box::new(1);%0A++++let+shared:+Rc%3Ci32%3E+=+Rc::from(original);%0A++++assert_eq!(1,+*shared);%0A%7D&edition=2021)\n\n1.24.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#892)[Â§](#impl-From%3CCString%3E-for-Rc%3CCStr%3E)\n\n1.45.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2666-2669)[Â§](#impl-From%3CCow%3C'a,+B%3E%3E-for-Rc%3CB%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2684)[Â§](#method.from-2)\n\nCreate a reference-counted pointer from a clone-on-write pointer by copying its content.\n\n##### [Â§](#example-1)Example\n\n```\nlet cow: Cow<'_, str> = Cow::Borrowed(\"eggplant\");\nlet shared: Rc<str> = Rc::from(cow);\nassert_eq!(\"eggplant\", &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::borrow::Cow;%0A++++let+cow:+Cow%3C%27_,+str%3E+=+Cow::Borrowed(%22eggplant%22);%0A++++let+shared:+Rc%3Cstr%3E+=+Rc::from(cow);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.24.0 Â· [source](about:blank/src/std/ffi/os_str.rs.html#1262-1270)[Â§](#impl-From%3COsString%3E-for-Rc%3COsStr%3E)\n\n1.24.0 Â· [source](about:blank/src/std/path.rs.html#1889-1897)[Â§](#impl-From%3CPathBuf%3E-for-Rc%3CPath%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#287)[Â§](#impl-From%3CRc%3CW%3E%3E-for-LocalWaker)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#291)[Â§](#method.from-4)\n\nUse a `Wake`\\-able type as a `LocalWaker`.\n\nNo heap allocations or atomic operations are used for this conversion.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#299)[Â§](#impl-From%3CRc%3CW%3E%3E-for-RawWaker)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#303)[Â§](#method.from)\n\nUse a `Wake`\\-able type as a `RawWaker`.\n\nNo heap allocations or atomic operations are used for this conversion.\n\n1.62.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2693)[Â§](#impl-From%3CRc%3Cstr%3E%3E-for-Rc%3C%5Bu8%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2705)[Â§](#method.from-12)\n\nConverts a reference-counted string slice into a byte slice.\n\n##### [Â§](#example-8)Example\n\n```\nlet string: Rc<str> = Rc::from(\"eggplant\");\nlet bytes: Rc<[u8]> = Rc::from(string);\nassert_eq!(\"eggplant\".as_bytes(), bytes.as_ref());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+string:+Rc%3Cstr%3E+=+Rc::from(%22eggplant%22);%0A++++let+bytes:+Rc%3C%5Bu8%5D%3E+=+Rc::from(string);%0A++++assert_eq!(%22eggplant%22.as_bytes(),+bytes.as_ref());%0A%7D&edition=2021)\n\n1.21.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2599)[Â§](#impl-From%3CString%3E-for-Rc%3Cstr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2611)[Â§](#method.from-5)\n\nAllocate a reference-counted string slice and copy `v` into it.\n\n##### [Â§](#example-3)Example\n\n```\nlet original: String = \"statue\".to_owned();\nlet shared: Rc<str> = Rc::from(original);\nassert_eq!(\"statue\", &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+String+=+%22statue%22.to_owned();%0A++++let+shared:+Rc%3Cstr%3E+=+Rc::from(original);%0A++++assert_eq!(%22statue%22,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.6.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2519)[Â§](#impl-From%3CT%3E-for-Rc%3CT%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2533)[Â§](#method.from-10)\n\nConverts a generic type `T` into an `Rc<T>`\n\nThe conversion allocates on the heap and moves `t` from the stack into it.\n\n##### [Â§](#example-6)Example\n\n```\nlet x = 5;\nlet rc = Rc::new(5);\n\nassert_eq!(Rc::from(x), rc);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+x+=+5;%0A++++let+rc+=+Rc::new(5);%0A++++%0A++++assert_eq!(Rc::from(x),+rc);%0A%7D&edition=2021)\n\n1.21.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2637)[Â§](#impl-From%3CVec%3CT,+A%3E%3E-for-Rc%3C%5BT%5D,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2649)[Â§](#method.from-11)\n\nAllocate a reference-counted slice and move `v`â€™s items into it.\n\n##### [Â§](#example-7)Example\n\n```\nlet unique: Vec<i32> = vec![1, 2, 3];\nlet shared: Rc<[i32]> = Rc::from(unique);\nassert_eq!(&[1, 2, 3], &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+unique:+Vec%3Ci32%3E+=+vec!%5B1,+2,+3%5D;%0A++++let+shared:+Rc%3C%5Bi32%5D%3E+=+Rc::from(unique);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.37.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2727)[Â§](#impl-FromIterator%3CT%3E-for-Rc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2766)[Â§](#method.from_iter)\n\nTakes each element in the `Iterator` and collects it into an `Rc<[T]>`.\n\n##### [Â§](#performance-characteristics)Performance characteristics\n\n###### [Â§](#the-general-case)The general case\n\nIn the general case, collecting into `Rc<[T]>` is done by first collecting into a `Vec<T>`. That is, when writing the following:\n\n```\nlet evens: Rc<[u8]> = (0..10).filter(|&x| x % 2 == 0).collect();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+evens:+Rc%3C%5Bu8%5D%3E+=+(0..10).filter(%7C%26x%7C+x+%25+2+==+0).collect();%0A++++assert_eq!(%26*evens,+%26%5B0,+2,+4,+6,+8%5D);%0A%7D&edition=2021)\n\nthis behaves as if we wrote:\n\n```\nlet evens: Rc<[u8]> = (0..10).filter(|&x| x % 2 == 0)\n    .collect::<Vec<_>>() // The first set of allocations happens here.\n    .into(); // A second allocation for `Rc<[T]>` happens here.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+evens:+Rc%3C%5Bu8%5D%3E+=+(0..10).filter(%7C%26x%7C+x+%25+2+==+0)%0A++++++++.collect::%3CVec%3C_%3E%3E()+//+The+first+set+of+allocations+happens+here.%0A++++++++.into();+//+A+second+allocation+for+%60Rc%3C%5BT%5D%3E%60+happens+here.%0A++++assert_eq!(%26*evens,+%26%5B0,+2,+4,+6,+8%5D);%0A%7D&edition=2021)\n\nThis will allocate as many times as needed for constructing the `Vec<T>` and then it will allocate once for turning the `Vec<T>` into the `Rc<[T]>`.\n\n###### [Â§](#iterators-of-known-length)Iterators of known length\n\nWhen your `Iterator` implements `TrustedLen` and is of an exact size, a single allocation will be made for the `Rc<[T]>`. For example:\n\n```\nlet evens: Rc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+evens:+Rc%3C%5Bu8%5D%3E+=+(0..10).collect();+//+Just+a+single+allocation+happens+here.%0A++++assert_eq!(%26*evens,+%26*(0..10).collect::%3CVec%3C_%3E%3E());%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2490)[Â§](#impl-Hash-for-Rc%3CT,+A%3E)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2468)[Â§](#impl-Ord-for-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2484)[Â§](#method.cmp)\n\nComparison for two `Rc`s.\n\nThe two are compared by calling `cmp()` on their inner values.\n\n##### [Â§](#examples-50)Examples\n\n```\nuse std::rc::Rc;\nuse std::cmp::Ordering;\n\nlet five = Rc::new(5);\n\nassert_eq!(Ordering::Less, five.cmp(&Rc::new(6)));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert_eq!(Ordering::Less,+five.cmp(%26Rc::new(6)));%0A%7D&edition=2021)\n\n1.21.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#856-858)[Â§](#method.max)\n\nCompares and returns the maximum of two values. [Read more](about:blank/cmp/trait.Ord.html#method.max)\n\n1.21.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#877-879)[Â§](#method.min)\n\nCompares and returns the minimum of two values. [Read more](about:blank/cmp/trait.Ord.html#method.min)\n\n1.50.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#903-906)[Â§](#method.clamp)\n\nRestrict a value to a certain interval. [Read more](about:blank/cmp/trait.Ord.html#method.clamp)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2323)[Â§](#impl-PartialEq-for-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2343)[Â§](#method.eq)\n\nEquality for two `Rc`s.\n\nTwo `Rc`s are equal if their inner values are equal, even if they are stored in different allocation.\n\nIf `T` also implements `Eq` (implying reflexivity of equality), two `Rc`s that point to the same allocation are always equal.\n\n##### [Â§](#examples-41)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nassert!(five == Rc::new(5));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+==+Rc::new(5));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2365)[Â§](#method.ne)\n\nInequality for two `Rc`s.\n\nTwo `Rc`s are not equal if their inner values are not equal.\n\nIf `T` also implements `Eq` (implying reflexivity of equality), two `Rc`s that point to the same allocation are always equal.\n\n##### [Â§](#examples-42)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nassert!(five != Rc::new(6));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+!=+Rc::new(6));%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2374)[Â§](#impl-PartialOrd-for-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2390)[Â§](#method.partial_cmp)\n\nPartial comparison for two `Rc`s.\n\nThe two are compared by calling `partial_cmp()` on their inner values.\n\n##### [Â§](#examples-45)Examples\n\n```\nuse std::rc::Rc;\nuse std::cmp::Ordering;\n\nlet five = Rc::new(5);\n\nassert_eq!(Some(Ordering::Less), five.partial_cmp(&Rc::new(6)));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert_eq!(Some(Ordering::Less),+five.partial_cmp(%26Rc::new(6)));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2408)[Â§](#method.lt)\n\nLess-than comparison for two `Rc`s.\n\nThe two are compared by calling `<` on their inner values.\n\n##### [Â§](#examples-46)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nassert!(five < Rc::new(6));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+%3C+Rc::new(6));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2426)[Â§](#method.le)\n\nâ€˜Less than or equal toâ€™ comparison for two `Rc`s.\n\nThe two are compared by calling `<=` on their inner values.\n\n##### [Â§](#examples-47)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nassert!(five <= Rc::new(5));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+%3C=+Rc::new(5));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2444)[Â§](#method.gt)\n\nGreater-than comparison for two `Rc`s.\n\nThe two are compared by calling `>` on their inner values.\n\n##### [Â§](#examples-48)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nassert!(five > Rc::new(4));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+%3E+Rc::new(4));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2462)[Â§](#method.ge)\n\nâ€˜Greater than or equal toâ€™ comparison for two `Rc`s.\n\nThe two are compared by calling `>=` on their inner values.\n\n##### [Â§](#examples-49)Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n\nassert!(five >= Rc::new(5));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+%3E=+Rc::new(5));%0A%7D&edition=2021)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2511)[Â§](#impl-Pointer-for-Rc%3CT,+A%3E)\n\n1.43.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2712)[Â§](#impl-TryFrom%3CRc%3C%5BT%5D,+A%3E%3E-for-Rc%3C%5BT;+N%5D,+A%3E)\n\n[Â§](#associatedtype.Error)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2715)[Â§](#method.try_from)\n\nPerforms the conversion.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#341)[Â§](#impl-CoerceUnsized%3CRc%3CU,+A%3E%3E-for-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2156)[Â§](#impl-DerefPure-for-Rc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#344)[Â§](#impl-DispatchFromDyn%3CRc%3CU%3E%3E-for-Rc%3CT%3E)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2371)[Â§](#impl-Eq-for-Rc%3CT,+A%3E)\n\n1.58.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#338)[Â§](#impl-RefUnwindSafe-for-Rc%3CT,+A%3E)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#325)[Â§](#impl-Send-for-Rc%3CT,+A%3E)\n\n1.0.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#333)[Â§](#impl-Sync-for-Rc%3CT,+A%3E)\n\n1.33.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3495)[Â§](#impl-Unpin-for-Rc%3CT,+A%3E)\n\n1.9.0 Â· [source](https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#336)[Â§](#impl-UnwindSafe-for-Rc%3CT,+A%3E)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A single-threaded reference-counting pointer. â€˜Rcâ€™ stands for â€˜Reference Countedâ€™.\"><title>Rc in std::rc - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc struct\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Rc</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Rc</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.allocator\">allocator</a></li><li><a href=\"#method.as_ptr\">as_ptr</a></li><li><a href=\"#method.assume_init\">assume_init</a></li><li><a href=\"#method.assume_init-1\">assume_init</a></li><li><a href=\"#method.decrement_strong_count\">decrement_strong_count</a></li><li><a href=\"#method.decrement_strong_count_in\">decrement_strong_count_in</a></li><li><a href=\"#method.downcast\">downcast</a></li><li><a href=\"#method.downcast_unchecked\">downcast_unchecked</a></li><li><a href=\"#method.downgrade\">downgrade</a></li><li><a href=\"#method.from_raw\">from_raw</a></li><li><a href=\"#method.from_raw_in\">from_raw_in</a></li><li><a href=\"#method.get_mut\">get_mut</a></li><li><a href=\"#method.get_mut_unchecked\">get_mut_unchecked</a></li><li><a href=\"#method.increment_strong_count\">increment_strong_count</a></li><li><a href=\"#method.increment_strong_count_in\">increment_strong_count_in</a></li><li><a href=\"#method.into_inner\">into_inner</a></li><li><a href=\"#method.into_raw\">into_raw</a></li><li><a href=\"#method.into_raw_with_allocator\">into_raw_with_allocator</a></li><li><a href=\"#method.make_mut\">make_mut</a></li><li><a href=\"#method.new\">new</a></li><li><a href=\"#method.new_cyclic\">new_cyclic</a></li><li><a href=\"#method.new_in\">new_in</a></li><li><a href=\"#method.new_uninit\">new_uninit</a></li><li><a href=\"#method.new_uninit_in\">new_uninit_in</a></li><li><a href=\"#method.new_uninit_slice\">new_uninit_slice</a></li><li><a href=\"#method.new_uninit_slice_in\">new_uninit_slice_in</a></li><li><a href=\"#method.new_zeroed\">new_zeroed</a></li><li><a href=\"#method.new_zeroed_in\">new_zeroed_in</a></li><li><a href=\"#method.new_zeroed_slice\">new_zeroed_slice</a></li><li><a href=\"#method.new_zeroed_slice_in\">new_zeroed_slice_in</a></li><li><a href=\"#method.pin\">pin</a></li><li><a href=\"#method.pin_in\">pin_in</a></li><li><a href=\"#method.ptr_eq\">ptr_eq</a></li><li><a href=\"#method.strong_count\">strong_count</a></li><li><a href=\"#method.try_new\">try_new</a></li><li><a href=\"#method.try_new_in\">try_new_in</a></li><li><a href=\"#method.try_new_uninit\">try_new_uninit</a></li><li><a href=\"#method.try_new_uninit_in\">try_new_uninit_in</a></li><li><a href=\"#method.try_new_zeroed\">try_new_zeroed</a></li><li><a href=\"#method.try_new_zeroed_in\">try_new_zeroed_in</a></li><li><a href=\"#method.try_unwrap\">try_unwrap</a></li><li><a href=\"#method.unwrap_or_clone\">unwrap_or_clone</a></li><li><a href=\"#method.weak_count\">weak_count</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-Send-for-Rc%3CT,+A%3E\">!Send</a></li><li><a href=\"#impl-Sync-for-Rc%3CT,+A%3E\">!Sync</a></li><li><a href=\"#impl-AsFd-for-Rc%3CT%3E\">AsFd</a></li><li><a href=\"#impl-AsHandle-for-Rc%3CT%3E\">AsHandle</a></li><li><a href=\"#impl-AsRawFd-for-Rc%3CT%3E\">AsRawFd</a></li><li><a href=\"#impl-AsRef%3CT%3E-for-Rc%3CT,+A%3E\">AsRef&lt;T&gt;</a></li><li><a href=\"#impl-AsSocket-for-Rc%3CT%3E\">AsSocket</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-Rc%3CT,+A%3E\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-Clone-for-Rc%3CT,+A%3E\">Clone</a></li><li><a href=\"#impl-CoerceUnsized%3CRc%3CU,+A%3E%3E-for-Rc%3CT,+A%3E\">CoerceUnsized&lt;Rc&lt;U, A&gt;&gt;</a></li><li><a href=\"#impl-Debug-for-Rc%3CT,+A%3E\">Debug</a></li><li><a href=\"#impl-Default-for-Rc%3C%5BT%5D%3E\">Default</a></li><li><a href=\"#impl-Default-for-Rc%3CCStr%3E\">Default</a></li><li><a href=\"#impl-Default-for-Rc%3CT%3E\">Default</a></li><li><a href=\"#impl-Default-for-Rc%3Cstr%3E\">Default</a></li><li><a href=\"#impl-Deref-for-Rc%3CT,+A%3E\">Deref</a></li><li><a href=\"#impl-DerefPure-for-Rc%3CT,+A%3E\">DerefPure</a></li><li><a href=\"#impl-DispatchFromDyn%3CRc%3CU%3E%3E-for-Rc%3CT%3E\">DispatchFromDyn&lt;Rc&lt;U&gt;&gt;</a></li><li><a href=\"#impl-Display-for-Rc%3CT,+A%3E\">Display</a></li><li><a href=\"#impl-Drop-for-Rc%3CT,+A%3E\">Drop</a></li><li><a href=\"#impl-Eq-for-Rc%3CT,+A%3E\">Eq</a></li><li><a href=\"#impl-From%3C%26CStr%3E-for-Rc%3CCStr%3E\">From&lt;&amp;CStr&gt;</a></li><li><a href=\"#impl-From%3C%26OsStr%3E-for-Rc%3COsStr%3E\">From&lt;&amp;OsStr&gt;</a></li><li><a href=\"#impl-From%3C%26Path%3E-for-Rc%3CPath%3E\">From&lt;&amp;Path&gt;</a></li><li><a href=\"#impl-From%3C%26%5BT%5D%3E-for-Rc%3C%5BT%5D%3E\">From&lt;&amp;[T]&gt;</a></li><li><a href=\"#impl-From%3C%26str%3E-for-Rc%3Cstr%3E\">From&lt;&amp;str&gt;</a></li><li><a href=\"#impl-From%3CBox%3CT,+A%3E%3E-for-Rc%3CT,+A%3E\">From&lt;Box&lt;T, A&gt;&gt;</a></li><li><a href=\"#impl-From%3CCString%3E-for-Rc%3CCStr%3E\">From&lt;CString&gt;</a></li><li><a href=\"#impl-From%3CCow%3C'a,+B%3E%3E-for-Rc%3CB%3E\">From&lt;Cow&lt;'a, B&gt;&gt;</a></li><li><a href=\"#impl-From%3COsString%3E-for-Rc%3COsStr%3E\">From&lt;OsString&gt;</a></li><li><a href=\"#impl-From%3CPathBuf%3E-for-Rc%3CPath%3E\">From&lt;PathBuf&gt;</a></li><li><a href=\"#impl-From%3CRc%3CW%3E%3E-for-LocalWaker\">From&lt;Rc&lt;W&gt;&gt;</a></li><li><a href=\"#impl-From%3CRc%3CW%3E%3E-for-RawWaker\">From&lt;Rc&lt;W&gt;&gt;</a></li><li><a href=\"#impl-From%3CRc%3Cstr%3E%3E-for-Rc%3C%5Bu8%5D%3E\">From&lt;Rc&lt;str&gt;&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-Rc%3Cstr%3E\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-Rc%3CT%3E\">From&lt;T&gt;</a></li><li><a href=\"#impl-From%3CVec%3CT,+A%3E%3E-for-Rc%3C%5BT%5D,+A%3E\">From&lt;Vec&lt;T, A&gt;&gt;</a></li><li><a href=\"#impl-From%3C%5BT;+N%5D%3E-for-Rc%3C%5BT%5D%3E\">From&lt;[T; N]&gt;</a></li><li><a href=\"#impl-FromIterator%3CT%3E-for-Rc%3C%5BT%5D%3E\">FromIterator&lt;T&gt;</a></li><li><a href=\"#impl-Hash-for-Rc%3CT,+A%3E\">Hash</a></li><li><a href=\"#impl-Ord-for-Rc%3CT,+A%3E\">Ord</a></li><li><a href=\"#impl-PartialEq-for-Rc%3CT,+A%3E\">PartialEq</a></li><li><a href=\"#impl-PartialOrd-for-Rc%3CT,+A%3E\">PartialOrd</a></li><li><a href=\"#impl-Pointer-for-Rc%3CT,+A%3E\">Pointer</a></li><li><a href=\"#impl-RefUnwindSafe-for-Rc%3CT,+A%3E\">RefUnwindSafe</a></li><li><a href=\"#impl-TryFrom%3CRc%3C%5BT%5D,+A%3E%3E-for-Rc%3C%5BT;+N%5D,+A%3E\">TryFrom&lt;Rc&lt;[T], A&gt;&gt;</a></li><li><a href=\"#impl-Unpin-for-Rc%3CT,+A%3E\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-Rc%3CT,+A%3E\">UnwindSafe</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-Rc%3CT,+A%3E\">Freeze</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3C!%3E-for-T\">From&lt;!&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-ToOwned-for-T\">ToOwned</a></li><li><a href=\"#impl-ToString-for-T\">ToString</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::rc</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Rc.html\">Rc</a></li><li><a href=\"struct.UniqueRc.html\">UniqueRc</a></li><li><a href=\"struct.Weak.html\">Weak</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type â€˜Sâ€™ or â€˜/â€™ to search, â€˜?â€™ for more optionsâ€¦\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Struct <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">rc</a>::<wbr><a class=\"struct\" href=\"#\">Rc</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#315-318\">source</a> Â· <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>âˆ’</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub struct Rc&lt;T, A = <a class=\"struct\" href=\"../alloc/struct.Global.html\" title=\"struct std::alloc::Global\">Global</a>&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div>{ <span class=\"comment\">/* private fields */</span> }</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A single-threaded reference-counting pointer. â€˜Rcâ€™ stands for â€˜Reference\nCountedâ€™.</p>\n<p>See the <a href=\"./index.html\">module-level documentation</a> for more details.</p>\n<p>The inherent methods of <code>Rc</code> are all associated functions, which means\nthat you have to call them as e.g., <a href=\"struct.Rc.html#method.get_mut\" title=\"associated function std::rc::Rc::get_mut\"><code>Rc::get_mut(&amp;mut value)</code></a> instead of\n<code>value.get_mut()</code>. This avoids conflicts with methods of the inner type <code>T</code>.</p>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">Â§</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#383\">source</a><a href=\"#impl-Rc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#395\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.new\" class=\"fn\">new</a>(value: T) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Rc&lt;T&gt;</code>.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_cyclic\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.60.0\">1.60.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#461-463\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.new_cyclic\" class=\"fn\">new_cyclic</a>&lt;F&gt;(data_fn: F) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>(&amp;<a class=\"struct\" href=\"struct.Weak.html\" title=\"struct std::rc::Weak\">Weak</a>&lt;T&gt;) -&gt; T,</div></h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Rc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the allocation,\nto allow you to construct a <code>T</code> which holds a weak pointer to itself.</p>\n<p>Generally, a structure circularly referencing itself, either directly or\nindirectly, should not hold a strong reference to itself to prevent a memory leak.\nUsing this function, you get access to the weak pointer during the\ninitialization of <code>T</code>, before the <code>Rc&lt;T&gt;</code> is created, such that you can\nclone and store it inside the <code>T</code>.</p>\n<p><code>new_cyclic</code> first allocates the managed allocation for the <code>Rc&lt;T&gt;</code>,\nthen calls your closure, giving it a <code>Weak&lt;T&gt;</code> to this allocation,\nand only afterwards completes the construction of the <code>Rc&lt;T&gt;</code> by placing\nthe <code>T</code> returned from your closure into the allocation.</p>\n<p>Since the new <code>Rc&lt;T&gt;</code> is not fully-constructed until <code>Rc&lt;T&gt;::new_cyclic</code>\nreturns, calling <a href=\"struct.Weak.html#method.upgrade\" title=\"method std::rc::Weak::upgrade\"><code>upgrade</code></a> on the weak reference inside your closure will\nfail and result in a <code>None</code> value.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">Â§</a>Panics</h5>\n<p>If <code>data_fn</code> panics, the panic is propagated to the caller, and the\ntemporary <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak&lt;T&gt;</code></a> is dropped normally.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::{Rc, Weak};\n\n<span class=\"kw\">struct </span>Gadget {\n    me: Weak&lt;Gadget&gt;,\n}\n\n<span class=\"kw\">impl </span>Gadget {\n    <span class=\"doccomment\">/// Construct a reference counted Gadget.\n    </span><span class=\"kw\">fn </span>new() -&gt; Rc&lt;<span class=\"self\">Self</span>&gt; {\n        <span class=\"comment\">// `me` is a `Weak&lt;Gadget&gt;` pointing at the new allocation of the\n        // `Rc` we're constructing.\n        </span>Rc::new_cyclic(|me| {\n            <span class=\"comment\">// Create the actual struct here.\n            </span>Gadget { me: me.clone() }\n        })\n    }\n\n    <span class=\"doccomment\">/// Return a reference counted pointer to Self.\n    </span><span class=\"kw\">fn </span>me(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; Rc&lt;<span class=\"self\">Self</span>&gt; {\n        <span class=\"self\">self</span>.me.upgrade().unwrap()\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::rc::%7BRc,+Weak%7D;%0A++++%0A++++struct+Gadget+%7B%0A++++++++me:+Weak%3CGadget%3E,%0A++++%7D%0A++++%0A++++impl+Gadget+%7B%0A++++++++///+Construct+a+reference+counted+Gadget.%0A++++++++fn+new()+-%3E+Rc%3CSelf%3E+%7B%0A++++++++++++//+%60me%60+is+a+%60Weak%3CGadget%3E%60+pointing+at+the+new+allocation+of+the%0A++++++++++++//+%60Rc%60+we're+constructing.%0A++++++++++++Rc::new_cyclic(%7Cme%7C+%7B%0A++++++++++++++++//+Create+the+actual+struct+here.%0A++++++++++++++++Gadget+%7B+me:+me.clone()+%7D%0A++++++++++++%7D)%0A++++++++%7D%0A++++%0A++++++++///+Return+a+reference+counted+pointer+to+Self.%0A++++++++fn+me(%26self)+-%3E+Rc%3CSelf%3E+%7B%0A++++++++++++self.me.upgrade().unwrap()%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_uninit\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#525\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_uninit\" class=\"fn\">new_uninit</a>() -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc</code> with uninitialized contents.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Rc::&lt;u32&gt;::new_uninit();\n\n<span class=\"comment\">// Deferred initialization:\n</span>Rc::get_mut(<span class=\"kw-2\">&amp;mut </span>five).unwrap().write(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{ five.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32%3E::new_uninit();%0A++++%0A++++//+Deferred+initialization:%0A++++Rc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_zeroed\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#558\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_zeroed\" class=\"fn\">new_zeroed</a>() -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and\nincorrect usage of this method.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>zero = Rc::&lt;u32&gt;::new_zeroed();\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+zero+=+Rc::%3Cu32%3E::new_zeroed();%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#580\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new\" class=\"fn\">try_new</a>(value: T) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc&lt;T&gt;</code>, returning an error if the allocation fails</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::try_new(<span class=\"number\">5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::try_new(5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_uninit\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#615\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_uninit\" class=\"fn\">try_new_uninit</a>() -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc</code> with uninitialized contents, returning an error if the allocation fails</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Rc::&lt;u32&gt;::try_new_uninit()<span class=\"question-mark\">?</span>;\n\n<span class=\"comment\">// Deferred initialization:\n</span>Rc::get_mut(<span class=\"kw-2\">&amp;mut </span>five).unwrap().write(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{ five.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api,+new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32%3E::try_new_uninit()?;%0A++++%0A++++//+Deferred+initialization:%0A++++Rc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_zeroed\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#648\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_zeroed\" class=\"fn\">try_new_zeroed</a>() -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes, returning an error if the allocation fails</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and\nincorrect usage of this method.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>zero = Rc::&lt;u32&gt;::try_new_zeroed()<span class=\"question-mark\">?</span>;\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api,+new_uninit)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+zero+=+Rc::%3Cu32%3E::try_new_zeroed()?;%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.pin\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.33.0\">1.33.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#662\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.pin\" class=\"fn\">pin</a>(value: T) -&gt; <a class=\"struct\" href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Rc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>, then\n<code>value</code> will be pinned in memory and unable to be moved.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3CT,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#667\">source</a><a href=\"#impl-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.allocator\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#675\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.allocator\" class=\"fn\">allocator</a>(this: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;A</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns a reference to the underlying allocator.</p>\n<p>Note: this is an associated function, which means that you have\nto call it as <code>Rc::allocator(&amp;r)</code> instead of <code>r.allocator()</code>. This\nis so that there is no conflict with a method on the inner type.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#692\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_in\" class=\"fn\">new_in</a>(value: T, alloc: A) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc</code> in the provided allocator.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Rc::new_in(<span class=\"number\">5</span>, System);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Rc::new_in(5,+System);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_uninit_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#728\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_uninit_in\" class=\"fn\">new_uninit_in</a>(alloc: A) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc</code> with uninitialized contents in the provided allocator.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Rc::&lt;u32, <span class=\"kw\">_</span>&gt;::new_uninit_in(System);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>Rc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>five).as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32,+_%3E::new_uninit_in(System);%0A++++%0A++++let+five+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Rc::get_mut_unchecked(%26mut+five).as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_zeroed_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#767\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_zeroed_in\" class=\"fn\">new_zeroed_in</a>(alloc: A) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes, in the provided allocator.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and\nincorrect usage of this method.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>zero = Rc::&lt;u32, <span class=\"kw\">_</span>&gt;::new_zeroed_in(System);\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+zero+=+Rc::%3Cu32,+_%3E::new_zeroed_in(System);%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#795\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_in\" class=\"fn\">try_new_in</a>(value: T, alloc: A) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc&lt;T&gt;</code> in the provided allocator, returning an error if the allocation\nfails</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Rc::try_new_in(<span class=\"number\">5</span>, System);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Rc::try_new_in(5,+System);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_uninit_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#834\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_uninit_in\" class=\"fn\">try_new_uninit_in</a>(alloc: A) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc</code> with uninitialized contents, in the provided allocator, returning an\nerror if the allocation fails</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Rc::&lt;u32, <span class=\"kw\">_</span>&gt;::try_new_uninit_in(System)<span class=\"question-mark\">?</span>;\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>Rc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>five).as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api,+new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32,+_%3E::try_new_uninit_in(System)?;%0A++++%0A++++let+five+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Rc::get_mut_unchecked(%26mut+five).as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_zeroed_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#873\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_zeroed_in\" class=\"fn\">try_new_zeroed_in</a>(alloc: A) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Rc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes, in the provided allocator, returning an error if the allocation\nfails</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and\nincorrect usage of this method.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>zero = Rc::&lt;u32, <span class=\"kw\">_</span>&gt;::try_new_zeroed_in(System)<span class=\"question-mark\">?</span>;\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api,+new_uninit)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+zero+=+Rc::%3Cu32,+_%3E::try_new_zeroed_in(System)?;%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.pin_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#891-893\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.pin_in\" class=\"fn\">pin_in</a>(value: T, alloc: A) -&gt; <a class=\"struct\" href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;&gt;<div class=\"where\">where\n    A: 'static,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Rc&lt;T&gt;&gt;</code> in the provided allocator. If <code>T</code> does not implement <code>Unpin</code>, then\n<code>value</code> will be pinned in memory and unable to be moved.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_unwrap\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#919\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.try_unwrap\" class=\"fn\">try_unwrap</a>(this: <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the inner value, if the <code>Rc</code> has exactly one strong reference.</p>\n<p>Otherwise, an <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> is returned with the same <code>Rc</code> that was\npassed in.</p>\n<p>This will succeed even if there are outstanding weak references.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x = Rc::new(<span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(Rc::try_unwrap(x), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">3</span>));\n\n<span class=\"kw\">let </span>x = Rc::new(<span class=\"number\">4</span>);\n<span class=\"kw\">let </span>_y = Rc::clone(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>Rc::try_unwrap(x).unwrap_err(), <span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(3);%0A++++assert_eq!(Rc::try_unwrap(x),+Ok(3));%0A++++%0A++++let+x+=+Rc::new(4);%0A++++let+_y+=+Rc::clone(%26x);%0A++++assert_eq!(*Rc::try_unwrap(x).unwrap_err(),+4);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_inner\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.70.0\">1.70.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#971\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_inner\" class=\"fn\">into_inner</a>(this: <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the inner value, if the <code>Rc</code> has exactly one strong reference.</p>\n<p>Otherwise, <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned and the <code>Rc</code> is dropped.</p>\n<p>This will succeed even if there are outstanding weak references.</p>\n<p>If <code>Rc::into_inner</code> is called on every clone of this <code>Rc</code>,\nit is guaranteed that exactly one of the calls returns the inner value.\nThis means in particular that the inner value is not dropped.</p>\n<p><a href=\"struct.Rc.html#method.try_unwrap\" title=\"associated function std::rc::Rc::try_unwrap\"><code>Rc::try_unwrap</code></a> is conceptually similar to <code>Rc::into_inner</code>.\nAnd while they are meant for different use-cases, <code>Rc::into_inner(this)</code>\nis in fact equivalent to <code><a href=\"struct.Rc.html#method.try_unwrap\" title=\"associated function std::rc::Rc::try_unwrap\">Rc::try_unwrap</a>(this).<a href=\"../result/enum.Result.html#method.ok\" title=\"method std::result::Result::ok\">ok</a>()</code>.\n(Note that the same kind of equivalence does <strong>not</strong> hold true for\n<a href=\"../sync/struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a>, due to race conditions that do not apply to <code>Rc</code>!)</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x = Rc::new(<span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(Rc::into_inner(x), <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>));\n\n<span class=\"kw\">let </span>x = Rc::new(<span class=\"number\">4</span>);\n<span class=\"kw\">let </span>y = Rc::clone(<span class=\"kw-2\">&amp;</span>x);\n\n<span class=\"macro\">assert_eq!</span>(Rc::into_inner(y), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(Rc::into_inner(x), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(3);%0A++++assert_eq!(Rc::into_inner(x),+Some(3));%0A++++%0A++++let+x+=+Rc::new(4);%0A++++let+y+=+Rc::clone(%26x);%0A++++%0A++++assert_eq!(Rc::into_inner(y),+None);%0A++++assert_eq!(Rc::into_inner(x),+Some(4));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3C%5BT%5D%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#976\">source</a><a href=\"#impl-Rc%3C%5BT%5D%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_uninit_slice\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1002\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_uninit_slice\" class=\"fn\">new_uninit_slice</a>(len: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new reference-counted slice with uninitialized contents.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>values = Rc::&lt;[u32]&gt;::new_uninit_slice(<span class=\"number\">3</span>);\n\n<span class=\"comment\">// Deferred initialization:\n</span><span class=\"kw\">let </span>data = Rc::get_mut(<span class=\"kw-2\">&amp;mut </span>values).unwrap();\ndata[<span class=\"number\">0</span>].write(<span class=\"number\">1</span>);\ndata[<span class=\"number\">1</span>].write(<span class=\"number\">2</span>);\ndata[<span class=\"number\">2</span>].write(<span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{ values.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+values+=+Rc::%3C%5Bu32%5D%3E::new_uninit_slice(3);%0A++++%0A++++//+Deferred+initialization:%0A++++let+data+=+Rc::get_mut(%26mut+values).unwrap();%0A++++data%5B0%5D.write(1);%0A++++data%5B1%5D.write(2);%0A++++data%5B2%5D.write(3);%0A++++%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_zeroed_slice\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1029\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_zeroed_slice\" class=\"fn\">new_zeroed_slice</a>(len: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new reference-counted slice with uninitialized contents, with the memory being\nfilled with <code>0</code> bytes.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and\nincorrect usage of this method.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>values = Rc::&lt;[u32]&gt;::new_zeroed_slice(<span class=\"number\">3</span>);\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{ values.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+values+=+Rc::%3C%5Bu32%5D%3E::new_zeroed_slice(3);%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B0,+0,+0%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3C%5BT%5D,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1043\">source</a><a href=\"#impl-Rc%3C%5BT%5D,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_uninit_slice_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1073\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_uninit_slice_in\" class=\"fn\">new_uninit_slice_in</a>(len: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, alloc: A) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new reference-counted slice with uninitialized contents.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>values = Rc::&lt;[u32], <span class=\"kw\">_</span>&gt;::new_uninit_slice_in(<span class=\"number\">3</span>, System);\n\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>Rc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>values)[<span class=\"number\">0</span>].as_mut_ptr().write(<span class=\"number\">1</span>);\n    Rc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>values)[<span class=\"number\">1</span>].as_mut_ptr().write(<span class=\"number\">2</span>);\n    Rc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>values)[<span class=\"number\">2</span>].as_mut_ptr().write(<span class=\"number\">3</span>);\n\n    values.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+values+=+Rc::%3C%5Bu32%5D,+_%3E::new_uninit_slice_in(3,+System);%0A++++%0A++++let+values+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Rc::get_mut_unchecked(%26mut+values)%5B0%5D.as_mut_ptr().write(1);%0A++++++++Rc::get_mut_unchecked(%26mut+values)%5B1%5D.as_mut_ptr().write(2);%0A++++++++Rc::get_mut_unchecked(%26mut+values)%5B2%5D.as_mut_ptr().write(3);%0A++++%0A++++++++values.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_zeroed_slice_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1103\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_zeroed_slice_in\" class=\"fn\">new_zeroed_slice_in</a>(len: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, alloc: A) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new reference-counted slice with uninitialized contents, with the memory being\nfilled with <code>0</code> bytes.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and\nincorrect usage of this method.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>values = Rc::&lt;[u32], <span class=\"kw\">_</span>&gt;::new_zeroed_slice_in(<span class=\"number\">3</span>, System);\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{ values.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+values+=+Rc::%3C%5Bu32%5D,+_%3E::new_zeroed_slice_in(3,+System);%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B0,+0,+0%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3CMaybeUninit%3CT%3E,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1120\">source</a><a href=\"#impl-Rc%3CMaybeUninit%3CT%3E,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1152\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.assume_init\" class=\"fn\">assume_init</a>(self) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Converts to <code>Rc&lt;T&gt;</code>.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">Â§</a>Safety</h5>\n<p>As with <a href=\"../mem/union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>MaybeUninit::assume_init</code></a>,\nit is up to the caller to guarantee that the inner value\nreally is in an initialized state.\nCalling this when the content is not yet fully initialized\ncauses immediate undefined behavior.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Rc::&lt;u32&gt;::new_uninit();\n\n<span class=\"comment\">// Deferred initialization:\n</span>Rc::get_mut(<span class=\"kw-2\">&amp;mut </span>five).unwrap().write(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{ five.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+five+=+Rc::%3Cu32%3E::new_uninit();%0A++++%0A++++//+Deferred+initialization:%0A++++Rc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3C%5BMaybeUninit%3CT%3E%5D,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1158\">source</a><a href=\"#impl-Rc%3C%5BMaybeUninit%3CT%3E%5D,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init-1\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1193\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.assume_init-1\" class=\"fn\">assume_init</a>(self) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Converts to <code>Rc&lt;[T]&gt;</code>.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">Â§</a>Safety</h5>\n<p>As with <a href=\"../mem/union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>MaybeUninit::assume_init</code></a>,\nit is up to the caller to guarantee that the inner value\nreally is in an initialized state.\nCalling this when the content is not yet fully initialized\ncauses immediate undefined behavior.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>values = Rc::&lt;[u32]&gt;::new_uninit_slice(<span class=\"number\">3</span>);\n\n<span class=\"comment\">// Deferred initialization:\n</span><span class=\"kw\">let </span>data = Rc::get_mut(<span class=\"kw-2\">&amp;mut </span>values).unwrap();\ndata[<span class=\"number\">0</span>].write(<span class=\"number\">1</span>);\ndata[<span class=\"number\">1</span>].write(<span class=\"number\">2</span>);\ndata[<span class=\"number\">2</span>].write(<span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{ values.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+values+=+Rc::%3C%5Bu32%5D%3E::new_uninit_slice(3);%0A++++%0A++++//+Deferred+initialization:%0A++++let+data+=+Rc::get_mut(%26mut+values).unwrap();%0A++++data%5B0%5D.write(1);%0A++++data%5B1%5D.write(2);%0A++++data%5B2%5D.write(3);%0A++++%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3CT%3E-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1199\">source</a><a href=\"#impl-Rc%3CT%3E-1\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_raw\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1263\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.from_raw\" class=\"fn\">from_raw</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs an <code>Rc&lt;T&gt;</code> from a raw pointer.</p>\n<p>The raw pointer must have been previously returned by a call to\n<a href=\"struct.Rc.html#method.into_raw\" title=\"associated function std::rc::Rc::into_raw\"><code>Rc&lt;U&gt;::into_raw</code></a> with the following requirements:</p>\n<ul>\n<li>If <code>U</code> is sized, it must have the same size and alignment as <code>T</code>. This\nis trivially true if <code>U</code> is <code>T</code>.</li>\n<li>If <code>U</code> is unsized, its data pointer must have the same size and\nalignment as <code>T</code>. This is trivially true if <code>Rc&lt;U&gt;</code> was constructed\nthrough <code>Rc&lt;T&gt;</code> and then converted to <code>Rc&lt;U&gt;</code> through an <a href=\"https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions\">unsized\ncoercion</a>.</li>\n</ul>\n<p>Note that if <code>U</code> or <code>U</code>â€™s data pointer is not <code>T</code> but has the same size\nand alignment, this is basically like transmuting references of\ndifferent types. See <a href=\"../mem/fn.transmute.html\" title=\"fn std::mem::transmute\"><code>mem::transmute</code></a> for more information\non what restrictions apply in this case.</p>\n<p>The raw pointer must point to a block of memory allocated by the global allocator</p>\n<p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only\ndropped once.</p>\n<p>This function is unsafe because improper use may lead to memory unsafety,\neven if the returned <code>Rc&lt;T&gt;</code> is never accessed.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x = Rc::new(<span class=\"string\">\"hello\"</span>.to_owned());\n<span class=\"kw\">let </span>x_ptr = Rc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Convert back to an `Rc` to prevent leak.\n    </span><span class=\"kw\">let </span>x = Rc::from_raw(x_ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"string\">\"hello\"</span>);\n\n    <span class=\"comment\">// Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.\n</span>}\n\n<span class=\"comment\">// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(%22hello%22.to_owned());%0A++++let+x_ptr+=+Rc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++//+Convert+back+to+an+%60Rc%60+to+prevent+leak.%0A++++++++let+x+=+Rc::from_raw(x_ptr);%0A++++++++assert_eq!(%26*x,+%22hello%22);%0A++++%0A++++++++//+Further+calls+to+%60Rc::from_raw(x_ptr)%60+would+be+memory-unsafe.%0A++++%7D%0A++++%0A++++//+The+memory+was+freed+when+%60x%60+went+out+of+scope+above,+so+%60x_ptr%60+is+now+dangling!%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Convert a slice back into its original array:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x: Rc&lt;[u32]&gt; = Rc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"kw\">let </span>x_ptr: <span class=\"kw-2\">*const </span>[u32] = Rc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>x: Rc&lt;[u32; <span class=\"number\">3</span>]&gt; = Rc::from_raw(x_ptr.cast::&lt;[u32; <span class=\"number\">3</span>]&gt;());\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3C%5Bu32%5D%3E+=+Rc::new(%5B1,+2,+3%5D);%0A++++let+x_ptr:+*const+%5Bu32%5D+=+Rc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++let+x:+Rc%3C%5Bu32;+3%5D%3E+=+Rc::from_raw(x_ptr.cast::%3C%5Bu32;+3%5D%3E());%0A++++++++assert_eq!(%26*x,+%26%5B1,+2,+3%5D);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.increment_strong_count\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.53.0\">1.53.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1294\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.increment_strong_count\" class=\"fn\">increment_strong_count</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>)</h4></section></summary><div class=\"docblock\"><p>Increments the strong reference count on the <code>Rc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">Â§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Rc::into_raw</code>, the\nassociated <code>Rc</code> instance must be valid (i.e. the strong count must be at\nleast 1) for the duration of this method, and <code>ptr</code> must point to a block of memory\nallocated by the global allocator.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Rc::into_raw(five);\n    Rc::increment_strong_count(ptr);\n\n    <span class=\"kw\">let </span>five = Rc::from_raw(ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Rc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Rc::into_raw(five);%0A++++++++Rc::increment_strong_count(ptr);%0A++++%0A++++++++let+five+=+Rc::from_raw(ptr);%0A++++++++assert_eq!(2,+Rc::strong_count(%26five));%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.decrement_strong_count\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.53.0\">1.53.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1328\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.decrement_strong_count\" class=\"fn\">decrement_strong_count</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>)</h4></section></summary><div class=\"docblock\"><p>Decrements the strong reference count on the <code>Rc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">Â§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Rc::into_raw</code>, the\nassociated <code>Rc</code> instance must be valid (i.e. the strong count must be at\nleast 1) when invoking this method, and <code>ptr</code> must point to a block of memory\nallocated by the global allocator. This method can be used to release the final <code>Rc</code> and\nbacking storage, but <strong>should not</strong> be called after the final <code>Rc</code> has been released.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Rc::into_raw(five);\n    Rc::increment_strong_count(ptr);\n\n    <span class=\"kw\">let </span>five = Rc::from_raw(ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Rc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n    Rc::decrement_strong_count(ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, Rc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Rc::into_raw(five);%0A++++++++Rc::increment_strong_count(ptr);%0A++++%0A++++++++let+five+=+Rc::from_raw(ptr);%0A++++++++assert_eq!(2,+Rc::strong_count(%26five));%0A++++++++Rc::decrement_strong_count(ptr);%0A++++++++assert_eq!(1,+Rc::strong_count(%26five));%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3CT,+A%3E-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1333\">source</a><a href=\"#impl-Rc%3CT,+A%3E-1\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_raw\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1351\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_raw\" class=\"fn\">into_raw</a>(this: <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a></h4></section></summary><div class=\"docblock\"><p>Consumes the <code>Rc</code>, returning the wrapped pointer.</p>\n<p>To avoid a memory leak the pointer must be converted back to an <code>Rc</code> using\n<a href=\"struct.Rc.html#method.from_raw\" title=\"associated function std::rc::Rc::from_raw\"><code>Rc::from_raw</code></a>.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x = Rc::new(<span class=\"string\">\"hello\"</span>.to_owned());\n<span class=\"kw\">let </span>x_ptr = Rc::into_raw(x);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x_ptr }, <span class=\"string\">\"hello\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(%22hello%22.to_owned());%0A++++let+x_ptr+=+Rc::into_raw(x);%0A++++assert_eq!(unsafe+%7B+%26*x_ptr+%7D,+%22hello%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_raw_with_allocator\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1376\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.into_raw_with_allocator\" class=\"fn\">into_raw_with_allocator</a>(this: <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; (<a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>, A)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Consumes the <code>Rc</code>, returning the wrapped pointer and allocator.</p>\n<p>To avoid a memory leak the pointer must be converted back to an <code>Rc</code> using\n<a href=\"struct.Rc.html#method.from_raw_in\" title=\"associated function std::rc::Rc::from_raw_in\"><code>Rc::from_raw_in</code></a>.</p>\n<h5 id=\"examples-25\"><a class=\"doc-anchor\" href=\"#examples-25\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x = Rc::new_in(<span class=\"string\">\"hello\"</span>.to_owned(), System);\n<span class=\"kw\">let </span>(ptr, alloc) = Rc::into_raw_with_allocator(x);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>ptr }, <span class=\"string\">\"hello\"</span>);\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ Rc::from_raw_in(ptr, alloc) };\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"string\">\"hello\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x+=+Rc::new_in(%22hello%22.to_owned(),+System);%0A++++let+(ptr,+alloc)+=+Rc::into_raw_with_allocator(x);%0A++++assert_eq!(unsafe+%7B+%26*ptr+%7D,+%22hello%22);%0A++++let+x+=+unsafe+%7B+Rc::from_raw_in(ptr,+alloc)+%7D;%0A++++assert_eq!(%26*x,+%22hello%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.45.0\">1.45.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1402\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_ptr\" class=\"fn\">as_ptr</a>(this: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a></h4></section></summary><div class=\"docblock\"><p>Provides a raw pointer to the data.</p>\n<p>The counts are not affected in any way and the <code>Rc</code> is not consumed. The pointer is valid\nfor as long there are strong counts in the <code>Rc</code>.</p>\n<h5 id=\"examples-26\"><a class=\"doc-anchor\" href=\"#examples-26\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x = Rc::new(<span class=\"string\">\"hello\"</span>.to_owned());\n<span class=\"kw\">let </span>y = Rc::clone(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"kw\">let </span>x_ptr = Rc::as_ptr(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"macro\">assert_eq!</span>(x_ptr, Rc::as_ptr(<span class=\"kw-2\">&amp;</span>y));\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x_ptr }, <span class=\"string\">\"hello\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x+=+Rc::new(%22hello%22.to_owned());%0A++++let+y+=+Rc::clone(%26x);%0A++++let+x_ptr+=+Rc::as_ptr(%26x);%0A++++assert_eq!(x_ptr,+Rc::as_ptr(%26y));%0A++++assert_eq!(unsafe+%7B+%26*x_ptr+%7D,+%22hello%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_raw_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1479\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.from_raw_in\" class=\"fn\">from_raw_in</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>, alloc: A) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs an <code>Rc&lt;T, A&gt;</code> from a raw pointer in the provided allocator.</p>\n<p>The raw pointer must have been previously returned by a call to <a href=\"struct.Rc.html#method.into_raw\" title=\"associated function std::rc::Rc::into_raw\"><code>Rc&lt;U, A&gt;::into_raw</code></a> with the following requirements:</p>\n<ul>\n<li>If <code>U</code> is sized, it must have the same size and alignment as <code>T</code>. This\nis trivially true if <code>U</code> is <code>T</code>.</li>\n<li>If <code>U</code> is unsized, its data pointer must have the same size and\nalignment as <code>T</code>. This is trivially true if <code>Rc&lt;U&gt;</code> was constructed\nthrough <code>Rc&lt;T&gt;</code> and then converted to <code>Rc&lt;U&gt;</code> through an <a href=\"https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions\">unsized\ncoercion</a>.</li>\n</ul>\n<p>Note that if <code>U</code> or <code>U</code>â€™s data pointer is not <code>T</code> but has the same size\nand alignment, this is basically like transmuting references of\ndifferent types. See <a href=\"../mem/fn.transmute.html\" title=\"fn std::mem::transmute\"><code>mem::transmute</code></a> for more information\non what restrictions apply in this case.</p>\n<p>The raw pointer must point to a block of memory allocated by <code>alloc</code></p>\n<p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only\ndropped once.</p>\n<p>This function is unsafe because improper use may lead to memory unsafety,\neven if the returned <code>Rc&lt;T&gt;</code> is never accessed.</p>\n<h5 id=\"examples-27\"><a class=\"doc-anchor\" href=\"#examples-27\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x = Rc::new_in(<span class=\"string\">\"hello\"</span>.to_owned(), System);\n<span class=\"kw\">let </span>x_ptr = Rc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Convert back to an `Rc` to prevent leak.\n    </span><span class=\"kw\">let </span>x = Rc::from_raw_in(x_ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"string\">\"hello\"</span>);\n\n    <span class=\"comment\">// Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.\n</span>}\n\n<span class=\"comment\">// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x+=+Rc::new_in(%22hello%22.to_owned(),+System);%0A++++let+x_ptr+=+Rc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++//+Convert+back+to+an+%60Rc%60+to+prevent+leak.%0A++++++++let+x+=+Rc::from_raw_in(x_ptr,+System);%0A++++++++assert_eq!(%26*x,+%22hello%22);%0A++++%0A++++++++//+Further+calls+to+%60Rc::from_raw(x_ptr)%60+would+be+memory-unsafe.%0A++++%7D%0A++++%0A++++//+The+memory+was+freed+when+%60x%60+went+out+of+scope+above,+so+%60x_ptr%60+is+now+dangling!%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Convert a slice back into its original array:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x: Rc&lt;[u32], <span class=\"kw\">_</span>&gt; = Rc::new_in([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], System);\n<span class=\"kw\">let </span>x_ptr: <span class=\"kw-2\">*const </span>[u32] = Rc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>x: Rc&lt;[u32; <span class=\"number\">3</span>], <span class=\"kw\">_</span>&gt; = Rc::from_raw_in(x_ptr.cast::&lt;[u32; <span class=\"number\">3</span>]&gt;(), System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x:+Rc%3C%5Bu32%5D,+_%3E+=+Rc::new_in(%5B1,+2,+3%5D,+System);%0A++++let+x_ptr:+*const+%5Bu32%5D+=+Rc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++let+x:+Rc%3C%5Bu32;+3%5D,+_%3E+=+Rc::from_raw_in(x_ptr.cast::%3C%5Bu32;+3%5D%3E(),+System);%0A++++++++assert_eq!(%26*x,+%26%5B1,+2,+3%5D);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.downgrade\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1502-1504\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.downgrade\" class=\"fn\">downgrade</a>(this: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"struct\" href=\"struct.Weak.html\" title=\"struct std::rc::Weak\">Weak</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates a new <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointer to this allocation.</p>\n<h5 id=\"examples-28\"><a class=\"doc-anchor\" href=\"#examples-28\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>weak_five = Rc::downgrade(<span class=\"kw-2\">&amp;</span>five);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++let+weak_five+=+Rc::downgrade(%26five);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.weak_count\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1526\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.weak_count\" class=\"fn\">weak_count</a>(this: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Gets the number of <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointers to this allocation.</p>\n<h5 id=\"examples-29\"><a class=\"doc-anchor\" href=\"#examples-29\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>_weak_five = Rc::downgrade(<span class=\"kw-2\">&amp;</span>five);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, Rc::weak_count(<span class=\"kw-2\">&amp;</span>five));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++let+_weak_five+=+Rc::downgrade(%26five);%0A++++%0A++++assert_eq!(1,+Rc::weak_count(%26five));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.strong_count\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1544\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.strong_count\" class=\"fn\">strong_count</a>(this: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Gets the number of strong (<code>Rc</code>) pointers to this allocation.</p>\n<h5 id=\"examples-30\"><a class=\"doc-anchor\" href=\"#examples-30\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>_also_five = Rc::clone(<span class=\"kw-2\">&amp;</span>five);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Rc::strong_count(<span class=\"kw-2\">&amp;</span>five));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++let+_also_five+=+Rc::clone(%26five);%0A++++%0A++++assert_eq!(2,+Rc::strong_count(%26five));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.increment_strong_count_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1578-1580\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.increment_strong_count_in\" class=\"fn\">increment_strong_count_in</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>, alloc: A)<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Increments the strong reference count on the <code>Rc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-4\"><a class=\"doc-anchor\" href=\"#safety-4\">Â§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Rc::into_raw</code>, the\nassociated <code>Rc</code> instance must be valid (i.e. the strong count must be at\nleast 1) for the duration of this method, and <code>ptr</code> must point to a block of memory\nallocated by <code>alloc</code></p>\n<h5 id=\"examples-31\"><a class=\"doc-anchor\" href=\"#examples-31\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Rc::new_in(<span class=\"number\">5</span>, System);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Rc::into_raw(five);\n    Rc::increment_strong_count_in(ptr, System);\n\n    <span class=\"kw\">let </span>five = Rc::from_raw_in(ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Rc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Rc::new_in(5,+System);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Rc::into_raw(five);%0A++++++++Rc::increment_strong_count_in(ptr,+System);%0A++++%0A++++++++let+five+=+Rc::from_raw_in(ptr,+System);%0A++++++++assert_eq!(2,+Rc::strong_count(%26five));%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.decrement_strong_count_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1621\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.decrement_strong_count_in\" class=\"fn\">decrement_strong_count_in</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>, alloc: A)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Decrements the strong reference count on the <code>Rc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-5\"><a class=\"doc-anchor\" href=\"#safety-5\">Â§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Rc::into_raw</code>, the\nassociated <code>Rc</code> instance must be valid (i.e. the strong count must be at\nleast 1) when invoking this method, and <code>ptr</code> must point to a block of memory\nallocated by <code>alloc</code>. This method can be used to release the final <code>Rc</code> and backing storage,\nbut <strong>should not</strong> be called after the final <code>Rc</code> has been released.</p>\n<h5 id=\"examples-32\"><a class=\"doc-anchor\" href=\"#examples-32\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Rc::new_in(<span class=\"number\">5</span>, System);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Rc::into_raw(five);\n    Rc::increment_strong_count_in(ptr, System);\n\n    <span class=\"kw\">let </span>five = Rc::from_raw_in(ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Rc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n    Rc::decrement_strong_count_in(ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, Rc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Rc::new_in(5,+System);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Rc::into_raw(five);%0A++++++++Rc::increment_strong_count_in(ptr,+System);%0A++++%0A++++++++let+five+=+Rc::from_raw_in(ptr,+System);%0A++++++++assert_eq!(2,+Rc::strong_count(%26five));%0A++++++++Rc::decrement_strong_count_in(ptr,+System);%0A++++++++assert_eq!(1,+Rc::strong_count(%26five));%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1658\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.get_mut\" class=\"fn\">get_mut</a>(this: &amp;mut <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference into the given <code>Rc</code>, if there are\nno other <code>Rc</code> or <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointers to the same allocation.</p>\n<p>Returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> otherwise, because it is not safe to\nmutate a shared value.</p>\n<p>See also <a href=\"struct.Rc.html#method.make_mut\" title=\"associated function std::rc::Rc::make_mut\"><code>make_mut</code></a>, which will <a href=\"../clone/trait.Clone.html#tymethod.clone\" title=\"method std::clone::Clone::clone\"><code>clone</code></a>\nthe inner value when there are other <code>Rc</code> pointers.</p>\n<h5 id=\"examples-33\"><a class=\"doc-anchor\" href=\"#examples-33\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = Rc::new(<span class=\"number\">3</span>);\n<span class=\"kw-2\">*</span>Rc::get_mut(<span class=\"kw-2\">&amp;mut </span>x).unwrap() = <span class=\"number\">4</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">4</span>);\n\n<span class=\"kw\">let </span>_y = Rc::clone(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"macro\">assert!</span>(Rc::get_mut(<span class=\"kw-2\">&amp;mut </span>x).is_none());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+x+=+Rc::new(3);%0A++++*Rc::get_mut(%26mut+x).unwrap()+=+4;%0A++++assert_eq!(*x,+4);%0A++++%0A++++let+_y+=+Rc::clone(%26x);%0A++++assert!(Rc::get_mut(%26mut+x).is_none());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_mut_unchecked\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1724\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.get_mut_unchecked\" class=\"fn\">get_mut_unchecked</a>(this: &amp;mut <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>get_mut_unchecked</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63292\">#63292</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns a mutable reference into the given <code>Rc</code>,\nwithout any check.</p>\n<p>See also <a href=\"struct.Rc.html#method.get_mut\" title=\"associated function std::rc::Rc::get_mut\"><code>get_mut</code></a>, which is safe and does appropriate checks.</p>\n<h5 id=\"safety-6\"><a class=\"doc-anchor\" href=\"#safety-6\">Â§</a>Safety</h5>\n<p>If any other <code>Rc</code> or <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointers to the same allocation exist, then\nthey must not be dereferenced or have active borrows for the duration\nof the returned borrow, and their inner type must be exactly the same as the\ninner type of this Rc (including lifetimes). This is trivially the case if no\nsuch pointers exist, for example immediately after <code>Rc::new</code>.</p>\n<h5 id=\"examples-34\"><a class=\"doc-anchor\" href=\"#examples-34\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = Rc::new(String::new());\n<span class=\"kw\">unsafe </span>{\n    Rc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>x).push_str(<span class=\"string\">\"foo\"</span>)\n}\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"string\">\"foo\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+x+=+Rc::new(String::new());%0A++++unsafe+%7B%0A++++++++Rc::get_mut_unchecked(%26mut+x).push_str(%22foo%22)%0A++++%7D%0A++++assert_eq!(*x,+%22foo%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Other <code>Rc</code> pointers to the same allocation must be to the same type.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x: Rc&lt;str&gt; = Rc::from(<span class=\"string\">\"Hello, world!\"</span>);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>y: Rc&lt;[u8]&gt; = x.clone().into();\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// this is Undefined Behavior, because x's inner type is str, not [u8]\n    </span>Rc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>y).fill(<span class=\"number\">0xff</span>); <span class=\"comment\">// 0xff is invalid in UTF-8\n</span>}\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"kw-2\">&amp;*</span>x); <span class=\"comment\">// Invalid UTF-8 in a str</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3Cstr%3E+=+Rc::from(%22Hello,+world!%22);%0A++++let+mut+y:+Rc%3C%5Bu8%5D%3E+=+x.clone().into();%0A++++unsafe+%7B%0A++++++++//+this+is+Undefined+Behavior,+because+x's+inner+type+is+str,+not+%5Bu8%5D%0A++++++++Rc::get_mut_unchecked(%26mut+y).fill(0xff);+//+0xff+is+invalid+in+UTF-8%0A++++%7D%0A++++println!(%22%7B%7D%22,+%26*x);+//+Invalid+UTF-8+in+a+str%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Other <code>Rc</code> pointers to the same allocation must be to the exact same type, including lifetimes.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x: Rc&lt;<span class=\"kw-2\">&amp;</span>str&gt; = Rc::new(<span class=\"string\">\"Hello, world!\"</span>);\n{\n    <span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"Oh, no!\"</span>);\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>y: Rc&lt;<span class=\"kw-2\">&amp;</span>str&gt; = x.clone().into();\n    <span class=\"kw\">unsafe </span>{\n        <span class=\"comment\">// this is Undefined Behavior, because x's inner type\n        // is &amp;'long str, not &amp;'short str\n        </span><span class=\"kw-2\">*</span>Rc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>y) = <span class=\"kw-2\">&amp;</span>s;\n    }\n}\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"kw-2\">&amp;*</span>x); <span class=\"comment\">// Use-after-free</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3C%26str%3E+=+Rc::new(%22Hello,+world!%22);%0A++++%7B%0A++++++++let+s+=+String::from(%22Oh,+no!%22);%0A++++++++let+mut+y:+Rc%3C%26str%3E+=+x.clone().into();%0A++++++++unsafe+%7B%0A++++++++++++//+this+is+Undefined+Behavior,+because+x's+inner+type%0A++++++++++++//+is+%26'long+str,+not+%26'short+str%0A++++++++++++*Rc::get_mut_unchecked(%26mut+y)+=+%26s;%0A++++++++%7D%0A++++%7D%0A++++println!(%22%7B%7D%22,+%26*x);+//+Use-after-free%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ptr_eq\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1747\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.ptr_eq\" class=\"fn\">ptr_eq</a>(this: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;, other: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the two <code>Rc</code>s point to the same allocation in a vein similar to\n<a href=\"../ptr/fn.eq.html\" title=\"fn std::ptr::eq\"><code>ptr::eq</code></a>. This function ignores the metadata of  <code>dyn Trait</code> pointers.</p>\n<h5 id=\"examples-35\"><a class=\"doc-anchor\" href=\"#examples-35\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>same_five = Rc::clone(<span class=\"kw-2\">&amp;</span>five);\n<span class=\"kw\">let </span>other_five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(Rc::ptr_eq(<span class=\"kw-2\">&amp;</span>five, <span class=\"kw-2\">&amp;</span>same_five));\n<span class=\"macro\">assert!</span>(!Rc::ptr_eq(<span class=\"kw-2\">&amp;</span>five, <span class=\"kw-2\">&amp;</span>other_five));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++let+same_five+=+Rc::clone(%26five);%0A++++let+other_five+=+Rc::new(5);%0A++++%0A++++assert!(Rc::ptr_eq(%26five,+%26same_five));%0A++++assert!(!Rc::ptr_eq(%26five,+%26other_five));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3CT,+A%3E-2\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1752\">source</a><a href=\"#impl-Rc%3CT,+A%3E-2\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.make_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1806\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.make_mut\" class=\"fn\">make_mut</a>(this: &amp;mut <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\"><p>Makes a mutable reference into the given <code>Rc</code>.</p>\n<p>If there are other <code>Rc</code> pointers to the same allocation, then <code>make_mut</code> will\n<a href=\"../clone/trait.Clone.html#tymethod.clone\" title=\"method std::clone::Clone::clone\"><code>clone</code></a> the inner value to a new allocation to ensure unique ownership.  This is also\nreferred to as clone-on-write.</p>\n<p>However, if there are no other <code>Rc</code> pointers to this allocation, but some <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a>\npointers, then the <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointers will be disassociated and the inner value will not\nbe cloned.</p>\n<p>See also <a href=\"struct.Rc.html#method.get_mut\" title=\"associated function std::rc::Rc::get_mut\"><code>get_mut</code></a>, which will fail rather than cloning the inner value\nor disassociating <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointers.</p>\n<h5 id=\"examples-36\"><a class=\"doc-anchor\" href=\"#examples-36\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw-2\">*</span>Rc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;         <span class=\"comment\">// Won't clone anything\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>other_data = Rc::clone(<span class=\"kw-2\">&amp;</span>data); <span class=\"comment\">// Won't clone inner data\n</span><span class=\"kw-2\">*</span>Rc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;         <span class=\"comment\">// Clones inner data\n</span><span class=\"kw-2\">*</span>Rc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;         <span class=\"comment\">// Won't clone anything\n</span><span class=\"kw-2\">*</span>Rc::make_mut(<span class=\"kw-2\">&amp;mut </span>other_data) <span class=\"kw-2\">*</span>= <span class=\"number\">2</span>;   <span class=\"comment\">// Won't clone anything\n\n// Now `data` and `other_data` point to different allocations.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>data, <span class=\"number\">8</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>other_data, <span class=\"number\">12</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+data+=+Rc::new(5);%0A++++%0A++++*Rc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Won't+clone+anything%0A++++let+mut+other_data+=+Rc::clone(%26data);+//+Won't+clone+inner+data%0A++++*Rc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Clones+inner+data%0A++++*Rc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Won't+clone+anything%0A++++*Rc::make_mut(%26mut+other_data)+*=+2;+++//+Won't+clone+anything%0A++++%0A++++//+Now+%60data%60+and+%60other_data%60+point+to+different+allocations.%0A++++assert_eq!(*data,+8);%0A++++assert_eq!(*other_data,+12);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointers will be disassociated:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data = Rc::new(<span class=\"number\">75</span>);\n<span class=\"kw\">let </span>weak = Rc::downgrade(<span class=\"kw-2\">&amp;</span>data);\n\n<span class=\"macro\">assert!</span>(<span class=\"number\">75 </span>== <span class=\"kw-2\">*</span>data);\n<span class=\"macro\">assert!</span>(<span class=\"number\">75 </span>== <span class=\"kw-2\">*</span>weak.upgrade().unwrap());\n\n<span class=\"kw-2\">*</span>Rc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;\n\n<span class=\"macro\">assert!</span>(<span class=\"number\">76 </span>== <span class=\"kw-2\">*</span>data);\n<span class=\"macro\">assert!</span>(weak.upgrade().is_none());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+mut+data+=+Rc::new(75);%0A++++let+weak+=+Rc::downgrade(%26data);%0A++++%0A++++assert!(75+==+*data);%0A++++assert!(75+==+*weak.upgrade().unwrap());%0A++++%0A++++*Rc::make_mut(%26mut+data)+%2B=+1;%0A++++%0A++++assert!(76+==+*data);%0A++++assert!(weak.upgrade().is_none());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3CT,+A%3E-3\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1839\">source</a><a href=\"#impl-Rc%3CT,+A%3E-3\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.unwrap_or_clone\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.76.0\">1.76.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1870\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.unwrap_or_clone\" class=\"fn\">unwrap_or_clone</a>(this: <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; T</h4></section></summary><div class=\"docblock\"><p>If we have the only reference to <code>T</code> then unwrap it. Otherwise, clone <code>T</code> and return the\nclone.</p>\n<p>Assuming <code>rc_t</code> is of type <code>Rc&lt;T&gt;</code>, this function is functionally equivalent to\n<code>(*rc_t).clone()</code>, but will avoid cloning the inner value where possible.</p>\n<h5 id=\"examples-37\"><a class=\"doc-anchor\" href=\"#examples-37\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>inner = String::from(<span class=\"string\">\"test\"</span>);\n<span class=\"kw\">let </span>ptr = inner.as_ptr();\n\n<span class=\"kw\">let </span>rc = Rc::new(inner);\n<span class=\"kw\">let </span>inner = Rc::unwrap_or_clone(rc);\n<span class=\"comment\">// The inner value was not cloned\n</span><span class=\"macro\">assert!</span>(ptr::eq(ptr, inner.as_ptr()));\n\n<span class=\"kw\">let </span>rc = Rc::new(inner);\n<span class=\"kw\">let </span>rc2 = rc.clone();\n<span class=\"kw\">let </span>inner = Rc::unwrap_or_clone(rc);\n<span class=\"comment\">// Because there were 2 references, we had to clone the inner value.\n</span><span class=\"macro\">assert!</span>(!ptr::eq(ptr, inner.as_ptr()));\n<span class=\"comment\">// `rc2` is the last reference, so when we unwrap it we get back\n// the original `String`.\n</span><span class=\"kw\">let </span>inner = Rc::unwrap_or_clone(rc2);\n<span class=\"macro\">assert!</span>(ptr::eq(ptr, inner.as_ptr()));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bptr,+rc::Rc%7D;%0A++++let+inner+=+String::from(%22test%22);%0A++++let+ptr+=+inner.as_ptr();%0A++++%0A++++let+rc+=+Rc::new(inner);%0A++++let+inner+=+Rc::unwrap_or_clone(rc);%0A++++//+The+inner+value+was+not+cloned%0A++++assert!(ptr::eq(ptr,+inner.as_ptr()));%0A++++%0A++++let+rc+=+Rc::new(inner);%0A++++let+rc2+=+rc.clone();%0A++++let+inner+=+Rc::unwrap_or_clone(rc);%0A++++//+Because+there+were+2+references,+we+had+to+clone+the+inner+value.%0A++++assert!(!ptr::eq(ptr,+inner.as_ptr()));%0A++++//+%60rc2%60+is+the+last+reference,+so+when+we+unwrap+it+we+get+back%0A++++//+the+original+%60String%60.%0A++++let+inner+=+Rc::unwrap_or_clone(rc2);%0A++++assert!(ptr::eq(ptr,+inner.as_ptr()));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rc%3Cdyn+Any,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1875\">source</a><a href=\"#impl-Rc%3Cdyn+Any,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;dyn <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.downcast\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.29.0\">1.29.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1896\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.downcast\" class=\"fn\">downcast</a>&lt;T&gt;(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;, <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;dyn <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a>, A&gt;&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a>,</div></h4></section></summary><div class=\"docblock\"><p>Attempt to downcast the <code>Rc&lt;dyn Any&gt;</code> to a concrete type.</p>\n<h5 id=\"examples-38\"><a class=\"doc-anchor\" href=\"#examples-38\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::any::Any;\n<span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">fn </span>print_if_string(value: Rc&lt;<span class=\"kw\">dyn </span>Any&gt;) {\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Ok</span>(string) = value.downcast::&lt;String&gt;() {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"String ({}): {}\"</span>, string.len(), string);\n    }\n}\n\n<span class=\"kw\">let </span>my_string = <span class=\"string\">\"Hello World\"</span>.to_string();\nprint_if_string(Rc::new(my_string));\nprint_if_string(Rc::new(<span class=\"number\">0i8</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::any::Any;%0A++++use+std::rc::Rc;%0A++++%0A++++fn+print_if_string(value:+Rc%3Cdyn+Any%3E)+%7B%0A++++++++if+let+Ok(string)+=+value.downcast::%3CString%3E()+%7B%0A++++++++++++println!(%22String+(%7B%7D):+%7B%7D%22,+string.len(),+string);%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+my_string+=+%22Hello+World%22.to_string();%0A++++print_if_string(Rc::new(my_string));%0A++++print_if_string(Rc::new(0i8));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.downcast_unchecked\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#1935\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.downcast_unchecked\" class=\"fn\">downcast_unchecked</a>&lt;T&gt;(self) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>downcast_unchecked</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/90850\">#90850</a>)</span></div></span></summary><div class=\"docblock\"><p>Downcasts the <code>Rc&lt;dyn Any&gt;</code> to a concrete type.</p>\n<p>For a safe alternative see <a href=\"struct.Rc.html#method.downcast\" title=\"method std::rc::Rc::downcast\"><code>downcast</code></a>.</p>\n<h5 id=\"examples-39\"><a class=\"doc-anchor\" href=\"#examples-39\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(downcast_unchecked)]\n\n</span><span class=\"kw\">use </span>std::any::Any;\n<span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x: Rc&lt;<span class=\"kw\">dyn </span>Any&gt; = Rc::new(<span class=\"number\">1_usize</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x.downcast_unchecked::&lt;usize&gt;(), <span class=\"number\">1</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(downcast_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::any::Any;%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3Cdyn+Any%3E+=+Rc::new(1_usize);%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(*x.downcast_unchecked::%3Cusize%3E(),+1);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<h5 id=\"safety-7\"><a class=\"doc-anchor\" href=\"#safety-7\">Â§</a>Safety</h5>\n<p>The contained value must be of type <code>T</code>. Calling this method\nwith the incorrect type is <em>undefined behavior</em>.</p>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">Â§</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsFd-for-Rc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.69.0\">1.69.0</span> Â· <a class=\"src\" href=\"../../src/std/os/fd/owned.rs.html#415-420\">source</a></span><a href=\"#impl-AsFd-for-Rc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T: <a class=\"trait\" href=\"../os/fd/trait.AsFd.html\" title=\"trait std::os::fd::AsFd\">AsFd</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>&gt; <a class=\"trait\" href=\"../os/fd/trait.AsFd.html\" title=\"trait std::os::fd::AsFd\">AsFd</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_fd\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/os/fd/owned.rs.html#417-419\">source</a><a href=\"#method.as_fd\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../os/fd/trait.AsFd.html#tymethod.as_fd\" class=\"fn\">as_fd</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../os/fd/struct.BorrowedFd.html\" title=\"struct std::os::fd::BorrowedFd\">BorrowedFd</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\">Borrows the file descriptor. <a href=\"../os/fd/trait.AsFd.html#tymethod.as_fd\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsHandle-for-Rc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.71.0\">1.71.0</span> Â· <a class=\"src\" href=\"../../src/std/os/windows/io/handle.rs.html#487-492\">source</a></span><a href=\"#impl-AsHandle-for-Rc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T: <a class=\"trait\" href=\"../os/windows/io/trait.AsHandle.html\" title=\"trait std::os::windows::io::AsHandle\">AsHandle</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>&gt; <a class=\"trait\" href=\"../os/windows/io/trait.AsHandle.html\" title=\"trait std::os::windows::io::AsHandle\">AsHandle</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h3><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>Windows</strong> only.</div></span></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_handle\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/os/windows/io/handle.rs.html#489-491\">source</a><a href=\"#method.as_handle\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../os/windows/io/trait.AsHandle.html#tymethod.as_handle\" class=\"fn\">as_handle</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../os/windows/io/struct.BorrowedHandle.html\" title=\"struct std::os::windows::io::BorrowedHandle\">BorrowedHandle</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\">Borrows the handle. <a href=\"../os/windows/io/trait.AsHandle.html#tymethod.as_handle\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsRawFd-for-Rc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.69.0\">1.69.0</span> Â· <a class=\"src\" href=\"../../src/std/os/fd/raw.rs.html#261-266\">source</a></span><a href=\"#impl-AsRawFd-for-Rc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T: <a class=\"trait\" href=\"../os/fd/trait.AsRawFd.html\" title=\"trait std::os::fd::AsRawFd\">AsRawFd</a>&gt; <a class=\"trait\" href=\"../os/fd/trait.AsRawFd.html\" title=\"trait std::os::fd::AsRawFd\">AsRawFd</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_raw_fd\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/os/fd/raw.rs.html#263-265\">source</a><a href=\"#method.as_raw_fd\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../os/fd/trait.AsRawFd.html#tymethod.as_raw_fd\" class=\"fn\">as_raw_fd</a>(&amp;self) -&gt; <a class=\"type\" href=\"../os/fd/type.RawFd.html\" title=\"type std::os::fd::RawFd\">RawFd</a></h4></section></summary><div class=\"docblock\">Extracts the raw file descriptor. <a href=\"../os/fd/trait.AsRawFd.html#tymethod.as_raw_fd\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsRef%3CT%3E-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3488\">source</a></span><a href=\"#impl-AsRef%3CT%3E-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ref\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3489\">source</a><a href=\"#method.as_ref\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.AsRef.html#tymethod.as_ref\" class=\"fn\">as_ref</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsSocket-for-Rc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.71.0\">1.71.0</span> Â· <a class=\"src\" href=\"../../src/std/os/windows/io/socket.rs.html#278-283\">source</a></span><a href=\"#impl-AsSocket-for-Rc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T: <a class=\"trait\" href=\"../os/windows/io/trait.AsSocket.html\" title=\"trait std::os::windows::io::AsSocket\">AsSocket</a>&gt; <a class=\"trait\" href=\"../os/windows/io/trait.AsSocket.html\" title=\"trait std::os::windows::io::AsSocket\">AsSocket</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h3><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>Windows</strong> only.</div></span></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_socket\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/os/windows/io/socket.rs.html#280-282\">source</a><a href=\"#method.as_socket\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../os/windows/io/trait.AsSocket.html#tymethod.as_socket\" class=\"fn\">as_socket</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../os/windows/io/struct.BorrowedSocket.html\" title=\"struct std::os::windows::io::BorrowedSocket\">BorrowedSocket</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\">Borrows the socket.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Borrow%3CT%3E-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3481\">source</a></span><a href=\"#impl-Borrow%3CT%3E-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3482\">source</a><a href=\"#method.borrow\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Clone-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2209\">source</a></span><a href=\"#impl-Clone-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2225\">source</a><a href=\"#method.clone\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Makes a clone of the <code>Rc</code> pointer.</p>\n<p>This creates another pointer to the same allocation, increasing the\nstrong reference count.</p>\n<h5 id=\"examples-40\"><a class=\"doc-anchor\" href=\"#examples-40\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let _ </span>= Rc::clone(<span class=\"kw-2\">&amp;</span>five);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++let+_+=+Rc::clone(%26five);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#169\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Self</a>)</h4></section></summary><div class=\"docblock\">Performs copy-assignment from <code>source</code>. <a href=\"../clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2504\">source</a></span><a href=\"#impl-Debug-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2505\">source</a><a href=\"#method.fmt-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-Rc%3C%5BT%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2266\">source</a></span><a href=\"#impl-Default-for-Rc%3C%5BT%5D%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2271\">source</a><a href=\"#method.default-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty <code>[T]</code> inside an Rc</p>\n<p>This may or may not share an allocation with other Rcs on the same thread.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-Rc%3CCStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#915\">source</a></span><a href=\"#impl-Default-for-Rc%3CCStr%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#920\">source</a><a href=\"#method.default-2\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty CStr inside an Rc</p>\n<p>This may or may not share an allocation with other Rcs on the same thread.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-Rc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2235\">source</a></span><a href=\"#impl-Default-for-Rc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2247\">source</a><a href=\"#method.default\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>Rc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.</p>\n<h5 id=\"examples-43\"><a class=\"doc-anchor\" href=\"#examples-43\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>x: Rc&lt;i32&gt; = Default::default();\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+x:+Rc%3Ci32%3E+=+Default::default();%0A++++assert_eq!(*x,+0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-Rc%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2254\">source</a></span><a href=\"#impl-Default-for-Rc%3Cstr%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2259\">source</a><a href=\"#method.default-3\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty str inside an Rc</p>\n<p>This may or may not share an allocation with other Rcs on the same thread.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Deref-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2146\">source</a></span><a href=\"#impl-Deref-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../ops/trait.Deref.html\" title=\"trait std::ops::Deref\">Deref</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Target\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Target\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.Deref.html#associatedtype.Target\" class=\"associatedtype\">Target</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after dereferencing.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.deref\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2150\">source</a><a href=\"#method.deref\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.Deref.html#tymethod.deref\" class=\"fn\">deref</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Dereferences the value.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Display-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2497\">source</a></span><a href=\"#impl-Display-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2498\">source</a><a href=\"#method.fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Display.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Display.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Drop-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2162\">source</a></span><a href=\"#impl-Drop-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../ops/trait.Drop.html\" title=\"trait std::ops::Drop\">Drop</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.drop\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2188\">source</a><a href=\"#method.drop\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.Drop.html#tymethod.drop\" class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Drops the <code>Rc</code>.</p>\n<p>This will decrement the strong reference count. If the strong reference\ncount reaches zero then the only other references (if any) are\n<a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a>, so we <code>drop</code> the inner value.</p>\n<h5 id=\"examples-44\"><a class=\"doc-anchor\" href=\"#examples-44\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">struct </span>Foo;\n\n<span class=\"kw\">impl </span>Drop <span class=\"kw\">for </span>Foo {\n    <span class=\"kw\">fn </span>drop(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"dropped!\"</span>);\n    }\n}\n\n<span class=\"kw\">let </span>foo  = Rc::new(Foo);\n<span class=\"kw\">let </span>foo2 = Rc::clone(<span class=\"kw-2\">&amp;</span>foo);\n\ndrop(foo);    <span class=\"comment\">// Doesn't print anything\n</span>drop(foo2);   <span class=\"comment\">// Prints \"dropped!\"</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++struct+Foo;%0A++++%0A++++impl+Drop+for+Foo+%7B%0A++++++++fn+drop(%26mut+self)+%7B%0A++++++++++++println!(%22dropped!%22);%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+foo++=+Rc::new(Foo);%0A++++let+foo2+=+Rc::clone(%26foo);%0A++++%0A++++drop(foo);++++//+Doesn't+print+anything%0A++++drop(foo2);+++//+Prints+%22dropped!%22%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26%5BT%5D%3E-for-Rc%3C%5BT%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2561\">source</a></span><a href=\"#impl-From%3C%26%5BT%5D%3E-for-Rc%3C%5BT%5D%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2573\">source</a><a href=\"#method.from-3\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted slice and fill it by cloning <code>v</code>â€™s items.</p>\n<h5 id=\"example-2\"><a class=\"doc-anchor\" href=\"#example-2\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>original: <span class=\"kw-2\">&amp;</span>[i32] = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>shared: Rc&lt;[i32]&gt; = Rc::from(original);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+%26%5Bi32%5D+=+%26%5B1,+2,+3%5D;%0A++++let+shared:+Rc%3C%5Bi32%5D%3E+=+Rc::from(original);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26CStr%3E-for-Rc%3CCStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#903\">source</a></span><a href=\"#impl-From%3C%26CStr%3E-for-Rc%3CCStr%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-8\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#907\">source</a><a href=\"#method.from-8\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <code>&amp;CStr</code> into a <code>Rc&lt;CStr&gt;</code>,\nby copying the contents into a newly allocated <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a>.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26OsStr%3E-for-Rc%3COsStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> Â· <a class=\"src\" href=\"../../src/std/ffi/os_str.rs.html#1273-1280\">source</a></span><a href=\"#impl-From%3C%26OsStr%3E-for-Rc%3COsStr%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-16\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/ffi/os_str.rs.html#1276-1279\">source</a><a href=\"#method.from-16\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Copies the string into a newly allocated <code><a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</code>.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26Path%3E-for-Rc%3CPath%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> Â· <a class=\"src\" href=\"../../src/std/path.rs.html#1900-1907\">source</a></span><a href=\"#impl-From%3C%26Path%3E-for-Rc%3CPath%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-13\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/path.rs.html#1903-1906\">source</a><a href=\"#method.from-13\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"../path/struct.Path.html\" title=\"struct std::path::Path\"><code>Path</code></a> into an <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> by copying the <a href=\"../path/struct.Path.html\" title=\"struct std::path::Path\"><code>Path</code></a> data into a new <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> buffer.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26str%3E-for-Rc%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2580\">source</a></span><a href=\"#impl-From%3C%26str%3E-for-Rc%3Cstr%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2591\">source</a><a href=\"#method.from-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted string slice and copy <code>v</code> into it.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>shared: Rc&lt;str&gt; = Rc::from(<span class=\"string\">\"statue\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"statue\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+shared:+Rc%3Cstr%3E+=+Rc::from(%22statue%22);%0A++++assert_eq!(%22statue%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%5BT;+N%5D%3E-for-Rc%3C%5BT%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.74.0\">1.74.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2540\">source</a></span><a href=\"#impl-From%3C%5BT;+N%5D%3E-for-Rc%3C%5BT%5D%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-6\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2554\">source</a><a href=\"#method.from-6\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"../primitive.array.html\" title=\"primitive array\"><code>[T; N]</code></a> into an <code>Rc&lt;[T]&gt;</code>.</p>\n<p>The conversion moves the array into a newly allocated <code>Rc</code>.</p>\n<h5 id=\"example-4\"><a class=\"doc-anchor\" href=\"#example-4\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>original: [i32; <span class=\"number\">3</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>shared: Rc&lt;[i32]&gt; = Rc::from(original);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+%5Bi32;+3%5D+=+%5B1,+2,+3%5D;%0A++++let+shared:+Rc%3C%5Bi32%5D%3E+=+Rc::from(original);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CBox%3CT,+A%3E%3E-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2618\">source</a></span><a href=\"#impl-From%3CBox%3CT,+A%3E%3E-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;T, A&gt;&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-9\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2630\">source</a><a href=\"#method.from-9\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;T, A&gt;) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Move a boxed object to a new, reference counted, allocation.</p>\n<h5 id=\"example-5\"><a class=\"doc-anchor\" href=\"#example-5\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>original: Box&lt;i32&gt; = Box::new(<span class=\"number\">1</span>);\n<span class=\"kw\">let </span>shared: Rc&lt;i32&gt; = Rc::from(original);\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, <span class=\"kw-2\">*</span>shared);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+Box%3Ci32%3E+=+Box::new(1);%0A++++let+shared:+Rc%3Ci32%3E+=+Rc::from(original);%0A++++assert_eq!(1,+*shared);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CCString%3E-for-Rc%3CCStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#892\">source</a></span><a href=\"#impl-From%3CCString%3E-for-Rc%3CCStr%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CString.html\" title=\"struct std::ffi::CString\">CString</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-7\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#896\">source</a><a href=\"#method.from-7\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"../ffi/struct.CString.html\" title=\"struct std::ffi::CString\">CString</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"../ffi/struct.CString.html\" title=\"struct std::ffi::CString\"><code>CString</code></a> into an <code><a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</code> by moving the <a href=\"../ffi/struct.CString.html\" title=\"struct std::ffi::CString\"><code>CString</code></a>\ndata into a new <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> buffer.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CCow%3C'a,+B%3E%3E-for-Rc%3CB%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.45.0\">1.45.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2666-2669\">source</a></span><a href=\"#impl-From%3CCow%3C'a,+B%3E%3E-for-Rc%3CB%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'a, B&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, B&gt;&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;B&gt;<div class=\"where\">where\n    B: <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;B&gt;: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a B</a>&gt; + <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&lt;B as <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a>&gt;::<a class=\"associatedtype\" href=\"../borrow/trait.ToOwned.html#associatedtype.Owned\" title=\"type std::borrow::ToOwned::Owned\">Owned</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2684\">source</a><a href=\"#method.from-2\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(cow: <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, B&gt;) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;B&gt;</h4></section></summary><div class=\"docblock\"><p>Create a reference-counted pointer from\na clone-on-write pointer by copying its content.</p>\n<h5 id=\"example-1\"><a class=\"doc-anchor\" href=\"#example-1\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>cow: Cow&lt;<span class=\"lifetime\">'_</span>, str&gt; = Cow::Borrowed(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"kw\">let </span>shared: Rc&lt;str&gt; = Rc::from(cow);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::borrow::Cow;%0A++++let+cow:+Cow%3C'_,+str%3E+=+Cow::Borrowed(%22eggplant%22);%0A++++let+shared:+Rc%3Cstr%3E+=+Rc::from(cow);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3COsString%3E-for-Rc%3COsStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> Â· <a class=\"src\" href=\"../../src/std/ffi/os_str.rs.html#1262-1270\">source</a></span><a href=\"#impl-From%3COsString%3E-for-Rc%3COsStr%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-14\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/ffi/os_str.rs.html#1266-1269\">source</a><a href=\"#method.from-14\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts an <a href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a> into an <code><a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</code> by moving the <a href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a>\ndata into a new <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> buffer.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CPathBuf%3E-for-Rc%3CPath%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> Â· <a class=\"src\" href=\"../../src/std/path.rs.html#1889-1897\">source</a></span><a href=\"#impl-From%3CPathBuf%3E-for-Rc%3CPath%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\">PathBuf</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-15\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/path.rs.html#1893-1896\">source</a><a href=\"#method.from-15\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\">PathBuf</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\"><code>PathBuf</code></a> into an <code><a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</code> by moving the <a href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\"><code>PathBuf</code></a> data into\na new <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> buffer.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CRc%3CW%3E%3E-for-LocalWaker\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#287\">source</a><a href=\"#impl-From%3CRc%3CW%3E%3E-for-LocalWaker\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;W&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;W&gt;&gt; for <a class=\"struct\" href=\"../task/struct.LocalWaker.html\" title=\"struct std::task::LocalWaker\">LocalWaker</a><div class=\"where\">where\n    W: <a class=\"trait\" href=\"../task/trait.LocalWake.html\" title=\"trait std::task::LocalWake\">LocalWake</a> + 'static,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#291\">source</a><a href=\"#method.from-4\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(waker: <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;W&gt;) -&gt; <a class=\"struct\" href=\"../task/struct.LocalWaker.html\" title=\"struct std::task::LocalWaker\">LocalWaker</a></h4></section></summary><div class=\"docblock\"><p>Use a <code>Wake</code>-able type as a <code>LocalWaker</code>.</p>\n<p>No heap allocations or atomic operations are used for this conversion.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CRc%3CW%3E%3E-for-RawWaker\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#299\">source</a><a href=\"#impl-From%3CRc%3CW%3E%3E-for-RawWaker\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;W&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;W&gt;&gt; for <a class=\"struct\" href=\"../task/struct.RawWaker.html\" title=\"struct std::task::RawWaker\">RawWaker</a><div class=\"where\">where\n    W: <a class=\"trait\" href=\"../task/trait.LocalWake.html\" title=\"trait std::task::LocalWake\">LocalWake</a> + 'static,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#303\">source</a><a href=\"#method.from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(waker: <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;W&gt;) -&gt; <a class=\"struct\" href=\"../task/struct.RawWaker.html\" title=\"struct std::task::RawWaker\">RawWaker</a></h4></section></summary><div class=\"docblock\"><p>Use a <code>Wake</code>-able type as a <code>RawWaker</code>.</p>\n<p>No heap allocations or atomic operations are used for this conversion.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CRc%3Cstr%3E%3E-for-Rc%3C%5Bu8%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.62.0\">1.62.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2693\">source</a></span><a href=\"#impl-From%3CRc%3Cstr%3E%3E-for-Rc%3C%5Bu8%5D%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-12\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2705\">source</a><a href=\"#method.from-12\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(rc: <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a reference-counted string slice into a byte slice.</p>\n<h5 id=\"example-8\"><a class=\"doc-anchor\" href=\"#example-8\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>string: Rc&lt;str&gt; = Rc::from(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"kw\">let </span>bytes: Rc&lt;[u8]&gt; = Rc::from(string);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>.as_bytes(), bytes.as_ref());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+string:+Rc%3Cstr%3E+=+Rc::from(%22eggplant%22);%0A++++let+bytes:+Rc%3C%5Bu8%5D%3E+=+Rc::from(string);%0A++++assert_eq!(%22eggplant%22.as_bytes(),+bytes.as_ref());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-Rc%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2599\">source</a></span><a href=\"#impl-From%3CString%3E-for-Rc%3Cstr%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2611\">source</a><a href=\"#method.from-5\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted string slice and copy <code>v</code> into it.</p>\n<h5 id=\"example-3\"><a class=\"doc-anchor\" href=\"#example-3\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>original: String = <span class=\"string\">\"statue\"</span>.to_owned();\n<span class=\"kw\">let </span>shared: Rc&lt;str&gt; = Rc::from(original);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"statue\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+original:+String+=+%22statue%22.to_owned();%0A++++let+shared:+Rc%3Cstr%3E+=+Rc::from(original);%0A++++assert_eq!(%22statue%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CT%3E-for-Rc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2519\">source</a></span><a href=\"#impl-From%3CT%3E-for-Rc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-10\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2533\">source</a><a href=\"#method.from-10\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a generic type <code>T</code> into an <code>Rc&lt;T&gt;</code></p>\n<p>The conversion allocates on the heap and moves <code>t</code>\nfrom the stack into it.</p>\n<h5 id=\"example-6\"><a class=\"doc-anchor\" href=\"#example-6\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">5</span>;\n<span class=\"kw\">let </span>rc = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(Rc::from(x), rc);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+x+=+5;%0A++++let+rc+=+Rc::new(5);%0A++++%0A++++assert_eq!(Rc::from(x),+rc);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CVec%3CT,+A%3E%3E-for-Rc%3C%5BT%5D,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2637\">source</a></span><a href=\"#impl-From%3CVec%3CT,+A%3E%3E-for-Rc%3C%5BT%5D,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-11\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2649\">source</a><a href=\"#method.from-11\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted slice and move <code>v</code>â€™s items into it.</p>\n<h5 id=\"example-7\"><a class=\"doc-anchor\" href=\"#example-7\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>unique: Vec&lt;i32&gt; = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>shared: Rc&lt;[i32]&gt; = Rc::from(unique);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+unique:+Vec%3Ci32%3E+=+vec!%5B1,+2,+3%5D;%0A++++let+shared:+Rc%3C%5Bi32%5D%3E+=+Rc::from(unique);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3CT%3E-for-Rc%3C%5BT%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.37.0\">1.37.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2727\">source</a></span><a href=\"#impl-FromIterator%3CT%3E-for-Rc%3C%5BT%5D%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2766\">source</a><a href=\"#method.from_iter\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Takes each element in the <code>Iterator</code> and collects it into an <code>Rc&lt;[T]&gt;</code>.</p>\n<h5 id=\"performance-characteristics\"><a class=\"doc-anchor\" href=\"#performance-characteristics\">Â§</a>Performance characteristics</h5><h6 id=\"the-general-case\"><a class=\"doc-anchor\" href=\"#the-general-case\">Â§</a>The general case</h6>\n<p>In the general case, collecting into <code>Rc&lt;[T]&gt;</code> is done by first\ncollecting into a <code>Vec&lt;T&gt;</code>. That is, when writing the following:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>evens: Rc&lt;[u8]&gt; = (<span class=\"number\">0</span>..<span class=\"number\">10</span>).filter(|<span class=\"kw-2\">&amp;</span>x| x % <span class=\"number\">2 </span>== <span class=\"number\">0</span>).collect();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+evens:+Rc%3C%5Bu8%5D%3E+=+(0..10).filter(%7C%26x%7C+x+%25+2+==+0).collect();%0A++++assert_eq!(%26*evens,+%26%5B0,+2,+4,+6,+8%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>this behaves as if we wrote:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>evens: Rc&lt;[u8]&gt; = (<span class=\"number\">0</span>..<span class=\"number\">10</span>).filter(|<span class=\"kw-2\">&amp;</span>x| x % <span class=\"number\">2 </span>== <span class=\"number\">0</span>)\n    .collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;() <span class=\"comment\">// The first set of allocations happens here.\n    </span>.into(); <span class=\"comment\">// A second allocation for `Rc&lt;[T]&gt;` happens here.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+evens:+Rc%3C%5Bu8%5D%3E+=+(0..10).filter(%7C%26x%7C+x+%25+2+==+0)%0A++++++++.collect::%3CVec%3C_%3E%3E()+//+The+first+set+of+allocations+happens+here.%0A++++++++.into();+//+A+second+allocation+for+%60Rc%3C%5BT%5D%3E%60+happens+here.%0A++++assert_eq!(%26*evens,+%26%5B0,+2,+4,+6,+8%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will allocate as many times as needed for constructing the <code>Vec&lt;T&gt;</code>\nand then it will allocate once for turning the <code>Vec&lt;T&gt;</code> into the <code>Rc&lt;[T]&gt;</code>.</p>\n<h6 id=\"iterators-of-known-length\"><a class=\"doc-anchor\" href=\"#iterators-of-known-length\">Â§</a>Iterators of known length</h6>\n<p>When your <code>Iterator</code> implements <code>TrustedLen</code> and is of an exact size,\na single allocation will be made for the <code>Rc&lt;[T]&gt;</code>. For example:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>evens: Rc&lt;[u8]&gt; = (<span class=\"number\">0</span>..<span class=\"number\">10</span>).collect(); <span class=\"comment\">// Just a single allocation happens here.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+evens:+Rc%3C%5Bu8%5D%3E+=+(0..10).collect();+//+Just+a+single+allocation+happens+here.%0A++++assert_eq!(%26*evens,+%26*(0..10).collect::%3CVec%3C_%3E%3E());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Hash-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2490\">source</a></span><a href=\"#impl-Hash-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2491\">source</a><a href=\"#method.hash\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../hash/trait.Hash.html#tymethod.hash\" class=\"fn\">hash</a>&lt;H&gt;(&amp;self, state: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,</div></h4></section></summary><div class=\"docblock\">Feeds this value into the given <a href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../hash/trait.Hash.html#tymethod.hash\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/hash/mod.rs.html#238-240\">source</a></span><a href=\"#method.hash_slice\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../hash/trait.Hash.html#method.hash_slice\" class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[Self]</a>, state: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Feeds a slice of this type into the given <a href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../hash/trait.Hash.html#method.hash_slice\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Ord-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2468\">source</a></span><a href=\"#impl-Ord-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2484\">source</a><a href=\"#method.cmp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#tymethod.cmp\" class=\"fn\">cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></h4></section></summary><div class=\"docblock\"><p>Comparison for two <code>Rc</code>s.</p>\n<p>The two are compared by calling <code>cmp()</code> on their inner values.</p>\n<h5 id=\"examples-50\"><a class=\"doc-anchor\" href=\"#examples-50\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(Ordering::Less, five.cmp(<span class=\"kw-2\">&amp;</span>Rc::new(<span class=\"number\">6</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert_eq!(Ordering::Less,+five.cmp(%26Rc::new(6)));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#856-858\">source</a></span><a href=\"#method.max\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.max\" class=\"fn\">max</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the maximum of two values. <a href=\"../cmp/trait.Ord.html#method.max\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#877-879\">source</a></span><a href=\"#method.min\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.min\" class=\"fn\">min</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the minimum of two values. <a href=\"../cmp/trait.Ord.html#method.min\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clamp\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.50.0\">1.50.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#903-906\">source</a></span><a href=\"#method.clamp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.clamp\" class=\"fn\">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section></summary><div class=\"docblock\">Restrict a value to a certain interval. <a href=\"../cmp/trait.Ord.html#method.clamp\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2323\">source</a></span><a href=\"#impl-PartialEq-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2343\">source</a><a href=\"#method.eq\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Equality for two <code>Rc</code>s.</p>\n<p>Two <code>Rc</code>s are equal if their inner values are equal, even if they are\nstored in different allocation.</p>\n<p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality),\ntwo <code>Rc</code>s that point to the same allocation are\nalways equal.</p>\n<h5 id=\"examples-41\"><a class=\"doc-anchor\" href=\"#examples-41\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five == Rc::new(<span class=\"number\">5</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+==+Rc::new(5));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2365\">source</a><a href=\"#method.ne\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Inequality for two <code>Rc</code>s.</p>\n<p>Two <code>Rc</code>s are not equal if their inner values are not equal.</p>\n<p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality),\ntwo <code>Rc</code>s that point to the same allocation are\nalways equal.</p>\n<h5 id=\"examples-42\"><a class=\"doc-anchor\" href=\"#examples-42\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five != Rc::new(<span class=\"number\">6</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+!=+Rc::new(6));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialOrd-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2374\">source</a></span><a href=\"#impl-PartialOrd-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2390\">source</a><a href=\"#method.partial_cmp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Partial comparison for two <code>Rc</code>s.</p>\n<p>The two are compared by calling <code>partial_cmp()</code> on their inner values.</p>\n<h5 id=\"examples-45\"><a class=\"doc-anchor\" href=\"#examples-45\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(Ordering::Less), five.partial_cmp(<span class=\"kw-2\">&amp;</span>Rc::new(<span class=\"number\">6</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert_eq!(Some(Ordering::Less),+five.partial_cmp(%26Rc::new(6)));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2408\">source</a><a href=\"#method.lt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Less-than comparison for two <code>Rc</code>s.</p>\n<p>The two are compared by calling <code>&lt;</code> on their inner values.</p>\n<h5 id=\"examples-46\"><a class=\"doc-anchor\" href=\"#examples-46\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &lt; Rc::new(<span class=\"number\">6</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+%3C+Rc::new(6));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2426\">source</a><a href=\"#method.le\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>â€˜Less than or equal toâ€™ comparison for two <code>Rc</code>s.</p>\n<p>The two are compared by calling <code>&lt;=</code> on their inner values.</p>\n<h5 id=\"examples-47\"><a class=\"doc-anchor\" href=\"#examples-47\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &lt;= Rc::new(<span class=\"number\">5</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+%3C=+Rc::new(5));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2444\">source</a><a href=\"#method.gt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Greater-than comparison for two <code>Rc</code>s.</p>\n<p>The two are compared by calling <code>&gt;</code> on their inner values.</p>\n<h5 id=\"examples-48\"><a class=\"doc-anchor\" href=\"#examples-48\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &gt; Rc::new(<span class=\"number\">4</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+%3E+Rc::new(4));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2462\">source</a><a href=\"#method.ge\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>â€˜Greater than or equal toâ€™ comparison for two <code>Rc</code>s.</p>\n<p>The two are compared by calling <code>&gt;=</code> on their inner values.</p>\n<h5 id=\"examples-49\"><a class=\"doc-anchor\" href=\"#examples-49\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>five = Rc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &gt;= Rc::new(<span class=\"number\">5</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+five+=+Rc::new(5);%0A++++%0A++++assert!(five+%3E=+Rc::new(5));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Pointer-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2511\">source</a></span><a href=\"#impl-Pointer-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../fmt/trait.Pointer.html\" title=\"trait std::fmt::Pointer\">Pointer</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2512\">source</a><a href=\"#method.fmt-2\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Pointer.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Pointer.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-TryFrom%3CRc%3C%5BT%5D,+A%3E%3E-for-Rc%3C%5BT;+N%5D,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2712\">source</a></span><a href=\"#impl-TryFrom%3CRc%3C%5BT%5D,+A%3E%3E-for-Rc%3C%5BT;+N%5D,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;</h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2715\">source</a><a href=\"#method.try_from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(\n    boxed_slice: <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;,\n) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>, A&gt;, &lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>, A&gt; as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><section id=\"impl-CoerceUnsized%3CRc%3CU,+A%3E%3E-for-Rc%3CT,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#341\">source</a><a href=\"#impl-CoerceUnsized%3CRc%3CU,+A%3E%3E-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U, A&gt; <a class=\"trait\" href=\"../ops/trait.CoerceUnsized.html\" title=\"trait std::ops::CoerceUnsized\">CoerceUnsized</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;U, A&gt;&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Unsize.html\" title=\"trait std::marker::Unsize\">Unsize</a>&lt;U&gt; + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    U: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-DerefPure-for-Rc%3CT,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2156\">source</a><a href=\"#impl-DerefPure-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../ops/trait.DerefPure.html\" title=\"trait std::ops::DerefPure\">DerefPure</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-DispatchFromDyn%3CRc%3CU%3E%3E-for-Rc%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#344\">source</a><a href=\"#impl-DispatchFromDyn%3CRc%3CU%3E%3E-for-Rc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../ops/trait.DispatchFromDyn.html\" title=\"trait std::ops::DispatchFromDyn\">DispatchFromDyn</a>&lt;<a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;U&gt;&gt; for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Unsize.html\" title=\"trait std::marker::Unsize\">Unsize</a>&lt;U&gt; + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    U: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Eq-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#2371\">source</a></span><a href=\"#impl-Eq-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section><section id=\"impl-RefUnwindSafe-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.58.0\">1.58.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#338\">source</a></span><a href=\"#impl-RefUnwindSafe-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a>,</div></h3></section><section id=\"impl-Send-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#325\">source</a></span><a href=\"#impl-Send-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; !<a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Sync-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#333\">source</a></span><a href=\"#impl-Sync-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; !<a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Unpin-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.33.0\">1.33.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3495\">source</a></span><a href=\"#impl-Unpin-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-UnwindSafe-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.9.0\">1.9.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#336\">source</a></span><a href=\"#impl-UnwindSafe-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a>,</div></h3></section></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">Â§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-Rc%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Freeze-for-Rc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">Â§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3C!%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#782\">source</a><a href=\"#impl-From%3C!%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.never.html\">!</a>&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-17\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#783\">source</a><a href=\"#method.from-17\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: <a class=\"primitive\" href=\"../primitive.never.html\">!</a>) -&gt; T</h4></section></summary><div class=\"docblock\">Converts to this type from the input type.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-18\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from-18\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToOwned-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85\">source</a><a href=\"#impl-ToOwned-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Owned\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88\">source</a><a href=\"#method.to_owned\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\">Creates owned data from borrowed data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92\">source</a><a href=\"#method.clone_into\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>)</h4></section></summary><div class=\"docblock\">Uses borrowed data to replace owned data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToString-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2552\">source</a><a href=\"#impl-ToString-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../string/trait.ToString.html\" title=\"trait std::string::ToString\">ToString</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_string\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2558\">source</a><a href=\"#method.to_string\" class=\"anchor\">Â§</a><h4 class=\"code-header\">default fn <a href=\"../string/trait.ToString.html#tymethod.to_string\" class=\"fn\">to_string</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\">Converts the given value to a <code>String</code>. <a href=\"../string/trait.ToString.html#tymethod.to_string\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-2\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-2\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:12:25.498Z"
}