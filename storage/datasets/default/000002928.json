{
	"title": "FileExt in std::os::unix::fs - Rust",
	"url": "https://doc.rust-lang.org/stable/std/os/unix/fs/trait.FileExt.html",
	"markdown": "# FileExt in std::os::unix::fs - Rust\n\n## Trait [std](../../../index.html)::[os](../../index.html)::[unix](../index.html)::[fs](index.html)::[FileExt](#)\n\n1.15.0 ¬∑ [source](about:blank/src/std/os/unix/fs.rs.html#26-260) ¬∑\n\n```\npub trait FileExt {\n    // Required methods\n    fn read_at(&self, buf: &mut [u8], offset: u64) -> Result<usize>;\n    fn write_at(&self, buf: &[u8], offset: u64) -> Result<usize>;\n\n    // Provided methods\n    fn read_vectored_at(\n        &self,\n        bufs: &mut [IoSliceMut<'_>],\n        offset: u64,\n    ) -> Result<usize> { ... }\n    fn read_exact_at(&self, buf: &mut [u8], offset: u64) -> Result<()> { ... }\n    fn write_vectored_at(\n        &self,\n        bufs: &[IoSlice<'_>],\n        offset: u64,\n    ) -> Result<usize> { ... }\n    fn write_all_at(&self, buf: &[u8], offset: u64) -> Result<()> { ... }\n}\n```\n\nAvailable on **Unix** only.\n\nExpand description\n\nUnix-specific extensions to [`fs::File`](../../../fs/struct.File.html \"struct std::fs::File\").\n\n1.15.0 ¬∑ [source](about:blank/src/std/os/unix/fs.rs.html#59)\n\nReads a number of bytes starting from a given offset.\n\nReturns the number of bytes read.\n\nThe offset is relative to the start of the file and thus independent from the current cursor.\n\nThe current file cursor is not affected by this function.\n\nNote that similar to [`File::read`](about:blank/fs/struct.File.html#method.read \"method std::fs::File::read\"), it is not an error to return with a short read.\n\n##### [¬ß](#examples)Examples\n\n```\nuse std::io;\nuse std::fs::File;\nuse std::os::unix::prelude::FileExt;\n\nfn main() -> io::Result<()> {\n    let mut buf = [0u8; 8];\n    let file = File::open(\"foo.txt\")?;\n\n    // We now read 8 bytes from the offset 10.\n    let num_bytes_read = file.read_at(&mut buf, 10)?;\n    println!(\"read {num_bytes_read} bytes: {buf:?}\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::fs::File;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+buf+=+%5B0u8;+8%5D;%0A++++let+file+=+File::open(%22foo.txt%22)?;%0A%0A++++//+We+now+read+8+bytes+from+the+offset+10.%0A++++let+num_bytes_read+=+file.read_at(%26mut+buf,+10)?;%0A++++println!(%22read+%7Bnum_bytes_read%7D+bytes:+%7Bbuf:?%7D%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n1.15.0 ¬∑ [source](about:blank/src/std/os/unix/fs.rs.html#195)\n\nWrites a number of bytes starting from a given offset.\n\nReturns the number of bytes written.\n\nThe offset is relative to the start of the file and thus independent from the current cursor.\n\nThe current file cursor is not affected by this function.\n\nWhen writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are initialized with the value 0.\n\nNote that similar to [`File::write`](about:blank/fs/struct.File.html#method.write \"method std::fs::File::write\"), it is not an error to return a short write.\n\n##### [¬ß](#bug)Bug\n\nOn some systems, `write_at` utilises [`pwrite64`](https://man7.org/linux/man-pages/man2/pwrite.2.html) to write to files. However, this syscall has a [bug](https://man7.org/linux/man-pages/man2/pwrite.2.html#BUGS) where files opened with the `O_APPEND` flag fail to respect the offset parameter, always appending to the end of the file instead.\n\nIt is possible to inadvertently set this flag, like in the example below. Therefore, it is important to be vigilant while changing options to mitigate unexpected behaviour.\n\n```\nuse std::fs::File;\nuse std::io;\nuse std::os::unix::prelude::FileExt;\n\nfn main() -> io::Result<()> {\n    // Open a file with the append option (sets the `O_APPEND` flag)\n    let file = File::options().append(true).open(\"foo.txt\")?;\n\n    // We attempt to write at offset 10; instead appended to EOF\n    file.write_at(b\"sushi\", 10)?;\n\n    // foo.txt is 5 bytes long instead of 15\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::fs::File;%0Ause+std::io;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++//+Open+a+file+with+the+append+option+(sets+the+%60O_APPEND%60+flag)%0A++++let+file+=+File::options().append(true).open(%22foo.txt%22)?;%0A%0A++++//+We+attempt+to+write+at+offset+10;+instead+appended+to+EOF%0A++++file.write_at(b%22sushi%22,+10)?;%0A%0A++++//+foo.txt+is+5+bytes+long+instead+of+15%0A++++Ok(())%0A%7D&edition=2021)\n\n##### [¬ß](#examples-1)Examples\n\n```\nuse std::fs::File;\nuse std::io;\nuse std::os::unix::prelude::FileExt;\n\nfn main() -> io::Result<()> {\n    let file = File::create(\"foo.txt\")?;\n\n    // We now write at the offset 10.\n    file.write_at(b\"sushi\", 10)?;\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::fs::File;%0Ause+std::io;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+file+=+File::create(%22foo.txt%22)?;%0A%0A++++//+We+now+write+at+the+offset+10.%0A++++file.write_at(b%22sushi%22,+10)?;%0A++++Ok(())%0A%7D&edition=2021)\n\n[source](about:blank/src/std/os/unix/fs.rs.html#67-69)\n\nüî¨This is a nightly-only experimental API. (`unix_file_vectored_at`¬†[#89517](https://github.com/rust-lang/rust/issues/89517))\n\nLike `read_at`, except that it reads into a slice of buffers.\n\nData is copied to fill each buffer in order, with the final buffer written to possibly being only partially filled. This method must behave equivalently to a single call to read with concatenated buffers.\n\n1.33.0 ¬∑ [source](about:blank/src/std/os/unix/fs.rs.html#117-131)\n\nReads the exact number of bytes required to fill `buf` from the given offset.\n\nThe offset is relative to the start of the file and thus independent from the current cursor.\n\nThe current file cursor is not affected by this function.\n\nSimilar to [`io::Read::read_exact`](about:blank/io/trait.Read.html#method.read_exact \"method std::io::Read::read_exact\") but uses [`read_at`](about:blank/trait.FileExt.html#tymethod.read_at \"method std::os::unix::fs::FileExt::read_at\") instead of `read`.\n\n##### [¬ß](#errors)Errors\n\nIf this function encounters an error of the kind [`io::ErrorKind::Interrupted`](about:blank/io/enum.ErrorKind.html#variant.Interrupted \"variant std::io::ErrorKind::Interrupted\") then the error is ignored and the operation will continue.\n\nIf this function encounters an ‚Äúend of file‚Äù before completely filling the buffer, it returns an error of the kind [`io::ErrorKind::UnexpectedEof`](about:blank/io/enum.ErrorKind.html#variant.UnexpectedEof \"variant std::io::ErrorKind::UnexpectedEof\"). The contents of `buf` are unspecified in this case.\n\nIf any other read error is encountered then this function immediately returns. The contents of `buf` are unspecified in this case.\n\nIf this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.\n\n##### [¬ß](#examples-2)Examples\n\n```\nuse std::io;\nuse std::fs::File;\nuse std::os::unix::prelude::FileExt;\n\nfn main() -> io::Result<()> {\n    let mut buf = [0u8; 8];\n    let file = File::open(\"foo.txt\")?;\n\n    // We now read exactly 8 bytes from the offset 10.\n    file.read_exact_at(&mut buf, 10)?;\n    println!(\"read {} bytes: {:?}\", buf.len(), buf);\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::fs::File;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+buf+=+%5B0u8;+8%5D;%0A++++let+file+=+File::open(%22foo.txt%22)?;%0A%0A++++//+We+now+read+exactly+8+bytes+from+the+offset+10.%0A++++file.read_exact_at(%26mut+buf,+10)?;%0A++++println!(%22read+%7B%7D+bytes:+%7B:?%7D%22,+buf.len(),+buf);%0A++++Ok(())%0A%7D&edition=2021)\n\n[source](about:blank/src/std/os/unix/fs.rs.html#203-205)\n\nüî¨This is a nightly-only experimental API. (`unix_file_vectored_at`¬†[#89517](https://github.com/rust-lang/rust/issues/89517))\n\nLike `write_at`, except that it writes from a slice of buffers.\n\nData is copied from each buffer in order, with the final buffer read from possibly being only partially consumed. This method must behave as a call to `write_at` with the buffers concatenated would.\n\n1.33.0 ¬∑ [source](about:blank/src/std/os/unix/fs.rs.html#244-259)\n\nAttempts to write an entire buffer starting from a given offset.\n\nThe offset is relative to the start of the file and thus independent from the current cursor.\n\nThe current file cursor is not affected by this function.\n\nThis method will continuously call [`write_at`](about:blank/trait.FileExt.html#tymethod.write_at \"method std::os::unix::fs::FileExt::write_at\") until there is no more data to be written or an error of non-[`io::ErrorKind::Interrupted`](about:blank/io/enum.ErrorKind.html#variant.Interrupted \"variant std::io::ErrorKind::Interrupted\") kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of [`io::ErrorKind::Interrupted`](about:blank/io/enum.ErrorKind.html#variant.Interrupted \"variant std::io::ErrorKind::Interrupted\") kind generated from this method will be returned.\n\n##### [¬ß](#errors-1)Errors\n\nThis function will return the first error of non-[`io::ErrorKind::Interrupted`](about:blank/io/enum.ErrorKind.html#variant.Interrupted \"variant std::io::ErrorKind::Interrupted\") kind that [`write_at`](about:blank/trait.FileExt.html#tymethod.write_at \"method std::os::unix::fs::FileExt::write_at\") returns.\n\n##### [¬ß](#examples-3)Examples\n\n```\nuse std::fs::File;\nuse std::io;\nuse std::os::unix::prelude::FileExt;\n\nfn main() -> io::Result<()> {\n    let file = File::open(\"foo.txt\")?;\n\n    // We now write at the offset 10.\n    file.write_all_at(b\"sushi\", 10)?;\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::fs::File;%0Ause+std::io;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+file+=+File::open(%22foo.txt%22)?;%0A%0A++++//+We+now+write+at+the+offset+10.%0A++++file.write_all_at(b%22sushi%22,+10)?;%0A++++Ok(())%0A%7D&edition=2021)\n\n1.15.0 ¬∑ [source](about:blank/src/std/os/unix/fs.rs.html#263-276)[¬ß](#impl-FileExt-for-File)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Unix-specific extensions to `fs::File`.\"><title>FileExt in std::os::unix::fs - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../../../\" data-static-root-path=\"../../../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc trait\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">FileExt</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">FileExt</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#required-methods\">Required Methods</a></h3><ul class=\"block\"><li><a href=\"#tymethod.read_at\">read_at</a></li><li><a href=\"#tymethod.write_at\">write_at</a></li></ul><h3><a href=\"#provided-methods\">Provided Methods</a></h3><ul class=\"block\"><li><a href=\"#method.read_exact_at\">read_exact_at</a></li><li><a href=\"#method.read_vectored_at\">read_vectored_at</a></li><li><a href=\"#method.write_all_at\">write_all_at</a></li><li><a href=\"#method.write_vectored_at\">write_vectored_at</a></li></ul><h3><a href=\"#implementors\">Implementors</a></h3></section><h2><a href=\"index.html\">In std::os::unix::fs</a></h2><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.DirBuilderExt.html\">DirBuilderExt</a></li><li><a href=\"trait.DirEntryExt.html\">DirEntryExt</a></li><li><a href=\"trait.DirEntryExt2.html\">DirEntryExt2</a></li><li><a href=\"trait.FileExt.html\">FileExt</a></li><li><a href=\"trait.FileTypeExt.html\">FileTypeExt</a></li><li><a href=\"trait.MetadataExt.html\">MetadataExt</a></li><li><a href=\"trait.OpenOptionsExt.html\">OpenOptionsExt</a></li><li><a href=\"trait.PermissionsExt.html\">PermissionsExt</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.chown.html\">chown</a></li><li><a href=\"fn.chroot.html\">chroot</a></li><li><a href=\"fn.fchown.html\">fchown</a></li><li><a href=\"fn.lchown.html\">lchown</a></li><li><a href=\"fn.symlink.html\">symlink</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‚ÄòS‚Äô or ‚Äò/‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Trait <a href=\"../../../index.html\">std</a>::<wbr><a href=\"../../index.html\">os</a>::<wbr><a href=\"../index.html\">unix</a>::<wbr><a href=\"index.html\">fs</a>::<wbr><a class=\"trait\" href=\"#\">FileExt</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> ¬∑ <a class=\"src\" href=\"../../../../src/std/os/unix/fs.rs.html#26-260\">source</a> ¬∑ <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>‚àí</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub trait FileExt {\n    // Required methods\n    fn <a href=\"#tymethod.read_at\" class=\"fn\">read_at</a>(&amp;self, buf: &amp;mut [<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>], offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;;\n<span class=\"item-spacer\"></span>    fn <a href=\"#tymethod.write_at\" class=\"fn\">write_at</a>(&amp;self, buf: &amp;[<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>], offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;;\n\n    // Provided methods\n    fn <a href=\"#method.read_vectored_at\" class=\"fn\">read_vectored_at</a>(\n        &amp;self,\n        bufs: &amp;mut [<a class=\"struct\" href=\"../../../io/struct.IoSliceMut.html\" title=\"struct std::io::IoSliceMut\">IoSliceMut</a>&lt;'_&gt;],\n        offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>,\n    ) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt; { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.read_exact_at\" class=\"fn\">read_exact_at</a>(&amp;self, buf: &amp;mut [<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>], offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt; { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.write_vectored_at\" class=\"fn\">write_vectored_at</a>(\n        &amp;self,\n        bufs: &amp;[<a class=\"struct\" href=\"../../../io/struct.IoSlice.html\" title=\"struct std::io::IoSlice\">IoSlice</a>&lt;'_&gt;],\n        offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>,\n    ) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt; { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.write_all_at\" class=\"fn\">write_all_at</a>(&amp;self, buf: &amp;[<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>], offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt; { ... }\n}</code></pre><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>Unix</strong> only.</div></span><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Unix-specific extensions to <a href=\"../../../fs/struct.File.html\" title=\"struct std::fs::File\"><code>fs::File</code></a>.</p>\n</div></details><h2 id=\"required-methods\" class=\"section-header\">Required Methods<a href=\"#required-methods\" class=\"anchor\">¬ß</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"tymethod.read_at\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> ¬∑ <a class=\"src\" href=\"../../../../src/std/os/unix/fs.rs.html#59\">source</a></span><h4 class=\"code-header\">fn <a href=\"#tymethod.read_at\" class=\"fn\">read_at</a>(&amp;self, buf: &amp;mut [<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>], offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Reads a number of bytes starting from a given offset.</p>\n<p>Returns the number of bytes read.</p>\n<p>The offset is relative to the start of the file and thus independent\nfrom the current cursor.</p>\n<p>The current file cursor is not affected by this function.</p>\n<p>Note that similar to <a href=\"../../../fs/struct.File.html#method.read\" title=\"method std::fs::File::read\"><code>File::read</code></a>, it is not an error to return with a\nshort read.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::os::unix::prelude::FileExt;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = [<span class=\"number\">0u8</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span>file = File::open(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// We now read 8 bytes from the offset 10.\n    </span><span class=\"kw\">let </span>num_bytes_read = file.read_at(<span class=\"kw-2\">&amp;mut </span>buf, <span class=\"number\">10</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"read {num_bytes_read} bytes: {buf:?}\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::fs::File;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+buf+=+%5B0u8;+8%5D;%0A++++let+file+=+File::open(%22foo.txt%22)?;%0A%0A++++//+We+now+read+8+bytes+from+the+offset+10.%0A++++let+num_bytes_read+=+file.read_at(%26mut+buf,+10)?;%0A++++println!(%22read+%7Bnum_bytes_read%7D+bytes:+%7Bbuf:?%7D%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"tymethod.write_at\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> ¬∑ <a class=\"src\" href=\"../../../../src/std/os/unix/fs.rs.html#195\">source</a></span><h4 class=\"code-header\">fn <a href=\"#tymethod.write_at\" class=\"fn\">write_at</a>(&amp;self, buf: &amp;[<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>], offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Writes a number of bytes starting from a given offset.</p>\n<p>Returns the number of bytes written.</p>\n<p>The offset is relative to the start of the file and thus independent\nfrom the current cursor.</p>\n<p>The current file cursor is not affected by this function.</p>\n<p>When writing beyond the end of the file, the file is appropriately\nextended and the intermediate bytes are initialized with the value 0.</p>\n<p>Note that similar to <a href=\"../../../fs/struct.File.html#method.write\" title=\"method std::fs::File::write\"><code>File::write</code></a>, it is not an error to return a\nshort write.</p>\n<h5 id=\"bug\"><a class=\"doc-anchor\" href=\"#bug\">¬ß</a>Bug</h5>\n<p>On some systems, <code>write_at</code> utilises <a href=\"https://man7.org/linux/man-pages/man2/pwrite.2.html\"><code>pwrite64</code></a> to write to files.\nHowever, this syscall has a <a href=\"https://man7.org/linux/man-pages/man2/pwrite.2.html#BUGS\">bug</a> where files opened with the <code>O_APPEND</code>\nflag fail to respect the offset parameter, always appending to the end\nof the file instead.</p>\n<p>It is possible to inadvertently set this flag, like in the example below.\nTherefore, it is important to be vigilant while changing options to mitigate\nunexpected behaviour.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::os::unix::prelude::FileExt;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"comment\">// Open a file with the append option (sets the `O_APPEND` flag)\n    </span><span class=\"kw\">let </span>file = File::options().append(<span class=\"bool-val\">true</span>).open(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// We attempt to write at offset 10; instead appended to EOF\n    </span>file.write_at(<span class=\"string\">b\"sushi\"</span>, <span class=\"number\">10</span>)<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// foo.txt is 5 bytes long instead of 15\n    </span><span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::fs::File;%0Ause+std::io;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++//+Open+a+file+with+the+append+option+(sets+the+%60O_APPEND%60+flag)%0A++++let+file+=+File::options().append(true).open(%22foo.txt%22)?;%0A%0A++++//+We+attempt+to+write+at+offset+10;+instead+appended+to+EOF%0A++++file.write_at(b%22sushi%22,+10)?;%0A%0A++++//+foo.txt+is+5+bytes+long+instead+of+15%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::os::unix::prelude::FileExt;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>file = File::create(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// We now write at the offset 10.\n    </span>file.write_at(<span class=\"string\">b\"sushi\"</span>, <span class=\"number\">10</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::fs::File;%0Ause+std::io;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+file+=+File::create(%22foo.txt%22)?;%0A%0A++++//+We+now+write+at+the+offset+10.%0A++++file.write_at(b%22sushi%22,+10)?;%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div><h2 id=\"provided-methods\" class=\"section-header\">Provided Methods<a href=\"#provided-methods\" class=\"anchor\">¬ß</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read_vectored_at\" class=\"method\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/fs.rs.html#67-69\">source</a><h4 class=\"code-header\">fn <a href=\"#method.read_vectored_at\" class=\"fn\">read_vectored_at</a>(\n    &amp;self,\n    bufs: &amp;mut [<a class=\"struct\" href=\"../../../io/struct.IoSliceMut.html\" title=\"struct std::io::IoSliceMut\">IoSliceMut</a>&lt;'_&gt;],\n    offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>,\n) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>unix_file_vectored_at</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/89517\">#89517</a>)</span></div></span></summary><div class=\"docblock\"><p>Like <code>read_at</code>, except that it reads into a slice of buffers.</p>\n<p>Data is copied to fill each buffer in order, with the final buffer\nwritten to possibly being only partially filled. This method must behave\nequivalently to a single call to read with concatenated buffers.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read_exact_at\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.33.0\">1.33.0</span> ¬∑ <a class=\"src\" href=\"../../../../src/std/os/unix/fs.rs.html#117-131\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.read_exact_at\" class=\"fn\">read_exact_at</a>(&amp;self, buf: &amp;mut [<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>], offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Reads the exact number of bytes required to fill <code>buf</code> from the given offset.</p>\n<p>The offset is relative to the start of the file and thus independent\nfrom the current cursor.</p>\n<p>The current file cursor is not affected by this function.</p>\n<p>Similar to <a href=\"../../../io/trait.Read.html#method.read_exact\" title=\"method std::io::Read::read_exact\"><code>io::Read::read_exact</code></a> but uses <a href=\"trait.FileExt.html#tymethod.read_at\" title=\"method std::os::unix::fs::FileExt::read_at\"><code>read_at</code></a> instead of <code>read</code>.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">¬ß</a>Errors</h5>\n<p>If this function encounters an error of the kind\n<a href=\"../../../io/enum.ErrorKind.html#variant.Interrupted\" title=\"variant std::io::ErrorKind::Interrupted\"><code>io::ErrorKind::Interrupted</code></a> then the error is ignored and the operation\nwill continue.</p>\n<p>If this function encounters an ‚Äúend of file‚Äù before completely filling\nthe buffer, it returns an error of the kind <a href=\"../../../io/enum.ErrorKind.html#variant.UnexpectedEof\" title=\"variant std::io::ErrorKind::UnexpectedEof\"><code>io::ErrorKind::UnexpectedEof</code></a>.\nThe contents of <code>buf</code> are unspecified in this case.</p>\n<p>If any other read error is encountered then this function immediately\nreturns. The contents of <code>buf</code> are unspecified in this case.</p>\n<p>If this function returns an error, it is unspecified how many bytes it\nhas read, but it will never read more than would be necessary to\ncompletely fill the buffer.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::os::unix::prelude::FileExt;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = [<span class=\"number\">0u8</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span>file = File::open(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// We now read exactly 8 bytes from the offset 10.\n    </span>file.read_exact_at(<span class=\"kw-2\">&amp;mut </span>buf, <span class=\"number\">10</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"read {} bytes: {:?}\"</span>, buf.len(), buf);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::fs::File;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+buf+=+%5B0u8;+8%5D;%0A++++let+file+=+File::open(%22foo.txt%22)?;%0A%0A++++//+We+now+read+exactly+8+bytes+from+the+offset+10.%0A++++file.read_exact_at(%26mut+buf,+10)?;%0A++++println!(%22read+%7B%7D+bytes:+%7B:?%7D%22,+buf.len(),+buf);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_vectored_at\" class=\"method\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/fs.rs.html#203-205\">source</a><h4 class=\"code-header\">fn <a href=\"#method.write_vectored_at\" class=\"fn\">write_vectored_at</a>(&amp;self, bufs: &amp;[<a class=\"struct\" href=\"../../../io/struct.IoSlice.html\" title=\"struct std::io::IoSlice\">IoSlice</a>&lt;'_&gt;], offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>unix_file_vectored_at</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/89517\">#89517</a>)</span></div></span></summary><div class=\"docblock\"><p>Like <code>write_at</code>, except that it writes from a slice of buffers.</p>\n<p>Data is copied from each buffer in order, with the final buffer read\nfrom possibly being only partially consumed. This method must behave as\na call to <code>write_at</code> with the buffers concatenated would.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_all_at\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.33.0\">1.33.0</span> ¬∑ <a class=\"src\" href=\"../../../../src/std/os/unix/fs.rs.html#244-259\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.write_all_at\" class=\"fn\">write_all_at</a>(&amp;self, buf: &amp;[<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>], offset: <a class=\"primitive\" href=\"../../../primitive.u64.html\">u64</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Attempts to write an entire buffer starting from a given offset.</p>\n<p>The offset is relative to the start of the file and thus independent\nfrom the current cursor.</p>\n<p>The current file cursor is not affected by this function.</p>\n<p>This method will continuously call <a href=\"trait.FileExt.html#tymethod.write_at\" title=\"method std::os::unix::fs::FileExt::write_at\"><code>write_at</code></a> until there is no more data\nto be written or an error of non-<a href=\"../../../io/enum.ErrorKind.html#variant.Interrupted\" title=\"variant std::io::ErrorKind::Interrupted\"><code>io::ErrorKind::Interrupted</code></a> kind is\nreturned. This method will not return until the entire buffer has been\nsuccessfully written or such an error occurs. The first error that is\nnot of <a href=\"../../../io/enum.ErrorKind.html#variant.Interrupted\" title=\"variant std::io::ErrorKind::Interrupted\"><code>io::ErrorKind::Interrupted</code></a> kind generated from this method will be\nreturned.</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">¬ß</a>Errors</h5>\n<p>This function will return the first error of\nnon-<a href=\"../../../io/enum.ErrorKind.html#variant.Interrupted\" title=\"variant std::io::ErrorKind::Interrupted\"><code>io::ErrorKind::Interrupted</code></a> kind that <a href=\"trait.FileExt.html#tymethod.write_at\" title=\"method std::os::unix::fs::FileExt::write_at\"><code>write_at</code></a> returns.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">¬ß</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::os::unix::prelude::FileExt;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>file = File::open(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// We now write at the offset 10.\n    </span>file.write_all_at(<span class=\"string\">b\"sushi\"</span>, <span class=\"number\">10</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::fs::File;%0Ause+std::io;%0Ause+std::os::unix::prelude::FileExt;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+file+=+File::open(%22foo.txt%22)?;%0A%0A++++//+We+now+write+at+the+offset+10.%0A++++file.write_all_at(b%22sushi%22,+10)?;%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div><h2 id=\"implementors\" class=\"section-header\">Implementors<a href=\"#implementors\" class=\"anchor\">¬ß</a></h2><div id=\"implementors-list\"><section id=\"impl-FileExt-for-File\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> ¬∑ <a class=\"src\" href=\"../../../../src/std/os/unix/fs.rs.html#263-276\">source</a></span><a href=\"#impl-FileExt-for-File\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.FileExt.html\" title=\"trait std::os::unix::fs::FileExt\">FileExt</a> for <a class=\"struct\" href=\"../../../fs/struct.File.html\" title=\"struct std::fs::File\">File</a></h3></section></div><script src=\"../../../../trait.impl/std/os/unix/fs/trait.FileExt.js\" async=\"\"></script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:26:25.401Z"
}