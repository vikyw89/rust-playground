{
	"title": "Type layout - The Rust Reference",
	"url": "https://doc.rust-lang.org/stable/reference/type-layout.html",
	"markdown": "# Type layout - The Rust Reference\n\nThe layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.\n\nType layout can be changed with each compilation. Instead of trying to document exactly what is done, we only document what is guaranteed today.\n\n## [Size and Alignment](#size-and-alignment)\n\nAll values have an alignment and size.\n\nThe _alignment_ of a value specifies what addresses are valid to store the value at. A value of alignment `n` must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the [`align_of_val`](../std/mem/fn.align_of_val.html) function.\n\nThe _size_ of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. Note that some types are zero-sized; 0 is considered a multiple of any alignment (for example, on some platforms, the type `[u16; 0]` has size 0 and alignment 2). The size of a value can be checked with the [`size_of_val`](../std/mem/fn.size_of_val.html) function.\n\nTypes where all values have the same size and alignment, and both are known at compile time, implement the [`Sized`](../std/marker/trait.Sized.html) trait and can be checked with the [`size_of`](../std/mem/fn.size_of.html) and [`align_of`](../std/mem/fn.align_of.html) functions. Types that are not [`Sized`](../std/marker/trait.Sized.html) are known as [dynamically sized types](dynamically-sized-types.html). Since all values of a `Sized` type share the same size and alignment, we refer to those shared values as the size of the type and the alignment of the type respectively.\n\n## [Primitive Data Layout](#primitive-data-layout)\n\nThe size of most primitives is given in this table.\n\n| Type | `size_of::<Type>()` |\n| --- | --- |\n| `bool` | 1 |\n| `u8` / `i8` | 1 |\n| `u16` / `i16` | 2 |\n| `u32` / `i32` | 4 |\n| `u64` / `i64` | 8 |\n| `u128` / `i128` | 16 |\n| `usize` / `isize` | See below |\n| `f32` | 4 |\n| `f64` | 8 |\n| `char` | 4 |\n\n`usize` and `isize` have a size big enough to contain every address on the target platform. For example, on a 32 bit target, this is 4 bytes, and on a 64 bit target, this is 8 bytes.\n\nThe alignment of primitives is platform-specific. In most cases, their alignment is equal to their size, but it may be less. In particular, `i128` and `u128` are often aligned to 4 or 8 bytes even though their size is 16, and on many 32-bit platforms, `i64`, `u64`, and `f64` are only aligned to 4 bytes, not 8.\n\n## [Pointers and References Layout](#pointers-and-references-layout)\n\nPointers and references have the same layout. Mutability of the pointer or reference does not change the layout.\n\nPointers to sized types have the same size and alignment as `usize`.\n\nPointers to unsized types are sized. The size and alignment is guaranteed to be at least equal to the size and alignment of a pointer.\n\n> Note: Though you should not rely on this, all pointers to DSTs are currently twice the size of the size of `usize` and have the same alignment.\n\n## [Array Layout](#array-layout)\n\nAn array of `[T; N]` has a size of `size_of::<T>() * N` and the same alignment of `T`. Arrays are laid out so that the zero-based `nth` element of the array is offset from the start of the array by `n * size_of::<T>()` bytes.\n\n## [Slice Layout](#slice-layout)\n\nSlices have the same layout as the section of the array they slice.\n\n> Note: This is about the raw `[T]` type, not pointers (`&[T]`, `Box<[T]>`, etc.) to slices.\n\n## [`str` Layout](#str-layout)\n\nString slices are a UTF-8 representation of characters that have the same layout as slices of type `[u8]`.\n\n## [Tuple Layout](#tuple-layout)\n\nTuples are laid out according to the [`Rust` representation](#the-rust-representation).\n\nThe exception to this is the unit tuple (`()`), which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.\n\n## [Trait Object Layout](#trait-object-layout)\n\nTrait objects have the same layout as the value the trait object is of.\n\n> Note: This is about the raw trait object types, not pointers (`&dyn Trait`, `Box<dyn Trait>`, etc.) to trait objects.\n\n## [Closure Layout](#closure-layout)\n\nClosures have no layout guarantees.\n\n## [Representations](#representations)\n\nAll user-defined composite types (`struct`s, `enum`s, and `union`s) have a _representation_ that specifies what the layout is for the type. The possible representations for a type are:\n\n-   [`Rust`](#the-rust-representation) (default)\n-   [`C`](#the-c-representation)\n-   The [primitive representations](#primitive-representations)\n-   [`transparent`](#the-transparent-representation)\n\nThe representation of a type can be changed by applying the `repr` attribute to it. The following example shows a struct with a `C` representation.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[repr(C)]\nstruct ThreeInts {\n    first: i16,\n    second: i8,\n    third: i32\n}\n}\n```\n\nThe alignment may be raised or lowered with the `align` and `packed` modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.\n\n```rust\n#![allow(unused)]\nfn main() {\n// Default representation, alignment lowered to 2.\n#[repr(packed(2))]\nstruct PackedStruct {\n    first: i16,\n    second: i8,\n    third: i32\n}\n\n// C representation, alignment raised to 8\n#[repr(C, align(8))]\nstruct AlignedStruct {\n    first: i16,\n    second: i8,\n    third: i32\n}\n}\n```\n\n> Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, `Foo<Bar>` and `Foo<Baz>` both have the same representation.\n\nThe representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a `C` representation that contains a struct `Inner` with the default representation will not change the layout of `Inner`.\n\n### The `Rust` Representation\n\nThe `Rust` representation is the default representation for nominal types without a `repr` attribute. Using this representation explicitly through a `repr` attribute is guaranteed to be the same as omitting the attribute entirely.\n\nThe only data layout guarantees made by this representation are those required for soundness. They are:\n\n1.  The fields are properly aligned.\n2.  The fields do not overlap.\n3.  The alignment of the type is at least the maximum alignment of its fields.\n\nFormally, the first guarantee means that the offset of any field is divisible by that field's alignment. The second guarantee means that the fields can be ordered such that the offset plus the size of any field is less than or equal to the offset of the next field in the ordering. The ordering does not have to be the same as the order in which the fields are specified in the declaration of the type.\n\nBe aware that the second guarantee does not imply that the fields have distinct addresses: zero-sized types may have the same address as other fields in the same struct.\n\nThere are no other guarantees of data layout made by this representation.\n\n### [The `C` Representation](#the-c-representation)\n\nThe `C` representation is designed for dual purposes. One purpose is for creating types that are interoperable with the C Language. The second purpose is to create types that you can soundly perform operations on that rely on data layout such as reinterpreting values as a different type.\n\nBecause of this dual purpose, it is possible to create types that are not useful for interfacing with the C programming language.\n\nThis representation can be applied to structs, unions, and enums. The exception is [zero-variant enums](about:blank/items/enumerations.html#zero-variant-enums) for which the `C` representation is an error.\n\n#### [`#[repr(C)]` Structs](#reprc-structs)\n\nThe alignment of the struct is the alignment of the most-aligned field in it.\n\nThe size and offset of fields is determined by the following algorithm.\n\nStart with a current offset of 0 bytes.\n\nFor each field in declaration order in the struct, first determine the size and alignment of the field. If the current offset is not a multiple of the field's alignment, then add padding bytes to the current offset until it is a multiple of the field's alignment. The offset for the field is what the current offset is now. Then increase the current offset by the size of the field.\n\nFinally, the size of the struct is the current offset rounded up to the nearest multiple of the struct's alignment.\n\nHere is this algorithm described in pseudocode.\n\n```rust\n/// Returns the amount of padding needed after `offset` to ensure that the\n/// following address will be aligned to `alignment`.\nfn padding_needed_for(offset: usize, alignment: usize) -> usize {\n    let misalignment = offset % alignment;\n    if misalignment > 0 {\n        // round up to next multiple of `alignment`\n        alignment - misalignment\n    } else {\n        // already a multiple of `alignment`\n        0\n    }\n}\n\nstruct.alignment = struct.fields().map(|field| field.alignment).max();\n\nlet current_offset = 0;\n\nfor field in struct.fields_in_declaration_order() {\n    // Increase the current offset so that it's a multiple of the alignment\n    // of this field. For the first field, this will always be zero.\n    // The skipped bytes are called padding bytes.\n    current_offset += padding_needed_for(current_offset, field.alignment);\n\n    struct[field].offset = current_offset;\n\n    current_offset += field.size;\n}\n\nstruct.size = current_offset + padding_needed_for(current_offset, struct.alignment);\n```\n\nWarning: This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use [`Layout`](../std/alloc/struct.Layout.html).\n\n> Note: This algorithm can produce zero-sized structs. In C, an empty struct declaration like `struct Foo { }` is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the `[[no_unique_address]]` attribute, in which case they do not increase the overall size of the struct.\n\n#### [`#[repr(C)]` Unions](#reprc-unions)\n\nA union declared with `#[repr(C)]` will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[repr(C)]\nunion Union {\n    f1: u16,\n    f2: [u8; 4],\n}\n\nassert_eq!(std::mem::size_of::<Union>(), 4);  // From f2\nassert_eq!(std::mem::align_of::<Union>(), 2); // From f1\n\n#[repr(C)]\nunion SizeRoundedUp {\n   a: u32,\n   b: [u16; 3],\n}\n\nassert_eq!(std::mem::size_of::<SizeRoundedUp>(), 8);  // Size of 6 from b,\n                                                      // rounded up to 8 from\n                                                      // alignment of a.\nassert_eq!(std::mem::align_of::<SizeRoundedUp>(), 4); // From a\n}\n```\n\n#### [`#[repr(C)]` Field-less Enums](#reprc-field-less-enums)\n\nFor [field-less enums](about:blank/items/enumerations.html#field-less-enum), the `C` representation has the size and alignment of the default `enum` size and alignment for the target platform's C ABI.\n\n> Note: The enum representation in C is implementation defined, so this is really a \"best guess\". In particular, this may be incorrect when the C code of interest is compiled with certain flags.\n\nWarning: There are crucial differences between an `enum` in the C language and Rust's [field-less enums](about:blank/items/enumerations.html#field-less-enum) with this representation. An `enum` in C is mostly a `typedef` plus some named constants; in other words, an object of an `enum` type can hold any integer value. For example, this is often used for bitflags in `C`. In contrast, Rustâ€™s [field-less enums](about:blank/items/enumerations.html#field-less-enum) can only legally hold the discriminant values, everything else is [undefined behavior](behavior-considered-undefined.html). Therefore, using a field-less enum in FFI to model a C `enum` is often wrong.\n\n#### [`#[repr(C)]` Enums With Fields](#reprc-enums-with-fields)\n\nThe representation of a `repr(C)` enum with fields is a `repr(C)` struct with two fields, also called a \"tagged union\" in C:\n\n-   a `repr(C)` version of the enum with all fields removed (\"the tag\")\n-   a `repr(C)` union of `repr(C)` structs for the fields of each variant that had them (\"the payload\")\n\n> Note: Due to the representation of `repr(C)` structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an `enum`'s representation may therefore use whichever form is more convenient or consistent for them.\n\n```rust\n#![allow(unused)]\nfn main() {\n// This Enum has the same representation as ...\n#[repr(C)]\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ... this struct.\n#[repr(C)]\nstruct MyEnumRepr {\n    tag: MyEnumDiscriminant,\n    payload: MyEnumFields,\n}\n\n// This is the discriminant enum.\n#[repr(C)]\nenum MyEnumDiscriminant { A, B, C, D }\n\n// This is the variant union.\n#[repr(C)]\nunion MyEnumFields {\n    A: MyAFields,\n    B: MyBFields,\n    C: MyCFields,\n    D: MyDFields,\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyAFields(u32);\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyBFields(f32, u64);\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyCFields { x: u32, y: u8 }\n\n// This struct could be omitted (it is a zero-sized type), and it must be in\n// C/C++ headers.\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyDFields;\n}\n```\n\n> Note: `union`s with non-`Copy` fields are unstable, see [55149](https://github.com/rust-lang/rust/issues/55149).\n\n### [Primitive representations](#primitive-representations)\n\nThe _primitive representations_ are the representations with the same names as the primitive integer types. That is: `u8`, `u16`, `u32`, `u64`, `u128`, `usize`, `i8`, `i16`, `i32`, `i64`, `i128`, and `isize`.\n\nPrimitive representations can only be applied to enumerations and have different behavior whether the enum has fields or no fields. It is an error for [zero-variant enums](about:blank/items/enumerations.html#zero-variant-enums) to have a primitive representation. Combining two primitive representations together is an error.\n\n#### [Primitive Representation of Field-less Enums](#primitive-representation-of-field-less-enums)\n\nFor [field-less enums](about:blank/items/enumerations.html#field-less-enum), primitive representations set the size and alignment to be the same as the primitive type of the same name. For example, a field-less enum with a `u8` representation can only have discriminants between 0 and 255 inclusive.\n\n#### [Primitive Representation of Enums With Fields](#primitive-representation-of-enums-with-fields)\n\nThe representation of a primitive representation enum is a `repr(C)` union of `repr(C)` structs for each variant with a field. The first field of each struct in the union is the primitive representation version of the enum with all fields removed (\"the tag\") and the remaining fields are the fields of that variant.\n\n> Note: This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a `struct`).\n\n```rust\n#![allow(unused)]\nfn main() {\n// This enum has the same representation as ...\n#[repr(u8)]\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ... this union.\n#[repr(C)]\nunion MyEnumRepr {\n    A: MyVariantA,\n    B: MyVariantB,\n    C: MyVariantC,\n    D: MyVariantD,\n}\n\n// This is the discriminant enum.\n#[repr(u8)]\n#[derive(Copy, Clone)]\nenum MyEnumDiscriminant { A, B, C, D }\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantA(MyEnumDiscriminant, u32);\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantB(MyEnumDiscriminant, f32, u64);\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantD(MyEnumDiscriminant);\n}\n```\n\n> Note: `union`s with non-`Copy` fields are unstable, see [55149](https://github.com/rust-lang/rust/issues/55149).\n\n#### [Combining primitive representations of enums with fields and `#[repr(C)]`](#combining-primitive-representations-of-enums-with-fields-and-reprc)\n\nFor enums with fields, it is also possible to combine `repr(C)` and a primitive representation (e.g., `repr(C, u8)`). This modifies the [`repr(C)`](#reprc-enums-with-fields) by changing the representation of the discriminant enum to the chosen primitive instead. So, if you chose the `u8` representation, then the discriminant enum would have a size and alignment of 1 byte.\n\nThe discriminant enum from the example [earlier](#reprc-enums-with-fields) then becomes:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[repr(C, u8)] // `u8` was added\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ...\n\n#[repr(u8)] // So `u8` is used here instead of `C`\nenum MyEnumDiscriminant { A, B, C, D }\n\n// ...\n}\n```\n\nFor example, with a `repr(C, u8)` enum it is not possible to have 257 unique discriminants (\"tags\") whereas the same enum with only a `repr(C)` attribute will compile without any problems.\n\nUsing a primitive representation in addition to `repr(C)` can change the size of an enum from the `repr(C)` form:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[repr(C)]\nenum EnumC {\n    Variant0(u8),\n    Variant1,\n}\n\n#[repr(C, u8)]\nenum Enum8 {\n    Variant0(u8),\n    Variant1,\n}\n\n#[repr(C, u16)]\nenum Enum16 {\n    Variant0(u8),\n    Variant1,\n}\n\n// The size of the C representation is platform dependant\nassert_eq!(std::mem::size_of::<EnumC>(), 8);\n// One byte for the discriminant and one byte for the value in Enum8::Variant0\nassert_eq!(std::mem::size_of::<Enum8>(), 2);\n// Two bytes for the discriminant and one byte for the value in Enum16::Variant0\n// plus one byte of padding.\nassert_eq!(std::mem::size_of::<Enum16>(), 4);\n}\n```\n\n### [The alignment modifiers](#the-alignment-modifiers)\n\nThe `align` and `packed` modifiers can be used to respectively raise or lower the alignment of `struct`s and `union`s. `packed` may also alter the padding between fields (although it will not alter the padding inside of any field). On their own, `align` and `packed` do not provide guarantees about the order of fields in the layout of a struct or the layout of an enum variant, although they may be combined with representations (such as `C`) which do provide such guarantees.\n\nThe alignment is specified as an integer parameter in the form of `#[repr(align(x))]` or `#[repr(packed(x))]`. The alignment value must be a power of two from 1 up to 229. For `packed`, if no value is given, as in `#[repr(packed)]`, then the value is 1.\n\nFor `align`, if the specified alignment is less than the alignment of the type without the `align` modifier, then the alignment is unaffected.\n\nFor `packed`, if the specified alignment is greater than the type's alignment without the `packed` modifier, then the alignment and layout is unaffected. The alignments of each field, for the purpose of positioning fields, is the smaller of the specified alignment and the alignment of the field's type. Inter-field padding is guaranteed to be the minimum required in order to satisfy each field's (possibly altered) alignment (although note that, on its own, `packed` does not provide any guarantee about field ordering). An important consequence of these rules is that a type with `#[repr(packed(1))]` (or `#[repr(packed)]`) will have no inter-field padding.\n\nThe `align` and `packed` modifiers cannot be applied on the same type and a `packed` type cannot transitively contain another `align`ed type. `align` and `packed` may only be applied to the [`Rust`](#the-rust-representation) and [`C`](#the-c-representation) representations.\n\nThe `align` modifier can also be applied on an `enum`. When it is, the effect on the `enum`'s alignment is the same as if the `enum` was wrapped in a newtype `struct` with the same `align` modifier.\n\n> Note: References to unaligned fields are not allowed because it is [undefined behavior](behavior-considered-undefined.html). When fields are unaligned due to an alignment modifier, consider the following options for using references and dereferences:\n> \n> ```rust\n> #![allow(unused)]\n> fn main() {\n> #[repr(packed)]\n> struct Packed {\n>     f1: u8,\n>     f2: u16,\n> }\n> let mut e = Packed { f1: 1, f2: 2 };\n> // Instead of creating a reference to a field, copy the value to a local variable.\n> let x = e.f2;\n> // Or in situations like `println!` which creates a reference, use braces\n> // to change it to a copy of the value.\n> println!(\"{}\", {e.f2});\n> // Or if you need a pointer, use the unaligned methods for reading and writing\n> // instead of dereferencing the pointer directly.\n> let ptr: *const u16 = std::ptr::addr_of!(e.f2);\n> let value = unsafe { ptr.read_unaligned() };\n> let mut_ptr: *mut u16 = std::ptr::addr_of_mut!(e.f2);\n> unsafe { mut_ptr.write_unaligned(3) }\n> }\n> ```\n\n### [The `transparent` Representation](#the-transparent-representation)\n\nThe `transparent` representation can only be used on a [`struct`](items/structs.html) or an [`enum`](items/enumerations.html) with a single variant that has:\n\n-   a single field with non-zero size, and\n-   any number of fields with size 0 and alignment 1 (e.g. [`PhantomData<T>`](about:blank/special-types-and-traits.html#phantomdatat)).\n\nStructs and enums with this representation have the same layout and ABI as the single non-zero sized field.\n\nThis is different than the `C` representation because a struct with the `C` representation will always have the ABI of a `C` `struct` while, for example, a struct with the `transparent` representation with a primitive field will have the ABI of the primitive field.\n\nBecause this representation delegates type layout to another type, it cannot be used with any other representation.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Type layout - The Rust Reference</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/reference.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"notation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Notation</a></li><li class=\"chapter-item expanded \"><a href=\"lexical-structure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Lexical structure</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"input-format.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Input format</a></li><li class=\"chapter-item expanded \"><a href=\"keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"identifiers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Identifiers</a></li><li class=\"chapter-item expanded \"><a href=\"comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"whitespace.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Whitespace</a></li><li class=\"chapter-item expanded \"><a href=\"tokens.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Tokens</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Macros</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macros-by-example.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Macros By Example</a></li><li class=\"chapter-item expanded \"><a href=\"procedural-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Procedural Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"crates-and-source-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Crates and source files</a></li><li class=\"chapter-item expanded \"><a href=\"conditional-compilation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Conditional compilation</a></li><li class=\"chapter-item expanded \"><a href=\"items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Items</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"items/modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Modules</a></li><li class=\"chapter-item expanded \"><a href=\"items/extern-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Extern crates</a></li><li class=\"chapter-item expanded \"><a href=\"items/use-declarations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Use declarations</a></li><li class=\"chapter-item expanded \"><a href=\"items/functions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.4.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"items/type-aliases.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.5.</strong> Type aliases</a></li><li class=\"chapter-item expanded \"><a href=\"items/structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.6.</strong> Structs</a></li><li class=\"chapter-item expanded \"><a href=\"items/enumerations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.7.</strong> Enumerations</a></li><li class=\"chapter-item expanded \"><a href=\"items/unions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.8.</strong> Unions</a></li><li class=\"chapter-item expanded \"><a href=\"items/constant-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.9.</strong> Constant items</a></li><li class=\"chapter-item expanded \"><a href=\"items/static-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.10.</strong> Static items</a></li><li class=\"chapter-item expanded \"><a href=\"items/traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.11.</strong> Traits</a></li><li class=\"chapter-item expanded \"><a href=\"items/implementations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.12.</strong> Implementations</a></li><li class=\"chapter-item expanded \"><a href=\"items/external-blocks.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.13.</strong> External blocks</a></li><li class=\"chapter-item expanded \"><a href=\"items/generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.14.</strong> Generic parameters</a></li><li class=\"chapter-item expanded \"><a href=\"items/associated-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.15.</strong> Associated Items</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"attributes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Attributes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"attributes/testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Testing</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/derive.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Derive</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/diagnostics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Diagnostics</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/codegen.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Code generation</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/limits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Limits</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/type_system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.6.</strong> Type System</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/debugger.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.7.</strong> Debugger</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"statements-and-expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Statements and expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"statements.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Statements</a></li><li class=\"chapter-item expanded \"><a href=\"expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"expressions/literal-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.1.</strong> Literal expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/path-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.2.</strong> Path expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/block-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.3.</strong> Block expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/operator-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.4.</strong> Operator expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/grouped-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.5.</strong> Grouped expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/array-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.6.</strong> Array and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/tuple-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.7.</strong> Tuple and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/struct-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.8.</strong> Struct expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.9.</strong> Call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/method-call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.10.</strong> Method call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/field-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.11.</strong> Field access expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/closure-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.12.</strong> Closure expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/loop-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.13.</strong> Loop expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/range-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.14.</strong> Range expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/if-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.15.</strong> If and if let expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/match-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.16.</strong> Match expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/return-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.17.</strong> Return expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/await-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.18.</strong> Await expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/underscore-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.19.</strong> Underscore expressions</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Patterns</a></li><li class=\"chapter-item expanded \"><a href=\"type-system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Type system</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Types</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types/boolean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Boolean type</a></li><li class=\"chapter-item expanded \"><a href=\"types/numeric.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Numeric types</a></li><li class=\"chapter-item expanded \"><a href=\"types/textual.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Textual types</a></li><li class=\"chapter-item expanded \"><a href=\"types/never.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Never type</a></li><li class=\"chapter-item expanded \"><a href=\"types/tuple.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Tuple types</a></li><li class=\"chapter-item expanded \"><a href=\"types/array.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.6.</strong> Array types</a></li><li class=\"chapter-item expanded \"><a href=\"types/slice.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.7.</strong> Slice types</a></li><li class=\"chapter-item expanded \"><a href=\"types/struct.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.8.</strong> Struct types</a></li><li class=\"chapter-item expanded \"><a href=\"types/enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.9.</strong> Enumerated types</a></li><li class=\"chapter-item expanded \"><a href=\"types/union.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.10.</strong> Union types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-item.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.11.</strong> Function item types</a></li><li class=\"chapter-item expanded \"><a href=\"types/closure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.12.</strong> Closure types</a></li><li class=\"chapter-item expanded \"><a href=\"types/pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.13.</strong> Pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.14.</strong> Function pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/trait-object.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.15.</strong> Trait object types</a></li><li class=\"chapter-item expanded \"><a href=\"types/impl-trait.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.16.</strong> Impl trait type</a></li><li class=\"chapter-item expanded \"><a href=\"types/parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.17.</strong> Type parameters</a></li><li class=\"chapter-item expanded \"><a href=\"types/inferred.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.18.</strong> Inferred type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"dynamically-sized-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Dynamically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"type-layout.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Type layout</a></li><li class=\"chapter-item expanded \"><a href=\"interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.4.</strong> Interior mutability</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.5.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"trait-bounds.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.6.</strong> Trait and lifetime bounds</a></li><li class=\"chapter-item expanded \"><a href=\"type-coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.7.</strong> Type coercions</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.8.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.9.</strong> Lifetime elision</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"special-types-and-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Special types and traits</a></li><li class=\"chapter-item expanded \"><a href=\"names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Names</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"names/namespaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Namespaces</a></li><li class=\"chapter-item expanded \"><a href=\"names/scopes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Scopes</a></li><li class=\"chapter-item expanded \"><a href=\"names/preludes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Preludes</a></li><li class=\"chapter-item expanded \"><a href=\"paths.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Paths</a></li><li class=\"chapter-item expanded \"><a href=\"names/name-resolution.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Name resolution</a></li><li class=\"chapter-item expanded \"><a href=\"visibility-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Visibility and privacy</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"memory-model.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Memory model</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"memory-allocation-and-lifetime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Memory allocation and lifetime</a></li><li class=\"chapter-item expanded \"><a href=\"variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Variables</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"linkage.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> Linkage</a></li><li class=\"chapter-item expanded \"><a href=\"inline-assembly.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Inline assembly</a></li><li class=\"chapter-item expanded \"><a href=\"unsafety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Unsafety</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"unsafe-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> The unsafe keyword</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-considered-undefined.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Behavior considered undefined</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-not-considered-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Behavior not considered unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"const_eval.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Constant Evaluation</a></li><li class=\"chapter-item expanded \"><a href=\"abi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Application Binary Interface</a></li><li class=\"chapter-item expanded \"><a href=\"runtime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> The Rust runtime</a></li><li class=\"chapter-item expanded \"><a href=\"appendices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Appendices</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macro-ambiguity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class=\"chapter-item expanded \"><a href=\"influences.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Influences</a></li><li class=\"chapter-item expanded \"><a href=\"glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Glossary</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Reference</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/edit/master/src/type-layout.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"type-layout\"><a class=\"header\" href=\"#type-layout\">Type Layout</a></h1>\n<p>The layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout.</p>\n<p>Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today.</p>\n<h2 id=\"size-and-alignment\"><a class=\"header\" href=\"#size-and-alignment\">Size and Alignment</a></h2>\n<p>All values have an alignment and size.</p>\n<p>The <em>alignment</em> of a value specifies what addresses are valid to store the value\nat. A value of alignment <code class=\"hljs\">n</code> must only be stored at an address that is a\nmultiple of n. For example, a value with an alignment of 2 must be stored at an\neven address, while a value with an alignment of 1 can be stored at any address.\nAlignment is measured in bytes, and must be at least 1, and always a power of 2.\nThe alignment of a value can be checked with the <a href=\"../std/mem/fn.align_of_val.html\"><code class=\"hljs\">align_of_val</code></a> function.</p>\n<p>The <em>size</em> of a value is the offset in bytes between successive elements in an\narray with that item type including alignment padding. The size of a value is\nalways a multiple of its alignment. Note that some types are zero-sized; 0 is\nconsidered a multiple of any alignment (for example, on some platforms, the type\n<code class=\"hljs\">[u16; 0]</code> has size 0 and alignment 2). The size of a value can be checked with\nthe <a href=\"../std/mem/fn.size_of_val.html\"><code class=\"hljs\">size_of_val</code></a> function.</p>\n<p>Types where all values have the same size and alignment, and both are known at\ncompile time, implement the <a href=\"../std/marker/trait.Sized.html\"><code class=\"hljs\">Sized</code></a> trait and can be checked with the\n<a href=\"../std/mem/fn.size_of.html\"><code class=\"hljs\">size_of</code></a> and <a href=\"../std/mem/fn.align_of.html\"><code class=\"hljs\">align_of</code></a> functions. Types that are not <a href=\"../std/marker/trait.Sized.html\"><code class=\"hljs\">Sized</code></a> are known\nas <a href=\"dynamically-sized-types.html\">dynamically sized types</a>. Since all values of a <code class=\"hljs\">Sized</code> type share the same\nsize and alignment, we refer to those shared values as the size of the type and\nthe alignment of the type respectively.</p>\n<h2 id=\"primitive-data-layout\"><a class=\"header\" href=\"#primitive-data-layout\">Primitive Data Layout</a></h2>\n<p>The size of most primitives is given in this table.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Type</th><th><code class=\"hljs\">size_of::&lt;Type&gt;()</code></th></tr></thead><tbody>\n<tr><td><code class=\"hljs\">bool</code></td><td>1</td></tr>\n<tr><td><code class=\"hljs\">u8</code> / <code class=\"hljs\">i8</code></td><td>1</td></tr>\n<tr><td><code class=\"hljs\">u16</code> / <code class=\"hljs\">i16</code></td><td>2</td></tr>\n<tr><td><code class=\"hljs\">u32</code> / <code class=\"hljs\">i32</code></td><td>4</td></tr>\n<tr><td><code class=\"hljs\">u64</code> / <code class=\"hljs\">i64</code></td><td>8</td></tr>\n<tr><td><code class=\"hljs\">u128</code> / <code class=\"hljs\">i128</code></td><td>16</td></tr>\n<tr><td><code class=\"hljs\">usize</code> / <code class=\"hljs\">isize</code></td><td>See below</td></tr>\n<tr><td><code class=\"hljs\">f32</code></td><td>4</td></tr>\n<tr><td><code class=\"hljs\">f64</code></td><td>8</td></tr>\n<tr><td><code class=\"hljs\">char</code></td><td>4</td></tr>\n</tbody></table>\n</div>\n<p><code class=\"hljs\">usize</code> and <code class=\"hljs\">isize</code> have a size big enough to contain every address on the\ntarget platform. For example, on a 32 bit target, this is 4 bytes, and on a 64\nbit target, this is 8 bytes.</p>\n<p>The alignment of primitives is platform-specific.\nIn most cases, their alignment is equal to their size, but it may be less.\nIn particular, <code class=\"hljs\">i128</code> and <code class=\"hljs\">u128</code> are often aligned to 4 or 8 bytes even though\ntheir size is 16, and on many 32-bit platforms, <code class=\"hljs\">i64</code>, <code class=\"hljs\">u64</code>, and <code class=\"hljs\">f64</code> are only\naligned to 4 bytes, not 8.</p>\n<h2 id=\"pointers-and-references-layout\"><a class=\"header\" href=\"#pointers-and-references-layout\">Pointers and References Layout</a></h2>\n<p>Pointers and references have the same layout. Mutability of the pointer or\nreference does not change the layout.</p>\n<p>Pointers to sized types have the same size and alignment as <code class=\"hljs\">usize</code>.</p>\n<p>Pointers to unsized types are sized. The size and alignment is guaranteed to be\nat least equal to the size and alignment of a pointer.</p>\n<blockquote>\n<p>Note: Though you should not rely on this, all pointers to\n<abbr title=\"Dynamically Sized Types\">DSTs</abbr> are currently twice the\nsize of the size of <code class=\"hljs\">usize</code> and have the same alignment.</p>\n</blockquote>\n<h2 id=\"array-layout\"><a class=\"header\" href=\"#array-layout\">Array Layout</a></h2>\n<p>An array of <code class=\"hljs\">[T; N]</code> has a size of <code class=\"hljs\">size_of::&lt;T&gt;() * N</code> and the same alignment\nof <code class=\"hljs\">T</code>. Arrays are laid out so that the zero-based <code class=\"hljs\">nth</code> element of the array\nis offset from the start of the array by <code class=\"hljs\">n * size_of::&lt;T&gt;()</code> bytes.</p>\n<h2 id=\"slice-layout\"><a class=\"header\" href=\"#slice-layout\">Slice Layout</a></h2>\n<p>Slices have the same layout as the section of the array they slice.</p>\n<blockquote>\n<p>Note: This is about the raw <code class=\"hljs\">[T]</code> type, not pointers (<code class=\"hljs\">&amp;[T]</code>, <code class=\"hljs\">Box&lt;[T]&gt;</code>,\netc.) to slices.</p>\n</blockquote>\n<h2 id=\"str-layout\"><a class=\"header\" href=\"#str-layout\"><code>str</code> Layout</a></h2>\n<p>String slices are a UTF-8 representation of characters that have the same layout as slices of type <code class=\"hljs\">[u8]</code>.</p>\n<h2 id=\"tuple-layout\"><a class=\"header\" href=\"#tuple-layout\">Tuple Layout</a></h2>\n<p>Tuples are laid out according to the <a href=\"#the-rust-representation\"><code class=\"hljs\">Rust</code> representation</a>.</p>\n<p>The exception to this is the unit tuple (<code class=\"hljs\">()</code>), which is guaranteed as a\nzero-sized type to have a size of 0 and an alignment of 1.</p>\n<h2 id=\"trait-object-layout\"><a class=\"header\" href=\"#trait-object-layout\">Trait Object Layout</a></h2>\n<p>Trait objects have the same layout as the value the trait object is of.</p>\n<blockquote>\n<p>Note: This is about the raw trait object types, not pointers (<code class=\"hljs\">&amp;dyn Trait</code>,\n<code class=\"hljs\">Box&lt;dyn Trait&gt;</code>, etc.) to trait objects.</p>\n</blockquote>\n<h2 id=\"closure-layout\"><a class=\"header\" href=\"#closure-layout\">Closure Layout</a></h2>\n<p>Closures have no layout guarantees.</p>\n<h2 id=\"representations\"><a class=\"header\" href=\"#representations\">Representations</a></h2>\n<p>All user-defined composite types (<code class=\"hljs\">struct</code>s, <code class=\"hljs\">enum</code>s, and <code class=\"hljs\">union</code>s) have a\n<em>representation</em> that specifies what the layout is for the type. The possible\nrepresentations for a type are:</p>\n<ul>\n<li><a href=\"#the-rust-representation\"><code class=\"hljs\">Rust</code></a> (default)</li>\n<li><a href=\"#the-c-representation\"><code class=\"hljs\">C</code></a></li>\n<li>The <a href=\"#primitive-representations\">primitive representations</a></li>\n<li><a href=\"#the-transparent-representation\"><code class=\"hljs\">transparent</code></a></li>\n</ul>\n<p>The representation of a type can be changed by applying the <code class=\"hljs\">repr</code> attribute\nto it. The following example shows a struct with a <code class=\"hljs\">C</code> representation.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreeInts</span></span> {\n    first: <span class=\"hljs-built_in\">i16</span>,\n    second: <span class=\"hljs-built_in\">i8</span>,\n    third: <span class=\"hljs-built_in\">i32</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The alignment may be raised or lowered with the <code class=\"hljs\">align</code> and <code class=\"hljs\">packed</code> modifiers\nrespectively. They alter the representation specified in the attribute.\nIf no representation is specified, the default one is altered.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// Default representation, alignment lowered to 2.</span>\n<span class=\"hljs-meta\">#[repr(packed(2))]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PackedStruct</span></span> {\n    first: <span class=\"hljs-built_in\">i16</span>,\n    second: <span class=\"hljs-built_in\">i8</span>,\n    third: <span class=\"hljs-built_in\">i32</span>\n}\n\n<span class=\"hljs-comment\">// C representation, alignment raised to 8</span>\n<span class=\"hljs-meta\">#[repr(C, align(8))]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">AlignedStruct</span></span> {\n    first: <span class=\"hljs-built_in\">i16</span>,\n    second: <span class=\"hljs-built_in\">i8</span>,\n    third: <span class=\"hljs-built_in\">i32</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<blockquote>\n<p>Note: As a consequence of the representation being an attribute on the item,\nthe representation does not depend on generic parameters. Any two types with\nthe same name have the same representation. For example, <code class=\"hljs\">Foo&lt;Bar&gt;</code> and\n<code class=\"hljs\">Foo&lt;Baz&gt;</code> both have the same representation.</p>\n</blockquote>\n<p>The representation of a type can change the padding between fields, but does\nnot change the layout of the fields themselves. For example, a struct with a\n<code class=\"hljs\">C</code> representation that contains a struct <code class=\"hljs\">Inner</code> with the default\nrepresentation will not change the layout of <code class=\"hljs\">Inner</code>.</p>\n<h3 id=\"the-rust-representation\"><a class=\"header\" href=\"#the-rust-representation\"></a><a id=\"the-default-representation\"></a> The <code class=\"hljs\">Rust</code> Representation</h3>\n<p>The <code class=\"hljs\">Rust</code> representation is the default representation for nominal types\nwithout a <code class=\"hljs\">repr</code> attribute. Using this representation explicitly through a\n<code class=\"hljs\">repr</code> attribute is guaranteed to be the same as omitting the attribute\nentirely.</p>\n<p>The only data layout guarantees made by this representation are those required\nfor soundness. They are:</p>\n<ol>\n<li>The fields are properly aligned.</li>\n<li>The fields do not overlap.</li>\n<li>The alignment of the type is at least the maximum alignment of its fields.</li>\n</ol>\n<p>Formally, the first guarantee means that the offset of any field is divisible by\nthat field's alignment. The second guarantee means that the fields can be\nordered such that the offset plus the size of any field is less than or equal to\nthe offset of the next field in the ordering. The ordering does not have to be\nthe same as the order in which the fields are specified in the declaration of\nthe type.</p>\n<p>Be aware that the second guarantee does not imply that the fields have distinct\naddresses: zero-sized types may have the same address as other fields in the\nsame struct.</p>\n<p>There are no other guarantees of data layout made by this representation.</p>\n<h3 id=\"the-c-representation\"><a class=\"header\" href=\"#the-c-representation\">The <code>C</code> Representation</a></h3>\n<p>The <code class=\"hljs\">C</code> representation is designed for dual purposes. One purpose is for\ncreating types that are interoperable with the C Language. The second purpose is\nto create types that you can soundly perform operations on that rely on data\nlayout such as reinterpreting values as a different type.</p>\n<p>Because of this dual purpose, it is possible to create types that are not useful\nfor interfacing with the C programming language.</p>\n<p>This representation can be applied to structs, unions, and enums. The exception\nis <a href=\"items/enumerations.html#zero-variant-enums\">zero-variant enums</a> for which the <code class=\"hljs\">C</code> representation is an error.</p>\n<h4 id=\"reprc-structs\"><a class=\"header\" href=\"#reprc-structs\"><code>#[repr(C)]</code> Structs</a></h4>\n<p>The alignment of the struct is the alignment of the most-aligned field in it.</p>\n<p>The size and offset of fields is determined by the following algorithm.</p>\n<p>Start with a current offset of 0 bytes.</p>\n<p>For each field in declaration order in the struct, first determine the size and\nalignment of the field. If the current offset is not a multiple of the field's\nalignment, then add padding bytes to the current offset until it is a multiple\nof the field's alignment. The offset for the field is what the current offset\nis now. Then increase the current offset by the size of the field.</p>\n<p>Finally, the size of the struct is the current offset rounded up to the nearest\nmultiple of the struct's alignment.</p>\n<p>Here is this algorithm described in pseudocode.</p>\n<!-- ignore: pseudocode -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">/// Returns the amount of padding needed after `offset` to ensure that the</span>\n<span class=\"hljs-comment\">/// following address will be aligned to `alignment`.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">padding_needed_for</span></span>(offset: <span class=\"hljs-built_in\">usize</span>, alignment: <span class=\"hljs-built_in\">usize</span>) -&gt; <span class=\"hljs-built_in\">usize</span> {\n    <span class=\"hljs-keyword\">let</span> misalignment = offset % alignment;\n    <span class=\"hljs-keyword\">if</span> misalignment &gt; <span class=\"hljs-number\">0</span> {\n        <span class=\"hljs-comment\">// round up to next multiple of `alignment`</span>\n        alignment - misalignment\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// already a multiple of `alignment`</span>\n        <span class=\"hljs-number\">0</span>\n    }\n}\n\n<span class=\"hljs-keyword\">struct</span>.alignment = <span class=\"hljs-keyword\">struct</span>.fields().map(|field| field.alignment).max();\n\n<span class=\"hljs-keyword\">let</span> current_offset = 0;\n\n<span class=\"hljs-keyword\">for</span> field <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">struct</span>.fields_in_declaration_order() {\n    // Increase the current offset so that it's a multiple of the alignment\n    // of this field. For the first field, this will always be zero.\n    // The skipped bytes are called padding bytes.\n    current_offset += padding_needed_for(current_offset, field.alignment);\n\n    <span class=\"hljs-keyword\">struct</span>[field].offset = current_offset;\n\n    current_offset += field.size;\n}\n\n<span class=\"hljs-keyword\">struct</span>.size = current_offset + padding_needed_for(current_offset, <span class=\"hljs-keyword\">struct</span>.alignment);</code></pre>\n<div class=\"warning\">\n<p>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for\nthe sake of clarity. To perform memory layout computations in actual code, use\n<a href=\"../std/alloc/struct.Layout.html\"><code class=\"hljs\">Layout</code></a>.</p>\n</div>\n<blockquote>\n<p>Note: This algorithm can produce zero-sized structs. In C, an empty struct\ndeclaration like <code class=\"hljs\">struct Foo { }</code> is illegal. However, both gcc and clang\nsupport options to enable such structs, and assign them size zero. C++, in\ncontrast, gives empty structs a size of 1, unless they are inherited from or\nthey are fields that have the <code class=\"hljs\">[[no_unique_address]]</code> attribute, in which\ncase they do not increase the overall size of the struct.</p>\n</blockquote>\n<h4 id=\"reprc-unions\"><a class=\"header\" href=\"#reprc-unions\"><code>#[repr(C)]</code> Unions</a></h4>\n<p>A union declared with <code class=\"hljs\">#[repr(C)]</code> will have the same size and alignment as an\nequivalent C union declaration in the C language for the target platform.\nThe union will have a size of the maximum size of all of its fields rounded to\nits alignment, and an alignment of the maximum alignment of all of its fields.\nThese maximums may come from different fields.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title\">Union</span></span> {\n    f1: <span class=\"hljs-built_in\">u16</span>,\n    f2: [<span class=\"hljs-built_in\">u8</span>; <span class=\"hljs-number\">4</span>],\n}\n\n<span class=\"hljs-built_in\">assert_eq!</span>(std::mem::size_of::&lt;Union&gt;(), <span class=\"hljs-number\">4</span>);  <span class=\"hljs-comment\">// From f2</span>\n<span class=\"hljs-built_in\">assert_eq!</span>(std::mem::align_of::&lt;Union&gt;(), <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// From f1</span>\n\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title\">SizeRoundedUp</span></span> {\n   a: <span class=\"hljs-built_in\">u32</span>,\n   b: [<span class=\"hljs-built_in\">u16</span>; <span class=\"hljs-number\">3</span>],\n}\n\n<span class=\"hljs-built_in\">assert_eq!</span>(std::mem::size_of::&lt;SizeRoundedUp&gt;(), <span class=\"hljs-number\">8</span>);  <span class=\"hljs-comment\">// Size of 6 from b,</span>\n                                                      <span class=\"hljs-comment\">// rounded up to 8 from</span>\n                                                      <span class=\"hljs-comment\">// alignment of a.</span>\n<span class=\"hljs-built_in\">assert_eq!</span>(std::mem::align_of::&lt;SizeRoundedUp&gt;(), <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// From a</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<h4 id=\"reprc-field-less-enums\"><a class=\"header\" href=\"#reprc-field-less-enums\"><code>#[repr(C)]</code> Field-less Enums</a></h4>\n<p>For <a href=\"items/enumerations.html#field-less-enum\">field-less enums</a>, the <code class=\"hljs\">C</code> representation has the size and alignment of\nthe default <code class=\"hljs\">enum</code> size and alignment for the target platform's C ABI.</p>\n<blockquote>\n<p>Note: The enum representation in C is implementation defined, so this is\nreally a \"best guess\". In particular, this may be incorrect when the C code\nof interest is compiled with certain flags.</p>\n</blockquote>\n<div class=\"warning\">\n<p>Warning: There are crucial differences between an <code class=\"hljs\">enum</code> in the C language and\nRust's <a href=\"items/enumerations.html#field-less-enum\">field-less enums</a> with this representation. An <code class=\"hljs\">enum</code> in C is\nmostly a <code class=\"hljs\">typedef</code> plus some named constants; in other words, an object of an\n<code class=\"hljs\">enum</code> type can hold any integer value. For example, this is often used for\nbitflags in <code class=\"hljs\">C</code>. In contrast, Rustâ€™s <a href=\"items/enumerations.html#field-less-enum\">field-less enums</a> can only legally hold\nthe discriminant values, everything else is <a href=\"behavior-considered-undefined.html\">undefined behavior</a>. Therefore,\nusing a field-less enum in FFI to model a C <code class=\"hljs\">enum</code> is often wrong.</p>\n</div>\n<h4 id=\"reprc-enums-with-fields\"><a class=\"header\" href=\"#reprc-enums-with-fields\"><code>#[repr(C)]</code> Enums With Fields</a></h4>\n<p>The representation of a <code class=\"hljs\">repr(C)</code> enum with fields is a <code class=\"hljs\">repr(C)</code> struct with\ntwo fields, also called a \"tagged union\" in C:</p>\n<ul>\n<li>a <code class=\"hljs\">repr(C)</code> version of the enum with all fields removed (\"the tag\")</li>\n<li>a <code class=\"hljs\">repr(C)</code> union of <code class=\"hljs\">repr(C)</code> structs for the fields of each variant that had\nthem (\"the payload\")</li>\n</ul>\n<blockquote>\n<p>Note: Due to the representation of <code class=\"hljs\">repr(C)</code> structs and unions, if a variant\nhas a single field there is no difference between putting that field directly\nin the union or wrapping it in a struct; any system which wishes to manipulate\nsuch an <code class=\"hljs\">enum</code>'s representation may therefore use whichever form is more\nconvenient or consistent for them.</p>\n</blockquote>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// This Enum has the same representation as ...</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">MyEnum</span></span> {\n    A(<span class=\"hljs-built_in\">u32</span>),\n    B(<span class=\"hljs-built_in\">f32</span>, <span class=\"hljs-built_in\">u64</span>),\n    C { x: <span class=\"hljs-built_in\">u32</span>, y: <span class=\"hljs-built_in\">u8</span> },\n    D,\n }\n\n<span class=\"hljs-comment\">// ... this struct.</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyEnumRepr</span></span> {\n    tag: MyEnumDiscriminant,\n    payload: MyEnumFields,\n}\n\n<span class=\"hljs-comment\">// This is the discriminant enum.</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">MyEnumDiscriminant</span></span> { A, B, C, D }\n\n<span class=\"hljs-comment\">// This is the variant union.</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title\">MyEnumFields</span></span> {\n    A: MyAFields,\n    B: MyBFields,\n    C: MyCFields,\n    D: MyDFields,\n}\n\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[derive(Copy, Clone)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyAFields</span></span>(<span class=\"hljs-built_in\">u32</span>);\n\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[derive(Copy, Clone)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyBFields</span></span>(<span class=\"hljs-built_in\">f32</span>, <span class=\"hljs-built_in\">u64</span>);\n\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[derive(Copy, Clone)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyCFields</span></span> { x: <span class=\"hljs-built_in\">u32</span>, y: <span class=\"hljs-built_in\">u8</span> }\n\n<span class=\"hljs-comment\">// This struct could be omitted (it is a zero-sized type), and it must be in</span>\n<span class=\"hljs-comment\">// C/C++ headers.</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[derive(Copy, Clone)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyDFields</span></span>;\n<span class=\"boring\">}</span></code></pre></pre>\n<blockquote>\n<p>Note: <code class=\"hljs\">union</code>s with non-<code class=\"hljs\">Copy</code> fields are unstable, see <a href=\"https://github.com/rust-lang/rust/issues/55149\">55149</a>.</p>\n</blockquote>\n<h3 id=\"primitive-representations\"><a class=\"header\" href=\"#primitive-representations\">Primitive representations</a></h3>\n<p>The <em>primitive representations</em> are the representations with the same names as\nthe primitive integer types. That is: <code class=\"hljs\">u8</code>, <code class=\"hljs\">u16</code>, <code class=\"hljs\">u32</code>, <code class=\"hljs\">u64</code>, <code class=\"hljs\">u128</code>,\n<code class=\"hljs\">usize</code>, <code class=\"hljs\">i8</code>, <code class=\"hljs\">i16</code>, <code class=\"hljs\">i32</code>, <code class=\"hljs\">i64</code>, <code class=\"hljs\">i128</code>, and <code class=\"hljs\">isize</code>.</p>\n<p>Primitive representations can only be applied to enumerations and have\ndifferent behavior whether the enum has fields or no fields. It is an error\nfor <a href=\"items/enumerations.html#zero-variant-enums\">zero-variant enums</a> to have a primitive representation. Combining\ntwo primitive representations together is an error.</p>\n<h4 id=\"primitive-representation-of-field-less-enums\"><a class=\"header\" href=\"#primitive-representation-of-field-less-enums\">Primitive Representation of Field-less Enums</a></h4>\n<p>For <a href=\"items/enumerations.html#field-less-enum\">field-less enums</a>, primitive representations set the size and alignment to\nbe the same as the primitive type of the same name. For example, a field-less\nenum with a <code class=\"hljs\">u8</code> representation can only have discriminants between 0 and 255\ninclusive.</p>\n<h4 id=\"primitive-representation-of-enums-with-fields\"><a class=\"header\" href=\"#primitive-representation-of-enums-with-fields\">Primitive Representation of Enums With Fields</a></h4>\n<p>The representation of a primitive representation enum is a <code class=\"hljs\">repr(C)</code> union of\n<code class=\"hljs\">repr(C)</code> structs for each variant with a field. The first field of each struct\nin the union is the primitive representation version of the enum with all fields\nremoved (\"the tag\") and the remaining fields are the fields of that variant.</p>\n<blockquote>\n<p>Note: This representation is unchanged if the tag is given its own member in\nthe union, should that make manipulation more clear for you (although to\nfollow the C++ standard the tag member should be wrapped in a <code class=\"hljs\">struct</code>).</p>\n</blockquote>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// This enum has the same representation as ...</span>\n<span class=\"hljs-meta\">#[repr(u8)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">MyEnum</span></span> {\n    A(<span class=\"hljs-built_in\">u32</span>),\n    B(<span class=\"hljs-built_in\">f32</span>, <span class=\"hljs-built_in\">u64</span>),\n    C { x: <span class=\"hljs-built_in\">u32</span>, y: <span class=\"hljs-built_in\">u8</span> },\n    D,\n }\n\n<span class=\"hljs-comment\">// ... this union.</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title\">MyEnumRepr</span></span> {\n    A: MyVariantA,\n    B: MyVariantB,\n    C: MyVariantC,\n    D: MyVariantD,\n}\n\n<span class=\"hljs-comment\">// This is the discriminant enum.</span>\n<span class=\"hljs-meta\">#[repr(u8)]</span>\n<span class=\"hljs-meta\">#[derive(Copy, Clone)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">MyEnumDiscriminant</span></span> { A, B, C, D }\n\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[derive(Clone, Copy)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyVariantA</span></span>(MyEnumDiscriminant, <span class=\"hljs-built_in\">u32</span>);\n\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[derive(Clone, Copy)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyVariantB</span></span>(MyEnumDiscriminant, <span class=\"hljs-built_in\">f32</span>, <span class=\"hljs-built_in\">u64</span>);\n\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[derive(Clone, Copy)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyVariantC</span></span> { tag: MyEnumDiscriminant, x: <span class=\"hljs-built_in\">u32</span>, y: <span class=\"hljs-built_in\">u8</span> }\n\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[derive(Clone, Copy)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyVariantD</span></span>(MyEnumDiscriminant);\n<span class=\"boring\">}</span></code></pre></pre>\n<blockquote>\n<p>Note: <code class=\"hljs\">union</code>s with non-<code class=\"hljs\">Copy</code> fields are unstable, see <a href=\"https://github.com/rust-lang/rust/issues/55149\">55149</a>.</p>\n</blockquote>\n<h4 id=\"combining-primitive-representations-of-enums-with-fields-and-reprc\"><a class=\"header\" href=\"#combining-primitive-representations-of-enums-with-fields-and-reprc\">Combining primitive representations of enums with fields and <code>#[repr(C)]</code></a></h4>\n<p>For enums with fields, it is also possible to combine <code class=\"hljs\">repr(C)</code> and a\nprimitive representation (e.g., <code class=\"hljs\">repr(C, u8)</code>). This modifies the <a href=\"#reprc-enums-with-fields\"><code class=\"hljs\">repr(C)</code></a> by\nchanging the representation of the discriminant enum to the chosen primitive\ninstead. So, if you chose the <code class=\"hljs\">u8</code> representation, then the discriminant enum\nwould have a size and alignment of 1 byte.</p>\n<p>The discriminant enum from the example <a href=\"#reprc-enums-with-fields\">earlier</a> then becomes:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[repr(C, u8)]</span> <span class=\"hljs-comment\">// `u8` was added</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">MyEnum</span></span> {\n    A(<span class=\"hljs-built_in\">u32</span>),\n    B(<span class=\"hljs-built_in\">f32</span>, <span class=\"hljs-built_in\">u64</span>),\n    C { x: <span class=\"hljs-built_in\">u32</span>, y: <span class=\"hljs-built_in\">u8</span> },\n    D,\n }\n\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-meta\">#[repr(u8)]</span> <span class=\"hljs-comment\">// So `u8` is used here instead of `C`</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">MyEnumDiscriminant</span></span> { A, B, C, D }\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p>For example, with a <code class=\"hljs\">repr(C, u8)</code> enum it is not possible to have 257 unique\ndiscriminants (\"tags\") whereas the same enum with only a <code class=\"hljs\">repr(C)</code> attribute\nwill compile without any problems.</p>\n<p>Using a primitive representation in addition to <code class=\"hljs\">repr(C)</code> can change the size of\nan enum from the <code class=\"hljs\">repr(C)</code> form:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">EnumC</span></span> {\n    Variant0(<span class=\"hljs-built_in\">u8</span>),\n    Variant1,\n}\n\n<span class=\"hljs-meta\">#[repr(C, u8)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Enum8</span></span> {\n    Variant0(<span class=\"hljs-built_in\">u8</span>),\n    Variant1,\n}\n\n<span class=\"hljs-meta\">#[repr(C, u16)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Enum16</span></span> {\n    Variant0(<span class=\"hljs-built_in\">u8</span>),\n    Variant1,\n}\n\n<span class=\"hljs-comment\">// The size of the C representation is platform dependant</span>\n<span class=\"hljs-built_in\">assert_eq!</span>(std::mem::size_of::&lt;EnumC&gt;(), <span class=\"hljs-number\">8</span>);\n<span class=\"hljs-comment\">// One byte for the discriminant and one byte for the value in Enum8::Variant0</span>\n<span class=\"hljs-built_in\">assert_eq!</span>(std::mem::size_of::&lt;Enum8&gt;(), <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-comment\">// Two bytes for the discriminant and one byte for the value in Enum16::Variant0</span>\n<span class=\"hljs-comment\">// plus one byte of padding.</span>\n<span class=\"hljs-built_in\">assert_eq!</span>(std::mem::size_of::&lt;Enum16&gt;(), <span class=\"hljs-number\">4</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<h3 id=\"the-alignment-modifiers\"><a class=\"header\" href=\"#the-alignment-modifiers\">The alignment modifiers</a></h3>\n<p>The <code class=\"hljs\">align</code> and <code class=\"hljs\">packed</code> modifiers can be used to respectively raise or lower\nthe alignment of <code class=\"hljs\">struct</code>s and <code class=\"hljs\">union</code>s. <code class=\"hljs\">packed</code> may also alter the padding\nbetween fields (although it will not alter the padding inside of any field).\nOn their own, <code class=\"hljs\">align</code> and <code class=\"hljs\">packed</code> do not provide guarantees about the order\nof fields in the layout of a struct or the layout of an enum variant, although\nthey may be combined with representations (such as <code class=\"hljs\">C</code>) which do provide such\nguarantees.</p>\n<p>The alignment is specified as an integer parameter in the form of\n<code class=\"hljs\">#[repr(align(x))]</code> or <code class=\"hljs\">#[repr(packed(x))]</code>. The alignment value must be a\npower of two from 1 up to 2<sup>29</sup>. For <code class=\"hljs\">packed</code>, if no value is given,\nas in <code class=\"hljs\">#[repr(packed)]</code>, then the value is 1.</p>\n<p>For <code class=\"hljs\">align</code>, if the specified alignment is less than the alignment of the type\nwithout the <code class=\"hljs\">align</code> modifier, then the alignment is unaffected.</p>\n<p>For <code class=\"hljs\">packed</code>, if the specified alignment is greater than the type's alignment\nwithout the <code class=\"hljs\">packed</code> modifier, then the alignment and layout is unaffected.\nThe alignments of each field, for the purpose of positioning fields, is the\nsmaller of the specified alignment and the alignment of the field's type.\nInter-field padding is guaranteed to be the minimum required in order to\nsatisfy each field's (possibly altered) alignment (although note that, on its\nown, <code class=\"hljs\">packed</code> does not provide any guarantee about field ordering). An\nimportant consequence of these rules is that a type with <code class=\"hljs\">#[repr(packed(1))]</code>\n(or <code class=\"hljs\">#[repr(packed)]</code>) will have no inter-field padding.</p>\n<p>The <code class=\"hljs\">align</code> and <code class=\"hljs\">packed</code> modifiers cannot be applied on the same type and a\n<code class=\"hljs\">packed</code> type cannot transitively contain another <code class=\"hljs\">align</code>ed type. <code class=\"hljs\">align</code> and\n<code class=\"hljs\">packed</code> may only be applied to the <a href=\"#the-rust-representation\"><code class=\"hljs\">Rust</code></a> and <a href=\"#the-c-representation\"><code class=\"hljs\">C</code></a> representations.</p>\n<p>The <code class=\"hljs\">align</code> modifier can also be applied on an <code class=\"hljs\">enum</code>.\nWhen it is, the effect on the <code class=\"hljs\">enum</code>'s alignment is the same as if the <code class=\"hljs\">enum</code>\nwas wrapped in a newtype <code class=\"hljs\">struct</code> with the same <code class=\"hljs\">align</code> modifier.</p>\n<blockquote>\n<p>Note: References to unaligned fields are not allowed because it is <a href=\"behavior-considered-undefined.html\">undefined behavior</a>.\nWhen fields are unaligned due to an alignment modifier, consider the following options for using references and dereferences:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[repr(packed)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    f1: <span class=\"hljs-built_in\">u8</span>,\n    f2: <span class=\"hljs-built_in\">u16</span>,\n}\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> e = Packed { f1: <span class=\"hljs-number\">1</span>, f2: <span class=\"hljs-number\">2</span> };\n<span class=\"hljs-comment\">// Instead of creating a reference to a field, copy the value to a local variable.</span>\n<span class=\"hljs-keyword\">let</span> x = e.f2;\n<span class=\"hljs-comment\">// Or in situations like `println!` which creates a reference, use braces</span>\n<span class=\"hljs-comment\">// to change it to a copy of the value.</span>\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, {e.f2});\n<span class=\"hljs-comment\">// Or if you need a pointer, use the unaligned methods for reading and writing</span>\n<span class=\"hljs-comment\">// instead of dereferencing the pointer directly.</span>\n<span class=\"hljs-keyword\">let</span> ptr: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u16</span> = std::ptr::addr_of!(e.f2);\n<span class=\"hljs-keyword\">let</span> value = <span class=\"hljs-keyword\">unsafe</span> { ptr.read_unaligned() };\n<span class=\"hljs-keyword\">let</span> mut_ptr: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u16</span> = std::ptr::addr_of_mut!(e.f2);\n<span class=\"hljs-keyword\">unsafe</span> { mut_ptr.write_unaligned(<span class=\"hljs-number\">3</span>) }\n<span class=\"boring\">}</span></code></pre></pre>\n</blockquote>\n<h3 id=\"the-transparent-representation\"><a class=\"header\" href=\"#the-transparent-representation\">The <code>transparent</code> Representation</a></h3>\n<p>The <code class=\"hljs\">transparent</code> representation can only be used on a <a href=\"items/structs.html\"><code class=\"hljs\">struct</code></a>\nor an <a href=\"items/enumerations.html\"><code class=\"hljs\">enum</code></a> with a single variant that has:</p>\n<ul>\n<li>a single field with non-zero size, and</li>\n<li>any number of fields with size 0 and alignment 1 (e.g. <a href=\"special-types-and-traits.html#phantomdatat\"><code class=\"hljs\">PhantomData&lt;T&gt;</code></a>).</li>\n</ul>\n<p>Structs and enums with this representation have the same layout and ABI\nas the single non-zero sized field.</p>\n<p>This is different than the <code class=\"hljs\">C</code> representation because\na struct with the <code class=\"hljs\">C</code> representation will always have the ABI of a <code class=\"hljs\">C</code> <code class=\"hljs\">struct</code>\nwhile, for example, a struct with the <code class=\"hljs\">transparent</code> representation with a\nprimitive field will have the ABI of the primitive field.</p>\n<p>Because this representation delegates type layout to another type, it cannot be\nused with any other representation.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"dynamically-sized-types.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"interior-mutability.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"dynamically-sized-types.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"interior-mutability.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:13:28.622Z"
}