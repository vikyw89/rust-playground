{
	"title": "Macro Follow-Set Ambiguity Formal Specification - The Rust Reference",
	"url": "https://doc.rust-lang.org/stable/reference/macro-ambiguity.html",
	"markdown": "# Macro Follow-Set Ambiguity Formal Specification\n\nThis page documents the formal specification of the follow rules for [Macros By Example](macros-by-example.html). They were originally specified in [RFC 550](https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md), from which the bulk of this text is copied, and expanded upon in subsequent RFCs.\n\n## [Definitions & Conventions](#definitions--conventions)\n\n-   `macro`: anything invokable as `foo!(...)` in source code.\n-   `MBE`: macro-by-example, a macro defined by `macro_rules`.\n-   `matcher`: the left-hand-side of a rule in a `macro_rules` invocation, or a subportion thereof.\n-   `macro parser`: the bit of code in the Rust parser that will parse the input using a grammar derived from all of the matchers.\n-   `fragment`: The class of Rust syntax that a given matcher will accept (or \"match\").\n-   `repetition` : a fragment that follows a regular repeating pattern\n-   `NT`: non-terminal, the various \"meta-variables\" or repetition matchers that can appear in a matcher, specified in MBE syntax with a leading `$` character.\n-   `simple NT`: a \"meta-variable\" non-terminal (further discussion below).\n-   `complex NT`: a repetition matching non-terminal, specified via repetition operators (`*`, `+`, `?`).\n-   `token`: an atomic element of a matcher; i.e. identifiers, operators, open/close delimiters, _and_ simple NT's.\n-   `token tree`: a tree structure formed from tokens (the leaves), complex NT's, and finite sequences of token trees.\n-   `delimiter token`: a token that is meant to divide the end of one fragment and the start of the next fragment.\n-   `separator token`: an optional delimiter token in an complex NT that separates each pair of elements in the matched repetition.\n-   `separated complex NT`: a complex NT that has its own separator token.\n-   `delimited sequence`: a sequence of token trees with appropriate open- and close-delimiters at the start and end of the sequence.\n-   `empty fragment`: The class of invisible Rust syntax that separates tokens, i.e. whitespace, or (in some lexical contexts), the empty token sequence.\n-   `fragment specifier`: The identifier in a simple NT that specifies which fragment the NT accepts.\n-   `language`: a context-free language.\n\nExample:\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! i_am_an_mbe {\n    (start $foo:expr $($i:ident),* end) => ($foo)\n}\n}\n```\n\n`(start $foo:expr $($i:ident),* end)` is a matcher. The whole matcher is a delimited sequence (with open- and close-delimiters `(` and `)`), and `$foo` and `$i` are simple NT's with `expr` and `ident` as their respective fragment specifiers.\n\n`$(i:ident),*` is _also_ an NT; it is a complex NT that matches a comma-separated repetition of identifiers. The `,` is the separator token for the complex NT; it occurs in between each pair of elements (if any) of the matched fragment.\n\nAnother example of a complex NT is `$(hi $e:expr ;)+`, which matches any fragment of the form `hi <expr>; hi <expr>; ...` where `hi <expr>;` occurs at least once. Note that this complex NT does not have a dedicated separator token.\n\n(Note that Rust's parser ensures that delimited sequences always occur with proper nesting of token tree structure and correct matching of open- and close-delimiters.)\n\nWe will tend to use the variable \"M\" to stand for a matcher, variables \"t\" and \"u\" for arbitrary individual tokens, and the variables \"tt\" and \"uu\" for arbitrary token trees. (The use of \"tt\" does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)\n\n\"SEP\" will range over separator tokens, \"OP\" over the repetition operators `*`, `+`, and `?`, \"OPEN\"/\"CLOSE\" over matching token pairs surrounding a delimited sequence (e.g. `[` and `]`).\n\nGreek letters \"α\" \"β\" \"γ\" \"δ\" stand for potentially empty token-tree sequences. (However, the Greek letter \"ε\" (epsilon) has a special role in the presentation and does not stand for a token-tree sequence.)\n\n-   This Greek letter convention is usually just employed when the presence of a sequence is a technical detail; in particular, when we wish to _emphasize_ that we are operating on a sequence of token-trees, we will use the notation \"tt ...\" for the sequence, not a Greek letter.\n\nNote that a matcher is merely a token tree. A \"simple NT\", as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, `$foo:ty` is a simple NT but `$($foo:ty)+` is a complex NT.\n\nNote also that in the context of this formalism, the term \"token\" generally _includes_ simple NTs.\n\nFinally, it is useful for the reader to keep in mind that according to the definitions of this formalism, no simple NT matches the empty fragment, and likewise no token matches the empty fragment of Rust syntax. (Thus, the _only_ NT that can match the empty fragment is a complex NT.) This is not actually true, because the `vis` matcher can match an empty fragment. Thus, for the purposes of the formalism, we will treat `$v:vis` as actually being `$($v:vis)?`, with a requirement that the matcher match an empty fragment.\n\n### [The Matcher Invariants](#the-matcher-invariants)\n\nTo be valid, a matcher must meet the following three invariants. The definitions of FIRST and FOLLOW are described later.\n\n1.  For any two successive token tree sequences in a matcher `M` (i.e. `M = ... tt uu ...`) with `uu ...` nonempty, we must have FOLLOW(`... tt`) ∪ {ε} ⊇ FIRST(`uu ...`).\n2.  For any separated complex NT in a matcher, `M = ... $(tt ...) SEP OP ...`, we must have `SEP` ∈ FOLLOW(`tt ...`).\n3.  For an unseparated complex NT in a matcher, `M = ... $(tt ...) OP ...`, if OP = `*` or `+`, we must have FOLLOW(`tt ...`) ⊇ FIRST(`tt ...`).\n\nThe first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set. This ensures that a legal macro definition will continue to assign the same determination as to where `... tt` ends and `uu ...` begins, even as new syntactic forms are added to the language.\n\nThe second invariant says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of `tt ...`'s, even as new syntactic forms are added to the language.\n\nThe third invariant says that when we have a complex NT that can match two or more copies of the same thing with no separation in between, it must be permissible for them to be placed next to each other as per the first invariant. This invariant also requires they be nonempty, which eliminates a possible ambiguity.\n\n**NOTE: The third invariant is currently unenforced due to historical oversight and significant reliance on the behaviour. It is currently undecided what to do about this going forward. Macros that do not respect the behaviour may become invalid in a future edition of Rust. See the [tracking issue](https://github.com/rust-lang/rust/issues/56575).**\n\n### [FIRST and FOLLOW, informally](#first-and-follow-informally)\n\nA given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).\n\nEach of the three sets is made up of tokens. FIRST(M) and LAST(M) may also contain a distinguished non-token element ε (\"epsilon\"), which indicates that M can match the empty fragment. (But FOLLOW(M) is always just a set of tokens.)\n\nInformally:\n\n-   FIRST(M): collects the tokens potentially used first when matching a fragment to M.\n    \n-   LAST(M): collects the tokens potentially used last when matching a fragment to M.\n    \n-   FOLLOW(M): the set of tokens allowed to follow immediately after some fragment matched by M.\n    \n    In other words: t ∈ FOLLOW(M) if and only if there exists (potentially empty) token sequences α, β, γ, δ where:\n    \n    -   M matches β,\n        \n    -   t matches γ, and\n        \n    -   The concatenation α β γ δ is a parseable Rust program.\n        \n\nWe use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.\n\n(To review one's understanding of the above informal descriptions, the reader at this point may want to jump ahead to the [examples of FIRST/LAST](#examples-of-first-and-last) before reading their formal definitions.)\n\n### [FIRST, LAST](#first-last)\n\nBelow are formal inductive definitions for FIRST and LAST.\n\n\"A ∪ B\" denotes set union, \"A ∩ B\" denotes set intersection, and \"A \\\\ B\" denotes set difference (i.e. all elements of A that are not present in B).\n\n#### [FIRST](#first)\n\nFIRST(M) is defined by case analysis on the sequence M and the structure of its first token-tree (if any):\n\n-   if M is the empty sequence, then FIRST(M) = { ε },\n    \n-   if M starts with a token t, then FIRST(M) = { t },\n    \n    (Note: this covers the case where M starts with a delimited token-tree sequence, `M = OPEN tt ... CLOSE ...`, in which case `t = OPEN` and thus FIRST(M) = { `OPEN` }.)\n    \n    (Note: this critically relies on the property that no simple NT matches the empty fragment.)\n    \n-   Otherwise, M is a token-tree sequence starting with a complex NT: `M = $( tt ... ) OP α`, or `M = $( tt ... ) SEP OP α`, (where `α` is the (potentially empty) sequence of token trees for the rest of the matcher).\n    \n    -   Let SEP\\_SET(M) = { SEP } if SEP is present and ε ∈ FIRST(`tt ...`); otherwise SEP\\_SET(M) = {}.\n-   Let ALPHA\\_SET(M) = FIRST(`α`) if OP = `*` or `?` and ALPHA\\_SET(M) = {} if OP = `+`.\n    \n-   FIRST(M) = (FIRST(`tt ...`) \\\\ {ε}) ∪ SEP\\_SET(M) ∪ ALPHA\\_SET(M).\n    \n\nThe definition for complex NTs deserves some justification. SEP\\_SET(M) defines the possibility that the separator could be a valid first token for M, which happens when there is a separator defined and the repeated fragment could be empty. ALPHA\\_SET(M) defines the possibility that the complex NT could be empty, meaning that M's valid first tokens are those of the following token-tree sequences `α`. This occurs when either `*` or `?` is used, in which case there could be zero repetitions. In theory, this could also occur if `+` was used with a potentially-empty repeating fragment, but this is forbidden by the third invariant.\n\nFrom there, clearly FIRST(M) can include any token from SEP\\_SET(M) or ALPHA\\_SET(M), and if the complex NT match is nonempty, then any token starting FIRST(`tt ...`) could work too. The last piece to consider is ε. SEP\\_SET(M) and FIRST(`tt ...`) \\\\ {ε} cannot contain ε, but ALPHA\\_SET(M) could. Hence, this definition allows M to accept ε if and only if ε ∈ ALPHA\\_SET(M) does. This is correct because for M to accept ε in the complex NT case, both the complex NT and α must accept it. If OP = `+`, meaning that the complex NT cannot be empty, then by definition ε ∉ ALPHA\\_SET(M). Otherwise, the complex NT can accept zero repetitions, and then ALPHA\\_SET(M) = FOLLOW(`α`). So this definition is correct with respect to \\\\varepsilon as well.\n\n#### [LAST](#last)\n\nLAST(M), defined by case analysis on M itself (a sequence of token-trees):\n\n-   if M is the empty sequence, then LAST(M) = { ε }\n    \n-   if M is a singleton token t, then LAST(M) = { t }\n    \n-   if M is the singleton complex NT repeating zero or more times, `M = $( tt ... ) *`, or `M = $( tt ... ) SEP *`\n    \n    -   Let sep\\_set = { SEP } if SEP present; otherwise sep\\_set = {}.\n        \n    -   if ε ∈ LAST(`tt ...`) then LAST(M) = LAST(`tt ...`) ∪ sep\\_set\n        \n    -   otherwise, the sequence `tt ...` must be non-empty; LAST(M) = LAST(`tt ...`) ∪ {ε}.\n        \n-   if M is the singleton complex NT repeating one or more times, `M = $( tt ... ) +`, or `M = $( tt ... ) SEP +`\n    \n    -   Let sep\\_set = { SEP } if SEP present; otherwise sep\\_set = {}.\n        \n    -   if ε ∈ LAST(`tt ...`) then LAST(M) = LAST(`tt ...`) ∪ sep\\_set\n        \n    -   otherwise, the sequence `tt ...` must be non-empty; LAST(M) = LAST(`tt ...`)\n        \n-   if M is the singleton complex NT repeating zero or one time, `M = $( tt ...) ?`, then LAST(M) = LAST(`tt ...`) ∪ {ε}.\n    \n-   if M is a delimited token-tree sequence `OPEN tt ... CLOSE`, then LAST(M) = { `CLOSE` }.\n    \n-   if M is a non-empty sequence of token-trees `tt uu ...`,\n    \n    -   If ε ∈ LAST(`uu ...`), then LAST(M) = LAST(`tt`) ∪ (LAST(`uu ...`) \\\\ { ε }).\n        \n    -   Otherwise, the sequence `uu ...` must be non-empty; then LAST(M) = LAST(`uu ...`).\n        \n\n### [Examples of FIRST and LAST](#examples-of-first-and-last)\n\nBelow are some examples of FIRST and LAST. (Note in particular how the special ε element is introduced and eliminated based on the interaction between the pieces of the input.)\n\nOur first example is presented in a tree structure to elaborate on how the analysis of the matcher composes. (Some of the simpler subtrees have been elided.)\n\n```text\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n            ~~~~~~~~   ~~~~~~~                ~\n                |         |                   |\nFIRST:   { $d:ident }  { $e:expr }          { h }\n\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+\n            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~\n                        |                      |               |\nFIRST:          { $d:ident }               { h, ε }         { f }\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~\n                        |                       |              |       |\nFIRST:        { $d:ident, ε }            {  h, ε, ;  }      { f }   { g }\n\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                                        |\nFIRST:                       { $d:ident, h, ;,  f }\n\n```\n\nThus:\n\n-   FIRST(`$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g`) = { `$d:ident`, `h`, `;`, `f` }\n\nNote however that:\n\n-   FIRST(`$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*`) = { `$d:ident`, `h`, `;`, `f`, ε }\n\nHere are similar examples but now for LAST.\n\n-   LAST(`$d:ident $e:expr`) = { `$e:expr` }\n-   LAST(`$( $d:ident $e:expr );*`) = { `$e:expr`, ε }\n-   LAST(`$( $d:ident $e:expr );* $(h)*`) = { `$e:expr`, ε, `h` }\n-   LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+`) = { `;` }\n-   LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+ g`) = { `g` }\n\n### [FOLLOW(M)](#followm)\n\nFinally, the definition for FOLLOW(M) is built up as follows. pat, expr, etc. represent simple nonterminals with the given fragment specifier.\n\n-   FOLLOW(pat) = {`=>`, `,`, `=`, `|`, `if`, `in`}\\`.\n    \n-   FOLLOW(expr) = FOLLOW(stmt) = {`=>`, `,`, `;`}\\`.\n    \n-   FOLLOW(ty) = FOLLOW(path) = {`{`, `[`, `,`, `=>`, `:`, `=`, `>`, `>>`, `;`, `|`, `as`, `where`, block nonterminals}.\n    \n-   FOLLOW(vis) = {`,`l any keyword or identifier except a non-raw `priv`; any token that can begin a type; ident, ty, and path nonterminals}.\n    \n-   FOLLOW(t) = ANYTOKEN for any other simple token, including block, ident, tt, item, lifetime, literal and meta simple nonterminals, and all terminals.\n    \n-   FOLLOW(M), for any other M, is defined as the intersection, as t ranges over (LAST(M) \\\\ {ε}), of FOLLOW(t).\n    \n\nThe tokens that can begin a type are, as of this writing, {`(`, `[`, `!`, `*`, `&`, `&&`, `?`, lifetimes, `>`, `>>`, `::`, any non-keyword identifier, `super`, `self`, `Self`, `extern`, `crate`, `$crate`, `_`, `for`, `impl`, `fn`, `unsafe`, `typeof`, `dyn`}, although this list may not be complete because people won't always remember to update the appendix when new ones are added.\n\nExamples of FOLLOW for complex M:\n\n-   FOLLOW(`$( $d:ident $e:expr )*`) = FOLLOW(`$e:expr`)\n-   FOLLOW(`$( $d:ident $e:expr )* $(;)*`) = FOLLOW(`$e:expr`) ∩ ANYTOKEN = FOLLOW(`$e:expr`)\n-   FOLLOW(`$( $d:ident $e:expr )* $(;)* $( f |)+`) = ANYTOKEN\n\n### [Examples of valid and invalid matchers](#examples-of-valid-and-invalid-matchers)\n\nWith the above specification in hand, we can present arguments for why particular matchers are legal and others are not.\n\n-   `($ty:ty < foo ,)` : illegal, because FIRST(`< foo ,`) = { `<` } ⊈ FOLLOW(`ty`)\n    \n-   `($ty:ty , foo <)` : legal, because FIRST(`, foo <`) = { `,` } is ⊆ FOLLOW(`ty`).\n    \n-   `($pa:pat $pb:pat $ty:ty ,)` : illegal, because FIRST(`$pb:pat $ty:ty ,`) = { `$pb:pat` } ⊈ FOLLOW(`pat`), and also FIRST(`$ty:ty ,`) = { `$ty:ty` } ⊈ FOLLOW(`pat`).\n    \n-   `( $($a:tt $b:tt)* ; )` : legal, because FIRST(`$b:tt`) = { `$b:tt` } is ⊆ FOLLOW(`tt`) = ANYTOKEN, as is FIRST(`;`) = { `;` }.\n    \n-   `( $($t:tt),* , $(t:tt),* )` : legal, (though any attempt to actually use this macro will signal a local ambiguity error during expansion).\n    \n-   `($ty:ty $(; not sep)* -)` : illegal, because FIRST(`$(; not sep)* -`) = { `;`, `-` } is not in FOLLOW(`ty`).\n    \n-   `($($ty:ty)-+)` : illegal, because separator `-` is not in FOLLOW(`ty`).\n    \n-   `($($e:expr)*)` : illegal, because expr NTs are not in FOLLOW(expr NT).",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Macro Follow-Set Ambiguity Formal Specification - The Rust Reference</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/reference.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"notation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Notation</a></li><li class=\"chapter-item expanded \"><a href=\"lexical-structure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Lexical structure</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"input-format.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Input format</a></li><li class=\"chapter-item expanded \"><a href=\"keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"identifiers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Identifiers</a></li><li class=\"chapter-item expanded \"><a href=\"comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"whitespace.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Whitespace</a></li><li class=\"chapter-item expanded \"><a href=\"tokens.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Tokens</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Macros</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macros-by-example.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Macros By Example</a></li><li class=\"chapter-item expanded \"><a href=\"procedural-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Procedural Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"crates-and-source-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Crates and source files</a></li><li class=\"chapter-item expanded \"><a href=\"conditional-compilation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Conditional compilation</a></li><li class=\"chapter-item expanded \"><a href=\"items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Items</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"items/modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Modules</a></li><li class=\"chapter-item expanded \"><a href=\"items/extern-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Extern crates</a></li><li class=\"chapter-item expanded \"><a href=\"items/use-declarations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Use declarations</a></li><li class=\"chapter-item expanded \"><a href=\"items/functions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.4.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"items/type-aliases.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.5.</strong> Type aliases</a></li><li class=\"chapter-item expanded \"><a href=\"items/structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.6.</strong> Structs</a></li><li class=\"chapter-item expanded \"><a href=\"items/enumerations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.7.</strong> Enumerations</a></li><li class=\"chapter-item expanded \"><a href=\"items/unions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.8.</strong> Unions</a></li><li class=\"chapter-item expanded \"><a href=\"items/constant-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.9.</strong> Constant items</a></li><li class=\"chapter-item expanded \"><a href=\"items/static-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.10.</strong> Static items</a></li><li class=\"chapter-item expanded \"><a href=\"items/traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.11.</strong> Traits</a></li><li class=\"chapter-item expanded \"><a href=\"items/implementations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.12.</strong> Implementations</a></li><li class=\"chapter-item expanded \"><a href=\"items/external-blocks.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.13.</strong> External blocks</a></li><li class=\"chapter-item expanded \"><a href=\"items/generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.14.</strong> Generic parameters</a></li><li class=\"chapter-item expanded \"><a href=\"items/associated-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.15.</strong> Associated Items</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"attributes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Attributes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"attributes/testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Testing</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/derive.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Derive</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/diagnostics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Diagnostics</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/codegen.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Code generation</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/limits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Limits</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/type_system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.6.</strong> Type System</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/debugger.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.7.</strong> Debugger</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"statements-and-expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Statements and expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"statements.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Statements</a></li><li class=\"chapter-item expanded \"><a href=\"expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"expressions/literal-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.1.</strong> Literal expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/path-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.2.</strong> Path expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/block-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.3.</strong> Block expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/operator-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.4.</strong> Operator expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/grouped-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.5.</strong> Grouped expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/array-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.6.</strong> Array and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/tuple-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.7.</strong> Tuple and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/struct-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.8.</strong> Struct expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.9.</strong> Call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/method-call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.10.</strong> Method call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/field-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.11.</strong> Field access expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/closure-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.12.</strong> Closure expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/loop-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.13.</strong> Loop expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/range-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.14.</strong> Range expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/if-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.15.</strong> If and if let expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/match-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.16.</strong> Match expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/return-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.17.</strong> Return expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/await-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.18.</strong> Await expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/underscore-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.19.</strong> Underscore expressions</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Patterns</a></li><li class=\"chapter-item expanded \"><a href=\"type-system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Type system</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Types</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types/boolean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Boolean type</a></li><li class=\"chapter-item expanded \"><a href=\"types/numeric.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Numeric types</a></li><li class=\"chapter-item expanded \"><a href=\"types/textual.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Textual types</a></li><li class=\"chapter-item expanded \"><a href=\"types/never.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Never type</a></li><li class=\"chapter-item expanded \"><a href=\"types/tuple.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Tuple types</a></li><li class=\"chapter-item expanded \"><a href=\"types/array.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.6.</strong> Array types</a></li><li class=\"chapter-item expanded \"><a href=\"types/slice.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.7.</strong> Slice types</a></li><li class=\"chapter-item expanded \"><a href=\"types/struct.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.8.</strong> Struct types</a></li><li class=\"chapter-item expanded \"><a href=\"types/enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.9.</strong> Enumerated types</a></li><li class=\"chapter-item expanded \"><a href=\"types/union.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.10.</strong> Union types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-item.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.11.</strong> Function item types</a></li><li class=\"chapter-item expanded \"><a href=\"types/closure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.12.</strong> Closure types</a></li><li class=\"chapter-item expanded \"><a href=\"types/pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.13.</strong> Pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.14.</strong> Function pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/trait-object.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.15.</strong> Trait object types</a></li><li class=\"chapter-item expanded \"><a href=\"types/impl-trait.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.16.</strong> Impl trait type</a></li><li class=\"chapter-item expanded \"><a href=\"types/parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.17.</strong> Type parameters</a></li><li class=\"chapter-item expanded \"><a href=\"types/inferred.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.18.</strong> Inferred type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"dynamically-sized-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Dynamically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"type-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Type layout</a></li><li class=\"chapter-item expanded \"><a href=\"interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.4.</strong> Interior mutability</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.5.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"trait-bounds.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.6.</strong> Trait and lifetime bounds</a></li><li class=\"chapter-item expanded \"><a href=\"type-coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.7.</strong> Type coercions</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.8.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.9.</strong> Lifetime elision</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"special-types-and-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Special types and traits</a></li><li class=\"chapter-item expanded \"><a href=\"names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Names</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"names/namespaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Namespaces</a></li><li class=\"chapter-item expanded \"><a href=\"names/scopes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Scopes</a></li><li class=\"chapter-item expanded \"><a href=\"names/preludes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Preludes</a></li><li class=\"chapter-item expanded \"><a href=\"paths.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Paths</a></li><li class=\"chapter-item expanded \"><a href=\"names/name-resolution.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Name resolution</a></li><li class=\"chapter-item expanded \"><a href=\"visibility-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Visibility and privacy</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"memory-model.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Memory model</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"memory-allocation-and-lifetime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Memory allocation and lifetime</a></li><li class=\"chapter-item expanded \"><a href=\"variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Variables</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"linkage.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> Linkage</a></li><li class=\"chapter-item expanded \"><a href=\"inline-assembly.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Inline assembly</a></li><li class=\"chapter-item expanded \"><a href=\"unsafety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Unsafety</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"unsafe-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> The unsafe keyword</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-considered-undefined.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Behavior considered undefined</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-not-considered-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Behavior not considered unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"const_eval.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Constant Evaluation</a></li><li class=\"chapter-item expanded \"><a href=\"abi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Application Binary Interface</a></li><li class=\"chapter-item expanded \"><a href=\"runtime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> The Rust runtime</a></li><li class=\"chapter-item expanded \"><a href=\"appendices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Appendices</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macro-ambiguity.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class=\"chapter-item expanded \"><a href=\"influences.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Influences</a></li><li class=\"chapter-item expanded \"><a href=\"glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Glossary</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Reference</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/edit/master/src/macro-ambiguity.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"appendix-macro-follow-set-ambiguity-formal-specification\"><a class=\"header\" href=\"#appendix-macro-follow-set-ambiguity-formal-specification\">Appendix: Macro Follow-Set Ambiguity Formal Specification</a></h1>\n<p>This page documents the formal specification of the follow rules for <a href=\"macros-by-example.html\">Macros\nBy Example</a>. They were originally specified in <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md\">RFC 550</a>, from which the bulk\nof this text is copied, and expanded upon in subsequent RFCs.</p>\n<h2 id=\"definitions--conventions\"><a class=\"header\" href=\"#definitions--conventions\">Definitions &amp; Conventions</a></h2>\n<ul>\n<li><code class=\"hljs\">macro</code>: anything invokable as <code class=\"hljs\">foo!(...)</code> in source code.</li>\n<li><code class=\"hljs\">MBE</code>: macro-by-example, a macro defined by <code class=\"hljs\">macro_rules</code>.</li>\n<li><code class=\"hljs\">matcher</code>: the left-hand-side of a rule in a <code class=\"hljs\">macro_rules</code> invocation, or a\nsubportion thereof.</li>\n<li><code class=\"hljs\">macro parser</code>: the bit of code in the Rust parser that will parse the\ninput using a grammar derived from all of the matchers.</li>\n<li><code class=\"hljs\">fragment</code>: The class of Rust syntax that a given matcher will accept (or\n\"match\").</li>\n<li><code class=\"hljs\">repetition</code> : a fragment that follows a regular repeating pattern</li>\n<li><code class=\"hljs\">NT</code>: non-terminal, the various \"meta-variables\" or repetition matchers\nthat can appear in a matcher, specified in MBE syntax with a leading <code class=\"hljs\">$</code>\ncharacter.</li>\n<li><code class=\"hljs\">simple NT</code>: a \"meta-variable\" non-terminal (further discussion below).</li>\n<li><code class=\"hljs\">complex NT</code>: a repetition matching non-terminal, specified via repetition\noperators (<code class=\"hljs\">*</code>, <code class=\"hljs\">+</code>, <code class=\"hljs\">?</code>).</li>\n<li><code class=\"hljs\">token</code>: an atomic element of a matcher; i.e. identifiers, operators,\nopen/close delimiters, <em>and</em> simple NT's.</li>\n<li><code class=\"hljs\">token tree</code>: a tree structure formed from tokens (the leaves), complex\nNT's, and finite sequences of token trees.</li>\n<li><code class=\"hljs\">delimiter token</code>: a token that is meant to divide the end of one fragment\nand the start of the next fragment.</li>\n<li><code class=\"hljs\">separator token</code>: an optional delimiter token in an complex NT that\nseparates each pair of elements in the matched repetition.</li>\n<li><code class=\"hljs\">separated complex NT</code>: a complex NT that has its own separator token.</li>\n<li><code class=\"hljs\">delimited sequence</code>: a sequence of token trees with appropriate open- and\nclose-delimiters at the start and end of the sequence.</li>\n<li><code class=\"hljs\">empty fragment</code>: The class of invisible Rust syntax that separates tokens,\ni.e. whitespace, or (in some lexical contexts), the empty token sequence.</li>\n<li><code class=\"hljs\">fragment specifier</code>: The identifier in a simple NT that specifies which\nfragment the NT accepts.</li>\n<li><code class=\"hljs\">language</code>: a context-free language.</li>\n</ul>\n<p>Example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-built_in\">macro_rules!</span> i_am_an_mbe {\n    (start $foo:expr $($i:ident),* end) =&gt; ($foo)\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p><code class=\"hljs\">(start $foo:expr $($i:ident),* end)</code> is a matcher. The whole matcher is a\ndelimited sequence (with open- and close-delimiters <code class=\"hljs\">(</code> and <code class=\"hljs\">)</code>), and <code class=\"hljs\">$foo</code>\nand <code class=\"hljs\">$i</code> are simple NT's with <code class=\"hljs\">expr</code> and <code class=\"hljs\">ident</code> as their respective fragment\nspecifiers.</p>\n<p><code class=\"hljs\">$(i:ident),*</code> is <em>also</em> an NT; it is a complex NT that matches a\ncomma-separated repetition of identifiers. The <code class=\"hljs\">,</code> is the separator token for\nthe complex NT; it occurs in between each pair of elements (if any) of the\nmatched fragment.</p>\n<p>Another example of a complex NT is <code class=\"hljs\">$(hi $e:expr ;)+</code>, which matches any\nfragment of the form <code class=\"hljs\">hi &lt;expr&gt;; hi &lt;expr&gt;; ...</code> where <code class=\"hljs\">hi &lt;expr&gt;;</code> occurs at\nleast once. Note that this complex NT does not have a dedicated separator\ntoken.</p>\n<p>(Note that Rust's parser ensures that delimited sequences always occur with\nproper nesting of token tree structure and correct matching of open- and\nclose-delimiters.)</p>\n<p>We will tend to use the variable \"M\" to stand for a matcher, variables \"t\" and\n\"u\" for arbitrary individual tokens, and the variables \"tt\" and \"uu\" for\narbitrary token trees. (The use of \"tt\" does present potential ambiguity with\nits additional role as a fragment specifier; but it will be clear from context\nwhich interpretation is meant.)</p>\n<p>\"SEP\" will range over separator tokens, \"OP\" over the repetition operators\n<code class=\"hljs\">*</code>, <code class=\"hljs\">+</code>, and <code class=\"hljs\">?</code>, \"OPEN\"/\"CLOSE\" over matching token pairs surrounding a\ndelimited sequence (e.g. <code class=\"hljs\">[</code> and <code class=\"hljs\">]</code>).</p>\n<p>Greek letters \"α\" \"β\" \"γ\" \"δ\"  stand for potentially empty token-tree sequences.\n(However, the Greek letter \"ε\" (epsilon) has a special role in the presentation\nand does not stand for a token-tree sequence.)</p>\n<ul>\n<li>This Greek letter convention is usually just employed when the presence of\na sequence is a technical detail; in particular, when we wish to <em>emphasize</em>\nthat we are operating on a sequence of token-trees, we will use the notation\n\"tt ...\" for the sequence, not a Greek letter.</li>\n</ul>\n<p>Note that a matcher is merely a token tree. A \"simple NT\", as mentioned above,\nis an meta-variable NT; thus it is a non-repetition. For example, <code class=\"hljs\">$foo:ty</code> is\na simple NT but <code class=\"hljs\">$($foo:ty)+</code> is a complex NT.</p>\n<p>Note also that in the context of this formalism, the term \"token\" generally\n<em>includes</em> simple NTs.</p>\n<p>Finally, it is useful for the reader to keep in mind that according to the\ndefinitions of this formalism, no simple NT matches the empty fragment, and\nlikewise no token matches the empty fragment of Rust syntax. (Thus, the <em>only</em>\nNT that can match the empty fragment is a complex NT.) This is not actually\ntrue, because the <code class=\"hljs\">vis</code> matcher can match an empty fragment. Thus, for the\npurposes of the formalism, we will treat <code class=\"hljs\">$v:vis</code> as actually being\n<code class=\"hljs\">$($v:vis)?</code>, with a requirement that the matcher match an empty fragment.</p>\n<h3 id=\"the-matcher-invariants\"><a class=\"header\" href=\"#the-matcher-invariants\">The Matcher Invariants</a></h3>\n<p>To be valid, a matcher must meet the following three invariants. The definitions\nof FIRST and FOLLOW are described later.</p>\n<ol>\n<li>For any two successive token tree sequences in a matcher <code class=\"hljs\">M</code> (i.e. <code class=\"hljs\">M = ... tt uu ...</code>) with <code class=\"hljs\">uu ...</code> nonempty, we must have FOLLOW(<code class=\"hljs\">... tt</code>) ∪ {ε} ⊇\nFIRST(<code class=\"hljs\">uu ...</code>).</li>\n<li>For any separated complex NT in a matcher, <code class=\"hljs\">M = ... $(tt ...) SEP OP ...</code>,\nwe must have <code class=\"hljs\">SEP</code> ∈ FOLLOW(<code class=\"hljs\">tt ...</code>).</li>\n<li>For an unseparated complex NT in a matcher, <code class=\"hljs\">M = ... $(tt ...) OP ...</code>, if\nOP = <code class=\"hljs\">*</code> or <code class=\"hljs\">+</code>, we must have FOLLOW(<code class=\"hljs\">tt ...</code>) ⊇ FIRST(<code class=\"hljs\">tt ...</code>).</li>\n</ol>\n<p>The first invariant says that whatever actual token that comes after a matcher,\nif any, must be somewhere in the predetermined follow set.  This ensures that a\nlegal macro definition will continue to assign the same determination as to\nwhere <code class=\"hljs\">... tt</code> ends and <code class=\"hljs\">uu ...</code> begins, even as new syntactic forms are added\nto the language.</p>\n<p>The second invariant says that a separated complex NT must use a separator token\nthat is part of the predetermined follow set for the internal contents of the\nNT. This ensures that a legal macro definition will continue to parse an input\nfragment into the same delimited sequence of <code class=\"hljs\">tt ...</code>'s, even as new syntactic\nforms are added to the language.</p>\n<p>The third invariant says that when we have a complex NT that can match two or\nmore copies of the same thing with no separation in between, it must be\npermissible for them to be placed next to each other as per the first invariant.\nThis invariant also requires they be nonempty, which eliminates a possible\nambiguity.</p>\n<p><strong>NOTE: The third invariant is currently unenforced due to historical oversight\nand significant reliance on the behaviour. It is currently undecided what to do\nabout this going forward. Macros that do not respect the behaviour may become\ninvalid in a future edition of Rust. See the <a href=\"https://github.com/rust-lang/rust/issues/56575\">tracking issue</a>.</strong></p>\n<h3 id=\"first-and-follow-informally\"><a class=\"header\" href=\"#first-and-follow-informally\">FIRST and FOLLOW, informally</a></h3>\n<p>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</p>\n<p>Each of the three sets is made up of tokens. FIRST(M) and LAST(M) may also\ncontain a distinguished non-token element ε (\"epsilon\"), which indicates that M\ncan match the empty fragment. (But FOLLOW(M) is always just a set of tokens.)</p>\n<p>Informally:</p>\n<ul>\n<li>\n<p>FIRST(M): collects the tokens potentially used first when matching a\nfragment to M.</p>\n</li>\n<li>\n<p>LAST(M): collects the tokens potentially used last when matching a fragment\nto M.</p>\n</li>\n<li>\n<p>FOLLOW(M): the set of tokens allowed to follow immediately after some\nfragment matched by M.</p>\n<p>In other words: t ∈ FOLLOW(M) if and only if there exists (potentially\nempty) token sequences α, β, γ, δ where:</p>\n<ul>\n<li>\n<p>M matches β,</p>\n</li>\n<li>\n<p>t matches γ, and</p>\n</li>\n<li>\n<p>The concatenation α β γ δ is a parseable Rust program.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple\nNTs). For example, if any token is legal after a matcher M, then FOLLOW(M) =\nANYTOKEN.</p>\n<p>(To review one's understanding of the above informal descriptions, the reader\nat this point may want to jump ahead to the <a href=\"#examples-of-first-and-last\">examples of\nFIRST/LAST</a> before reading their formal\ndefinitions.)</p>\n<h3 id=\"first-last\"><a class=\"header\" href=\"#first-last\">FIRST, LAST</a></h3>\n<p>Below are formal inductive definitions for FIRST and LAST.</p>\n<p>\"A ∪ B\" denotes set union, \"A ∩ B\" denotes set intersection, and \"A \\ B\"\ndenotes set difference (i.e. all elements of A that are not present in B).</p>\n<h4 id=\"first\"><a class=\"header\" href=\"#first\">FIRST</a></h4>\n<p>FIRST(M) is defined by case analysis on the sequence M and the structure of its\nfirst token-tree (if any):</p>\n<ul>\n<li>\n<p>if M is the empty sequence, then FIRST(M) = { ε },</p>\n</li>\n<li>\n<p>if M starts with a token t, then FIRST(M) = { t },</p>\n<p>(Note: this covers the case where M starts with a delimited token-tree\nsequence, <code class=\"hljs\">M = OPEN tt ... CLOSE ...</code>, in which case <code class=\"hljs\">t = OPEN</code> and thus\nFIRST(M) = { <code class=\"hljs\">OPEN</code> }.)</p>\n<p>(Note: this critically relies on the property that no simple NT matches the\nempty fragment.)</p>\n</li>\n<li>\n<p>Otherwise, M is a token-tree sequence starting with a complex NT: <code class=\"hljs\">M = $( tt ... ) OP α</code>, or <code class=\"hljs\">M = $( tt ... ) SEP OP α</code>, (where <code class=\"hljs\">α</code> is the (potentially\nempty) sequence of token trees for the rest of the matcher).</p>\n<ul>\n<li>Let SEP_SET(M) = { SEP } if SEP is present and ε ∈ FIRST(<code class=\"hljs\">tt ...</code>);\notherwise SEP_SET(M) = {}.</li>\n</ul>\n</li>\n<li>\n<p>Let ALPHA_SET(M) = FIRST(<code class=\"hljs\">α</code>) if OP = <code class=\"hljs\">*</code> or <code class=\"hljs\">?</code> and ALPHA_SET(M) = {} if\nOP = <code class=\"hljs\">+</code>.</p>\n</li>\n<li>\n<p>FIRST(M) = (FIRST(<code class=\"hljs\">tt ...</code>) \\ {ε}) ∪ SEP_SET(M) ∪ ALPHA_SET(M).</p>\n</li>\n</ul>\n<p>The definition for complex NTs deserves some justification. SEP_SET(M) defines\nthe possibility that the separator could be a valid first token for M, which\nhappens when there is a separator defined and the repeated fragment could be\nempty. ALPHA_SET(M) defines the possibility that the complex NT could be empty,\nmeaning that M's valid first tokens are those of the following token-tree\nsequences <code class=\"hljs\">α</code>. This occurs when either <code class=\"hljs\">*</code> or <code class=\"hljs\">?</code> is used, in which case there\ncould be zero repetitions. In theory, this could also occur if <code class=\"hljs\">+</code> was used with\na potentially-empty repeating fragment, but this is forbidden by the third\ninvariant.</p>\n<p>From there, clearly FIRST(M) can include any token from SEP_SET(M) or\nALPHA_SET(M), and if the complex NT match is nonempty, then any token starting\nFIRST(<code class=\"hljs\">tt ...</code>) could work too. The last piece to consider is ε. SEP_SET(M) and\nFIRST(<code class=\"hljs\">tt ...</code>) \\ {ε} cannot contain ε, but ALPHA_SET(M) could. Hence, this\ndefinition allows M to accept ε if and only if ε ∈ ALPHA_SET(M) does. This is\ncorrect because for M to accept ε in the complex NT case, both the complex NT\nand α must accept it. If OP = <code class=\"hljs\">+</code>, meaning that the complex NT cannot be empty,\nthen by definition ε ∉ ALPHA_SET(M). Otherwise, the complex NT can accept zero\nrepetitions, and then ALPHA_SET(M) = FOLLOW(<code class=\"hljs\">α</code>). So this definition is correct\nwith respect to \\varepsilon as well.</p>\n<h4 id=\"last\"><a class=\"header\" href=\"#last\">LAST</a></h4>\n<p>LAST(M), defined by case analysis on M itself (a sequence of token-trees):</p>\n<ul>\n<li>\n<p>if M is the empty sequence, then LAST(M) = { ε }</p>\n</li>\n<li>\n<p>if M is a singleton token t, then LAST(M) = { t }</p>\n</li>\n<li>\n<p>if M is the singleton complex NT repeating zero or more times, <code class=\"hljs\">M = $( tt ... ) *</code>, or <code class=\"hljs\">M = $( tt ... ) SEP *</code></p>\n<ul>\n<li>\n<p>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</p>\n</li>\n<li>\n<p>if ε ∈ LAST(<code class=\"hljs\">tt ...</code>) then LAST(M) = LAST(<code class=\"hljs\">tt ...</code>) ∪ sep_set</p>\n</li>\n<li>\n<p>otherwise, the sequence <code class=\"hljs\">tt ...</code> must be non-empty; LAST(M) = LAST(<code class=\"hljs\">tt ...</code>) ∪ {ε}.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>if M is the singleton complex NT repeating one or more times, <code class=\"hljs\">M = $( tt ... ) +</code>, or <code class=\"hljs\">M = $( tt ... ) SEP +</code></p>\n<ul>\n<li>\n<p>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</p>\n</li>\n<li>\n<p>if ε ∈ LAST(<code class=\"hljs\">tt ...</code>) then LAST(M) = LAST(<code class=\"hljs\">tt ...</code>) ∪ sep_set</p>\n</li>\n<li>\n<p>otherwise, the sequence <code class=\"hljs\">tt ...</code> must be non-empty; LAST(M) = LAST(<code class=\"hljs\">tt ...</code>)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>if M is the singleton complex NT repeating zero or one time, <code class=\"hljs\">M = $( tt ...) ?</code>, then LAST(M) = LAST(<code class=\"hljs\">tt ...</code>) ∪ {ε}.</p>\n</li>\n<li>\n<p>if M is a delimited token-tree sequence <code class=\"hljs\">OPEN tt ... CLOSE</code>, then LAST(M) =\n{ <code class=\"hljs\">CLOSE</code> }.</p>\n</li>\n<li>\n<p>if M is a non-empty sequence of token-trees <code class=\"hljs\">tt uu ...</code>,</p>\n<ul>\n<li>\n<p>If ε ∈ LAST(<code class=\"hljs\">uu ...</code>), then LAST(M) = LAST(<code class=\"hljs\">tt</code>) ∪ (LAST(<code class=\"hljs\">uu ...</code>) \\ { ε }).</p>\n</li>\n<li>\n<p>Otherwise, the sequence <code class=\"hljs\">uu ...</code> must be non-empty; then LAST(M) =\nLAST(<code class=\"hljs\">uu ...</code>).</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"examples-of-first-and-last\"><a class=\"header\" href=\"#examples-of-first-and-last\">Examples of FIRST and LAST</a></h3>\n<p>Below are some examples of FIRST and LAST.\n(Note in particular how the special ε element is introduced and\neliminated based on the interaction between the pieces of the input.)</p>\n<p>Our first example is presented in a tree structure to elaborate on how\nthe analysis of the matcher composes. (Some of the simpler subtrees\nhave been elided.)</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n            ~~~~~~~~   ~~~~~~~                ~\n                |         |                   |\nFIRST:   { $d:ident }  { $e:expr }          { h }\n\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+\n            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~\n                        |                      |               |\nFIRST:          { $d:ident }               { h, ε }         { f }\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~\n                        |                       |              |       |\nFIRST:        { $d:ident, ε }            {  h, ε, ;  }      { f }   { g }\n\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                                        |\nFIRST:                       { $d:ident, h, ;,  f }\n</code></pre>\n<p>Thus:</p>\n<ul>\n<li>FIRST(<code class=\"hljs\">$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g</code>) = { <code class=\"hljs\">$d:ident</code>, <code class=\"hljs\">h</code>, <code class=\"hljs\">;</code>, <code class=\"hljs\">f</code> }</li>\n</ul>\n<p>Note however that:</p>\n<ul>\n<li>FIRST(<code class=\"hljs\">$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*</code>) = { <code class=\"hljs\">$d:ident</code>, <code class=\"hljs\">h</code>, <code class=\"hljs\">;</code>, <code class=\"hljs\">f</code>, ε }</li>\n</ul>\n<p>Here are similar examples but now for LAST.</p>\n<ul>\n<li>LAST(<code class=\"hljs\">$d:ident $e:expr</code>) = { <code class=\"hljs\">$e:expr</code> }</li>\n<li>LAST(<code class=\"hljs\">$( $d:ident $e:expr );*</code>) = { <code class=\"hljs\">$e:expr</code>, ε }</li>\n<li>LAST(<code class=\"hljs\">$( $d:ident $e:expr );* $(h)*</code>) = { <code class=\"hljs\">$e:expr</code>, ε, <code class=\"hljs\">h</code> }</li>\n<li>LAST(<code class=\"hljs\">$( $d:ident $e:expr );* $(h)* $( f ;)+</code>) = { <code class=\"hljs\">;</code> }</li>\n<li>LAST(<code class=\"hljs\">$( $d:ident $e:expr );* $(h)* $( f ;)+ g</code>) = { <code class=\"hljs\">g</code> }</li>\n</ul>\n<h3 id=\"followm\"><a class=\"header\" href=\"#followm\">FOLLOW(M)</a></h3>\n<p>Finally, the definition for FOLLOW(M) is built up as follows. pat, expr, etc.\nrepresent simple nonterminals with the given fragment specifier.</p>\n<ul>\n<li>\n<p>FOLLOW(pat) = {<code class=\"hljs\">=&gt;</code>, <code class=\"hljs\">,</code>, <code class=\"hljs\">=</code>, <code class=\"hljs\">|</code>, <code class=\"hljs\">if</code>, <code class=\"hljs\">in</code>}`.</p>\n</li>\n<li>\n<p>FOLLOW(expr) = FOLLOW(stmt) =  {<code class=\"hljs\">=&gt;</code>, <code class=\"hljs\">,</code>, <code class=\"hljs\">;</code>}`.</p>\n</li>\n<li>\n<p>FOLLOW(ty) = FOLLOW(path) = {<code class=\"hljs\">{</code>, <code class=\"hljs\">[</code>, <code class=\"hljs\">,</code>, <code class=\"hljs\">=&gt;</code>, <code class=\"hljs\">:</code>, <code class=\"hljs\">=</code>, <code class=\"hljs\">&gt;</code>, <code class=\"hljs\">&gt;&gt;</code>, <code class=\"hljs\">;</code>,\n<code class=\"hljs\">|</code>, <code class=\"hljs\">as</code>, <code class=\"hljs\">where</code>, block nonterminals}.</p>\n</li>\n<li>\n<p>FOLLOW(vis) = {<code class=\"hljs\">,</code>l any keyword or identifier except a non-raw <code class=\"hljs\">priv</code>; any\ntoken that can begin a type; ident, ty, and path nonterminals}.</p>\n</li>\n<li>\n<p>FOLLOW(t) = ANYTOKEN for any other simple token, including block, ident,\ntt, item, lifetime, literal and meta simple nonterminals, and all terminals.</p>\n</li>\n<li>\n<p>FOLLOW(M), for any other M, is defined as the intersection, as t ranges over\n(LAST(M) \\ {ε}), of FOLLOW(t).</p>\n</li>\n</ul>\n<p>The tokens that can begin a type are, as of this writing, {<code class=\"hljs\">(</code>, <code class=\"hljs\">[</code>, <code class=\"hljs\">!</code>, <code class=\"hljs\">*</code>,\n<code class=\"hljs\">&amp;</code>, <code class=\"hljs\">&amp;&amp;</code>, <code class=\"hljs\">?</code>, lifetimes, <code class=\"hljs\">&gt;</code>, <code class=\"hljs\">&gt;&gt;</code>, <code class=\"hljs\">::</code>, any non-keyword identifier, <code class=\"hljs\">super</code>,\n<code class=\"hljs\">self</code>, <code class=\"hljs\">Self</code>, <code class=\"hljs\">extern</code>, <code class=\"hljs\">crate</code>, <code class=\"hljs\">$crate</code>, <code class=\"hljs\">_</code>, <code class=\"hljs\">for</code>, <code class=\"hljs\">impl</code>, <code class=\"hljs\">fn</code>, <code class=\"hljs\">unsafe</code>,\n<code class=\"hljs\">typeof</code>, <code class=\"hljs\">dyn</code>}, although this list may not be complete because people won't\nalways remember to update the appendix when new ones are added.</p>\n<p>Examples of FOLLOW for complex M:</p>\n<ul>\n<li>FOLLOW(<code class=\"hljs\">$( $d:ident $e:expr )*</code>) = FOLLOW(<code class=\"hljs\">$e:expr</code>)</li>\n<li>FOLLOW(<code class=\"hljs\">$( $d:ident $e:expr )* $(;)*</code>) = FOLLOW(<code class=\"hljs\">$e:expr</code>) ∩ ANYTOKEN = FOLLOW(<code class=\"hljs\">$e:expr</code>)</li>\n<li>FOLLOW(<code class=\"hljs\">$( $d:ident $e:expr )* $(;)* $( f |)+</code>) = ANYTOKEN</li>\n</ul>\n<h3 id=\"examples-of-valid-and-invalid-matchers\"><a class=\"header\" href=\"#examples-of-valid-and-invalid-matchers\">Examples of valid and invalid matchers</a></h3>\n<p>With the above specification in hand, we can present arguments for\nwhy particular matchers are legal and others are not.</p>\n<ul>\n<li>\n<p><code class=\"hljs\">($ty:ty &lt; foo ,)</code> : illegal, because FIRST(<code class=\"hljs\">&lt; foo ,</code>) = { <code class=\"hljs\">&lt;</code> } ⊈ FOLLOW(<code class=\"hljs\">ty</code>)</p>\n</li>\n<li>\n<p><code class=\"hljs\">($ty:ty , foo &lt;)</code> : legal, because FIRST(<code class=\"hljs\">, foo &lt;</code>) = { <code class=\"hljs\">,</code> }  is ⊆ FOLLOW(<code class=\"hljs\">ty</code>).</p>\n</li>\n<li>\n<p><code class=\"hljs\">($pa:pat $pb:pat $ty:ty ,)</code> : illegal, because FIRST(<code class=\"hljs\">$pb:pat $ty:ty ,</code>) = { <code class=\"hljs\">$pb:pat</code> } ⊈ FOLLOW(<code class=\"hljs\">pat</code>), and also FIRST(<code class=\"hljs\">$ty:ty ,</code>) = { <code class=\"hljs\">$ty:ty</code> } ⊈ FOLLOW(<code class=\"hljs\">pat</code>).</p>\n</li>\n<li>\n<p><code class=\"hljs\">( $($a:tt $b:tt)* ; )</code> : legal, because FIRST(<code class=\"hljs\">$b:tt</code>) = { <code class=\"hljs\">$b:tt</code> } is ⊆ FOLLOW(<code class=\"hljs\">tt</code>) = ANYTOKEN, as is FIRST(<code class=\"hljs\">;</code>) = { <code class=\"hljs\">;</code> }.</p>\n</li>\n<li>\n<p><code class=\"hljs\">( $($t:tt),* , $(t:tt),* )</code> : legal,  (though any attempt to actually use this macro will signal a local ambiguity error during expansion).</p>\n</li>\n<li>\n<p><code class=\"hljs\">($ty:ty $(; not sep)* -)</code> : illegal, because FIRST(<code class=\"hljs\">$(; not sep)* -</code>) = { <code class=\"hljs\">;</code>, <code class=\"hljs\">-</code> } is not in FOLLOW(<code class=\"hljs\">ty</code>).</p>\n</li>\n<li>\n<p><code class=\"hljs\">($($ty:ty)-+)</code> : illegal, because separator <code class=\"hljs\">-</code> is not in FOLLOW(<code class=\"hljs\">ty</code>).</p>\n</li>\n<li>\n<p><code class=\"hljs\">($($e:expr)*)</code> : illegal, because expr NTs are not in FOLLOW(expr NT).</p>\n</li>\n</ul>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"appendices.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"influences.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"appendices.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"influences.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:13:36.176Z"
}