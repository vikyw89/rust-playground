{
	"title": "Leaking - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/leaking.html",
	"markdown": "# Leaking - The Rustonomicon\n\nOwnership-based resource management is intended to simplify composition. You acquire resources when you create the object, and you release the resources when it gets destroyed. Since destruction is handled for you, it means you can't forget to release the resources, and it happens as soon as possible! Surely this is perfect and all of our problems are solved.\n\nEverything is terrible and we have new and exotic problems to try to solve.\n\nMany people like to believe that Rust eliminates resource leaks. In practice, this is basically true. You would be surprised to see a Safe Rust program leak resources in an uncontrolled way.\n\nHowever from a theoretical perspective this is absolutely not the case, no matter how you look at it. In the strictest sense, \"leaking\" is so abstract as to be unpreventable. It's quite trivial to initialize a collection at the start of a program, fill it with tons of objects with destructors, and then enter an infinite event loop that never refers to it. The collection will sit around uselessly, holding on to its precious resources until the program terminates (at which point all those resources would have been reclaimed by the OS anyway).\n\nWe may consider a more restricted form of leak: failing to drop a value that is unreachable. Rust also doesn't prevent this. In fact Rust _has a function for doing this_: `mem::forget`. This function consumes the value it is passed _and then doesn't run its destructor_.\n\nIn the past `mem::forget` was marked as unsafe as a sort of lint against using it, since failing to call a destructor is generally not a well-behaved thing to do (though useful for some special unsafe code). However this was generally determined to be an untenable stance to take: there are many ways to fail to call a destructor in safe code. The most famous example is creating a cycle of reference-counted pointers using interior mutability.\n\nIt is reasonable for safe code to assume that destructor leaks do not happen, as any program that leaks destructors is probably wrong. However _unsafe_ code cannot rely on destructors to be run in order to be safe. For most types this doesn't matter: if you leak the destructor then the type is by definition inaccessible, so it doesn't matter, right? For instance, if you leak a `Box<u8>` then you waste some memory but that's hardly going to violate memory-safety.\n\nHowever where we must be careful with destructor leaks are _proxy_ types. These are types which manage access to a distinct object, but don't actually own it. Proxy objects are quite rare. Proxy objects you'll need to care about are even rarer. However we'll focus on three interesting examples in the standard library:\n\n-   `vec::Drain`\n-   `Rc`\n-   `thread::scoped::JoinGuard`\n\n## [Drain](#drain)\n\n`drain` is a collections API that moves data out of the container without consuming the container. This enables us to reuse the allocation of a `Vec` after claiming ownership over all of its contents. It produces an iterator (Drain) that returns the contents of the Vec by-value.\n\nNow, consider Drain in the middle of iteration: some values have been moved out, and others haven't. This means that part of the Vec is now full of logically uninitialized data! We could backshift all the elements in the Vec every time we remove a value, but this would have pretty catastrophic performance consequences.\n\nInstead, we would like Drain to fix the Vec's backing storage when it is dropped. It should run itself to completion, backshift any elements that weren't removed (drain supports subranges), and then fix Vec's `len`. It's even unwinding-safe! Easy!\n\nNow consider the following:\n\n```rust\nlet mut vec = vec![Box::new(0); 4];\n\n{\n    // start draining, vec can no longer be accessed\n    let mut drainer = vec.drain(..);\n\n    // pull out two elements and immediately drop them\n    drainer.next();\n    drainer.next();\n\n    // get rid of drainer, but don't call its destructor\n    mem::forget(drainer);\n}\n\n// Oops, vec[0] was dropped, we're reading a pointer into free'd memory!\nprintln!(\"{}\", vec[0]);\n```\n\nThis is pretty clearly Not Good. Unfortunately, we're kind of stuck between a rock and a hard place: maintaining consistent state at every step has an enormous cost (and would negate any benefits of the API). Failing to maintain consistent state gives us Undefined Behavior in safe code (making the API unsound).\n\nSo what can we do? Well, we can pick a trivially consistent state: set the Vec's len to be 0 when we start the iteration, and fix it up if necessary in the destructor. That way, if everything executes like normal we get the desired behavior with minimal overhead. But if someone has the _audacity_ to mem::forget us in the middle of the iteration, all that does is _leak even more_ (and possibly leave the Vec in an unexpected but otherwise consistent state). Since we've accepted that mem::forget is safe, this is definitely safe. We call leaks causing more leaks a _leak amplification_.\n\n## [Rc](#rc)\n\nRc is an interesting case because at first glance it doesn't appear to be a proxy value at all. After all, it manages the data it points to, and dropping all the Rcs for a value will drop that value. Leaking an Rc doesn't seem like it would be particularly dangerous. It will leave the refcount permanently incremented and prevent the data from being freed or dropped, but that seems just like Box, right?\n\nNope.\n\nLet's consider a simplified implementation of Rc:\n\n```rust\nstruct Rc<T> {\n    ptr: *mut RcBox<T>,\n}\n\nstruct RcBox<T> {\n    data: T,\n    ref_count: usize,\n}\n\nimpl<T> Rc<T> {\n    fn new(data: T) -> Self {\n        unsafe {\n            // Wouldn't it be nice if heap::allocate worked like this?\n            let ptr = heap::allocate::<RcBox<T>>();\n            ptr::write(ptr, RcBox {\n                data,\n                ref_count: 1,\n            });\n            Rc { ptr }\n        }\n    }\n\n    fn clone(&self) -> Self {\n        unsafe {\n            (*self.ptr).ref_count += 1;\n        }\n        Rc { ptr: self.ptr }\n    }\n}\n\nimpl<T> Drop for Rc<T> {\n    fn drop(&mut self) {\n        unsafe {\n            (*self.ptr).ref_count -= 1;\n            if (*self.ptr).ref_count == 0 {\n                // drop the data and then free it\n                ptr::read(self.ptr);\n                heap::deallocate(self.ptr);\n            }\n        }\n    }\n}\n```\n\nThis code contains an implicit and subtle assumption: `ref_count` can fit in a `usize`, because there can't be more than `usize::MAX` Rcs in memory. However this itself assumes that the `ref_count` accurately reflects the number of Rcs in memory, which we know is false with `mem::forget`. Using `mem::forget` we can overflow the `ref_count`, and then get it down to 0 with outstanding Rcs. Then we can happily use-after-free the inner data. Bad Bad Not Good.\n\nThis can be solved by just checking the `ref_count` and doing _something_. The standard library's stance is to just abort, because your program has become horribly degenerate. Also _oh my gosh_ it's such a ridiculous corner case.\n\n## [thread::scoped::JoinGuard](#threadscopedjoinguard)\n\n> Note: This API has already been removed from std, for more information you may refer [issue #24292](https://github.com/rust-lang/rust/issues/24292).\n> \n> This section remains here because we think this example is still important, regardless of whether it is part of std or not.\n\nThe thread::scoped API intended to allow threads to be spawned that reference data on their parent's stack without any synchronization over that data by ensuring the parent joins the thread before any of the shared data goes out of scope.\n\n```rust\npub fn scoped<'a, F>(f: F) -> JoinGuard<'a>\n    where F: FnOnce() + Send + 'a\n```\n\nHere `f` is some closure for the other thread to execute. Saying that `F: Send + 'a` is saying that it closes over data that lives for `'a`, and it either owns that data or the data was Sync (implying `&data` is Send).\n\nBecause JoinGuard has a lifetime, it keeps all the data it closes over borrowed in the parent thread. This means the JoinGuard can't outlive the data that the other thread is working on. When the JoinGuard _does_ get dropped it blocks the parent thread, ensuring the child terminates before any of the closed-over data goes out of scope in the parent.\n\nUsage looked like:\n\n```rust\nlet mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n{\n    let mut guards = vec![];\n    for x in &mut data {\n        // Move the mutable reference into the closure, and execute\n        // it on a different thread. The closure has a lifetime bound\n        // by the lifetime of the mutable reference `x` we store in it.\n        // The guard that is returned is in turn assigned the lifetime\n        // of the closure, so it also mutably borrows `data` as `x` did.\n        // This means we cannot access `data` until the guard goes away.\n        let guard = thread::scoped(move || {\n            *x *= 2;\n        });\n        // store the thread's guard for later\n        guards.push(guard);\n    }\n    // All guards are dropped here, forcing the threads to join\n    // (this thread blocks here until the others terminate).\n    // Once the threads join, the borrow expires and the data becomes\n    // accessible again in this thread.\n}\n// data is definitely mutated here.\n```\n\nIn principle, this totally works! Rust's ownership system perfectly ensures it! ...except it relies on a destructor being called to be safe.\n\n```rust\nlet mut data = Box::new(0);\n{\n    let guard = thread::scoped(|| {\n        // This is at best a data race. At worst, it's also a use-after-free.\n        *data += 1;\n    });\n    // Because the guard is forgotten, expiring the loan without blocking this\n    // thread.\n    mem::forget(guard);\n}\n// So the Box is dropped here while the scoped thread may or may not be trying\n// to access it.\n```\n\nDang. Here the destructor running was pretty fundamental to the API, and it had to be scrapped in favor of a completely different design.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Leaking - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"leaking\"><a class=\"header\" href=\"#leaking\">Leaking</a></h1>\n<p>Ownership-based resource management is intended to simplify composition. You\nacquire resources when you create the object, and you release the resources when\nit gets destroyed. Since destruction is handled for you, it means you can't\nforget to release the resources, and it happens as soon as possible! Surely this\nis perfect and all of our problems are solved.</p>\n<p>Everything is terrible and we have new and exotic problems to try to solve.</p>\n<p>Many people like to believe that Rust eliminates resource leaks. In practice,\nthis is basically true. You would be surprised to see a Safe Rust program\nleak resources in an uncontrolled way.</p>\n<p>However from a theoretical perspective this is absolutely not the case, no\nmatter how you look at it. In the strictest sense, \"leaking\" is so abstract as\nto be unpreventable. It's quite trivial to initialize a collection at the start\nof a program, fill it with tons of objects with destructors, and then enter an\ninfinite event loop that never refers to it. The collection will sit around\nuselessly, holding on to its precious resources until the program terminates (at\nwhich point all those resources would have been reclaimed by the OS anyway).</p>\n<p>We may consider a more restricted form of leak: failing to drop a value that is\nunreachable. Rust also doesn't prevent this. In fact Rust <em>has a function for\ndoing this</em>: <code class=\"hljs\">mem::forget</code>. This function consumes the value it is passed <em>and\nthen doesn't run its destructor</em>.</p>\n<p>In the past <code class=\"hljs\">mem::forget</code> was marked as unsafe as a sort of lint against using\nit, since failing to call a destructor is generally not a well-behaved thing to\ndo (though useful for some special unsafe code). However this was generally\ndetermined to be an untenable stance to take: there are many ways to fail to\ncall a destructor in safe code. The most famous example is creating a cycle of\nreference-counted pointers using interior mutability.</p>\n<p>It is reasonable for safe code to assume that destructor leaks do not happen, as\nany program that leaks destructors is probably wrong. However <em>unsafe</em> code\ncannot rely on destructors to be run in order to be safe. For most types this\ndoesn't matter: if you leak the destructor then the type is by definition\ninaccessible, so it doesn't matter, right? For instance, if you leak a <code class=\"hljs\">Box&lt;u8&gt;</code>\nthen you waste some memory but that's hardly going to violate memory-safety.</p>\n<p>However where we must be careful with destructor leaks are <em>proxy</em> types. These\nare types which manage access to a distinct object, but don't actually own it.\nProxy objects are quite rare. Proxy objects you'll need to care about are even\nrarer. However we'll focus on three interesting examples in the standard\nlibrary:</p>\n<ul>\n<li><code class=\"hljs\">vec::Drain</code></li>\n<li><code class=\"hljs\">Rc</code></li>\n<li><code class=\"hljs\">thread::scoped::JoinGuard</code></li>\n</ul>\n<h2 id=\"drain\"><a class=\"header\" href=\"#drain\">Drain</a></h2>\n<p><code class=\"hljs\">drain</code> is a collections API that moves data out of the container without\nconsuming the container. This enables us to reuse the allocation of a <code class=\"hljs\">Vec</code>\nafter claiming ownership over all of its contents. It produces an iterator\n(Drain) that returns the contents of the Vec by-value.</p>\n<p>Now, consider Drain in the middle of iteration: some values have been moved out,\nand others haven't. This means that part of the Vec is now full of logically\nuninitialized data! We could backshift all the elements in the Vec every time we\nremove a value, but this would have pretty catastrophic performance\nconsequences.</p>\n<p>Instead, we would like Drain to fix the Vec's backing storage when it is\ndropped. It should run itself to completion, backshift any elements that weren't\nremoved (drain supports subranges), and then fix Vec's <code class=\"hljs\">len</code>. It's even\nunwinding-safe! Easy!</p>\n<p>Now consider the following:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> vec = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">0</span>); <span class=\"hljs-number\">4</span>];\n\n{\n    <span class=\"hljs-comment\">// start draining, vec can no longer be accessed</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> drainer = vec.drain(..);\n\n    <span class=\"hljs-comment\">// pull out two elements and immediately drop them</span>\n    drainer.next();\n    drainer.next();\n\n    <span class=\"hljs-comment\">// get rid of drainer, but don't call its destructor</span>\n    mem::forget(drainer);\n}\n\n<span class=\"hljs-comment\">// Oops, vec[0] was dropped, we're reading a pointer into free'd memory!</span>\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, vec[<span class=\"hljs-number\">0</span>]);</code></pre>\n<p>This is pretty clearly Not Good. Unfortunately, we're kind of stuck between a\nrock and a hard place: maintaining consistent state at every step has an\nenormous cost (and would negate any benefits of the API). Failing to maintain\nconsistent state gives us Undefined Behavior in safe code (making the API\nunsound).</p>\n<p>So what can we do? Well, we can pick a trivially consistent state: set the Vec's\nlen to be 0 when we start the iteration, and fix it up if necessary in the\ndestructor. That way, if everything executes like normal we get the desired\nbehavior with minimal overhead. But if someone has the <em>audacity</em> to\nmem::forget us in the middle of the iteration, all that does is <em>leak even more</em>\n(and possibly leave the Vec in an unexpected but otherwise consistent state).\nSince we've accepted that mem::forget is safe, this is definitely safe. We call\nleaks causing more leaks a <em>leak amplification</em>.</p>\n<h2 id=\"rc\"><a class=\"header\" href=\"#rc\">Rc</a></h2>\n<p>Rc is an interesting case because at first glance it doesn't appear to be a\nproxy value at all. After all, it manages the data it points to, and dropping\nall the Rcs for a value will drop that value. Leaking an Rc doesn't seem like it\nwould be particularly dangerous. It will leave the refcount permanently\nincremented and prevent the data from being freed or dropped, but that seems\njust like Box, right?</p>\n<p>Nope.</p>\n<p>Let's consider a simplified implementation of Rc:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rc</span></span>&lt;T&gt; {\n    ptr: *<span class=\"hljs-keyword\">mut</span> RcBox&lt;T&gt;,\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RcBox</span></span>&lt;T&gt; {\n    data: T,\n    ref_count: <span class=\"hljs-built_in\">usize</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; Rc&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(data: T) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-comment\">// Wouldn't it be nice if heap::allocate worked like this?</span>\n            <span class=\"hljs-keyword\">let</span> ptr = heap::allocate::&lt;RcBox&lt;T&gt;&gt;();\n            ptr::write(ptr, RcBox {\n                data,\n                ref_count: <span class=\"hljs-number\">1</span>,\n            });\n            Rc { ptr }\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">clone</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            (*<span class=\"hljs-keyword\">self</span>.ptr).ref_count += <span class=\"hljs-number\">1</span>;\n        }\n        Rc { ptr: <span class=\"hljs-keyword\">self</span>.ptr }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Rc&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            (*<span class=\"hljs-keyword\">self</span>.ptr).ref_count -= <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-keyword\">if</span> (*<span class=\"hljs-keyword\">self</span>.ptr).ref_count == <span class=\"hljs-number\">0</span> {\n                <span class=\"hljs-comment\">// drop the data and then free it</span>\n                ptr::read(<span class=\"hljs-keyword\">self</span>.ptr);\n                heap::deallocate(<span class=\"hljs-keyword\">self</span>.ptr);\n            }\n        }\n    }\n}</code></pre>\n<p>This code contains an implicit and subtle assumption: <code class=\"hljs\">ref_count</code> can fit in a\n<code class=\"hljs\">usize</code>, because there can't be more than <code class=\"hljs\">usize::MAX</code> Rcs in memory. However\nthis itself assumes that the <code class=\"hljs\">ref_count</code> accurately reflects the number of Rcs\nin memory, which we know is false with <code class=\"hljs\">mem::forget</code>. Using <code class=\"hljs\">mem::forget</code> we can\noverflow the <code class=\"hljs\">ref_count</code>, and then get it down to 0 with outstanding Rcs. Then\nwe can happily use-after-free the inner data. Bad Bad Not Good.</p>\n<p>This can be solved by just checking the <code class=\"hljs\">ref_count</code> and doing <em>something</em>. The\nstandard library's stance is to just abort, because your program has become\nhorribly degenerate. Also <em>oh my gosh</em> it's such a ridiculous corner case.</p>\n<h2 id=\"threadscopedjoinguard\"><a class=\"header\" href=\"#threadscopedjoinguard\">thread::scoped::JoinGuard</a></h2>\n<blockquote>\n<p>Note: This API has already been removed from std, for more information\nyou may refer <a href=\"https://github.com/rust-lang/rust/issues/24292\">issue #24292</a>.</p>\n<p>This section remains here because we think this example is still\nimportant, regardless of whether it is part of std or not.</p>\n</blockquote>\n<p>The thread::scoped API intended to allow threads to be spawned that reference\ndata on their parent's stack without any synchronization over that data by\nensuring the parent joins the thread before any of the shared data goes out\nof scope.</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">scoped</span></span>&lt;<span class=\"hljs-symbol\">'a</span>, F&gt;(f: F) -&gt; JoinGuard&lt;<span class=\"hljs-symbol\">'a</span>&gt;\n    <span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'a</span></code></pre>\n<p>Here <code class=\"hljs\">f</code> is some closure for the other thread to execute. Saying that\n<code class=\"hljs\">F: Send + 'a</code> is saying that it closes over data that lives for <code class=\"hljs\">'a</code>, and it\neither owns that data or the data was Sync (implying <code class=\"hljs\">&amp;data</code> is Send).</p>\n<p>Because JoinGuard has a lifetime, it keeps all the data it closes over\nborrowed in the parent thread. This means the JoinGuard can't outlive\nthe data that the other thread is working on. When the JoinGuard <em>does</em> get\ndropped it blocks the parent thread, ensuring the child terminates before any\nof the closed-over data goes out of scope in the parent.</p>\n<p>Usage looked like:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> data = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>];\n{\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> guards = <span class=\"hljs-built_in\">vec!</span>[];\n    <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> data {\n        <span class=\"hljs-comment\">// Move the mutable reference into the closure, and execute</span>\n        <span class=\"hljs-comment\">// it on a different thread. The closure has a lifetime bound</span>\n        <span class=\"hljs-comment\">// by the lifetime of the mutable reference `x` we store in it.</span>\n        <span class=\"hljs-comment\">// The guard that is returned is in turn assigned the lifetime</span>\n        <span class=\"hljs-comment\">// of the closure, so it also mutably borrows `data` as `x` did.</span>\n        <span class=\"hljs-comment\">// This means we cannot access `data` until the guard goes away.</span>\n        <span class=\"hljs-keyword\">let</span> guard = thread::scoped(<span class=\"hljs-keyword\">move</span> || {\n            *x *= <span class=\"hljs-number\">2</span>;\n        });\n        <span class=\"hljs-comment\">// store the thread's guard for later</span>\n        guards.push(guard);\n    }\n    <span class=\"hljs-comment\">// All guards are dropped here, forcing the threads to join</span>\n    <span class=\"hljs-comment\">// (this thread blocks here until the others terminate).</span>\n    <span class=\"hljs-comment\">// Once the threads join, the borrow expires and the data becomes</span>\n    <span class=\"hljs-comment\">// accessible again in this thread.</span>\n}\n<span class=\"hljs-comment\">// data is definitely mutated here.</span></code></pre>\n<p>In principle, this totally works! Rust's ownership system perfectly ensures it!\n...except it relies on a destructor being called to be safe.</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> data = <span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">0</span>);\n{\n    <span class=\"hljs-keyword\">let</span> guard = thread::scoped(|| {\n        <span class=\"hljs-comment\">// This is at best a data race. At worst, it's also a use-after-free.</span>\n        *data += <span class=\"hljs-number\">1</span>;\n    });\n    <span class=\"hljs-comment\">// Because the guard is forgotten, expiring the loan without blocking this</span>\n    <span class=\"hljs-comment\">// thread.</span>\n    mem::forget(guard);\n}\n<span class=\"hljs-comment\">// So the Box is dropped here while the scoped thread may or may not be trying</span>\n<span class=\"hljs-comment\">// to access it.</span></code></pre>\n<p>Dang. Here the destructor running was pretty fundamental to the API, and it had\nto be scrapped in favor of a completely different design.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"destructors.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"unwinding.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"destructors.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"unwinding.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:09.116Z"
}