{
	"title": "MaybeUninit in std::mem - Rust",
	"url": "https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html",
	"markdown": "# MaybeUninit in std::mem - Rust\n\n```\npub union MaybeUninit<T> {\n    /* private fields */\n}\n```\n\nExpand description\n\nA wrapper type to construct uninitialized instances of `T`.\n\n## [§](#initialization-invariant)Initialization invariant\n\nThe compiler, in general, assumes that a variable is properly initialized according to the requirements of the variable’s type. For example, a variable of reference type must be aligned and non-null. This is an invariant that must _always_ be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous [undefined behavior](../../reference/behavior-considered-undefined.html), no matter whether that reference ever gets used to access memory:\n\n```\nuse std::mem::{self, MaybeUninit};\n\nlet x: &i32 = unsafe { mem::zeroed() }; // undefined behavior! ⚠️\n// The equivalent code with `MaybeUninit<&i32>`:\nlet x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior! ⚠️\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7Bself,+MaybeUninit%7D;%0A++++%0A++++let+x:+%26i32+=+unsafe+%7B+mem::zeroed()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A++++//+The+equivalent+code+with+%60MaybeUninit%3C%26i32%3E%60:%0A++++let+x:+%26i32+=+unsafe+%7B+MaybeUninit::zeroed().assume_init()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A%7D&edition=2021)\n\nThis is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing `enum` layout.\n\nSimilarly, entirely uninitialized memory may have any content, while a `bool` must always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n\n```\nuse std::mem::{self, MaybeUninit};\n\nlet b: bool = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️\n// The equivalent code with `MaybeUninit<bool>`:\nlet b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! ⚠️\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7Bself,+MaybeUninit%7D;%0A++++%0A++++let+b:+bool+=+unsafe+%7B+mem::uninitialized()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A++++//+The+equivalent+code+with+%60MaybeUninit%3Cbool%3E%60:%0A++++let+b:+bool+=+unsafe+%7B+MaybeUninit::uninit().assume_init()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A%7D&edition=2021)\n\nMoreover, uninitialized memory is special in that it does not have a fixed value (“fixed” meaning “it won’t change without being written to”). Reading the same uninitialized byte multiple times can give different results. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type, which otherwise can hold any _fixed_ bit pattern:\n\n```\nuse std::mem::{self, MaybeUninit};\n\nlet x: i32 = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️\n// The equivalent code with `MaybeUninit<i32>`:\nlet x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! ⚠️\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7Bself,+MaybeUninit%7D;%0A++++%0A++++let+x:+i32+=+unsafe+%7B+mem::uninitialized()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A++++//+The+equivalent+code+with+%60MaybeUninit%3Ci32%3E%60:%0A++++let+x:+i32+=+unsafe+%7B+MaybeUninit::uninit().assume_init()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A%7D&edition=2021)\n\nOn top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a `1`\\-initialized [`Vec<T>`](../../std/vec/struct.Vec.html) is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause _immediate_ undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).\n\n## [§](#examples)Examples\n\n`MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data. It is a signal to the compiler indicating that the data here might _not_ be initialized:\n\n```\nuse std::mem::MaybeUninit;\n\n// Create an explicitly uninitialized reference. The compiler knows that data inside\n// a `MaybeUninit<T>` may be invalid, and hence this is not UB:\nlet mut x = MaybeUninit::<&i32>::uninit();\n// Set it to a valid value.\nx.write(&0);\n// Extract the initialized data -- this is only allowed *after* properly\n// initializing `x`!\nlet x = unsafe { x.assume_init() };\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++//+Create+an+explicitly+uninitialized+reference.+The+compiler+knows+that+data+inside%0A++++//+a+%60MaybeUninit%3CT%3E%60+may+be+invalid,+and+hence+this+is+not+UB:%0A++++let+mut+x+=+MaybeUninit::%3C%26i32%3E::uninit();%0A++++//+Set+it+to+a+valid+value.%0A++++x.write(%260);%0A++++//+Extract+the+initialized+data+--+this+is+only+allowed+*after*+properly%0A++++//+initializing+%60x%60!%0A++++let+x+=+unsafe+%7B+x.assume_init()+%7D;%0A%7D&edition=2021)\n\nThe compiler then knows to not make any incorrect assumptions or optimizations on this code.\n\nYou can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without any of the run-time tracking and without any of the safety checks.\n\n### [§](#out-pointers)out-pointers\n\nYou can use `MaybeUninit<T>` to implement “out-pointers”: instead of returning data from a function, pass it a pointer to some (uninitialized) memory to put the result into. This can be useful when it is important for the caller to control how the memory the result is stored in gets allocated, and you want to avoid unnecessary moves.\n\n```\nuse std::mem::MaybeUninit;\n\nunsafe fn make_vec(out: *mut Vec<i32>) {\n    // `write` does not drop the old contents, which is important.\n    out.write(vec![1, 2, 3]);\n}\n\nlet mut v = MaybeUninit::uninit();\nunsafe { make_vec(v.as_mut_ptr()); }\n// Now we know `v` is initialized! This also makes sure the vector gets\n// properly dropped.\nlet v = unsafe { v.assume_init() };\nassert_eq!(&v, &[1, 2, 3]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++unsafe+fn+make_vec(out:+*mut+Vec%3Ci32%3E)+%7B%0A++++++++//+%60write%60+does+not+drop+the+old+contents,+which+is+important.%0A++++++++out.write(vec!%5B1,+2,+3%5D);%0A++++%7D%0A++++%0A++++let+mut+v+=+MaybeUninit::uninit();%0A++++unsafe+%7B+make_vec(v.as_mut_ptr());+%7D%0A++++//+Now+we+know+%60v%60+is+initialized!+This+also+makes+sure+the+vector+gets%0A++++//+properly+dropped.%0A++++let+v+=+unsafe+%7B+v.assume_init()+%7D;%0A++++assert_eq!(%26v,+%26%5B1,+2,+3%5D);%0A%7D&edition=2021)\n\n### [§](#initializing-an-array-element-by-element)Initializing an array element-by-element\n\n`MaybeUninit<T>` can be used to initialize a large array element-by-element:\n\n```\nuse std::mem::{self, MaybeUninit};\n\nlet data = {\n    // Create an uninitialized array of `MaybeUninit`.\n    let mut data: [MaybeUninit<Vec<u32>>; 1000] = [const { MaybeUninit::uninit() }; 1000];\n\n    // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n    // we have a memory leak, but there is no memory safety issue.\n    for elem in &mut data[..] {\n        elem.write(vec![42]);\n    }\n\n    // Everything is initialized. Transmute the array to the\n    // initialized type.\n    unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n};\n\nassert_eq!(&data[0], &[42]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7Bself,+MaybeUninit%7D;%0A++++%0A++++let+data+=+%7B%0A++++++++//+Create+an+uninitialized+array+of+%60MaybeUninit%60.%0A++++++++let+mut+data:+%5BMaybeUninit%3CVec%3Cu32%3E%3E;+1000%5D+=+%5Bconst+%7B+MaybeUninit::uninit()+%7D;+1000%5D;%0A++++%0A++++++++//+Dropping+a+%60MaybeUninit%60+does+nothing,+so+if+there+is+a+panic+during+this+loop,%0A++++++++//+we+have+a+memory+leak,+but+there+is+no+memory+safety+issue.%0A++++++++for+elem+in+%26mut+data%5B..%5D+%7B%0A++++++++++++elem.write(vec!%5B42%5D);%0A++++++++%7D%0A++++%0A++++++++//+Everything+is+initialized.+Transmute+the+array+to+the%0A++++++++//+initialized+type.%0A++++++++unsafe+%7B+mem::transmute::%3C_,+%5BVec%3Cu32%3E;+1000%5D%3E(data)+%7D%0A++++%7D;%0A++++%0A++++assert_eq!(%26data%5B0%5D,+%26%5B42%5D);%0A%7D&edition=2021)\n\nYou can also work with partially initialized arrays, which could be found in low-level datastructures.\n\n```\nuse std::mem::MaybeUninit;\n\n// Create an uninitialized array of `MaybeUninit`.\nlet mut data: [MaybeUninit<String>; 1000] = [const { MaybeUninit::uninit() }; 1000];\n// Count the number of elements we have assigned.\nlet mut data_len: usize = 0;\n\nfor elem in &mut data[0..500] {\n    elem.write(String::from(\"hello\"));\n    data_len += 1;\n}\n\n// For each item in the array, drop if we allocated it.\nfor elem in &mut data[0..data_len] {\n    unsafe { elem.assume_init_drop(); }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++//+Create+an+uninitialized+array+of+%60MaybeUninit%60.%0A++++let+mut+data:+%5BMaybeUninit%3CString%3E;+1000%5D+=+%5Bconst+%7B+MaybeUninit::uninit()+%7D;+1000%5D;%0A++++//+Count+the+number+of+elements+we+have+assigned.%0A++++let+mut+data_len:+usize+=+0;%0A++++%0A++++for+elem+in+%26mut+data%5B0..500%5D+%7B%0A++++++++elem.write(String::from(%22hello%22));%0A++++++++data_len+%2B=+1;%0A++++%7D%0A++++%0A++++//+For+each+item+in+the+array,+drop+if+we+allocated+it.%0A++++for+elem+in+%26mut+data%5B0..data_len%5D+%7B%0A++++++++unsafe+%7B+elem.assume_init_drop();+%7D%0A++++%7D%0A%7D&edition=2021)\n\n### [§](#initializing-a-struct-field-by-field)Initializing a struct field-by-field\n\nYou can use `MaybeUninit<T>`, and the [`std::ptr::addr_of_mut`](../ptr/macro.addr_of_mut.html \"macro std::ptr::addr_of_mut\") macro, to initialize structs field by field:\n\n```\nuse std::mem::MaybeUninit;\nuse std::ptr::addr_of_mut;\n\n#[derive(Debug, PartialEq)]\npub struct Foo {\n    name: String,\n    list: Vec<u8>,\n}\n\nlet foo = {\n    let mut uninit: MaybeUninit<Foo> = MaybeUninit::uninit();\n    let ptr = uninit.as_mut_ptr();\n\n    // Initializing the `name` field\n    // Using `write` instead of assignment via `=` to not call `drop` on the\n    // old, uninitialized value.\n    unsafe { addr_of_mut!((*ptr).name).write(\"Bob\".to_string()); }\n\n    // Initializing the `list` field\n    // If there is a panic here, then the `String` in the `name` field leaks.\n    unsafe { addr_of_mut!((*ptr).list).write(vec![0, 1, 2]); }\n\n    // All the fields are initialized, so we call `assume_init` to get an initialized Foo.\n    unsafe { uninit.assume_init() }\n};\n\nassert_eq!(\n    foo,\n    Foo {\n        name: \"Bob\".to_string(),\n        list: vec![0, 1, 2]\n    }\n);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++use+std::ptr::addr_of_mut;%0A++++%0A++++%23%5Bderive(Debug,+PartialEq)%5D%0A++++pub+struct+Foo+%7B%0A++++++++name:+String,%0A++++++++list:+Vec%3Cu8%3E,%0A++++%7D%0A++++%0A++++let+foo+=+%7B%0A++++++++let+mut+uninit:+MaybeUninit%3CFoo%3E+=+MaybeUninit::uninit();%0A++++++++let+ptr+=+uninit.as_mut_ptr();%0A++++%0A++++++++//+Initializing+the+%60name%60+field%0A++++++++//+Using+%60write%60+instead+of+assignment+via+%60=%60+to+not+call+%60drop%60+on+the%0A++++++++//+old,+uninitialized+value.%0A++++++++unsafe+%7B+addr_of_mut!((*ptr).name).write(%22Bob%22.to_string());+%7D%0A++++%0A++++++++//+Initializing+the+%60list%60+field%0A++++++++//+If+there+is+a+panic+here,+then+the+%60String%60+in+the+%60name%60+field+leaks.%0A++++++++unsafe+%7B+addr_of_mut!((*ptr).list).write(vec!%5B0,+1,+2%5D);+%7D%0A++++%0A++++++++//+All+the+fields+are+initialized,+so+we+call+%60assume_init%60+to+get+an+initialized+Foo.%0A++++++++unsafe+%7B+uninit.assume_init()+%7D%0A++++%7D;%0A++++%0A++++assert_eq!(%0A++++++++foo,%0A++++++++Foo+%7B%0A++++++++++++name:+%22Bob%22.to_string(),%0A++++++++++++list:+vec!%5B0,+1,+2%5D%0A++++++++%7D%0A++++);%0A%7D&edition=2021)\n\n## [§](#layout-1)Layout\n\n`MaybeUninit<T>` is guaranteed to have the same size, alignment, and ABI as `T`:\n\n```\nuse std::mem::{MaybeUninit, size_of, align_of};\nassert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\nassert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7BMaybeUninit,+size_of,+align_of%7D;%0A++++assert_eq!(size_of::%3CMaybeUninit%3Cu64%3E%3E(),+size_of::%3Cu64%3E());%0A++++assert_eq!(align_of::%3CMaybeUninit%3Cu64%3E%3E(),+align_of::%3Cu64%3E());%0A%7D&edition=2021)\n\nHowever remember that a type _containing_ a `MaybeUninit<T>` is not necessarily the same layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit value is valid for a `MaybeUninit<T>` the compiler can’t apply non-zero/niche-filling optimizations, potentially resulting in a larger size:\n\n```\nassert_eq!(size_of::<Option<bool>>(), 1);\nassert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7BMaybeUninit,+size_of%7D;%0A++++assert_eq!(size_of::%3COption%3Cbool%3E%3E(),+1);%0A++++assert_eq!(size_of::%3COption%3CMaybeUninit%3Cbool%3E%3E%3E(),+2);%0A%7D&edition=2021)\n\nIf `T` is FFI-safe, then so is `MaybeUninit<T>`.\n\nWhile `MaybeUninit` is `#[repr(transparent)]` (indicating it guarantees the same size, alignment, and ABI as `T`), this does _not_ change any of the previous caveats. `Option<T>` and `Option<MaybeUninit<T>>` may still have different sizes, and types containing a field of type `T` may be laid out (and sized) differently than if that field were `MaybeUninit<T>`. `MaybeUninit` is a union type, and `#[repr(transparent)]` on unions is unstable (see [the tracking issue](https://github.com/rust-lang/rust/issues/60405)). Over time, the exact guarantees of `#[repr(transparent)]` on unions may evolve, and `MaybeUninit` may or may not remain `#[repr(transparent)]`. That said, `MaybeUninit<T>` will _always_ guarantee that it has the same size, alignment, and ABI as `T`; it’s just that the way `MaybeUninit` implements that guarantee may evolve.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#835)[§](#impl-Box%3CMaybeUninit%3CT%3E,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#866)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConverts to `Box<T, A>`.\n\n##### [§](#safety)Safety\n\nAs with [`MaybeUninit::assume_init`](about:blank/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\"), it is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.\n\n##### [§](#examples-1)Examples\n\n```\n#![feature(new_uninit)]\n\nlet mut five = Box::<u32>::new_uninit();\n\nlet five: Box<u32> = unsafe {\n    // Deferred initialization:\n    five.as_mut_ptr().write(5);\n\n    five.assume_init()\n};\n\nassert_eq!(*five, 5)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++let+mut+five+=+Box::%3Cu32%3E::new_uninit();%0A++++%0A++++let+five:+Box%3Cu32%3E+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++five.as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#900)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nWrites the value and converts to `Box<T, A>`.\n\nThis method converts the box similarly to [`Box::assume_init`](about:blank/boxed/struct.Box.html#method.assume_init \"method std::boxed::Box::assume_init\") but writes `value` into it before conversion thus guaranteeing safety. In some scenarios use of this method may improve performance because the compiler may be able to optimize copying from stack.\n\n##### [§](#examples-2)Examples\n\n```\n#![feature(new_uninit)]\n\nlet big_box = Box::<[usize; 1024]>::new_uninit();\n\nlet mut array = [0; 1024];\nfor (i, place) in array.iter_mut().enumerate() {\n    *place = i;\n}\n\n// The optimizer may be able to elide this copy, so previous code writes\n// to heap directly.\nlet big_box = Box::write(big_box, array);\n\nfor (i, x) in big_box.iter().enumerate() {\n    assert_eq!(*x, i);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++let+big_box+=+Box::%3C%5Busize;+1024%5D%3E::new_uninit();%0A++++%0A++++let+mut+array+=+%5B0;+1024%5D;%0A++++for+(i,+place)+in+array.iter_mut().enumerate()+%7B%0A++++++++*place+=+i;%0A++++%7D%0A++++%0A++++//+The+optimizer+may+be+able+to+elide+this+copy,+so+previous+code+writes%0A++++//+to+heap+directly.%0A++++let+big_box+=+Box::write(big_box,+array);%0A++++%0A++++for+(i,+x)+in+big_box.iter().enumerate()+%7B%0A++++++++assert_eq!(*x,+i);%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#264)[§](#impl-MaybeUninit%3CT%3E)\n\n1.36.0 (const: 1.36.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#284)\n\nCreates a new `MaybeUninit<T>` initialized with the given value. It is safe to call [`assume_init`](about:blank/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\") on the return value of this function.\n\nNote that dropping a `MaybeUninit<T>` will never call `T`’s drop code. It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n##### [§](#example)Example\n\n```\nuse std::mem::MaybeUninit;\n\nlet v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+v:+MaybeUninit%3CVec%3Cu8%3E%3E+=+MaybeUninit::new(vec!%5B42%5D);%0A%7D&edition=2021)\n\n1.36.0 (const: 1.36.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#307)\n\nCreates a new `MaybeUninit<T>` in an uninitialized state.\n\nNote that dropping a `MaybeUninit<T>` will never call `T`’s drop code. It is your responsibility to make sure `T` gets dropped if it got initialized.\n\nSee the [type-level documentation](union.MaybeUninit.html \"union std::mem::MaybeUninit\") for some examples.\n\n##### [§](#example-1)Example\n\n```\nuse std::mem::MaybeUninit;\n\nlet v: MaybeUninit<String> = MaybeUninit::uninit();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+v:+MaybeUninit%3CString%3E+=+MaybeUninit::uninit();%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#344)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_uninit_array` [#96097](https://github.com/rust-lang/rust/issues/96097))\n\nCreate a new array of `MaybeUninit<T>` items, in an uninitialized state.\n\nNote: in a future Rust version this method may become unnecessary when Rust allows [inline const expressions](https://github.com/rust-lang/rust/issues/76001). The example below could then use `let mut buf = [const { MaybeUninit::<u8>::uninit() }; 32];`.\n\n##### [§](#examples-3)Examples\n\n```\n#![feature(maybe_uninit_uninit_array, maybe_uninit_slice)]\n\nuse std::mem::MaybeUninit;\n\nextern \"C\" {\n    fn read_into_buffer(ptr: *mut u8, max_len: usize) -> usize;\n}\n\n/// Returns a (possibly smaller) slice of data that was actually read\nfn read(buf: &mut [MaybeUninit<u8>]) -> &[u8] {\n    unsafe {\n        let len = read_into_buffer(buf.as_mut_ptr() as *mut u8, buf.len());\n        MaybeUninit::slice_assume_init_ref(&buf[..len])\n    }\n}\n\nlet mut buf: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\nlet data = read(&mut buf);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array,+maybe_uninit_slice)%5D%0A%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++extern+%22C%22+%7B%0A++++++++fn+read_into_buffer(ptr:+*mut+u8,+max_len:+usize)+-%3E+usize;%0A++++%7D%0A++++%0A++++///+Returns+a+(possibly+smaller)+slice+of+data+that+was+actually+read%0A++++fn+read(buf:+%26mut+%5BMaybeUninit%3Cu8%3E%5D)+-%3E+%26%5Bu8%5D+%7B%0A++++++++unsafe+%7B%0A++++++++++++let+len+=+read_into_buffer(buf.as_mut_ptr()+as+*mut+u8,+buf.len());%0A++++++++++++MaybeUninit::slice_assume_init_ref(%26buf%5B..len%5D)%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+mut+buf:+%5BMaybeUninit%3Cu8%3E;+32%5D+=+MaybeUninit::uninit_array();%0A++++let+data+=+read(%26mut+buf);%0A%7D&version=nightly&edition=2021)\n\n1.36.0 (const: 1.75.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#395)\n\nCreates a new `MaybeUninit<T>` in an uninitialized state, with the memory being filled with `0` bytes. It depends on `T` whether that already makes for proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized, but `MaybeUninit<&'static i32>::zeroed()` is not because references must not be null.\n\nNote that dropping a `MaybeUninit<T>` will never call `T`’s drop code. It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n##### [§](#example-2)Example\n\nCorrect usage of this function: initializing a struct with zero, where all fields of the struct can hold the bit-pattern 0 as a valid value.\n\n```\nuse std::mem::MaybeUninit;\n\nlet x = MaybeUninit::<(u8, bool)>::zeroed();\nlet x = unsafe { x.assume_init() };\nassert_eq!(x, (0, false));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+x+=+MaybeUninit::%3C(u8,+bool)%3E::zeroed();%0A++++let+x+=+unsafe+%7B+x.assume_init()+%7D;%0A++++assert_eq!(x,+(0,+false));%0A%7D&edition=2021)\n\nThis can be used in const contexts, such as to indicate the end of static arrays for plugin registration.\n\n_Incorrect_ usage of this function: calling `x.zeroed().assume_init()` when `0` is not a valid bit-pattern for the type:\n\n```\nuse std::mem::MaybeUninit;\n\nenum NotZero { One = 1, Two = 2 }\n\nlet x = MaybeUninit::<(u8, NotZero)>::zeroed();\nlet x = unsafe { x.assume_init() };\n// Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n// This is undefined behavior. ⚠️\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++enum+NotZero+%7B+One+=+1,+Two+=+2+%7D%0A++++%0A++++let+x+=+MaybeUninit::%3C(u8,+NotZero)%3E::zeroed();%0A++++let+x+=+unsafe+%7B+x.assume_init()+%7D;%0A++++//+Inside+a+pair,+we+create+a+%60NotZero%60+that+does+not+have+a+valid+discriminant.%0A++++//+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&edition=2021)\n\n1.55.0 (const: [unstable](https://github.com/rust-lang/rust/issues/63567 \"Tracking issue for const_maybe_uninit_write\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#486)\n\nSets the value of the `MaybeUninit<T>`.\n\nThis overwrites any previous value without dropping it, so be careful not to use this twice unless you want to skip running the destructor. For your convenience, this also returns a mutable reference to the (now safely initialized) contents of `self`.\n\nAs the content is stored inside a `MaybeUninit`, the destructor is not run for the inner data if the MaybeUninit leaves scope without a call to [`assume_init`](about:blank/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\"), [`assume_init_drop`](about:blank/union.MaybeUninit.html#method.assume_init_drop \"method std::mem::MaybeUninit::assume_init_drop\"), or similar. Code that receives the mutable reference returned by this function needs to keep this in mind. The safety model of Rust regards leaks as safe, but they are usually still undesirable. This being said, the mutable reference behaves like any other mutable reference would, so assigning a new value to it will drop the old content.\n\n##### [§](#examples-4)Examples\n\nCorrect usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n{\n    let hello = x.write((&b\"Hello, world!\").to_vec());\n    // Setting hello does not leak prior allocations, but drops them\n    *hello = (&b\"Hello\").to_vec();\n    hello[0] = 'h' as u8;\n}\n// x is initialized now:\nlet s = unsafe { x.assume_init() };\nassert_eq!(b\"hello\", s.as_slice());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu8%3E%3E::uninit();%0A++++%0A++++%7B%0A++++++++let+hello+=+x.write((%26b%22Hello,+world!%22).to_vec());%0A++++++++//+Setting+hello+does+not+leak+prior+allocations,+but+drops+them%0A++++++++*hello+=+(%26b%22Hello%22).to_vec();%0A++++++++hello%5B0%5D+=+%27h%27+as+u8;%0A++++%7D%0A++++//+x+is+initialized+now:%0A++++let+s+=+unsafe+%7B+x.assume_init()+%7D;%0A++++assert_eq!(b%22hello%22,+s.as_slice());%0A%7D&edition=2021)\n\nThis usage of the method causes a leak:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut x = MaybeUninit::<String>::uninit();\n\nx.write(\"Hello\".to_string());\n// This leaks the contained string:\nx.write(\"hello\".to_string());\n// x is initialized now:\nlet s = unsafe { x.assume_init() };\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CString%3E::uninit();%0A++++%0A++++x.write(%22Hello%22.to_string());%0A++++//+This+leaks+the+contained+string:%0A++++x.write(%22hello%22.to_string());%0A++++//+x+is+initialized+now:%0A++++let+s+=+unsafe+%7B+x.assume_init()+%7D;%0A%7D&edition=2021)\n\nThis method can be used to avoid unsafe in some cases. The example below shows a part of an implementation of a fixed sized arena that lends out pinned references. With `write`, we can avoid the need to write through a raw pointer:\n\n```\nuse core::pin::Pin;\nuse core::mem::MaybeUninit;\n\nstruct PinArena<T> {\n    memory: Box<[MaybeUninit<T>]>,\n    len: usize,\n}\n\nimpl <T> PinArena<T> {\n    pub fn capacity(&self) -> usize {\n        self.memory.len()\n    }\n    pub fn push(&mut self, val: T) -> Pin<&mut T> {\n        if self.len >= self.capacity() {\n            panic!(\"Attempted to push to a full pin arena!\");\n        }\n        let ref_ = self.memory[self.len].write(val);\n        self.len += 1;\n        unsafe { Pin::new_unchecked(ref_) }\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+core::pin::Pin;%0A++++use+core::mem::MaybeUninit;%0A++++%0A++++struct+PinArena%3CT%3E+%7B%0A++++++++memory:+Box%3C%5BMaybeUninit%3CT%3E%5D%3E,%0A++++++++len:+usize,%0A++++%7D%0A++++%0A++++impl+%3CT%3E+PinArena%3CT%3E+%7B%0A++++++++pub+fn+capacity(%26self)+-%3E+usize+%7B%0A++++++++++++self.memory.len()%0A++++++++%7D%0A++++++++pub+fn+push(%26mut+self,+val:+T)+-%3E+Pin%3C%26mut+T%3E+%7B%0A++++++++++++if+self.len+%3E=+self.capacity()+%7B%0A++++++++++++++++panic!(%22Attempted+to+push+to+a+full+pin+arena!%22);%0A++++++++++++%7D%0A++++++++++++let+ref_+=+self.memory%5Bself.len%5D.write(val);%0A++++++++++++self.len+%2B=+1;%0A++++++++++++unsafe+%7B+Pin::new_unchecked(ref_)+%7D%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n1.36.0 (const: 1.59.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#526)\n\nGets a pointer to the contained value. Reading from this pointer or turning it into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized. Writing to memory that this pointer (non-transitively) points to is undefined behavior (except inside an `UnsafeCell<T>`).\n\n##### [§](#examples-5)Examples\n\nCorrect usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut x = MaybeUninit::<Vec<u32>>::uninit();\nx.write(vec![0, 1, 2]);\n// Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\nlet x_vec = unsafe { &*x.as_ptr() };\nassert_eq!(x_vec.len(), 3);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++x.write(vec!%5B0,+1,+2%5D);%0A++++//+Create+a+reference+into+the+%60MaybeUninit%3CT%3E%60.+This+is+okay+because+we+initialized+it.%0A++++let+x_vec+=+unsafe+%7B+%26*x.as_ptr()+%7D;%0A++++assert_eq!(x_vec.len(),+3);%0A%7D&edition=2021)\n\n_Incorrect_ usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet x = MaybeUninit::<Vec<u32>>::uninit();\nlet x_vec = unsafe { &*x.as_ptr() };\n// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++let+x_vec+=+unsafe+%7B+%26*x.as_ptr()+%7D;%0A++++//+We+have+created+a+reference+to+an+uninitialized+vector!+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&edition=2021)\n\n(Notice that the rules around references to uninitialized data are not finalized yet, but until they are, it is advisable to avoid them.)\n\n1.36.0 (const: [unstable](https://github.com/rust-lang/rust/issues/75251 \"Tracking issue for const_maybe_uninit_as_mut_ptr\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#565)\n\nGets a mutable pointer to the contained value. Reading from this pointer or turning it into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n\n##### [§](#examples-6)Examples\n\nCorrect usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut x = MaybeUninit::<Vec<u32>>::uninit();\nx.write(vec![0, 1, 2]);\n// Create a reference into the `MaybeUninit<Vec<u32>>`.\n// This is okay because we initialized it.\nlet x_vec = unsafe { &mut *x.as_mut_ptr() };\nx_vec.push(3);\nassert_eq!(x_vec.len(), 4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++x.write(vec!%5B0,+1,+2%5D);%0A++++//+Create+a+reference+into+the+%60MaybeUninit%3CVec%3Cu32%3E%3E%60.%0A++++//+This+is+okay+because+we+initialized+it.%0A++++let+x_vec+=+unsafe+%7B+%26mut+*x.as_mut_ptr()+%7D;%0A++++x_vec.push(3);%0A++++assert_eq!(x_vec.len(),+4);%0A%7D&edition=2021)\n\n_Incorrect_ usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut x = MaybeUninit::<Vec<u32>>::uninit();\nlet x_vec = unsafe { &mut *x.as_mut_ptr() };\n// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++let+x_vec+=+unsafe+%7B+%26mut+*x.as_mut_ptr()+%7D;%0A++++//+We+have+created+a+reference+to+an+uninitialized+vector!+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&edition=2021)\n\n(Notice that the rules around references to uninitialized data are not finalized yet, but until they are, it is advisable to avoid them.)\n\n1.36.0 (const: 1.59.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#620)\n\nExtracts the value from the `MaybeUninit<T>` container. This is a great way to ensure that the data will get dropped, because the resulting `T` is subject to the usual drop handling.\n\n##### [§](#safety-1)Safety\n\nIt is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior. The [type-level documentation](#initialization-invariant) contains more information about this initialization invariant.\n\nOn top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a `1`\\-initialized [`Vec<T>`](../../std/vec/struct.Vec.html) is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause _immediate_ undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).\n\n##### [§](#examples-7)Examples\n\nCorrect usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut x = MaybeUninit::<bool>::uninit();\nx.write(true);\nlet x_init = unsafe { x.assume_init() };\nassert_eq!(x_init, true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3Cbool%3E::uninit();%0A++++x.write(true);%0A++++let+x_init+=+unsafe+%7B+x.assume_init()+%7D;%0A++++assert_eq!(x_init,+true);%0A%7D&edition=2021)\n\n_Incorrect_ usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet x = MaybeUninit::<Vec<u32>>::uninit();\nlet x_init = unsafe { x.assume_init() };\n// `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++let+x_init+=+unsafe+%7B+x.assume_init()+%7D;%0A++++//+%60x%60+had+not+been+initialized+yet,+so+this+last+line+caused+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&edition=2021)\n\n1.60.0 (const: 1.75.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#690)\n\nReads the value from the `MaybeUninit<T>` container. The resulting `T` is subject to the usual drop handling.\n\nWhenever possible, it is preferable to use [`assume_init`](about:blank/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\") instead, which prevents duplicating the content of the `MaybeUninit<T>`.\n\n##### [§](#safety-2)Safety\n\nIt is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior. The [type-level documentation](#initialization-invariant) contains more information about this initialization invariant.\n\nMoreover, similar to the [`ptr::read`](../ptr/fn.read.html \"fn std::ptr::read\") function, this function creates a bitwise copy of the contents, regardless whether the contained type implements the [`Copy`](../marker/trait.Copy.html \"trait std::marker::Copy\") trait or not. When using multiple copies of the data (by calling `assume_init_read` multiple times, or first calling `assume_init_read` and then [`assume_init`](about:blank/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\")), it is your responsibility to ensure that data may indeed be duplicated.\n\n##### [§](#examples-8)Examples\n\nCorrect usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut x = MaybeUninit::<u32>::uninit();\nx.write(13);\nlet x1 = unsafe { x.assume_init_read() };\n// `u32` is `Copy`, so we may read multiple times.\nlet x2 = unsafe { x.assume_init_read() };\nassert_eq!(x1, x2);\n\nlet mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\nx.write(None);\nlet x1 = unsafe { x.assume_init_read() };\n// Duplicating a `None` value is okay, so we may read multiple times.\nlet x2 = unsafe { x.assume_init_read() };\nassert_eq!(x1, x2);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3Cu32%3E::uninit();%0A++++x.write(13);%0A++++let+x1+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++//+%60u32%60+is+%60Copy%60,+so+we+may+read+multiple+times.%0A++++let+x2+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++assert_eq!(x1,+x2);%0A++++%0A++++let+mut+x+=+MaybeUninit::%3COption%3CVec%3Cu32%3E%3E%3E::uninit();%0A++++x.write(None);%0A++++let+x1+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++//+Duplicating+a+%60None%60+value+is+okay,+so+we+may+read+multiple+times.%0A++++let+x2+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++assert_eq!(x1,+x2);%0A%7D&edition=2021)\n\n_Incorrect_ usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\nx.write(Some(vec![0, 1, 2]));\nlet x1 = unsafe { x.assume_init_read() };\nlet x2 = unsafe { x.assume_init_read() };\n// We now created two copies of the same vector, leading to a double-free ⚠️ when\n// they both get dropped!\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3COption%3CVec%3Cu32%3E%3E%3E::uninit();%0A++++x.write(Some(vec!%5B0,+1,+2%5D));%0A++++let+x1+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++let+x2+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++//+We+now+created+two+copies+of+the+same+vector,+leading+to+a+double-free+%E2%9A%A0%EF%B8%8F+when%0A++++//+they+both+get+dropped!%0A%7D&edition=2021)\n\n1.60.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#722)\n\nDrops the contained value in place.\n\nIf you have ownership of the `MaybeUninit`, you can also use [`assume_init`](about:blank/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\") as an alternative.\n\n##### [§](#safety-3)Safety\n\nIt is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior.\n\nOn top of that, all additional invariants of the type `T` must be satisfied, as the `Drop` implementation of `T` (or its members) may rely on this. For example, setting a [`Vec<T>`](../../std/vec/struct.Vec.html) to an invalid but non-null address makes it initialized (under the current implementation; this does not constitute a stable guarantee), because the only requirement the compiler knows about it is that the data pointer must be non-null. Dropping such a `Vec<T>` however will cause undefined behaviour.\n\n1.55.0 (const: 1.59.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#784)\n\nGets a shared reference to the contained value.\n\nThis can be useful when we want to access a `MaybeUninit` that has been initialized but don’t have ownership of the `MaybeUninit` (preventing the use of `.assume_init()`).\n\n##### [§](#safety-4)Safety\n\nCalling this when the content is not yet fully initialized causes undefined behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state.\n\n##### [§](#examples-9)Examples\n\n###### [§](#correct-usage-of-this-method)Correct usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut x = MaybeUninit::<Vec<u32>>::uninit();\n// Initialize `x`:\nx.write(vec![1, 2, 3]);\n// Now that our `MaybeUninit<_>` is known to be initialized, it is okay to\n// create a shared reference to it:\nlet x: &Vec<u32> = unsafe {\n    // SAFETY: `x` has been initialized.\n    x.assume_init_ref()\n};\nassert_eq!(x, &vec![1, 2, 3]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++//+Initialize+%60x%60:%0A++++x.write(vec!%5B1,+2,+3%5D);%0A++++//+Now+that+our+%60MaybeUninit%3C_%3E%60+is+known+to+be+initialized,+it+is+okay+to%0A++++//+create+a+shared+reference+to+it:%0A++++let+x:+%26Vec%3Cu32%3E+=+unsafe+%7B%0A++++++++//+SAFETY:+%60x%60+has+been+initialized.%0A++++++++x.assume_init_ref()%0A++++%7D;%0A++++assert_eq!(x,+%26vec!%5B1,+2,+3%5D);%0A%7D&edition=2021)\n\n###### [§](#incorrect-usages-of-this-method)_Incorrect_ usages of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nlet x = MaybeUninit::<Vec<u32>>::uninit();\nlet x_vec: &Vec<u32> = unsafe { x.assume_init_ref() };\n// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++let+x_vec:+%26Vec%3Cu32%3E+=+unsafe+%7B+x.assume_init_ref()+%7D;%0A++++//+We+have+created+a+reference+to+an+uninitialized+vector!+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&edition=2021)\n\n```\nuse std::{cell::Cell, mem::MaybeUninit};\n\nlet b = MaybeUninit::<Cell<bool>>::uninit();\n// Initialize the `MaybeUninit` using `Cell::set`:\nunsafe {\n    b.assume_init_ref().set(true);\n   // ^^^^^^^^^^^^^^^\n   // Reference to an uninitialized `Cell<bool>`: UB!\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bcell::Cell,+mem::MaybeUninit%7D;%0A++++%0A++++let+b+=+MaybeUninit::%3CCell%3Cbool%3E%3E::uninit();%0A++++//+Initialize+the+%60MaybeUninit%60+using+%60Cell::set%60:%0A++++unsafe+%7B%0A++++++++b.assume_init_ref().set(true);%0A+++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A+++++++//+Reference+to+an+uninitialized+%60Cell%3Cbool%3E%60:+UB!%0A++++%7D%0A%7D&edition=2021)\n\n1.55.0 (const: unstable) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#901)\n\nGets a mutable (unique) reference to the contained value.\n\nThis can be useful when we want to access a `MaybeUninit` that has been initialized but don’t have ownership of the `MaybeUninit` (preventing the use of `.assume_init()`).\n\n##### [§](#safety-5)Safety\n\nCalling this when the content is not yet fully initialized causes undefined behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state. For instance, `.assume_init_mut()` cannot be used to initialize a `MaybeUninit`.\n\n##### [§](#examples-10)Examples\n\n###### [§](#correct-usage-of-this-method-1)Correct usage of this method:\n\n```\nuse std::mem::MaybeUninit;\n\nextern \"C\" {\n    /// Initializes *all* the bytes of the input buffer.\n    fn initialize_buffer(buf: *mut [u8; 1024]);\n}\n\nlet mut buf = MaybeUninit::<[u8; 1024]>::uninit();\n\n// Initialize `buf`:\nunsafe { initialize_buffer(buf.as_mut_ptr()); }\n// Now we know that `buf` has been initialized, so we could `.assume_init()` it.\n// However, using `.assume_init()` may trigger a `memcpy` of the 1024 bytes.\n// To assert our buffer has been initialized without copying it, we upgrade\n// the `&mut MaybeUninit<[u8; 1024]>` to a `&mut [u8; 1024]`:\nlet buf: &mut [u8; 1024] = unsafe {\n    // SAFETY: `buf` has been initialized.\n    buf.assume_init_mut()\n};\n\n// Now we can use `buf` as a normal slice:\nbuf.sort_unstable();\nassert!(\n    buf.windows(2).all(|pair| pair[0] <= pair[1]),\n    \"buffer is sorted\",\n);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unexpected_cfgs)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++unsafe+extern+%22C%22+fn+initialize_buffer(buf:+*mut+%5Bu8;+1024%5D)+%7B+*buf+=+%5B0;+1024%5D+%7D%0A++++%23%5Bcfg(FALSE)%5D%0A++++extern+%22C%22+%7B%0A++++++++///+Initializes+*all*+the+bytes+of+the+input+buffer.%0A++++++++fn+initialize_buffer(buf:+*mut+%5Bu8;+1024%5D);%0A++++%7D%0A++++%0A++++let+mut+buf+=+MaybeUninit::%3C%5Bu8;+1024%5D%3E::uninit();%0A++++%0A++++//+Initialize+%60buf%60:%0A++++unsafe+%7B+initialize_buffer(buf.as_mut_ptr());+%7D%0A++++//+Now+we+know+that+%60buf%60+has+been+initialized,+so+we+could+%60.assume_init()%60+it.%0A++++//+However,+using+%60.assume_init()%60+may+trigger+a+%60memcpy%60+of+the+1024+bytes.%0A++++//+To+assert+our+buffer+has+been+initialized+without+copying+it,+we+upgrade%0A++++//+the+%60%26mut+MaybeUninit%3C%5Bu8;+1024%5D%3E%60+to+a+%60%26mut+%5Bu8;+1024%5D%60:%0A++++let+buf:+%26mut+%5Bu8;+1024%5D+=+unsafe+%7B%0A++++++++//+SAFETY:+%60buf%60+has+been+initialized.%0A++++++++buf.assume_init_mut()%0A++++%7D;%0A++++%0A++++//+Now+we+can+use+%60buf%60+as+a+normal+slice:%0A++++buf.sort_unstable();%0A++++assert!(%0A++++++++buf.windows(2).all(%7Cpair%7C+pair%5B0%5D+%3C=+pair%5B1%5D),%0A++++++++%22buffer+is+sorted%22,%0A++++);%0A%7D&edition=2021)\n\n###### [§](#incorrect-usages-of-this-method-1)_Incorrect_ usages of this method:\n\nYou cannot use `.assume_init_mut()` to initialize a value:\n\n```\nuse std::mem::MaybeUninit;\n\nlet mut b = MaybeUninit::<bool>::uninit();\nunsafe {\n    *b.assume_init_mut() = true;\n    // We have created a (mutable) reference to an uninitialized `bool`!\n    // This is undefined behavior. ⚠️\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+b+=+MaybeUninit::%3Cbool%3E::uninit();%0A++++unsafe+%7B%0A++++++++*b.assume_init_mut()+=+true;%0A++++++++//+We+have+created+a+(mutable)+reference+to+an+uninitialized+%60bool%60!%0A++++++++//+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A++++%7D%0A%7D&edition=2021)\n\nFor instance, you cannot [`Read`](../../std/io/trait.Read.html) into an uninitialized buffer:\n\n```\nuse std::{io, mem::MaybeUninit};\n\nfn read_chunk (reader: &'_ mut dyn io::Read) -> io::Result<[u8; 64]>\n{\n    let mut buffer = MaybeUninit::<[u8; 64]>::uninit();\n    reader.read_exact(unsafe { buffer.assume_init_mut() })?;\n                            // ^^^^^^^^^^^^^^^^^^^^^^^^\n                            // (mutable) reference to uninitialized memory!\n                            // This is undefined behavior.\n    Ok(unsafe { buffer.assume_init() })\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bio,+mem::MaybeUninit%7D;%0A++++%0A++++fn+read_chunk+(reader:+%26%27_+mut+dyn+io::Read)+-%3E+io::Result%3C%5Bu8;+64%5D%3E%0A++++%7B%0A++++++++let+mut+buffer+=+MaybeUninit::%3C%5Bu8;+64%5D%3E::uninit();%0A++++++++reader.read_exact(unsafe+%7B+buffer.assume_init_mut()+%7D)?;%0A++++++++++++++++++++++++++++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A++++++++++++++++++++++++++++++++//+(mutable)+reference+to+uninitialized+memory!%0A++++++++++++++++++++++++++++++++//+This+is+undefined+behavior.%0A++++++++Ok(unsafe+%7B+buffer.assume_init()+%7D)%0A++++%7D%0A%7D&edition=2021)\n\nNor can you use direct field access to do field-by-field gradual initialization:\n\n```\nuse std::{mem::MaybeUninit, ptr};\n\nstruct Foo {\n    a: u32,\n    b: u8,\n}\n\nlet foo: Foo = unsafe {\n    let mut foo = MaybeUninit::<Foo>::uninit();\n    ptr::write(&mut foo.assume_init_mut().a as *mut u32, 1337);\n                 // ^^^^^^^^^^^^^^^^^^^^^\n                 // (mutable) reference to uninitialized memory!\n                 // This is undefined behavior.\n    ptr::write(&mut foo.assume_init_mut().b as *mut u8, 42);\n                 // ^^^^^^^^^^^^^^^^^^^^^\n                 // (mutable) reference to uninitialized memory!\n                 // This is undefined behavior.\n    foo.assume_init()\n};\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bmem::MaybeUninit,+ptr%7D;%0A++++%0A++++struct+Foo+%7B%0A++++++++a:+u32,%0A++++++++b:+u8,%0A++++%7D%0A++++%0A++++let+foo:+Foo+=+unsafe+%7B%0A++++++++let+mut+foo+=+MaybeUninit::%3CFoo%3E::uninit();%0A++++++++ptr::write(%26mut+foo.assume_init_mut().a+as+*mut+u32,+1337);%0A+++++++++++++++++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A+++++++++++++++++++++//+(mutable)+reference+to+uninitialized+memory!%0A+++++++++++++++++++++//+This+is+undefined+behavior.%0A++++++++ptr::write(%26mut+foo.assume_init_mut().b+as+*mut+u8,+42);%0A+++++++++++++++++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A+++++++++++++++++++++//+(mutable)+reference+to+uninitialized+memory!%0A+++++++++++++++++++++//+This+is+undefined+behavior.%0A++++++++foo.assume_init()%0A++++%7D;%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#940)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_array_assume_init` [#96097](https://github.com/rust-lang/rust/issues/96097))\n\nExtracts the values from an array of `MaybeUninit` containers.\n\n##### [§](#safety-6)Safety\n\nIt is up to the caller to guarantee that all elements of the array are in an initialized state.\n\n##### [§](#examples-11)Examples\n\n```\n#![feature(maybe_uninit_uninit_array)]\n#![feature(maybe_uninit_array_assume_init)]\nuse std::mem::MaybeUninit;\n\nlet mut array: [MaybeUninit<i32>; 3] = MaybeUninit::uninit_array();\narray[0].write(0);\narray[1].write(1);\narray[2].write(2);\n\n// SAFETY: Now safe as we initialised all elements\nlet array = unsafe {\n    MaybeUninit::array_assume_init(array)\n};\n\nassert_eq!(array, [0, 1, 2]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array)%5D%0A%23!%5Bfeature(maybe_uninit_array_assume_init)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+array:+%5BMaybeUninit%3Ci32%3E;+3%5D+=+MaybeUninit::uninit_array();%0A++++array%5B0%5D.write(0);%0A++++array%5B1%5D.write(1);%0A++++array%5B2%5D.write(2);%0A++++%0A++++//+SAFETY:+Now+safe+as+we+initialised+all+elements%0A++++let+array+=+unsafe+%7B%0A++++++++MaybeUninit::array_assume_init(array)%0A++++%7D;%0A++++%0A++++assert_eq!(array,+%5B0,+1,+2%5D);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#966)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_slice` [#63569](https://github.com/rust-lang/rust/issues/63569))\n\nAssuming all the elements are initialized, get a slice to them.\n\n##### [§](#safety-7)Safety\n\nIt is up to the caller to guarantee that the `MaybeUninit<T>` elements really are in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior.\n\nSee [`assume_init_ref`](about:blank/union.MaybeUninit.html#method.assume_init_ref \"method std::mem::MaybeUninit::assume_init_ref\") for more details and examples.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#988)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_slice` [#63569](https://github.com/rust-lang/rust/issues/63569))\n\nAssuming all the elements are initialized, get a mutable slice to them.\n\n##### [§](#safety-8)Safety\n\nIt is up to the caller to guarantee that the `MaybeUninit<T>` elements really are in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior.\n\nSee [`assume_init_mut`](about:blank/union.MaybeUninit.html#method.assume_init_mut \"method std::mem::MaybeUninit::assume_init_mut\") for more details and examples.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#998)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_slice` [#63569](https://github.com/rust-lang/rust/issues/63569))\n\nGets a pointer to the first element of the array.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1006)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_slice` [#63569](https://github.com/rust-lang/rust/issues/63569))\n\nGets a mutable pointer to the first element of the array.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1054-1056)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_write_slice` [#79995](https://github.com/rust-lang/rust/issues/79995))\n\nCopies the elements from `src` to `this`, returning a mutable reference to the now initialized contents of `this`.\n\nIf `T` does not implement `Copy`, use [`clone_from_slice`](about:blank/union.MaybeUninit.html#method.clone_from_slice \"associated function std::mem::MaybeUninit::clone_from_slice\")\n\nThis is similar to [`slice::copy_from_slice`](about:blank/primitive.slice.html#method.copy_from_slice \"method slice::copy_from_slice\").\n\n##### [§](#panics)Panics\n\nThis function will panic if the two slices have different lengths.\n\n##### [§](#examples-12)Examples\n\n```\n#![feature(maybe_uninit_write_slice)]\nuse std::mem::MaybeUninit;\n\nlet mut dst = [MaybeUninit::uninit(); 32];\nlet src = [0; 32];\n\nlet init = MaybeUninit::copy_from_slice(&mut dst, &src);\n\nassert_eq!(init, src);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+dst+=+%5BMaybeUninit::uninit();+32%5D;%0A++++let+src+=+%5B0;+32%5D;%0A++++%0A++++let+init+=+MaybeUninit::copy_from_slice(%26mut+dst,+%26src);%0A++++%0A++++assert_eq!(init,+src);%0A%7D&version=nightly&edition=2021)\n\n```\n#![feature(maybe_uninit_write_slice)]\nuse std::mem::MaybeUninit;\n\nlet mut vec = Vec::with_capacity(32);\nlet src = [0; 16];\n\nMaybeUninit::copy_from_slice(&mut vec.spare_capacity_mut()[..src.len()], &src);\n\n// SAFETY: we have just copied all the elements of len into the spare capacity\n// the first src.len() elements of the vec are valid now.\nunsafe {\n    vec.set_len(src.len());\n}\n\nassert_eq!(vec, src);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+vec+=+Vec::with_capacity(32);%0A++++let+src+=+%5B0;+16%5D;%0A++++%0A++++MaybeUninit::copy_from_slice(%26mut+vec.spare_capacity_mut()%5B..src.len()%5D,+%26src);%0A++++%0A++++//+SAFETY:+we+have+just+copied+all+the+elements+of+len+into+the+spare+capacity%0A++++//+the+first+src.len()+elements+of+the+vec+are+valid+now.%0A++++unsafe+%7B%0A++++++++vec.set_len(src.len());%0A++++%7D%0A++++%0A++++assert_eq!(vec,+src);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1114-1116)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_write_slice` [#79995](https://github.com/rust-lang/rust/issues/79995))\n\nClones the elements from `src` to `this`, returning a mutable reference to the now initialized contents of `this`. Any already initialized elements will not be dropped.\n\nIf `T` implements `Copy`, use [`copy_from_slice`](about:blank/union.MaybeUninit.html#method.copy_from_slice \"associated function std::mem::MaybeUninit::copy_from_slice\")\n\nThis is similar to [`slice::clone_from_slice`](about:blank/primitive.slice.html#method.clone_from_slice \"method slice::clone_from_slice\") but does not drop existing elements.\n\n##### [§](#panics-1)Panics\n\nThis function will panic if the two slices have different lengths, or if the implementation of `Clone` panics.\n\nIf there is a panic, the already cloned elements will be dropped.\n\n##### [§](#examples-13)Examples\n\n```\n#![feature(maybe_uninit_write_slice)]\nuse std::mem::MaybeUninit;\n\nlet mut dst = [MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit()];\nlet src = [\"wibbly\".to_string(), \"wobbly\".to_string(), \"timey\".to_string(), \"wimey\".to_string(), \"stuff\".to_string()];\n\nlet init = MaybeUninit::clone_from_slice(&mut dst, &src);\n\nassert_eq!(init, src);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+dst+=+%5BMaybeUninit::uninit(),+MaybeUninit::uninit(),+MaybeUninit::uninit(),+MaybeUninit::uninit(),+MaybeUninit::uninit()%5D;%0A++++let+src+=+%5B%22wibbly%22.to_string(),+%22wobbly%22.to_string(),+%22timey%22.to_string(),+%22wimey%22.to_string(),+%22stuff%22.to_string()%5D;%0A++++%0A++++let+init+=+MaybeUninit::clone_from_slice(%26mut+dst,+%26src);%0A++++%0A++++assert_eq!(init,+src);%0A%7D&version=nightly&edition=2021)\n\n```\n#![feature(maybe_uninit_write_slice)]\nuse std::mem::MaybeUninit;\n\nlet mut vec = Vec::with_capacity(32);\nlet src = [\"rust\", \"is\", \"a\", \"pretty\", \"cool\", \"language\"];\n\nMaybeUninit::clone_from_slice(&mut vec.spare_capacity_mut()[..src.len()], &src);\n\n// SAFETY: we have just cloned all the elements of len into the spare capacity\n// the first src.len() elements of the vec are valid now.\nunsafe {\n    vec.set_len(src.len());\n}\n\nassert_eq!(vec, src);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+vec+=+Vec::with_capacity(32);%0A++++let+src+=+%5B%22rust%22,+%22is%22,+%22a%22,+%22pretty%22,+%22cool%22,+%22language%22%5D;%0A++++%0A++++MaybeUninit::clone_from_slice(%26mut+vec.spare_capacity_mut()%5B..src.len()%5D,+%26src);%0A++++%0A++++//+SAFETY:+we+have+just+cloned+all+the+elements+of+len+into+the+spare+capacity%0A++++//+the+first+src.len()+elements+of+the+vec+are+valid+now.%0A++++unsafe+%7B%0A++++++++vec.set_len(src.len());%0A++++%7D%0A++++%0A++++assert_eq!(vec,+src);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1168-1170)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_fill` [#117428](https://github.com/rust-lang/rust/issues/117428))\n\nFills `this` with elements by cloning `value`, returning a mutable reference to the now initialized contents of `this`. Any previously initialized elements will not be dropped.\n\nThis is similar to [`slice::fill`](about:blank/primitive.slice.html#method.fill \"method slice::fill\").\n\n##### [§](#panics-2)Panics\n\nThis function will panic if any call to `Clone` panics.\n\nIf such a panic occurs, any elements previously initialized during this operation will be dropped.\n\n##### [§](#examples-14)Examples\n\nFill an uninit vec with 1.\n\n```\n#![feature(maybe_uninit_fill)]\nuse std::mem::MaybeUninit;\n\nlet mut buf = vec![MaybeUninit::uninit(); 10];\nlet initialized = MaybeUninit::fill(buf.as_mut_slice(), 1);\nassert_eq!(initialized, &mut [1; 10]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_fill)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+buf+=+vec!%5BMaybeUninit::uninit();+10%5D;%0A++++let+initialized+=+MaybeUninit::fill(buf.as_mut_slice(),+1);%0A++++assert_eq!(initialized,+%26mut+%5B1;+10%5D);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1202-1204)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_fill` [#117428](https://github.com/rust-lang/rust/issues/117428))\n\nFills `this` with elements returned by calling a closure repeatedly.\n\nThis method uses a closure to create new values. If you’d rather `Clone` a given value, use [`MaybeUninit::fill`](about:blank/union.MaybeUninit.html#method.fill \"associated function std::mem::MaybeUninit::fill\"). If you want to use the `Default` trait to generate values, you can pass [`Default::default`](about:blank/default/trait.Default.html#tymethod.default \"associated function std::default::Default::default\") as the argument.\n\n##### [§](#panics-3)Panics\n\nThis function will panic if any call to the provided closure panics.\n\nIf such a panic occurs, any elements previously initialized during this operation will be dropped.\n\n##### [§](#examples-15)Examples\n\nFill an uninit vec with the default value.\n\n```\n#![feature(maybe_uninit_fill)]\nuse std::mem::MaybeUninit;\n\nlet mut buf = vec![MaybeUninit::<i32>::uninit(); 10];\nlet initialized = MaybeUninit::fill_with(buf.as_mut_slice(), Default::default);\nassert_eq!(initialized, &mut [0; 10]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_fill)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+buf+=+vec!%5BMaybeUninit::%3Ci32%3E::uninit();+10%5D;%0A++++let+initialized+=+MaybeUninit::fill_with(buf.as_mut_slice(),+Default::default);%0A++++assert_eq!(initialized,+%26mut+%5B0;+10%5D);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1261-1266)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_fill` [#117428](https://github.com/rust-lang/rust/issues/117428))\n\nFills `this` with elements yielded by an iterator until either all elements have been initialized or the iterator is empty.\n\nReturns two slices. The first slice contains the initialized portion of the original slice. The second slice is the still-uninitialized remainder of the original slice.\n\n##### [§](#panics-4)Panics\n\nThis function panics if the iterator’s `next` function panics.\n\nIf such a panic occurs, any elements previously initialized during this operation will be dropped.\n\n##### [§](#examples-16)Examples\n\nFill an uninit vec with a cycling iterator.\n\n```\n#![feature(maybe_uninit_fill)]\nuse std::mem::MaybeUninit;\n\nlet mut buf = vec![MaybeUninit::uninit(); 5];\n\nlet iter = [1, 2, 3].into_iter().cycle();\nlet (initialized, remainder) = MaybeUninit::fill_from(&mut buf, iter);\n\nassert_eq!(initialized, &mut [1, 2, 3, 1, 2]);\nassert_eq!(0, remainder.len());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_fill)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+buf+=+vec!%5BMaybeUninit::uninit();+5%5D;%0A++++%0A++++let+iter+=+%5B1,+2,+3%5D.into_iter().cycle();%0A++++let+(initialized,+remainder)+=+MaybeUninit::fill_from(%26mut+buf,+iter);%0A++++%0A++++assert_eq!(initialized,+%26mut+%5B1,+2,+3,+1,+2%5D);%0A++++assert_eq!(0,+remainder.len());%0A%7D&version=nightly&edition=2021)\n\nFill an uninit vec, but not completely.\n\n```\n#![feature(maybe_uninit_fill)]\nuse std::mem::MaybeUninit;\n\nlet mut buf = vec![MaybeUninit::uninit(); 5];\nlet iter = [1, 2];\nlet (initialized, remainder) = MaybeUninit::fill_from(&mut buf, iter);\n\nassert_eq!(initialized, &mut [1, 2]);\nassert_eq!(remainder.len(), 3);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_fill)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+buf+=+vec!%5BMaybeUninit::uninit();+5%5D;%0A++++let+iter+=+%5B1,+2%5D;%0A++++let+(initialized,+remainder)+=+MaybeUninit::fill_from(%26mut+buf,+iter);%0A++++%0A++++assert_eq!(initialized,+%26mut+%5B1,+2%5D);%0A++++assert_eq!(remainder.len(),+3);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1305)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_as_bytes` [#93092](https://github.com/rust-lang/rust/issues/93092))\n\nReturns the contents of this `MaybeUninit` as a slice of potentially uninitialized bytes.\n\nNote that even if the contents of a `MaybeUninit` have been initialized, the value may still contain padding bytes which are left uninitialized.\n\n##### [§](#examples-17)Examples\n\n```\n#![feature(maybe_uninit_as_bytes, maybe_uninit_slice)]\nuse std::mem::MaybeUninit;\n\nlet val = 0x12345678_i32;\nlet uninit = MaybeUninit::new(val);\nlet uninit_bytes = uninit.as_bytes();\nlet bytes = unsafe { MaybeUninit::slice_assume_init_ref(uninit_bytes) };\nassert_eq!(bytes, val.to_ne_bytes());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes,+maybe_uninit_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+val+=+0x12345678_i32;%0A++++let+uninit+=+MaybeUninit::new(val);%0A++++let+uninit_bytes+=+uninit.as_bytes();%0A++++let+bytes+=+unsafe+%7B+MaybeUninit::slice_assume_init_ref(uninit_bytes)+%7D;%0A++++assert_eq!(bytes,+val.to_ne_bytes());%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1336)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_as_bytes` [#93092](https://github.com/rust-lang/rust/issues/93092))\n\nReturns the contents of this `MaybeUninit` as a mutable slice of potentially uninitialized bytes.\n\nNote that even if the contents of a `MaybeUninit` have been initialized, the value may still contain padding bytes which are left uninitialized.\n\n##### [§](#examples-18)Examples\n\n```\n#![feature(maybe_uninit_as_bytes)]\nuse std::mem::MaybeUninit;\n\nlet val = 0x12345678_i32;\nlet mut uninit = MaybeUninit::new(val);\nlet uninit_bytes = uninit.as_bytes_mut();\nif cfg!(target_endian = \"little\") {\n    uninit_bytes[0].write(0xcd);\n} else {\n    uninit_bytes[3].write(0xcd);\n}\nlet val2 = unsafe { uninit.assume_init() };\nassert_eq!(val2, 0x123456cd);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+val+=+0x12345678_i32;%0A++++let+mut+uninit+=+MaybeUninit::new(val);%0A++++let+uninit_bytes+=+uninit.as_bytes_mut();%0A++++if+cfg!(target_endian+=+%22little%22)+%7B%0A++++++++uninit_bytes%5B0%5D.write(0xcd);%0A++++%7D+else+%7B%0A++++++++uninit_bytes%5B3%5D.write(0xcd);%0A++++%7D%0A++++let+val2+=+unsafe+%7B+uninit.assume_init()+%7D;%0A++++assert_eq!(val2,+0x123456cd);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1366)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_as_bytes` [#93092](https://github.com/rust-lang/rust/issues/93092))\n\nReturns the contents of this slice of `MaybeUninit` as a slice of potentially uninitialized bytes.\n\nNote that even if the contents of a `MaybeUninit` have been initialized, the value may still contain padding bytes which are left uninitialized.\n\n##### [§](#examples-19)Examples\n\n```\n#![feature(maybe_uninit_as_bytes, maybe_uninit_write_slice, maybe_uninit_slice)]\nuse std::mem::MaybeUninit;\n\nlet uninit = [MaybeUninit::new(0x1234u16), MaybeUninit::new(0x5678u16)];\nlet uninit_bytes = MaybeUninit::slice_as_bytes(&uninit);\nlet bytes = unsafe { MaybeUninit::slice_assume_init_ref(&uninit_bytes) };\nlet val1 = u16::from_ne_bytes(bytes[0..2].try_into().unwrap());\nlet val2 = u16::from_ne_bytes(bytes[2..4].try_into().unwrap());\nassert_eq!(&[val1, val2], &[0x1234u16, 0x5678u16]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes,+maybe_uninit_write_slice,+maybe_uninit_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+uninit+=+%5BMaybeUninit::new(0x1234u16),+MaybeUninit::new(0x5678u16)%5D;%0A++++let+uninit_bytes+=+MaybeUninit::slice_as_bytes(%26uninit);%0A++++let+bytes+=+unsafe+%7B+MaybeUninit::slice_assume_init_ref(%26uninit_bytes)+%7D;%0A++++let+val1+=+u16::from_ne_bytes(bytes%5B0..2%5D.try_into().unwrap());%0A++++let+val2+=+u16::from_ne_bytes(bytes%5B2..4%5D.try_into().unwrap());%0A++++assert_eq!(%26%5Bval1,+val2%5D,+%26%5B0x1234u16,+0x5678u16%5D);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1395)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_as_bytes` [#93092](https://github.com/rust-lang/rust/issues/93092))\n\nReturns the contents of this mutable slice of `MaybeUninit` as a mutable slice of potentially uninitialized bytes.\n\nNote that even if the contents of a `MaybeUninit` have been initialized, the value may still contain padding bytes which are left uninitialized.\n\n##### [§](#examples-20)Examples\n\n```\n#![feature(maybe_uninit_as_bytes, maybe_uninit_write_slice, maybe_uninit_slice)]\nuse std::mem::MaybeUninit;\n\nlet mut uninit = [MaybeUninit::<u16>::uninit(), MaybeUninit::<u16>::uninit()];\nlet uninit_bytes = MaybeUninit::slice_as_bytes_mut(&mut uninit);\nMaybeUninit::copy_from_slice(uninit_bytes, &[0x12, 0x34, 0x56, 0x78]);\nlet vals = unsafe { MaybeUninit::slice_assume_init_ref(&uninit) };\nif cfg!(target_endian = \"little\") {\n    assert_eq!(vals, &[0x3412u16, 0x7856u16]);\n} else {\n    assert_eq!(vals, &[0x1234u16, 0x5678u16]);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes,+maybe_uninit_write_slice,+maybe_uninit_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+uninit+=+%5BMaybeUninit::%3Cu16%3E::uninit(),+MaybeUninit::%3Cu16%3E::uninit()%5D;%0A++++let+uninit_bytes+=+MaybeUninit::slice_as_bytes_mut(%26mut+uninit);%0A++++MaybeUninit::copy_from_slice(uninit_bytes,+%26%5B0x12,+0x34,+0x56,+0x78%5D);%0A++++let+vals+=+unsafe+%7B+MaybeUninit::slice_assume_init_ref(%26uninit)+%7D;%0A++++if+cfg!(target_endian+=+%22little%22)+%7B%0A++++++++assert_eq!(vals,+%26%5B0x3412u16,+0x7856u16%5D);%0A++++%7D+else+%7B%0A++++++++assert_eq!(vals,+%26%5B0x1234u16,+0x5678u16%5D);%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1402)[§](#impl-MaybeUninit%3C%5BT;+N%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1415)\n\n🔬This is a nightly-only experimental API. (`maybe_uninit_uninit_array_transpose` [#96097](https://github.com/rust-lang/rust/issues/96097))\n\nTransposes a `MaybeUninit<[T; N]>` into a `[MaybeUninit<T>; N]`.\n\n##### [§](#examples-21)Examples\n\n```\n#![feature(maybe_uninit_uninit_array_transpose)]\n\nlet data: [MaybeUninit<u8>; 1000] = MaybeUninit::uninit().transpose();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array_transpose)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+data:+%5BMaybeUninit%3Cu8%3E;+1000%5D+=+MaybeUninit::uninit().transpose();%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140)[§](#impl-Any-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208)[§](#impl-Borrow%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216)[§](#impl-BorrowMut%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765)[§](#impl-From%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768)[§](#method.from)\n\nReturns the argument unchanged.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750)[§](#impl-Into%3CU%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758)[§](#method.into)\n\nCalls `U::from(self)`.\n\nThat is, this conversion is whatever the implementation of `[From](../convert/trait.From.html \"trait std::convert::From\")<T> for U` chooses to do.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85)[§](#impl-ToOwned-for-T)\n\n[§](#associatedtype.Owned)\n\nThe resulting type after obtaining ownership.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88)[§](#method.to_owned)\n\nCreates owned data from borrowed data, usually by cloning. [Read more](about:blank/borrow/trait.ToOwned.html#tymethod.to_owned)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92)[§](#method.clone_into)\n\nUses borrowed data to replace owned data, usually by cloning. [Read more](about:blank/borrow/trait.ToOwned.html#method.clone_into)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807)[§](#impl-TryFrom%3CU%3E-for-T)\n\n[§](#associatedtype.Error-1)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812)[§](#method.try_from)\n\nPerforms the conversion.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792)[§](#impl-TryInto%3CU%3E-for-T)\n\n[§](#associatedtype.Error)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797)[§](#method.try_into)\n\nPerforms the conversion.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A wrapper type to construct uninitialized instances of `T`.\"><title>MaybeUninit in std::mem - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc union\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">MaybeUninit</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">MaybeUninit</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.array_assume_init\">array_assume_init</a></li><li><a href=\"#method.as_bytes\">as_bytes</a></li><li><a href=\"#method.as_bytes_mut\">as_bytes_mut</a></li><li><a href=\"#method.as_mut_ptr\">as_mut_ptr</a></li><li><a href=\"#method.as_ptr\">as_ptr</a></li><li><a href=\"#method.assume_init\">assume_init</a></li><li><a href=\"#method.assume_init-1\">assume_init</a></li><li><a href=\"#method.assume_init_drop\">assume_init_drop</a></li><li><a href=\"#method.assume_init_mut\">assume_init_mut</a></li><li><a href=\"#method.assume_init_read\">assume_init_read</a></li><li><a href=\"#method.assume_init_ref\">assume_init_ref</a></li><li><a href=\"#method.clone_from_slice\">clone_from_slice</a></li><li><a href=\"#method.copy_from_slice\">copy_from_slice</a></li><li><a href=\"#method.fill\">fill</a></li><li><a href=\"#method.fill_from\">fill_from</a></li><li><a href=\"#method.fill_with\">fill_with</a></li><li><a href=\"#method.new\">new</a></li><li><a href=\"#method.slice_as_bytes\">slice_as_bytes</a></li><li><a href=\"#method.slice_as_bytes_mut\">slice_as_bytes_mut</a></li><li><a href=\"#method.slice_as_mut_ptr\">slice_as_mut_ptr</a></li><li><a href=\"#method.slice_as_ptr\">slice_as_ptr</a></li><li><a href=\"#method.slice_assume_init_mut\">slice_assume_init_mut</a></li><li><a href=\"#method.slice_assume_init_ref\">slice_assume_init_ref</a></li><li><a href=\"#method.transpose\">transpose</a></li><li><a href=\"#method.uninit\">uninit</a></li><li><a href=\"#method.uninit_array\">uninit_array</a></li><li><a href=\"#method.write\">write</a></li><li><a href=\"#method.write-1\">write</a></li><li><a href=\"#method.zeroed\">zeroed</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-Clone-for-MaybeUninit%3CT%3E\">Clone</a></li><li><a href=\"#impl-Copy-for-MaybeUninit%3CT%3E\">Copy</a></li><li><a href=\"#impl-Debug-for-MaybeUninit%3CT%3E\">Debug</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-MaybeUninit%3CT%3E\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-MaybeUninit%3CT%3E\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-MaybeUninit%3CT%3E\">Send</a></li><li><a href=\"#impl-Sync-for-MaybeUninit%3CT%3E\">Sync</a></li><li><a href=\"#impl-Unpin-for-MaybeUninit%3CT%3E\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-MaybeUninit%3CT%3E\">UnwindSafe</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-ToOwned-for-T\">ToOwned</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::mem</a></h2><h3><a href=\"index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"macro.offset_of.html\">offset_of</a></li></ul><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Assume.html\">Assume</a></li><li><a href=\"struct.Discriminant.html\">Discriminant</a></li><li><a href=\"struct.ManuallyDrop.html\">ManuallyDrop</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.BikeshedIntrinsicFrom.html\">BikeshedIntrinsicFrom</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.align_of.html\">align_of</a></li><li><a href=\"fn.align_of_val.html\">align_of_val</a></li><li><a href=\"fn.align_of_val_raw.html\">align_of_val_raw</a></li><li><a href=\"fn.copy.html\">copy</a></li><li><a href=\"fn.discriminant.html\">discriminant</a></li><li><a href=\"fn.drop.html\">drop</a></li><li><a href=\"fn.forget.html\">forget</a></li><li><a href=\"fn.forget_unsized.html\">forget_unsized</a></li><li><a href=\"fn.min_align_of.html\">min_align_of</a></li><li><a href=\"fn.min_align_of_val.html\">min_align_of_val</a></li><li><a href=\"fn.needs_drop.html\">needs_drop</a></li><li><a href=\"fn.replace.html\">replace</a></li><li><a href=\"fn.size_of.html\">size_of</a></li><li><a href=\"fn.size_of_val.html\">size_of_val</a></li><li><a href=\"fn.size_of_val_raw.html\">size_of_val_raw</a></li><li><a href=\"fn.swap.html\">swap</a></li><li><a href=\"fn.take.html\">take</a></li><li><a href=\"fn.transmute.html\">transmute</a></li><li><a href=\"fn.transmute_copy.html\">transmute_copy</a></li><li><a href=\"fn.uninitialized.html\">uninitialized</a></li><li><a href=\"fn.variant_count.html\">variant_count</a></li><li><a href=\"fn.zeroed.html\">zeroed</a></li></ul><h3><a href=\"index.html#unions\">Unions</a></h3><ul class=\"block union\"><li><a href=\"union.MaybeUninit.html\">MaybeUninit</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Union <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">mem</a>::<wbr><a class=\"union\" href=\"#\">MaybeUninit</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.36.0\">1.36.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#243\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub union MaybeUninit&lt;T&gt; {\n    <span class=\"comment\">/* private fields */</span>\n}</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A wrapper type to construct uninitialized instances of <code>T</code>.</p>\n<h2 id=\"initialization-invariant\"><a class=\"doc-anchor\" href=\"#initialization-invariant\">§</a>Initialization invariant</h2>\n<p>The compiler, in general, assumes that a variable is properly initialized\naccording to the requirements of the variable’s type. For example, a variable of\nreference type must be aligned and non-null. This is an invariant that must\n<em>always</em> be upheld, even in unsafe code. As a consequence, zero-initializing a\nvariable of reference type causes instantaneous <a href=\"../../reference/behavior-considered-undefined.html\">undefined behavior</a>,\nno matter whether that reference ever gets used to access memory:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::{<span class=\"self\">self</span>, MaybeUninit};\n\n<span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>i32 = <span class=\"kw\">unsafe </span>{ mem::zeroed() }; <span class=\"comment\">// undefined behavior! ⚠️\n// The equivalent code with `MaybeUninit&lt;&amp;i32&gt;`:\n</span><span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>i32 = <span class=\"kw\">unsafe </span>{ MaybeUninit::zeroed().assume_init() }; <span class=\"comment\">// undefined behavior! ⚠️</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7Bself,+MaybeUninit%7D;%0A++++%0A++++let+x:+%26i32+=+unsafe+%7B+mem::zeroed()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A++++//+The+equivalent+code+with+%60MaybeUninit%3C%26i32%3E%60:%0A++++let+x:+%26i32+=+unsafe+%7B+MaybeUninit::zeroed().assume_init()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This is exploited by the compiler for various optimizations, such as eliding\nrun-time checks and optimizing <code>enum</code> layout.</p>\n<p>Similarly, entirely uninitialized memory may have any content, while a <code>bool</code> must\nalways be <code>true</code> or <code>false</code>. Hence, creating an uninitialized <code>bool</code> is undefined behavior:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::{<span class=\"self\">self</span>, MaybeUninit};\n\n<span class=\"kw\">let </span>b: bool = <span class=\"kw\">unsafe </span>{ mem::uninitialized() }; <span class=\"comment\">// undefined behavior! ⚠️\n// The equivalent code with `MaybeUninit&lt;bool&gt;`:\n</span><span class=\"kw\">let </span>b: bool = <span class=\"kw\">unsafe </span>{ MaybeUninit::uninit().assume_init() }; <span class=\"comment\">// undefined behavior! ⚠️</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7Bself,+MaybeUninit%7D;%0A++++%0A++++let+b:+bool+=+unsafe+%7B+mem::uninitialized()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A++++//+The+equivalent+code+with+%60MaybeUninit%3Cbool%3E%60:%0A++++let+b:+bool+=+unsafe+%7B+MaybeUninit::uninit().assume_init()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Moreover, uninitialized memory is special in that it does not have a fixed value (“fixed”\nmeaning “it won’t change without being written to”). Reading the same uninitialized byte\nmultiple times can give different results. This makes it undefined behavior to have\nuninitialized data in a variable even if that variable has an integer type, which otherwise can\nhold any <em>fixed</em> bit pattern:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::{<span class=\"self\">self</span>, MaybeUninit};\n\n<span class=\"kw\">let </span>x: i32 = <span class=\"kw\">unsafe </span>{ mem::uninitialized() }; <span class=\"comment\">// undefined behavior! ⚠️\n// The equivalent code with `MaybeUninit&lt;i32&gt;`:\n</span><span class=\"kw\">let </span>x: i32 = <span class=\"kw\">unsafe </span>{ MaybeUninit::uninit().assume_init() }; <span class=\"comment\">// undefined behavior! ⚠️</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7Bself,+MaybeUninit%7D;%0A++++%0A++++let+x:+i32+=+unsafe+%7B+mem::uninitialized()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A++++//+The+equivalent+code+with+%60MaybeUninit%3Ci32%3E%60:%0A++++let+x:+i32+=+unsafe+%7B+MaybeUninit::uninit().assume_init()+%7D;+//+undefined+behavior!+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021\">Run</a></div>\n<p>On top of that, remember that most types have additional invariants beyond merely\nbeing considered initialized at the type level. For example, a <code>1</code>-initialized <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a>\nis considered initialized (under the current implementation; this does not constitute\na stable guarantee) because the only requirement the compiler knows about it\nis that the data pointer must be non-null. Creating such a <code>Vec&lt;T&gt;</code> does not cause\n<em>immediate</em> undefined behavior, but will cause undefined behavior with most\nsafe operations (including dropping it).</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p><code>MaybeUninit&lt;T&gt;</code> serves to enable unsafe code to deal with uninitialized data.\nIt is a signal to the compiler indicating that the data here might <em>not</em>\nbe initialized:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"comment\">// Create an explicitly uninitialized reference. The compiler knows that data inside\n// a `MaybeUninit&lt;T&gt;` may be invalid, and hence this is not UB:\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;<span class=\"kw-2\">&amp;</span>i32&gt;::uninit();\n<span class=\"comment\">// Set it to a valid value.\n</span>x.write(<span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>);\n<span class=\"comment\">// Extract the initialized data -- this is only allowed *after* properly\n// initializing `x`!\n</span><span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ x.assume_init() };</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++//+Create+an+explicitly+uninitialized+reference.+The+compiler+knows+that+data+inside%0A++++//+a+%60MaybeUninit%3CT%3E%60+may+be+invalid,+and+hence+this+is+not+UB:%0A++++let+mut+x+=+MaybeUninit::%3C%26i32%3E::uninit();%0A++++//+Set+it+to+a+valid+value.%0A++++x.write(%260);%0A++++//+Extract+the+initialized+data+--+this+is+only+allowed+*after*+properly%0A++++//+initializing+%60x%60!%0A++++let+x+=+unsafe+%7B+x.assume_init()+%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The compiler then knows to not make any incorrect assumptions or optimizations on this code.</p>\n<p>You can think of <code>MaybeUninit&lt;T&gt;</code> as being a bit like <code>Option&lt;T&gt;</code> but without\nany of the run-time tracking and without any of the safety checks.</p>\n<h3 id=\"out-pointers\"><a class=\"doc-anchor\" href=\"#out-pointers\">§</a>out-pointers</h3>\n<p>You can use <code>MaybeUninit&lt;T&gt;</code> to implement “out-pointers”: instead of returning data\nfrom a function, pass it a pointer to some (uninitialized) memory to put the\nresult into. This can be useful when it is important for the caller to control\nhow the memory the result is stored in gets allocated, and you want to avoid\nunnecessary moves.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">unsafe fn </span>make_vec(out: <span class=\"kw-2\">*mut </span>Vec&lt;i32&gt;) {\n    <span class=\"comment\">// `write` does not drop the old contents, which is important.\n    </span>out.write(<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = MaybeUninit::uninit();\n<span class=\"kw\">unsafe </span>{ make_vec(v.as_mut_ptr()); }\n<span class=\"comment\">// Now we know `v` is initialized! This also makes sure the vector gets\n// properly dropped.\n</span><span class=\"kw\">let </span>v = <span class=\"kw\">unsafe </span>{ v.assume_init() };\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++unsafe+fn+make_vec(out:+*mut+Vec%3Ci32%3E)+%7B%0A++++++++//+%60write%60+does+not+drop+the+old+contents,+which+is+important.%0A++++++++out.write(vec!%5B1,+2,+3%5D);%0A++++%7D%0A++++%0A++++let+mut+v+=+MaybeUninit::uninit();%0A++++unsafe+%7B+make_vec(v.as_mut_ptr());+%7D%0A++++//+Now+we+know+%60v%60+is+initialized!+This+also+makes+sure+the+vector+gets%0A++++//+properly+dropped.%0A++++let+v+=+unsafe+%7B+v.assume_init()+%7D;%0A++++assert_eq!(%26v,+%26%5B1,+2,+3%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"initializing-an-array-element-by-element\"><a class=\"doc-anchor\" href=\"#initializing-an-array-element-by-element\">§</a>Initializing an array element-by-element</h3>\n<p><code>MaybeUninit&lt;T&gt;</code> can be used to initialize a large array element-by-element:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::{<span class=\"self\">self</span>, MaybeUninit};\n\n<span class=\"kw\">let </span>data = {\n    <span class=\"comment\">// Create an uninitialized array of `MaybeUninit`.\n    </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data: [MaybeUninit&lt;Vec&lt;u32&gt;&gt;; <span class=\"number\">1000</span>] = [<span class=\"kw\">const </span>{ MaybeUninit::uninit() }; <span class=\"number\">1000</span>];\n\n    <span class=\"comment\">// Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n    // we have a memory leak, but there is no memory safety issue.\n    </span><span class=\"kw\">for </span>elem <span class=\"kw\">in </span><span class=\"kw-2\">&amp;mut </span>data[..] {\n        elem.write(<span class=\"macro\">vec!</span>[<span class=\"number\">42</span>]);\n    }\n\n    <span class=\"comment\">// Everything is initialized. Transmute the array to the\n    // initialized type.\n    </span><span class=\"kw\">unsafe </span>{ mem::transmute::&lt;<span class=\"kw\">_</span>, [Vec&lt;u32&gt;; <span class=\"number\">1000</span>]&gt;(data) }\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>data[<span class=\"number\">0</span>], <span class=\"kw-2\">&amp;</span>[<span class=\"number\">42</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7Bself,+MaybeUninit%7D;%0A++++%0A++++let+data+=+%7B%0A++++++++//+Create+an+uninitialized+array+of+%60MaybeUninit%60.%0A++++++++let+mut+data:+%5BMaybeUninit%3CVec%3Cu32%3E%3E;+1000%5D+=+%5Bconst+%7B+MaybeUninit::uninit()+%7D;+1000%5D;%0A++++%0A++++++++//+Dropping+a+%60MaybeUninit%60+does+nothing,+so+if+there+is+a+panic+during+this+loop,%0A++++++++//+we+have+a+memory+leak,+but+there+is+no+memory+safety+issue.%0A++++++++for+elem+in+%26mut+data%5B..%5D+%7B%0A++++++++++++elem.write(vec!%5B42%5D);%0A++++++++%7D%0A++++%0A++++++++//+Everything+is+initialized.+Transmute+the+array+to+the%0A++++++++//+initialized+type.%0A++++++++unsafe+%7B+mem::transmute::%3C_,+%5BVec%3Cu32%3E;+1000%5D%3E(data)+%7D%0A++++%7D;%0A++++%0A++++assert_eq!(%26data%5B0%5D,+%26%5B42%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>You can also work with partially initialized arrays, which could\nbe found in low-level datastructures.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"comment\">// Create an uninitialized array of `MaybeUninit`.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data: [MaybeUninit&lt;String&gt;; <span class=\"number\">1000</span>] = [<span class=\"kw\">const </span>{ MaybeUninit::uninit() }; <span class=\"number\">1000</span>];\n<span class=\"comment\">// Count the number of elements we have assigned.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data_len: usize = <span class=\"number\">0</span>;\n\n<span class=\"kw\">for </span>elem <span class=\"kw\">in </span><span class=\"kw-2\">&amp;mut </span>data[<span class=\"number\">0</span>..<span class=\"number\">500</span>] {\n    elem.write(String::from(<span class=\"string\">\"hello\"</span>));\n    data_len += <span class=\"number\">1</span>;\n}\n\n<span class=\"comment\">// For each item in the array, drop if we allocated it.\n</span><span class=\"kw\">for </span>elem <span class=\"kw\">in </span><span class=\"kw-2\">&amp;mut </span>data[<span class=\"number\">0</span>..data_len] {\n    <span class=\"kw\">unsafe </span>{ elem.assume_init_drop(); }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++//+Create+an+uninitialized+array+of+%60MaybeUninit%60.%0A++++let+mut+data:+%5BMaybeUninit%3CString%3E;+1000%5D+=+%5Bconst+%7B+MaybeUninit::uninit()+%7D;+1000%5D;%0A++++//+Count+the+number+of+elements+we+have+assigned.%0A++++let+mut+data_len:+usize+=+0;%0A++++%0A++++for+elem+in+%26mut+data%5B0..500%5D+%7B%0A++++++++elem.write(String::from(%22hello%22));%0A++++++++data_len+%2B=+1;%0A++++%7D%0A++++%0A++++//+For+each+item+in+the+array,+drop+if+we+allocated+it.%0A++++for+elem+in+%26mut+data%5B0..data_len%5D+%7B%0A++++++++unsafe+%7B+elem.assume_init_drop();+%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"initializing-a-struct-field-by-field\"><a class=\"doc-anchor\" href=\"#initializing-a-struct-field-by-field\">§</a>Initializing a struct field-by-field</h3>\n<p>You can use <code>MaybeUninit&lt;T&gt;</code>, and the <a href=\"../ptr/macro.addr_of_mut.html\" title=\"macro std::ptr::addr_of_mut\"><code>std::ptr::addr_of_mut</code></a> macro, to initialize structs field by field:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n<span class=\"kw\">use </span>std::ptr::addr_of_mut;\n\n<span class=\"attr\">#[derive(Debug, PartialEq)]\n</span><span class=\"kw\">pub struct </span>Foo {\n    name: String,\n    list: Vec&lt;u8&gt;,\n}\n\n<span class=\"kw\">let </span>foo = {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>uninit: MaybeUninit&lt;Foo&gt; = MaybeUninit::uninit();\n    <span class=\"kw\">let </span>ptr = uninit.as_mut_ptr();\n\n    <span class=\"comment\">// Initializing the `name` field\n    // Using `write` instead of assignment via `=` to not call `drop` on the\n    // old, uninitialized value.\n    </span><span class=\"kw\">unsafe </span>{ <span class=\"macro\">addr_of_mut!</span>((<span class=\"kw-2\">*</span>ptr).name).write(<span class=\"string\">\"Bob\"</span>.to_string()); }\n\n    <span class=\"comment\">// Initializing the `list` field\n    // If there is a panic here, then the `String` in the `name` field leaks.\n    </span><span class=\"kw\">unsafe </span>{ <span class=\"macro\">addr_of_mut!</span>((<span class=\"kw-2\">*</span>ptr).list).write(<span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]); }\n\n    <span class=\"comment\">// All the fields are initialized, so we call `assume_init` to get an initialized Foo.\n    </span><span class=\"kw\">unsafe </span>{ uninit.assume_init() }\n};\n\n<span class=\"macro\">assert_eq!</span>(\n    foo,\n    Foo {\n        name: <span class=\"string\">\"Bob\"</span>.to_string(),\n        list: <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]\n    }\n);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++use+std::ptr::addr_of_mut;%0A++++%0A++++%23%5Bderive(Debug,+PartialEq)%5D%0A++++pub+struct+Foo+%7B%0A++++++++name:+String,%0A++++++++list:+Vec%3Cu8%3E,%0A++++%7D%0A++++%0A++++let+foo+=+%7B%0A++++++++let+mut+uninit:+MaybeUninit%3CFoo%3E+=+MaybeUninit::uninit();%0A++++++++let+ptr+=+uninit.as_mut_ptr();%0A++++%0A++++++++//+Initializing+the+%60name%60+field%0A++++++++//+Using+%60write%60+instead+of+assignment+via+%60=%60+to+not+call+%60drop%60+on+the%0A++++++++//+old,+uninitialized+value.%0A++++++++unsafe+%7B+addr_of_mut!((*ptr).name).write(%22Bob%22.to_string());+%7D%0A++++%0A++++++++//+Initializing+the+%60list%60+field%0A++++++++//+If+there+is+a+panic+here,+then+the+%60String%60+in+the+%60name%60+field+leaks.%0A++++++++unsafe+%7B+addr_of_mut!((*ptr).list).write(vec!%5B0,+1,+2%5D);+%7D%0A++++%0A++++++++//+All+the+fields+are+initialized,+so+we+call+%60assume_init%60+to+get+an+initialized+Foo.%0A++++++++unsafe+%7B+uninit.assume_init()+%7D%0A++++%7D;%0A++++%0A++++assert_eq!(%0A++++++++foo,%0A++++++++Foo+%7B%0A++++++++++++name:+%22Bob%22.to_string(),%0A++++++++++++list:+vec!%5B0,+1,+2%5D%0A++++++++%7D%0A++++);%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"layout-1\"><a class=\"doc-anchor\" href=\"#layout-1\">§</a>Layout</h2>\n<p><code>MaybeUninit&lt;T&gt;</code> is guaranteed to have the same size, alignment, and ABI as <code>T</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::{MaybeUninit, size_of, align_of};\n<span class=\"macro\">assert_eq!</span>(size_of::&lt;MaybeUninit&lt;u64&gt;&gt;(), size_of::&lt;u64&gt;());\n<span class=\"macro\">assert_eq!</span>(align_of::&lt;MaybeUninit&lt;u64&gt;&gt;(), align_of::&lt;u64&gt;());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7BMaybeUninit,+size_of,+align_of%7D;%0A++++assert_eq!(size_of::%3CMaybeUninit%3Cu64%3E%3E(),+size_of::%3Cu64%3E());%0A++++assert_eq!(align_of::%3CMaybeUninit%3Cu64%3E%3E(),+align_of::%3Cu64%3E());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>However remember that a type <em>containing</em> a <code>MaybeUninit&lt;T&gt;</code> is not necessarily the same\nlayout; Rust does not in general guarantee that the fields of a <code>Foo&lt;T&gt;</code> have the same order as\na <code>Foo&lt;U&gt;</code> even if <code>T</code> and <code>U</code> have the same size and alignment. Furthermore because any bit\nvalue is valid for a <code>MaybeUninit&lt;T&gt;</code> the compiler can’t apply non-zero/niche-filling\noptimizations, potentially resulting in a larger size:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(size_of::&lt;<span class=\"prelude-ty\">Option</span>&lt;bool&gt;&gt;(), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(size_of::&lt;<span class=\"prelude-ty\">Option</span>&lt;MaybeUninit&lt;bool&gt;&gt;&gt;(), <span class=\"number\">2</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::%7BMaybeUninit,+size_of%7D;%0A++++assert_eq!(size_of::%3COption%3Cbool%3E%3E(),+1);%0A++++assert_eq!(size_of::%3COption%3CMaybeUninit%3Cbool%3E%3E%3E(),+2);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If <code>T</code> is FFI-safe, then so is <code>MaybeUninit&lt;T&gt;</code>.</p>\n<p>While <code>MaybeUninit</code> is <code>#[repr(transparent)]</code> (indicating it guarantees the same size,\nalignment, and ABI as <code>T</code>), this does <em>not</em> change any of the previous caveats. <code>Option&lt;T&gt;</code> and\n<code>Option&lt;MaybeUninit&lt;T&gt;&gt;</code> may still have different sizes, and types containing a field of type\n<code>T</code> may be laid out (and sized) differently than if that field were <code>MaybeUninit&lt;T&gt;</code>.\n<code>MaybeUninit</code> is a union type, and <code>#[repr(transparent)]</code> on unions is unstable (see <a href=\"https://github.com/rust-lang/rust/issues/60405\">the\ntracking issue</a>). Over time, the exact\nguarantees of <code>#[repr(transparent)]</code> on unions may evolve, and <code>MaybeUninit</code> may or may not\nremain <code>#[repr(transparent)]</code>. That said, <code>MaybeUninit&lt;T&gt;</code> will <em>always</em> guarantee that it has\nthe same size, alignment, and ABI as <code>T</code>; it’s just that the way <code>MaybeUninit</code> implements that\nguarantee may evolve.</p>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">§</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Box%3CMaybeUninit%3CT%3E,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#835\">source</a><a href=\"#impl-Box%3CMaybeUninit%3CT%3E,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#866\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.assume_init\" class=\"fn\">assume_init</a>(self) -&gt; <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Converts to <code>Box&lt;T, A&gt;</code>.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h5>\n<p>As with <a href=\"union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>MaybeUninit::assume_init</code></a>,\nit is up to the caller to guarantee that the value\nreally is in an initialized state.\nCalling this when the content is not yet fully initialized\ncauses immediate undefined behavior.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Box::&lt;u32&gt;::new_uninit();\n\n<span class=\"kw\">let </span>five: Box&lt;u32&gt; = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>five.as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++let+mut+five+=+Box::%3Cu32%3E::new_uninit();%0A++++%0A++++let+five:+Box%3Cu32%3E+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++five.as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#900\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.write\" class=\"fn\">write</a>(boxed: <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;, value: T) -&gt; <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Writes the value and converts to <code>Box&lt;T, A&gt;</code>.</p>\n<p>This method converts the box similarly to <a href=\"../boxed/struct.Box.html#method.assume_init\" title=\"method std::boxed::Box::assume_init\"><code>Box::assume_init</code></a> but\nwrites <code>value</code> into it before conversion thus guaranteeing safety.\nIn some scenarios use of this method may improve performance because\nthe compiler may be able to optimize copying from stack.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n\n</span><span class=\"kw\">let </span>big_box = Box::&lt;[usize; <span class=\"number\">1024</span>]&gt;::new_uninit();\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>array = [<span class=\"number\">0</span>; <span class=\"number\">1024</span>];\n<span class=\"kw\">for </span>(i, place) <span class=\"kw\">in </span>array.iter_mut().enumerate() {\n    <span class=\"kw-2\">*</span>place = i;\n}\n\n<span class=\"comment\">// The optimizer may be able to elide this copy, so previous code writes\n// to heap directly.\n</span><span class=\"kw\">let </span>big_box = Box::write(big_box, array);\n\n<span class=\"kw\">for </span>(i, x) <span class=\"kw\">in </span>big_box.iter().enumerate() {\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, i);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++let+big_box+=+Box::%3C%5Busize;+1024%5D%3E::new_uninit();%0A++++%0A++++let+mut+array+=+%5B0;+1024%5D;%0A++++for+(i,+place)+in+array.iter_mut().enumerate()+%7B%0A++++++++*place+=+i;%0A++++%7D%0A++++%0A++++//+The+optimizer+may+be+able+to+elide+this+copy,+so+previous+code+writes%0A++++//+to+heap+directly.%0A++++let+big_box+=+Box::write(big_box,+array);%0A++++%0A++++for+(i,+x)+in+big_box.iter().enumerate()+%7B%0A++++++++assert_eq!(*x,+i);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-MaybeUninit%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#264\">source</a><a href=\"#impl-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.36.0\">1.36.0 (const: 1.36.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#284\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.new\" class=\"fn\">new</a>(val: T) -&gt; <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> initialized with the given value.\nIt is safe to call <a href=\"union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>assume_init</code></a> on the return value of this function.</p>\n<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.\nIt is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>v: MaybeUninit&lt;Vec&lt;u8&gt;&gt; = MaybeUninit::new(<span class=\"macro\">vec!</span>[<span class=\"number\">42</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+v:+MaybeUninit%3CVec%3Cu8%3E%3E+=+MaybeUninit::new(vec!%5B42%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.uninit\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.36.0\">1.36.0 (const: 1.36.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#307\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.uninit\" class=\"fn\">uninit</a>() -&gt; <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state.</p>\n<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.\nIt is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>\n<p>See the <a href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">type-level documentation</a> for some examples.</p>\n<h5 id=\"example-1\"><a class=\"doc-anchor\" href=\"#example-1\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>v: MaybeUninit&lt;String&gt; = MaybeUninit::uninit();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+v:+MaybeUninit%3CString%3E+=+MaybeUninit::uninit();%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.uninit_array\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#344\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.uninit_array\" class=\"fn\">uninit_array</a>&lt;const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;() -&gt; [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;; <a class=\"primitive\" href=\"../primitive.array.html\">N</a>]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_uninit_array</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/96097\">#96097</a>)</span></div></span></summary><div class=\"docblock\"><p>Create a new array of <code>MaybeUninit&lt;T&gt;</code> items, in an uninitialized state.</p>\n<p>Note: in a future Rust version this method may become unnecessary\nwhen Rust allows\n<a href=\"https://github.com/rust-lang/rust/issues/76001\">inline const expressions</a>.\nThe example below could then use <code>let mut buf = [const { MaybeUninit::&lt;u8&gt;::uninit() }; 32];</code>.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_uninit_array, maybe_uninit_slice)]\n\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">extern </span><span class=\"string\">\"C\" </span>{\n    <span class=\"kw\">fn </span>read_into_buffer(ptr: <span class=\"kw-2\">*mut </span>u8, max_len: usize) -&gt; usize;\n}\n\n<span class=\"doccomment\">/// Returns a (possibly smaller) slice of data that was actually read\n</span><span class=\"kw\">fn </span>read(buf: <span class=\"kw-2\">&amp;mut </span>[MaybeUninit&lt;u8&gt;]) -&gt; <span class=\"kw-2\">&amp;</span>[u8] {\n    <span class=\"kw\">unsafe </span>{\n        <span class=\"kw\">let </span>len = read_into_buffer(buf.as_mut_ptr() <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>u8, buf.len());\n        MaybeUninit::slice_assume_init_ref(<span class=\"kw-2\">&amp;</span>buf[..len])\n    }\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf: [MaybeUninit&lt;u8&gt;; <span class=\"number\">32</span>] = MaybeUninit::uninit_array();\n<span class=\"kw\">let </span>data = read(<span class=\"kw-2\">&amp;mut </span>buf);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array,+maybe_uninit_slice)%5D%0A%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++extern+%22C%22+%7B%0A++++++++fn+read_into_buffer(ptr:+*mut+u8,+max_len:+usize)+-%3E+usize;%0A++++%7D%0A++++%0A++++///+Returns+a+(possibly+smaller)+slice+of+data+that+was+actually+read%0A++++fn+read(buf:+%26mut+%5BMaybeUninit%3Cu8%3E%5D)+-%3E+%26%5Bu8%5D+%7B%0A++++++++unsafe+%7B%0A++++++++++++let+len+=+read_into_buffer(buf.as_mut_ptr()+as+*mut+u8,+buf.len());%0A++++++++++++MaybeUninit::slice_assume_init_ref(%26buf%5B..len%5D)%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+mut+buf:+%5BMaybeUninit%3Cu8%3E;+32%5D+=+MaybeUninit::uninit_array();%0A++++let+data+=+read(%26mut+buf);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.zeroed\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.75.0\">1.36.0 (const: 1.75.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#395\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.zeroed\" class=\"fn\">zeroed</a>() -&gt; <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state, with the memory being\nfilled with <code>0</code> bytes. It depends on <code>T</code> whether that already makes for\nproper initialization. For example, <code>MaybeUninit&lt;usize&gt;::zeroed()</code> is initialized,\nbut <code>MaybeUninit&lt;&amp;'static i32&gt;::zeroed()</code> is not because references must not\nbe null.</p>\n<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.\nIt is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>\n<h5 id=\"example-2\"><a class=\"doc-anchor\" href=\"#example-2\">§</a>Example</h5>\n<p>Correct usage of this function: initializing a struct with zero, where all\nfields of the struct can hold the bit-pattern 0 as a valid value.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;(u8, bool)&gt;::zeroed();\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"macro\">assert_eq!</span>(x, (<span class=\"number\">0</span>, <span class=\"bool-val\">false</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+x+=+MaybeUninit::%3C(u8,+bool)%3E::zeroed();%0A++++let+x+=+unsafe+%7B+x.assume_init()+%7D;%0A++++assert_eq!(x,+(0,+false));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This can be used in const contexts, such as to indicate the end of static arrays for\nplugin registration.</p>\n<p><em>Incorrect</em> usage of this function: calling <code>x.zeroed().assume_init()</code>\nwhen <code>0</code> is not a valid bit-pattern for the type:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">enum </span>NotZero { One = <span class=\"number\">1</span>, Two = <span class=\"number\">2 </span>}\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;(u8, NotZero)&gt;::zeroed();\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"comment\">// Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n// This is undefined behavior. ⚠️</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++enum+NotZero+%7B+One+=+1,+Two+=+2+%7D%0A++++%0A++++let+x+=+MaybeUninit::%3C(u8,+NotZero)%3E::zeroed();%0A++++let+x+=+unsafe+%7B+x.assume_init()+%7D;%0A++++//+Inside+a+pair,+we+create+a+%60NotZero%60+that+does+not+have+a+valid+discriminant.%0A++++//+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write-1\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.55.0, const unstable\">1.55.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/63567\" title=\"Tracking issue for const_maybe_uninit_write\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#486\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.write-1\" class=\"fn\">write</a>(&amp;mut self, val: T) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\"><p>Sets the value of the <code>MaybeUninit&lt;T&gt;</code>.</p>\n<p>This overwrites any previous value without dropping it, so be careful\nnot to use this twice unless you want to skip running the destructor.\nFor your convenience, this also returns a mutable reference to the\n(now safely initialized) contents of <code>self</code>.</p>\n<p>As the content is stored inside a <code>MaybeUninit</code>, the destructor is not\nrun for the inner data if the MaybeUninit leaves scope without a call to\n<a href=\"union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>assume_init</code></a>, <a href=\"union.MaybeUninit.html#method.assume_init_drop\" title=\"method std::mem::MaybeUninit::assume_init_drop\"><code>assume_init_drop</code></a>, or similar. Code that receives\nthe mutable reference returned by this function needs to keep this in\nmind. The safety model of Rust regards leaks as safe, but they are\nusually still undesirable. This being said, the mutable reference\nbehaves like any other mutable reference would, so assigning a new value\nto it will drop the old content.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u8&gt;&gt;::uninit();\n\n{\n    <span class=\"kw\">let </span>hello = x.write((<span class=\"kw-2\">&amp;</span><span class=\"string\">b\"Hello, world!\"</span>).to_vec());\n    <span class=\"comment\">// Setting hello does not leak prior allocations, but drops them\n    </span><span class=\"kw-2\">*</span>hello = (<span class=\"kw-2\">&amp;</span><span class=\"string\">b\"Hello\"</span>).to_vec();\n    hello[<span class=\"number\">0</span>] = <span class=\"string\">'h' </span><span class=\"kw\">as </span>u8;\n}\n<span class=\"comment\">// x is initialized now:\n</span><span class=\"kw\">let </span>s = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"hello\"</span>, s.as_slice());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu8%3E%3E::uninit();%0A++++%0A++++%7B%0A++++++++let+hello+=+x.write((%26b%22Hello,+world!%22).to_vec());%0A++++++++//+Setting+hello+does+not+leak+prior+allocations,+but+drops+them%0A++++++++*hello+=+(%26b%22Hello%22).to_vec();%0A++++++++hello%5B0%5D+=+'h'+as+u8;%0A++++%7D%0A++++//+x+is+initialized+now:%0A++++let+s+=+unsafe+%7B+x.assume_init()+%7D;%0A++++assert_eq!(b%22hello%22,+s.as_slice());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This usage of the method causes a leak:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;String&gt;::uninit();\n\nx.write(<span class=\"string\">\"Hello\"</span>.to_string());\n<span class=\"comment\">// This leaks the contained string:\n</span>x.write(<span class=\"string\">\"hello\"</span>.to_string());\n<span class=\"comment\">// x is initialized now:\n</span><span class=\"kw\">let </span>s = <span class=\"kw\">unsafe </span>{ x.assume_init() };</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CString%3E::uninit();%0A++++%0A++++x.write(%22Hello%22.to_string());%0A++++//+This+leaks+the+contained+string:%0A++++x.write(%22hello%22.to_string());%0A++++//+x+is+initialized+now:%0A++++let+s+=+unsafe+%7B+x.assume_init()+%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This method can be used to avoid unsafe in some cases. The example below\nshows a part of an implementation of a fixed sized arena that lends out\npinned references.\nWith <code>write</code>, we can avoid the need to write through a raw pointer:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>core::pin::Pin;\n<span class=\"kw\">use </span>core::mem::MaybeUninit;\n\n<span class=\"kw\">struct </span>PinArena&lt;T&gt; {\n    memory: Box&lt;[MaybeUninit&lt;T&gt;]&gt;,\n    len: usize,\n}\n\n<span class=\"kw\">impl </span>&lt;T&gt; PinArena&lt;T&gt; {\n    <span class=\"kw\">pub fn </span>capacity(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; usize {\n        <span class=\"self\">self</span>.memory.len()\n    }\n    <span class=\"kw\">pub fn </span>push(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>, val: T) -&gt; Pin&lt;<span class=\"kw-2\">&amp;mut </span>T&gt; {\n        <span class=\"kw\">if </span><span class=\"self\">self</span>.len &gt;= <span class=\"self\">self</span>.capacity() {\n            <span class=\"macro\">panic!</span>(<span class=\"string\">\"Attempted to push to a full pin arena!\"</span>);\n        }\n        <span class=\"kw\">let </span>ref_ = <span class=\"self\">self</span>.memory[<span class=\"self\">self</span>.len].write(val);\n        <span class=\"self\">self</span>.len += <span class=\"number\">1</span>;\n        <span class=\"kw\">unsafe </span>{ Pin::new_unchecked(ref_) }\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+core::pin::Pin;%0A++++use+core::mem::MaybeUninit;%0A++++%0A++++struct+PinArena%3CT%3E+%7B%0A++++++++memory:+Box%3C%5BMaybeUninit%3CT%3E%5D%3E,%0A++++++++len:+usize,%0A++++%7D%0A++++%0A++++impl+%3CT%3E+PinArena%3CT%3E+%7B%0A++++++++pub+fn+capacity(%26self)+-%3E+usize+%7B%0A++++++++++++self.memory.len()%0A++++++++%7D%0A++++++++pub+fn+push(%26mut+self,+val:+T)+-%3E+Pin%3C%26mut+T%3E+%7B%0A++++++++++++if+self.len+%3E=+self.capacity()+%7B%0A++++++++++++++++panic!(%22Attempted+to+push+to+a+full+pin+arena!%22);%0A++++++++++++%7D%0A++++++++++++let+ref_+=+self.memory%5Bself.len%5D.write(val);%0A++++++++++++self.len+%2B=+1;%0A++++++++++++unsafe+%7B+Pin::new_unchecked(ref_)+%7D%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.59.0\">1.36.0 (const: 1.59.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#526\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.as_ptr\" class=\"fn\">as_ptr</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a></h4></section></summary><div class=\"docblock\"><p>Gets a pointer to the contained value. Reading from this pointer or turning it\ninto a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.\nWriting to memory that this pointer (non-transitively) points to is undefined behavior\n(except inside an <code>UnsafeCell&lt;T&gt;</code>).</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\nx.write(<span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n<span class=\"comment\">// Create a reference into the `MaybeUninit&lt;T&gt;`. This is okay because we initialized it.\n</span><span class=\"kw\">let </span>x_vec = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x.as_ptr() };\n<span class=\"macro\">assert_eq!</span>(x_vec.len(), <span class=\"number\">3</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++x.write(vec!%5B0,+1,+2%5D);%0A++++//+Create+a+reference+into+the+%60MaybeUninit%3CT%3E%60.+This+is+okay+because+we+initialized+it.%0A++++let+x_vec+=+unsafe+%7B+%26*x.as_ptr()+%7D;%0A++++assert_eq!(x_vec.len(),+3);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><em>Incorrect</em> usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"kw\">let </span>x_vec = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x.as_ptr() };\n<span class=\"comment\">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++let+x_vec+=+unsafe+%7B+%26*x.as_ptr()+%7D;%0A++++//+We+have+created+a+reference+to+an+uninitialized+vector!+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021\">Run</a></div>\n<p>(Notice that the rules around references to uninitialized data are not finalized yet, but\nuntil they are, it is advisable to avoid them.)</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_mut_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const unstable\">1.36.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/75251\" title=\"Tracking issue for const_maybe_uninit_as_mut_ptr\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#565\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_mut_ptr\" class=\"fn\">as_mut_ptr</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut T</a></h4></section></summary><div class=\"docblock\"><p>Gets a mutable pointer to the contained value. Reading from this pointer or turning it\ninto a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\nx.write(<span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n<span class=\"comment\">// Create a reference into the `MaybeUninit&lt;Vec&lt;u32&gt;&gt;`.\n// This is okay because we initialized it.\n</span><span class=\"kw\">let </span>x_vec = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;mut *</span>x.as_mut_ptr() };\nx_vec.push(<span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(x_vec.len(), <span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++x.write(vec!%5B0,+1,+2%5D);%0A++++//+Create+a+reference+into+the+%60MaybeUninit%3CVec%3Cu32%3E%3E%60.%0A++++//+This+is+okay+because+we+initialized+it.%0A++++let+x_vec+=+unsafe+%7B+%26mut+*x.as_mut_ptr()+%7D;%0A++++x_vec.push(3);%0A++++assert_eq!(x_vec.len(),+4);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><em>Incorrect</em> usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"kw\">let </span>x_vec = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;mut *</span>x.as_mut_ptr() };\n<span class=\"comment\">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++let+x_vec+=+unsafe+%7B+%26mut+*x.as_mut_ptr()+%7D;%0A++++//+We+have+created+a+reference+to+an+uninitialized+vector!+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021\">Run</a></div>\n<p>(Notice that the rules around references to uninitialized data are not finalized yet, but\nuntil they are, it is advisable to avoid them.)</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init-1\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.59.0\">1.36.0 (const: 1.59.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#620\">source</a></span><h4 class=\"code-header\">pub const unsafe fn <a href=\"#method.assume_init-1\" class=\"fn\">assume_init</a>(self) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Extracts the value from the <code>MaybeUninit&lt;T&gt;</code> container. This is a great way\nto ensure that the data will get dropped, because the resulting <code>T</code> is\nsubject to the usual drop handling.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is in an initialized\nstate. Calling this when the content is not yet fully initialized causes immediate undefined\nbehavior. The <a href=\"#initialization-invariant\">type-level documentation</a> contains more information about\nthis initialization invariant.</p>\n<p>On top of that, remember that most types have additional invariants beyond merely\nbeing considered initialized at the type level. For example, a <code>1</code>-initialized <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a>\nis considered initialized (under the current implementation; this does not constitute\na stable guarantee) because the only requirement the compiler knows about it\nis that the data pointer must be non-null. Creating such a <code>Vec&lt;T&gt;</code> does not cause\n<em>immediate</em> undefined behavior, but will cause undefined behavior with most\nsafe operations (including dropping it).</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;bool&gt;::uninit();\nx.write(<span class=\"bool-val\">true</span>);\n<span class=\"kw\">let </span>x_init = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"macro\">assert_eq!</span>(x_init, <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3Cbool%3E::uninit();%0A++++x.write(true);%0A++++let+x_init+=+unsafe+%7B+x.assume_init()+%7D;%0A++++assert_eq!(x_init,+true);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><em>Incorrect</em> usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"kw\">let </span>x_init = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"comment\">// `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++let+x_init+=+unsafe+%7B+x.assume_init()+%7D;%0A++++//+%60x%60+had+not+been+initialized+yet,+so+this+last+line+caused+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init_read\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.60.0, const since 1.75.0\">1.60.0 (const: 1.75.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#690\">source</a></span><h4 class=\"code-header\">pub const unsafe fn <a href=\"#method.assume_init_read\" class=\"fn\">assume_init_read</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Reads the value from the <code>MaybeUninit&lt;T&gt;</code> container. The resulting <code>T</code> is subject\nto the usual drop handling.</p>\n<p>Whenever possible, it is preferable to use <a href=\"union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>assume_init</code></a> instead, which\nprevents duplicating the content of the <code>MaybeUninit&lt;T&gt;</code>.</p>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is in an initialized\nstate. Calling this when the content is not yet fully initialized causes undefined\nbehavior. The <a href=\"#initialization-invariant\">type-level documentation</a> contains more information about\nthis initialization invariant.</p>\n<p>Moreover, similar to the <a href=\"../ptr/fn.read.html\" title=\"fn std::ptr::read\"><code>ptr::read</code></a> function, this function creates a\nbitwise copy of the contents, regardless whether the contained type\nimplements the <a href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\"><code>Copy</code></a> trait or not. When using multiple copies of the\ndata (by calling <code>assume_init_read</code> multiple times, or first calling\n<code>assume_init_read</code> and then <a href=\"union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>assume_init</code></a>), it is your responsibility\nto ensure that data may indeed be duplicated.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;u32&gt;::uninit();\nx.write(<span class=\"number\">13</span>);\n<span class=\"kw\">let </span>x1 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"comment\">// `u32` is `Copy`, so we may read multiple times.\n</span><span class=\"kw\">let </span>x2 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"macro\">assert_eq!</span>(x1, x2);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;<span class=\"prelude-ty\">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();\nx.write(<span class=\"prelude-val\">None</span>);\n<span class=\"kw\">let </span>x1 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"comment\">// Duplicating a `None` value is okay, so we may read multiple times.\n</span><span class=\"kw\">let </span>x2 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"macro\">assert_eq!</span>(x1, x2);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3Cu32%3E::uninit();%0A++++x.write(13);%0A++++let+x1+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++//+%60u32%60+is+%60Copy%60,+so+we+may+read+multiple+times.%0A++++let+x2+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++assert_eq!(x1,+x2);%0A++++%0A++++let+mut+x+=+MaybeUninit::%3COption%3CVec%3Cu32%3E%3E%3E::uninit();%0A++++x.write(None);%0A++++let+x1+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++//+Duplicating+a+%60None%60+value+is+okay,+so+we+may+read+multiple+times.%0A++++let+x2+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++assert_eq!(x1,+x2);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><em>Incorrect</em> usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;<span class=\"prelude-ty\">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();\nx.write(<span class=\"prelude-val\">Some</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]));\n<span class=\"kw\">let </span>x1 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"kw\">let </span>x2 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"comment\">// We now created two copies of the same vector, leading to a double-free ⚠️ when\n// they both get dropped!</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3COption%3CVec%3Cu32%3E%3E%3E::uninit();%0A++++x.write(Some(vec!%5B0,+1,+2%5D));%0A++++let+x1+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++let+x2+=+unsafe+%7B+x.assume_init_read()+%7D;%0A++++//+We+now+created+two+copies+of+the+same+vector,+leading+to+a+double-free+%E2%9A%A0%EF%B8%8F+when%0A++++//+they+both+get+dropped!%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init_drop\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.60.0\">1.60.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#722\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.assume_init_drop\" class=\"fn\">assume_init_drop</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Drops the contained value in place.</p>\n<p>If you have ownership of the <code>MaybeUninit</code>, you can also use\n<a href=\"union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>assume_init</code></a> as an alternative.</p>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is\nin an initialized state. Calling this when the content is not yet fully\ninitialized causes undefined behavior.</p>\n<p>On top of that, all additional invariants of the type <code>T</code> must be\nsatisfied, as the <code>Drop</code> implementation of <code>T</code> (or its members) may\nrely on this. For example, setting a <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a> to an invalid but\nnon-null address makes it initialized (under the current implementation;\nthis does not constitute a stable guarantee), because the only\nrequirement the compiler knows about it is that the data pointer must be\nnon-null. Dropping such a <code>Vec&lt;T&gt;</code> however will cause undefined\nbehaviour.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init_ref\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.55.0, const since 1.59.0\">1.55.0 (const: 1.59.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#784\">source</a></span><h4 class=\"code-header\">pub const unsafe fn <a href=\"#method.assume_init_ref\" class=\"fn\">assume_init_ref</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\"><p>Gets a shared reference to the contained value.</p>\n<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been\ninitialized but don’t have ownership of the <code>MaybeUninit</code> (preventing the use\nof <code>.assume_init()</code>).</p>\n<h5 id=\"safety-4\"><a class=\"doc-anchor\" href=\"#safety-4\">§</a>Safety</h5>\n<p>Calling this when the content is not yet fully initialized causes undefined\nbehavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really\nis in an initialized state.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5><h6 id=\"correct-usage-of-this-method\"><a class=\"doc-anchor\" href=\"#correct-usage-of-this-method\">§</a>Correct usage of this method:</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"comment\">// Initialize `x`:\n</span>x.write(<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"comment\">// Now that our `MaybeUninit&lt;_&gt;` is known to be initialized, it is okay to\n// create a shared reference to it:\n</span><span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>Vec&lt;u32&gt; = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// SAFETY: `x` has been initialized.\n    </span>x.assume_init_ref()\n};\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span><span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++//+Initialize+%60x%60:%0A++++x.write(vec!%5B1,+2,+3%5D);%0A++++//+Now+that+our+%60MaybeUninit%3C_%3E%60+is+known+to+be+initialized,+it+is+okay+to%0A++++//+create+a+shared+reference+to+it:%0A++++let+x:+%26Vec%3Cu32%3E+=+unsafe+%7B%0A++++++++//+SAFETY:+%60x%60+has+been+initialized.%0A++++++++x.assume_init_ref()%0A++++%7D;%0A++++assert_eq!(x,+%26vec!%5B1,+2,+3%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<h6 id=\"incorrect-usages-of-this-method\"><a class=\"doc-anchor\" href=\"#incorrect-usages-of-this-method\">§</a><em>Incorrect</em> usages of this method:</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"kw\">let </span>x_vec: <span class=\"kw-2\">&amp;</span>Vec&lt;u32&gt; = <span class=\"kw\">unsafe </span>{ x.assume_init_ref() };\n<span class=\"comment\">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A++++let+x_vec:+%26Vec%3Cu32%3E+=+unsafe+%7B+x.assume_init_ref()+%7D;%0A++++//+We+have+created+a+reference+to+an+uninitialized+vector!+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021\">Run</a></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::{cell::Cell, mem::MaybeUninit};\n\n<span class=\"kw\">let </span>b = MaybeUninit::&lt;Cell&lt;bool&gt;&gt;::uninit();\n<span class=\"comment\">// Initialize the `MaybeUninit` using `Cell::set`:\n</span><span class=\"kw\">unsafe </span>{\n    b.assume_init_ref().set(<span class=\"bool-val\">true</span>);\n   <span class=\"comment\">// ^^^^^^^^^^^^^^^\n   // Reference to an uninitialized `Cell&lt;bool&gt;`: UB!\n</span>}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bcell::Cell,+mem::MaybeUninit%7D;%0A++++%0A++++let+b+=+MaybeUninit::%3CCell%3Cbool%3E%3E::uninit();%0A++++//+Initialize+the+%60MaybeUninit%60+using+%60Cell::set%60:%0A++++unsafe+%7B%0A++++++++b.assume_init_ref().set(true);%0A+++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A+++++++//+Reference+to+an+uninitialized+%60Cell%3Cbool%3E%60:+UB!%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.55.0, const unstable\">1.55.0 (const: unstable)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#901\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.assume_init_mut\" class=\"fn\">assume_init_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\"><p>Gets a mutable (unique) reference to the contained value.</p>\n<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been\ninitialized but don’t have ownership of the <code>MaybeUninit</code> (preventing the use\nof <code>.assume_init()</code>).</p>\n<h5 id=\"safety-5\"><a class=\"doc-anchor\" href=\"#safety-5\">§</a>Safety</h5>\n<p>Calling this when the content is not yet fully initialized causes undefined\nbehavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really\nis in an initialized state. For instance, <code>.assume_init_mut()</code> cannot be used to\ninitialize a <code>MaybeUninit</code>.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5><h6 id=\"correct-usage-of-this-method-1\"><a class=\"doc-anchor\" href=\"#correct-usage-of-this-method-1\">§</a>Correct usage of this method:</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">extern </span><span class=\"string\">\"C\" </span>{\n    <span class=\"doccomment\">/// Initializes *all* the bytes of the input buffer.\n    </span><span class=\"kw\">fn </span>initialize_buffer(buf: <span class=\"kw-2\">*mut </span>[u8; <span class=\"number\">1024</span>]);\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = MaybeUninit::&lt;[u8; <span class=\"number\">1024</span>]&gt;::uninit();\n\n<span class=\"comment\">// Initialize `buf`:\n</span><span class=\"kw\">unsafe </span>{ initialize_buffer(buf.as_mut_ptr()); }\n<span class=\"comment\">// Now we know that `buf` has been initialized, so we could `.assume_init()` it.\n// However, using `.assume_init()` may trigger a `memcpy` of the 1024 bytes.\n// To assert our buffer has been initialized without copying it, we upgrade\n// the `&amp;mut MaybeUninit&lt;[u8; 1024]&gt;` to a `&amp;mut [u8; 1024]`:\n</span><span class=\"kw\">let </span>buf: <span class=\"kw-2\">&amp;mut </span>[u8; <span class=\"number\">1024</span>] = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// SAFETY: `buf` has been initialized.\n    </span>buf.assume_init_mut()\n};\n\n<span class=\"comment\">// Now we can use `buf` as a normal slice:\n</span>buf.sort_unstable();\n<span class=\"macro\">assert!</span>(\n    buf.windows(<span class=\"number\">2</span>).all(|pair| pair[<span class=\"number\">0</span>] &lt;= pair[<span class=\"number\">1</span>]),\n    <span class=\"string\">\"buffer is sorted\"</span>,\n);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unexpected_cfgs)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++unsafe+extern+%22C%22+fn+initialize_buffer(buf:+*mut+%5Bu8;+1024%5D)+%7B+*buf+=+%5B0;+1024%5D+%7D%0A++++%23%5Bcfg(FALSE)%5D%0A++++extern+%22C%22+%7B%0A++++++++///+Initializes+*all*+the+bytes+of+the+input+buffer.%0A++++++++fn+initialize_buffer(buf:+*mut+%5Bu8;+1024%5D);%0A++++%7D%0A++++%0A++++let+mut+buf+=+MaybeUninit::%3C%5Bu8;+1024%5D%3E::uninit();%0A++++%0A++++//+Initialize+%60buf%60:%0A++++unsafe+%7B+initialize_buffer(buf.as_mut_ptr());+%7D%0A++++//+Now+we+know+that+%60buf%60+has+been+initialized,+so+we+could+%60.assume_init()%60+it.%0A++++//+However,+using+%60.assume_init()%60+may+trigger+a+%60memcpy%60+of+the+1024+bytes.%0A++++//+To+assert+our+buffer+has+been+initialized+without+copying+it,+we+upgrade%0A++++//+the+%60%26mut+MaybeUninit%3C%5Bu8;+1024%5D%3E%60+to+a+%60%26mut+%5Bu8;+1024%5D%60:%0A++++let+buf:+%26mut+%5Bu8;+1024%5D+=+unsafe+%7B%0A++++++++//+SAFETY:+%60buf%60+has+been+initialized.%0A++++++++buf.assume_init_mut()%0A++++%7D;%0A++++%0A++++//+Now+we+can+use+%60buf%60+as+a+normal+slice:%0A++++buf.sort_unstable();%0A++++assert!(%0A++++++++buf.windows(2).all(%7Cpair%7C+pair%5B0%5D+%3C=+pair%5B1%5D),%0A++++++++%22buffer+is+sorted%22,%0A++++);%0A%7D&amp;edition=2021\">Run</a></div>\n<h6 id=\"incorrect-usages-of-this-method-1\"><a class=\"doc-anchor\" href=\"#incorrect-usages-of-this-method-1\">§</a><em>Incorrect</em> usages of this method:</h6>\n<p>You cannot use <code>.assume_init_mut()</code> to initialize a value:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>b = MaybeUninit::&lt;bool&gt;::uninit();\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw-2\">*</span>b.assume_init_mut() = <span class=\"bool-val\">true</span>;\n    <span class=\"comment\">// We have created a (mutable) reference to an uninitialized `bool`!\n    // This is undefined behavior. ⚠️\n</span>}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+b+=+MaybeUninit::%3Cbool%3E::uninit();%0A++++unsafe+%7B%0A++++++++*b.assume_init_mut()+=+true;%0A++++++++//+We+have+created+a+(mutable)+reference+to+an+uninitialized+%60bool%60!%0A++++++++//+This+is+undefined+behavior.+%E2%9A%A0%EF%B8%8F%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>For instance, you cannot <a href=\"../../std/io/trait.Read.html\"><code>Read</code></a> into an uninitialized buffer:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::{io, mem::MaybeUninit};\n\n<span class=\"kw\">fn </span>read_chunk (reader: <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'_ </span><span class=\"kw-2\">mut </span><span class=\"kw\">dyn </span>io::Read) -&gt; io::Result&lt;[u8; <span class=\"number\">64</span>]&gt;\n{\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buffer = MaybeUninit::&lt;[u8; <span class=\"number\">64</span>]&gt;::uninit();\n    reader.read_exact(<span class=\"kw\">unsafe </span>{ buffer.assume_init_mut() })<span class=\"question-mark\">?</span>;\n                            <span class=\"comment\">// ^^^^^^^^^^^^^^^^^^^^^^^^\n                            // (mutable) reference to uninitialized memory!\n                            // This is undefined behavior.\n    </span><span class=\"prelude-val\">Ok</span>(<span class=\"kw\">unsafe </span>{ buffer.assume_init() })\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bio,+mem::MaybeUninit%7D;%0A++++%0A++++fn+read_chunk+(reader:+%26'_+mut+dyn+io::Read)+-%3E+io::Result%3C%5Bu8;+64%5D%3E%0A++++%7B%0A++++++++let+mut+buffer+=+MaybeUninit::%3C%5Bu8;+64%5D%3E::uninit();%0A++++++++reader.read_exact(unsafe+%7B+buffer.assume_init_mut()+%7D)?;%0A++++++++++++++++++++++++++++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A++++++++++++++++++++++++++++++++//+(mutable)+reference+to+uninitialized+memory!%0A++++++++++++++++++++++++++++++++//+This+is+undefined+behavior.%0A++++++++Ok(unsafe+%7B+buffer.assume_init()+%7D)%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Nor can you use direct field access to do field-by-field gradual initialization:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::{mem::MaybeUninit, ptr};\n\n<span class=\"kw\">struct </span>Foo {\n    a: u32,\n    b: u8,\n}\n\n<span class=\"kw\">let </span>foo: Foo = <span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>foo = MaybeUninit::&lt;Foo&gt;::uninit();\n    ptr::write(<span class=\"kw-2\">&amp;mut </span>foo.assume_init_mut().a <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>u32, <span class=\"number\">1337</span>);\n                 <span class=\"comment\">// ^^^^^^^^^^^^^^^^^^^^^\n                 // (mutable) reference to uninitialized memory!\n                 // This is undefined behavior.\n    </span>ptr::write(<span class=\"kw-2\">&amp;mut </span>foo.assume_init_mut().b <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>u8, <span class=\"number\">42</span>);\n                 <span class=\"comment\">// ^^^^^^^^^^^^^^^^^^^^^\n                 // (mutable) reference to uninitialized memory!\n                 // This is undefined behavior.\n    </span>foo.assume_init()\n};</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bmem::MaybeUninit,+ptr%7D;%0A++++%0A++++struct+Foo+%7B%0A++++++++a:+u32,%0A++++++++b:+u8,%0A++++%7D%0A++++%0A++++let+foo:+Foo+=+unsafe+%7B%0A++++++++let+mut+foo+=+MaybeUninit::%3CFoo%3E::uninit();%0A++++++++ptr::write(%26mut+foo.assume_init_mut().a+as+*mut+u32,+1337);%0A+++++++++++++++++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A+++++++++++++++++++++//+(mutable)+reference+to+uninitialized+memory!%0A+++++++++++++++++++++//+This+is+undefined+behavior.%0A++++++++ptr::write(%26mut+foo.assume_init_mut().b+as+*mut+u8,+42);%0A+++++++++++++++++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A+++++++++++++++++++++//+(mutable)+reference+to+uninitialized+memory!%0A+++++++++++++++++++++//+This+is+undefined+behavior.%0A++++++++foo.assume_init()%0A++++%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.array_assume_init\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#940\">source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"#method.array_assume_init\" class=\"fn\">array_assume_init</a>&lt;const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;(\n    array: [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;; <a class=\"primitive\" href=\"../primitive.array.html\">N</a>],\n) -&gt; <a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_array_assume_init</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/96097\">#96097</a>)</span></div></span></summary><div class=\"docblock\"><p>Extracts the values from an array of <code>MaybeUninit</code> containers.</p>\n<h5 id=\"safety-6\"><a class=\"doc-anchor\" href=\"#safety-6\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that all elements of the array are\nin an initialized state.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_uninit_array)]\n#![feature(maybe_uninit_array_assume_init)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>array: [MaybeUninit&lt;i32&gt;; <span class=\"number\">3</span>] = MaybeUninit::uninit_array();\narray[<span class=\"number\">0</span>].write(<span class=\"number\">0</span>);\narray[<span class=\"number\">1</span>].write(<span class=\"number\">1</span>);\narray[<span class=\"number\">2</span>].write(<span class=\"number\">2</span>);\n\n<span class=\"comment\">// SAFETY: Now safe as we initialised all elements\n</span><span class=\"kw\">let </span>array = <span class=\"kw\">unsafe </span>{\n    MaybeUninit::array_assume_init(array)\n};\n\n<span class=\"macro\">assert_eq!</span>(array, [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array)%5D%0A%23!%5Bfeature(maybe_uninit_array_assume_init)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+array:+%5BMaybeUninit%3Ci32%3E;+3%5D+=+MaybeUninit::uninit_array();%0A++++array%5B0%5D.write(0);%0A++++array%5B1%5D.write(1);%0A++++array%5B2%5D.write(2);%0A++++%0A++++//+SAFETY:+Now+safe+as+we+initialised+all+elements%0A++++let+array+=+unsafe+%7B%0A++++++++MaybeUninit::array_assume_init(array)%0A++++%7D;%0A++++%0A++++assert_eq!(array,+%5B0,+1,+2%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.slice_assume_init_ref\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#966\">source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"#method.slice_assume_init_ref\" class=\"fn\">slice_assume_init_ref</a>(slice: &amp;[<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63569\">#63569</a>)</span></div></span></summary><div class=\"docblock\"><p>Assuming all the elements are initialized, get a slice to them.</p>\n<h5 id=\"safety-7\"><a class=\"doc-anchor\" href=\"#safety-7\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> elements\nreally are in an initialized state.\nCalling this when the content is not yet fully initialized causes undefined behavior.</p>\n<p>See <a href=\"union.MaybeUninit.html#method.assume_init_ref\" title=\"method std::mem::MaybeUninit::assume_init_ref\"><code>assume_init_ref</code></a> for more details and examples.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.slice_assume_init_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#988\">source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"#method.slice_assume_init_mut\" class=\"fn\">slice_assume_init_mut</a>(\n    slice: &amp;mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;],\n) -&gt; &amp;mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63569\">#63569</a>)</span></div></span></summary><div class=\"docblock\"><p>Assuming all the elements are initialized, get a mutable slice to them.</p>\n<h5 id=\"safety-8\"><a class=\"doc-anchor\" href=\"#safety-8\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> elements\nreally are in an initialized state.\nCalling this when the content is not yet fully initialized causes undefined behavior.</p>\n<p>See <a href=\"union.MaybeUninit.html#method.assume_init_mut\" title=\"method std::mem::MaybeUninit::assume_init_mut\"><code>assume_init_mut</code></a> for more details and examples.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.slice_as_ptr\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#998\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.slice_as_ptr\" class=\"fn\">slice_as_ptr</a>(this: &amp;[<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63569\">#63569</a>)</span></div></span></summary><div class=\"docblock\"><p>Gets a pointer to the first element of the array.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.slice_as_mut_ptr\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1006\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.slice_as_mut_ptr\" class=\"fn\">slice_as_mut_ptr</a>(this: &amp;mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut T</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63569\">#63569</a>)</span></div></span></summary><div class=\"docblock\"><p>Gets a mutable pointer to the first element of the array.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.copy_from_slice\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1054-1056\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.copy_from_slice\" class=\"fn\">copy_from_slice</a>&lt;'a&gt;(\n    this: &amp;'a mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;],\n    src: &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>,\n) -&gt; &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_write_slice</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/79995\">#79995</a>)</span></div></span></summary><div class=\"docblock\"><p>Copies the elements from <code>src</code> to <code>this</code>, returning a mutable reference to the now initialized contents of <code>this</code>.</p>\n<p>If <code>T</code> does not implement <code>Copy</code>, use <a href=\"union.MaybeUninit.html#method.clone_from_slice\" title=\"associated function std::mem::MaybeUninit::clone_from_slice\"><code>clone_from_slice</code></a></p>\n<p>This is similar to <a href=\"../primitive.slice.html#method.copy_from_slice\" title=\"method slice::copy_from_slice\"><code>slice::copy_from_slice</code></a>.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This function will panic if the two slices have different lengths.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_write_slice)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>dst = [MaybeUninit::uninit(); <span class=\"number\">32</span>];\n<span class=\"kw\">let </span>src = [<span class=\"number\">0</span>; <span class=\"number\">32</span>];\n\n<span class=\"kw\">let </span>init = MaybeUninit::copy_from_slice(<span class=\"kw-2\">&amp;mut </span>dst, <span class=\"kw-2\">&amp;</span>src);\n\n<span class=\"macro\">assert_eq!</span>(init, src);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+dst+=+%5BMaybeUninit::uninit();+32%5D;%0A++++let+src+=+%5B0;+32%5D;%0A++++%0A++++let+init+=+MaybeUninit::copy_from_slice(%26mut+dst,+%26src);%0A++++%0A++++assert_eq!(init,+src);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_write_slice)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>vec = Vec::with_capacity(<span class=\"number\">32</span>);\n<span class=\"kw\">let </span>src = [<span class=\"number\">0</span>; <span class=\"number\">16</span>];\n\nMaybeUninit::copy_from_slice(<span class=\"kw-2\">&amp;mut </span>vec.spare_capacity_mut()[..src.len()], <span class=\"kw-2\">&amp;</span>src);\n\n<span class=\"comment\">// SAFETY: we have just copied all the elements of len into the spare capacity\n// the first src.len() elements of the vec are valid now.\n</span><span class=\"kw\">unsafe </span>{\n    vec.set_len(src.len());\n}\n\n<span class=\"macro\">assert_eq!</span>(vec, src);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+vec+=+Vec::with_capacity(32);%0A++++let+src+=+%5B0;+16%5D;%0A++++%0A++++MaybeUninit::copy_from_slice(%26mut+vec.spare_capacity_mut()%5B..src.len()%5D,+%26src);%0A++++%0A++++//+SAFETY:+we+have+just+copied+all+the+elements+of+len+into+the+spare+capacity%0A++++//+the+first+src.len()+elements+of+the+vec+are+valid+now.%0A++++unsafe+%7B%0A++++++++vec.set_len(src.len());%0A++++%7D%0A++++%0A++++assert_eq!(vec,+src);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_from_slice\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1114-1116\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.clone_from_slice\" class=\"fn\">clone_from_slice</a>&lt;'a&gt;(\n    this: &amp;'a mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;],\n    src: &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>,\n) -&gt; &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_write_slice</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/79995\">#79995</a>)</span></div></span></summary><div class=\"docblock\"><p>Clones the elements from <code>src</code> to <code>this</code>, returning a mutable reference to the now initialized contents of <code>this</code>.\nAny already initialized elements will not be dropped.</p>\n<p>If <code>T</code> implements <code>Copy</code>, use <a href=\"union.MaybeUninit.html#method.copy_from_slice\" title=\"associated function std::mem::MaybeUninit::copy_from_slice\"><code>copy_from_slice</code></a></p>\n<p>This is similar to <a href=\"../primitive.slice.html#method.clone_from_slice\" title=\"method slice::clone_from_slice\"><code>slice::clone_from_slice</code></a> but does not drop existing elements.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">§</a>Panics</h5>\n<p>This function will panic if the two slices have different lengths, or if the implementation of <code>Clone</code> panics.</p>\n<p>If there is a panic, the already cloned elements will be dropped.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_write_slice)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>dst = [MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit()];\n<span class=\"kw\">let </span>src = [<span class=\"string\">\"wibbly\"</span>.to_string(), <span class=\"string\">\"wobbly\"</span>.to_string(), <span class=\"string\">\"timey\"</span>.to_string(), <span class=\"string\">\"wimey\"</span>.to_string(), <span class=\"string\">\"stuff\"</span>.to_string()];\n\n<span class=\"kw\">let </span>init = MaybeUninit::clone_from_slice(<span class=\"kw-2\">&amp;mut </span>dst, <span class=\"kw-2\">&amp;</span>src);\n\n<span class=\"macro\">assert_eq!</span>(init, src);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+dst+=+%5BMaybeUninit::uninit(),+MaybeUninit::uninit(),+MaybeUninit::uninit(),+MaybeUninit::uninit(),+MaybeUninit::uninit()%5D;%0A++++let+src+=+%5B%22wibbly%22.to_string(),+%22wobbly%22.to_string(),+%22timey%22.to_string(),+%22wimey%22.to_string(),+%22stuff%22.to_string()%5D;%0A++++%0A++++let+init+=+MaybeUninit::clone_from_slice(%26mut+dst,+%26src);%0A++++%0A++++assert_eq!(init,+src);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_write_slice)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>vec = Vec::with_capacity(<span class=\"number\">32</span>);\n<span class=\"kw\">let </span>src = [<span class=\"string\">\"rust\"</span>, <span class=\"string\">\"is\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"pretty\"</span>, <span class=\"string\">\"cool\"</span>, <span class=\"string\">\"language\"</span>];\n\nMaybeUninit::clone_from_slice(<span class=\"kw-2\">&amp;mut </span>vec.spare_capacity_mut()[..src.len()], <span class=\"kw-2\">&amp;</span>src);\n\n<span class=\"comment\">// SAFETY: we have just cloned all the elements of len into the spare capacity\n// the first src.len() elements of the vec are valid now.\n</span><span class=\"kw\">unsafe </span>{\n    vec.set_len(src.len());\n}\n\n<span class=\"macro\">assert_eq!</span>(vec, src);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+vec+=+Vec::with_capacity(32);%0A++++let+src+=+%5B%22rust%22,+%22is%22,+%22a%22,+%22pretty%22,+%22cool%22,+%22language%22%5D;%0A++++%0A++++MaybeUninit::clone_from_slice(%26mut+vec.spare_capacity_mut()%5B..src.len()%5D,+%26src);%0A++++%0A++++//+SAFETY:+we+have+just+cloned+all+the+elements+of+len+into+the+spare+capacity%0A++++//+the+first+src.len()+elements+of+the+vec+are+valid+now.%0A++++unsafe+%7B%0A++++++++vec.set_len(src.len());%0A++++%7D%0A++++%0A++++assert_eq!(vec,+src);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fill\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1168-1170\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.fill\" class=\"fn\">fill</a>&lt;'a&gt;(this: &amp;'a mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], value: T) -&gt; &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_fill</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/117428\">#117428</a>)</span></div></span></summary><div class=\"docblock\"><p>Fills <code>this</code> with elements by cloning <code>value</code>, returning a mutable reference to the now\ninitialized contents of <code>this</code>.\nAny previously initialized elements will not be dropped.</p>\n<p>This is similar to <a href=\"../primitive.slice.html#method.fill\" title=\"method slice::fill\"><code>slice::fill</code></a>.</p>\n<h5 id=\"panics-2\"><a class=\"doc-anchor\" href=\"#panics-2\">§</a>Panics</h5>\n<p>This function will panic if any call to <code>Clone</code> panics.</p>\n<p>If such a panic occurs, any elements previously initialized during this operation will be\ndropped.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">§</a>Examples</h5>\n<p>Fill an uninit vec with 1.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_fill)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = <span class=\"macro\">vec!</span>[MaybeUninit::uninit(); <span class=\"number\">10</span>];\n<span class=\"kw\">let </span>initialized = MaybeUninit::fill(buf.as_mut_slice(), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(initialized, <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>; <span class=\"number\">10</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_fill)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+buf+=+vec!%5BMaybeUninit::uninit();+10%5D;%0A++++let+initialized+=+MaybeUninit::fill(buf.as_mut_slice(),+1);%0A++++assert_eq!(initialized,+%26mut+%5B1;+10%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fill_with\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1202-1204\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.fill_with\" class=\"fn\">fill_with</a>&lt;'a, F&gt;(this: &amp;'a mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], f: F) -&gt; &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a><div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>() -&gt; T,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_fill</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/117428\">#117428</a>)</span></div></span></summary><div class=\"docblock\"><p>Fills <code>this</code> with elements returned by calling a closure repeatedly.</p>\n<p>This method uses a closure to create new values.  If you’d rather <code>Clone</code> a given value, use\n<a href=\"union.MaybeUninit.html#method.fill\" title=\"associated function std::mem::MaybeUninit::fill\"><code>MaybeUninit::fill</code></a>.  If you want to use the <code>Default</code> trait to generate values, you can\npass <a href=\"../default/trait.Default.html#tymethod.default\" title=\"associated function std::default::Default::default\"><code>Default::default</code></a> as the argument.</p>\n<h5 id=\"panics-3\"><a class=\"doc-anchor\" href=\"#panics-3\">§</a>Panics</h5>\n<p>This function will panic if any call to the provided closure panics.</p>\n<p>If such a panic occurs, any elements previously initialized during this operation will be\ndropped.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">§</a>Examples</h5>\n<p>Fill an uninit vec with the default value.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_fill)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = <span class=\"macro\">vec!</span>[MaybeUninit::&lt;i32&gt;::uninit(); <span class=\"number\">10</span>];\n<span class=\"kw\">let </span>initialized = MaybeUninit::fill_with(buf.as_mut_slice(), Default::default);\n<span class=\"macro\">assert_eq!</span>(initialized, <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>; <span class=\"number\">10</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_fill)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+buf+=+vec!%5BMaybeUninit::%3Ci32%3E::uninit();+10%5D;%0A++++let+initialized+=+MaybeUninit::fill_with(buf.as_mut_slice(),+Default::default);%0A++++assert_eq!(initialized,+%26mut+%5B0;+10%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fill_from\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1261-1266\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.fill_from\" class=\"fn\">fill_from</a>&lt;'a, I&gt;(\n    this: &amp;'a mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;],\n    it: I,\n) -&gt; (&amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, &amp;'a mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;])<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_fill</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/117428\">#117428</a>)</span></div></span></summary><div class=\"docblock\"><p>Fills <code>this</code> with elements yielded by an iterator until either all elements have been\ninitialized or the iterator is empty.</p>\n<p>Returns two slices.  The first slice contains the initialized portion of the original slice.\nThe second slice is the still-uninitialized remainder of the original slice.</p>\n<h5 id=\"panics-4\"><a class=\"doc-anchor\" href=\"#panics-4\">§</a>Panics</h5>\n<p>This function panics if the iterator’s <code>next</code> function panics.</p>\n<p>If such a panic occurs, any elements previously initialized during this operation will be\ndropped.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">§</a>Examples</h5>\n<p>Fill an uninit vec with a cycling iterator.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_fill)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = <span class=\"macro\">vec!</span>[MaybeUninit::uninit(); <span class=\"number\">5</span>];\n\n<span class=\"kw\">let </span>iter = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].into_iter().cycle();\n<span class=\"kw\">let </span>(initialized, remainder) = MaybeUninit::fill_from(<span class=\"kw-2\">&amp;mut </span>buf, iter);\n\n<span class=\"macro\">assert_eq!</span>(initialized, <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">0</span>, remainder.len());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_fill)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+buf+=+vec!%5BMaybeUninit::uninit();+5%5D;%0A++++%0A++++let+iter+=+%5B1,+2,+3%5D.into_iter().cycle();%0A++++let+(initialized,+remainder)+=+MaybeUninit::fill_from(%26mut+buf,+iter);%0A++++%0A++++assert_eq!(initialized,+%26mut+%5B1,+2,+3,+1,+2%5D);%0A++++assert_eq!(0,+remainder.len());%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Fill an uninit vec, but not completely.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_fill)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = <span class=\"macro\">vec!</span>[MaybeUninit::uninit(); <span class=\"number\">5</span>];\n<span class=\"kw\">let </span>iter = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];\n<span class=\"kw\">let </span>(initialized, remainder) = MaybeUninit::fill_from(<span class=\"kw-2\">&amp;mut </span>buf, iter);\n\n<span class=\"macro\">assert_eq!</span>(initialized, <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n<span class=\"macro\">assert_eq!</span>(remainder.len(), <span class=\"number\">3</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_fill)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+buf+=+vec!%5BMaybeUninit::uninit();+5%5D;%0A++++let+iter+=+%5B1,+2%5D;%0A++++let+(initialized,+remainder)+=+MaybeUninit::fill_from(%26mut+buf,+iter);%0A++++%0A++++assert_eq!(initialized,+%26mut+%5B1,+2%5D);%0A++++assert_eq!(remainder.len(),+3);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_bytes\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1305\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.as_bytes\" class=\"fn\">as_bytes</a>(&amp;self) -&gt; &amp;[<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/93092\">#93092</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns the contents of this <code>MaybeUninit</code> as a slice of potentially uninitialized bytes.</p>\n<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still\ncontain padding bytes which are left uninitialized.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_as_bytes, maybe_uninit_slice)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>val = <span class=\"number\">0x12345678_i32</span>;\n<span class=\"kw\">let </span>uninit = MaybeUninit::new(val);\n<span class=\"kw\">let </span>uninit_bytes = uninit.as_bytes();\n<span class=\"kw\">let </span>bytes = <span class=\"kw\">unsafe </span>{ MaybeUninit::slice_assume_init_ref(uninit_bytes) };\n<span class=\"macro\">assert_eq!</span>(bytes, val.to_ne_bytes());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes,+maybe_uninit_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+val+=+0x12345678_i32;%0A++++let+uninit+=+MaybeUninit::new(val);%0A++++let+uninit_bytes+=+uninit.as_bytes();%0A++++let+bytes+=+unsafe+%7B+MaybeUninit::slice_assume_init_ref(uninit_bytes)+%7D;%0A++++assert_eq!(bytes,+val.to_ne_bytes());%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_bytes_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1336\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.as_bytes_mut\" class=\"fn\">as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/93092\">#93092</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns the contents of this <code>MaybeUninit</code> as a mutable slice of potentially uninitialized\nbytes.</p>\n<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still\ncontain padding bytes which are left uninitialized.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_as_bytes)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>val = <span class=\"number\">0x12345678_i32</span>;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>uninit = MaybeUninit::new(val);\n<span class=\"kw\">let </span>uninit_bytes = uninit.as_bytes_mut();\n<span class=\"kw\">if </span><span class=\"macro\">cfg!</span>(target_endian = <span class=\"string\">\"little\"</span>) {\n    uninit_bytes[<span class=\"number\">0</span>].write(<span class=\"number\">0xcd</span>);\n} <span class=\"kw\">else </span>{\n    uninit_bytes[<span class=\"number\">3</span>].write(<span class=\"number\">0xcd</span>);\n}\n<span class=\"kw\">let </span>val2 = <span class=\"kw\">unsafe </span>{ uninit.assume_init() };\n<span class=\"macro\">assert_eq!</span>(val2, <span class=\"number\">0x123456cd</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+val+=+0x12345678_i32;%0A++++let+mut+uninit+=+MaybeUninit::new(val);%0A++++let+uninit_bytes+=+uninit.as_bytes_mut();%0A++++if+cfg!(target_endian+=+%22little%22)+%7B%0A++++++++uninit_bytes%5B0%5D.write(0xcd);%0A++++%7D+else+%7B%0A++++++++uninit_bytes%5B3%5D.write(0xcd);%0A++++%7D%0A++++let+val2+=+unsafe+%7B+uninit.assume_init()+%7D;%0A++++assert_eq!(val2,+0x123456cd);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.slice_as_bytes\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1366\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.slice_as_bytes\" class=\"fn\">slice_as_bytes</a>(this: &amp;[<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;[<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/93092\">#93092</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns the contents of this slice of <code>MaybeUninit</code> as a slice of potentially uninitialized\nbytes.</p>\n<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still\ncontain padding bytes which are left uninitialized.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_as_bytes, maybe_uninit_write_slice, maybe_uninit_slice)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>uninit = [MaybeUninit::new(<span class=\"number\">0x1234u16</span>), MaybeUninit::new(<span class=\"number\">0x5678u16</span>)];\n<span class=\"kw\">let </span>uninit_bytes = MaybeUninit::slice_as_bytes(<span class=\"kw-2\">&amp;</span>uninit);\n<span class=\"kw\">let </span>bytes = <span class=\"kw\">unsafe </span>{ MaybeUninit::slice_assume_init_ref(<span class=\"kw-2\">&amp;</span>uninit_bytes) };\n<span class=\"kw\">let </span>val1 = u16::from_ne_bytes(bytes[<span class=\"number\">0</span>..<span class=\"number\">2</span>].try_into().unwrap());\n<span class=\"kw\">let </span>val2 = u16::from_ne_bytes(bytes[<span class=\"number\">2</span>..<span class=\"number\">4</span>].try_into().unwrap());\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[val1, val2], <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x1234u16</span>, <span class=\"number\">0x5678u16</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes,+maybe_uninit_write_slice,+maybe_uninit_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+uninit+=+%5BMaybeUninit::new(0x1234u16),+MaybeUninit::new(0x5678u16)%5D;%0A++++let+uninit_bytes+=+MaybeUninit::slice_as_bytes(%26uninit);%0A++++let+bytes+=+unsafe+%7B+MaybeUninit::slice_assume_init_ref(%26uninit_bytes)+%7D;%0A++++let+val1+=+u16::from_ne_bytes(bytes%5B0..2%5D.try_into().unwrap());%0A++++let+val2+=+u16::from_ne_bytes(bytes%5B2..4%5D.try_into().unwrap());%0A++++assert_eq!(%26%5Bval1,+val2%5D,+%26%5B0x1234u16,+0x5678u16%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.slice_as_bytes_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1395\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.slice_as_bytes_mut\" class=\"fn\">slice_as_bytes_mut</a>(this: &amp;mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;mut [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/93092\">#93092</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns the contents of this mutable slice of <code>MaybeUninit</code> as a mutable slice of\npotentially uninitialized bytes.</p>\n<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still\ncontain padding bytes which are left uninitialized.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_as_bytes, maybe_uninit_write_slice, maybe_uninit_slice)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>uninit = [MaybeUninit::&lt;u16&gt;::uninit(), MaybeUninit::&lt;u16&gt;::uninit()];\n<span class=\"kw\">let </span>uninit_bytes = MaybeUninit::slice_as_bytes_mut(<span class=\"kw-2\">&amp;mut </span>uninit);\nMaybeUninit::copy_from_slice(uninit_bytes, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x12</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0x56</span>, <span class=\"number\">0x78</span>]);\n<span class=\"kw\">let </span>vals = <span class=\"kw\">unsafe </span>{ MaybeUninit::slice_assume_init_ref(<span class=\"kw-2\">&amp;</span>uninit) };\n<span class=\"kw\">if </span><span class=\"macro\">cfg!</span>(target_endian = <span class=\"string\">\"little\"</span>) {\n    <span class=\"macro\">assert_eq!</span>(vals, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x3412u16</span>, <span class=\"number\">0x7856u16</span>]);\n} <span class=\"kw\">else </span>{\n    <span class=\"macro\">assert_eq!</span>(vals, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x1234u16</span>, <span class=\"number\">0x5678u16</span>]);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes,+maybe_uninit_write_slice,+maybe_uninit_slice)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+mut+uninit+=+%5BMaybeUninit::%3Cu16%3E::uninit(),+MaybeUninit::%3Cu16%3E::uninit()%5D;%0A++++let+uninit_bytes+=+MaybeUninit::slice_as_bytes_mut(%26mut+uninit);%0A++++MaybeUninit::copy_from_slice(uninit_bytes,+%26%5B0x12,+0x34,+0x56,+0x78%5D);%0A++++let+vals+=+unsafe+%7B+MaybeUninit::slice_assume_init_ref(%26uninit)+%7D;%0A++++if+cfg!(target_endian+=+%22little%22)+%7B%0A++++++++assert_eq!(vals,+%26%5B0x3412u16,+0x7856u16%5D);%0A++++%7D+else+%7B%0A++++++++assert_eq!(vals,+%26%5B0x1234u16,+0x5678u16%5D);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-MaybeUninit%3C%5BT;+N%5D%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1402\">source</a><a href=\"#impl-MaybeUninit%3C%5BT;+N%5D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.transpose\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#1415\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.transpose\" class=\"fn\">transpose</a>(self) -&gt; [<a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;; <a class=\"primitive\" href=\"../primitive.array.html\">N</a>]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_uninit_array_transpose</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/96097\">#96097</a>)</span></div></span></summary><div class=\"docblock\"><p>Transposes a <code>MaybeUninit&lt;[T; N]&gt;</code> into a <code>[MaybeUninit&lt;T&gt;; N]</code>.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_uninit_array_transpose)]\n\n</span><span class=\"kw\">let </span>data: [MaybeUninit&lt;u8&gt;; <span class=\"number\">1000</span>] = MaybeUninit::uninit().transpose();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array_transpose)%5D%0Afn+main()+%7B%0A++++use+std::mem::MaybeUninit;%0A++++%0A++++let+data:+%5BMaybeUninit%3Cu8%3E;+1000%5D+=+MaybeUninit::uninit().transpose();%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">§</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Clone-for-MaybeUninit%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0\">1.36.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#249\">source</a></span><a href=\"#impl-Clone-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> for <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#251\">source</a><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\">Returns a copy of the value. <a href=\"../clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#169\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Self</a>)</h4></section></summary><div class=\"docblock\">Performs copy-assignment from <code>source</code>. <a href=\"../clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-MaybeUninit%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.41.0\">1.41.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#258\">source</a></span><a href=\"#impl-Debug-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#259\">source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><section id=\"impl-Copy-for-MaybeUninit%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0\">1.36.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/maybe_uninit.rs.html#241\">source</a></span><a href=\"#impl-Copy-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a> for <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,</div></h3></section></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-MaybeUninit%3CT%3E\" class=\"impl\"><a href=\"#impl-Freeze-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a>,</div></h3></section><section id=\"impl-RefUnwindSafe-for-MaybeUninit%3CT%3E\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a>,</div></h3></section><section id=\"impl-Send-for-MaybeUninit%3CT%3E\" class=\"impl\"><a href=\"#impl-Send-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>,</div></h3></section><section id=\"impl-Sync-for-MaybeUninit%3CT%3E\" class=\"impl\"><a href=\"#impl-Sync-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a>,</div></h3></section><section id=\"impl-Unpin-for-MaybeUninit%3CT%3E\" class=\"impl\"><a href=\"#impl-Unpin-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a>,</div></h3></section><section id=\"impl-UnwindSafe-for-MaybeUninit%3CT%3E\" class=\"impl\"><a href=\"#impl-UnwindSafe-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"union\" href=\"union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a>,</div></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToOwned-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85\">source</a><a href=\"#impl-ToOwned-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Owned\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88\">source</a><a href=\"#method.to_owned\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\">Creates owned data from borrowed data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92\">source</a><a href=\"#method.clone_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>)</h4></section></summary><div class=\"docblock\">Uses borrowed data to replace owned data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:14:13.536Z"
}