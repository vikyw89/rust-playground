{
	"title": "Drop Check - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/dropck.html",
	"markdown": "# Drop Check - The Rustonomicon\n\nWe have seen how lifetimes provide us some fairly simple rules for ensuring that we never read dangling references. However up to this point we have only ever interacted with the _outlives_ relationship in an inclusive manner. That is, when we talked about `'a: 'b`, it was ok for `'a` to live _exactly_ as long as `'b`. At first glance, this seems to be a meaningless distinction. Nothing ever gets dropped at the same time as another, right? This is why we used the following desugaring of `let` statements:\n\n```rust\nlet x;\nlet y;\n```\n\ndesugaring to:\n\n```rust\n{\n    let x;\n    {\n        let y;\n    }\n}\n```\n\nThere are some more complex situations which are not possible to desugar using scopes, but the order is still defined ‒ variables are dropped in the reverse order of their definition, fields of structs and tuples in order of their definition. There are some more details about order of drop in [RFC 1857](https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-order.md).\n\nLet's do this:\n\n```rust\nlet tuple = (vec![], vec![]);\n```\n\nThe left vector is dropped first. But does it mean the right one strictly outlives it in the eyes of the borrow checker? The answer to this question is _no_. The borrow checker could track fields of tuples separately, but it would still be unable to decide what outlives what in case of vector elements, which are dropped manually via pure-library code the borrow checker doesn't understand.\n\nSo why do we care? We care because if the type system isn't careful, it could accidentally make dangling pointers. Consider the following simple program:\n\n```rust\nstruct Inspector<'a>(&'a u8);\n\nstruct World<'a> {\n    inspector: Option<Inspector<'a>>,\n    days: Box<u8>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days));\n}\n```\n\nThis program is totally sound and compiles today. The fact that `days` does not strictly outlive `inspector` doesn't matter. As long as the `inspector` is alive, so is `days`.\n\nHowever if we add a destructor, the program will no longer compile!\n\n```rust\nstruct Inspector<'a>(&'a u8);\n\nimpl<'a> Drop for Inspector<'a> {\n    fn drop(&mut self) {\n        println!(\"I was only {} days from retirement!\", self.0);\n    }\n}\n\nstruct World<'a> {\n    inspector: Option<Inspector<'a>>,\n    days: Box<u8>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days));\n    // Let's say `days` happens to get dropped first.\n    // Then when Inspector is dropped, it will try to read free'd memory!\n}\n```\n\n```text\nerror[E0597]: `world.days` does not live long enough\n  --> src/main.rs:19:38\n   |\n19 |     world.inspector = Some(Inspector(&world.days));\n   |                                      ^^^^^^^^^^^ borrowed value does not live long enough\n...\n22 | }\n   | -\n   | |\n   | `world.days` dropped here while still borrowed\n   | borrow might be used here, when `world` is dropped and runs the destructor for type `World<'_>`\n\n```\n\nYou can try changing the order of fields or use a tuple instead of the struct, it'll still not compile.\n\nImplementing `Drop` lets the `Inspector` execute some arbitrary code during its death. This means it can potentially observe that types that are supposed to live as long as it does actually were destroyed first.\n\nInterestingly, only generic types need to worry about this. If they aren't generic, then the only lifetimes they can harbor are `'static`, which will truly live _forever_. This is why this problem is referred to as _sound generic drop_. Sound generic drop is enforced by the _drop checker_. As of this writing, some of the finer details of how the drop checker (also called dropck) validates types is totally up in the air. However The Big Rule is the subtlety that we have focused on this whole section:\n\n**For a generic type to soundly implement drop, its generics arguments must strictly outlive it.**\n\nObeying this rule is (usually) necessary to satisfy the borrow checker; obeying it is sufficient but not necessary to be sound. That is, if your type obeys this rule then it's definitely sound to drop.\n\nThe reason that it is not always necessary to satisfy the above rule is that some Drop implementations will not access borrowed data even though their type gives them the capability for such access, or because we know the specific drop order and the borrowed data is still fine even if the borrow checker doesn't know that.\n\nFor example, this variant of the above `Inspector` example will never access borrowed data:\n\n```rust\nstruct Inspector<'a>(&'a u8, &'static str);\n\nimpl<'a> Drop for Inspector<'a> {\n    fn drop(&mut self) {\n        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n    }\n}\n\nstruct World<'a> {\n    inspector: Option<Inspector<'a>>,\n    days: Box<u8>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days, \"gadget\"));\n    // Let's say `days` happens to get dropped first.\n    // Even when Inspector is dropped, its destructor will not access the\n    // borrowed `days`.\n}\n```\n\nLikewise, this variant will also never access borrowed data:\n\n```rust\nstruct Inspector<T>(T, &'static str);\n\nimpl<T> Drop for Inspector<T> {\n    fn drop(&mut self) {\n        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n    }\n}\n\nstruct World<T> {\n    inspector: Option<Inspector<T>>,\n    days: Box<u8>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days, \"gadget\"));\n    // Let's say `days` happens to get dropped first.\n    // Even when Inspector is dropped, its destructor will not access the\n    // borrowed `days`.\n}\n```\n\nHowever, _both_ of the above variants are rejected by the borrow checker during the analysis of `fn main`, saying that `days` does not live long enough.\n\nThe reason is that the borrow checking analysis of `main` does not know about the internals of each `Inspector`'s `Drop` implementation. As far as the borrow checker knows while it is analyzing `main`, the body of an inspector's destructor might access that borrowed data.\n\nTherefore, the drop checker forces all borrowed data in a value to strictly outlive that value.\n\n## [An Escape Hatch](#an-escape-hatch)\n\nThe precise rules that govern drop checking may be less restrictive in the future.\n\nThe current analysis is deliberately conservative and trivial; it forces all borrowed data in a value to outlive that value, which is certainly sound.\n\nFuture versions of the language may make the analysis more precise, to reduce the number of cases where sound code is rejected as unsafe. This would help address cases such as the two `Inspector`s above that know not to inspect during destruction.\n\nIn the meantime, there is an unstable attribute that one can use to assert (unsafely) that a generic type's destructor is _guaranteed_ to not access any expired data, even if its type gives it the capability to do so.\n\nThat attribute is called `may_dangle` and was introduced in [RFC 1327](https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md). To deploy it on the `Inspector` from above, we would write:\n\n```rust\n#![feature(dropck_eyepatch)]\n\nstruct Inspector<'a>(&'a u8, &'static str);\n\nunsafe impl<#[may_dangle] 'a> Drop for Inspector<'a> {\n    fn drop(&mut self) {\n        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n    }\n}\n\nstruct World<'a> {\n    days: Box<u8>,\n    inspector: Option<Inspector<'a>>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days, \"gadget\"));\n}\n```\n\nUse of this attribute requires the `Drop` impl to be marked `unsafe` because the compiler is not checking the implicit assertion that no potentially expired data (e.g. `self.0` above) is accessed.\n\nThe attribute can be applied to any number of lifetime and type parameters. In the following example, we assert that we access no data behind a reference of lifetime `'b` and that the only uses of `T` will be moves or drops, but omit the attribute from `'a` and `U`, because we do access data with that lifetime and that type:\n\n```rust\n#![allow(unused)]\n#![feature(dropck_eyepatch)]\nfn main() {\nuse std::fmt::Display;\n\nstruct Inspector<'a, 'b, T, U: Display>(&'a u8, &'b u8, T, U);\n\nunsafe impl<'a, #[may_dangle] 'b, #[may_dangle] T, U: Display> Drop for Inspector<'a, 'b, T, U> {\n    fn drop(&mut self) {\n        println!(\"Inspector({}, _, _, {})\", self.0, self.3);\n    }\n}\n}\n```\n\nIt is sometimes obvious that no such access can occur, like the case above. However, when dealing with a generic type parameter, such access can occur indirectly. Examples of such indirect access are:\n\n-   invoking a callback,\n-   via a trait method call.\n\n(Future changes to the language, such as impl specialization, may add other avenues for such indirect access.)\n\nHere is an example of invoking a callback:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Inspector<T>(T, &'static str, Box<for <'r> fn(&'r T) -> String>);\n\nimpl<T> Drop for Inspector<T> {\n    fn drop(&mut self) {\n        // The `self.2` call could access a borrow e.g. if `T` is `&'a _`.\n        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n                 (self.2)(&self.0), self.1);\n    }\n}\n}\n```\n\nHere is an example of a trait method call:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::fmt;\n\nstruct Inspector<T: fmt::Display>(T, &'static str);\n\nimpl<T: fmt::Display> Drop for Inspector<T> {\n    fn drop(&mut self) {\n        // There is a hidden call to `<T as Display>::fmt` below, which\n        // could access a borrow e.g. if `T` is `&'a _`\n        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n                 self.0, self.1);\n    }\n}\n}\n```\n\nAnd of course, all of these accesses could be further hidden within some other method invoked by the destructor, rather than being written directly within it.\n\nIn all of the above cases where the `&'a u8` is accessed in the destructor, adding the `#[may_dangle]` attribute makes the type vulnerable to misuse that the borrow checker will not catch, inviting havoc. It is better to avoid adding the attribute.\n\nWhile the drop order of fields inside a struct is defined, relying on it is fragile and subtle. When the order matters, it is better to use the [`ManuallyDrop`](../std/mem/struct.ManuallyDrop.html) wrapper.\n\n## [Is that all about drop checker?](#is-that-all-about-drop-checker)\n\nIt turns out that when writing unsafe code, we generally don't need to worry at all about doing the right thing for the drop checker. However there is one special case that you need to worry about, which we will look at in the next section.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Drop Check - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"drop-check\"><a class=\"header\" href=\"#drop-check\">Drop Check</a></h1>\n<p>We have seen how lifetimes provide us some fairly simple rules for ensuring\nthat we never read dangling references. However up to this point we have only ever\ninteracted with the <em>outlives</em> relationship in an inclusive manner. That is,\nwhen we talked about <code class=\"hljs\">'a: 'b</code>, it was ok for <code class=\"hljs\">'a</code> to live <em>exactly</em> as long as\n<code class=\"hljs\">'b</code>. At first glance, this seems to be a meaningless distinction. Nothing ever\ngets dropped at the same time as another, right? This is why we used the\nfollowing desugaring of <code class=\"hljs\">let</code> statements:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> x;\n<span class=\"hljs-keyword\">let</span> y;</code></pre>\n<p>desugaring to:</p>\n<!-- ignore: desugared code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">{\n    <span class=\"hljs-keyword\">let</span> x;\n    {\n        <span class=\"hljs-keyword\">let</span> y;\n    }\n}</code></pre>\n<p>There are some more complex situations which are not possible to desugar using\nscopes, but the order is still defined ‒ variables are dropped in the reverse\norder of their definition, fields of structs and tuples in order of their\ndefinition. There are some more details about order of drop in <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-order.md\">RFC 1857</a>.</p>\n<p>Let's do this:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> tuple = (<span class=\"hljs-built_in\">vec!</span>[], <span class=\"hljs-built_in\">vec!</span>[]);</code></pre>\n<p>The left vector is dropped first. But does it mean the right one strictly\noutlives it in the eyes of the borrow checker? The answer to this question is\n<em>no</em>. The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.</p>\n<p>So why do we care? We care because if the type system isn't careful, it could\naccidentally make dangling pointers. Consider the following simple program:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inspector</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">u8</span>);\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">World</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; {\n    inspector: <span class=\"hljs-built_in\">Option</span>&lt;Inspector&lt;<span class=\"hljs-symbol\">'a</span>&gt;&gt;,\n    days: <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt;,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> world = World {\n        inspector: <span class=\"hljs-literal\">None</span>,\n        days: <span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">1</span>),\n    };\n    world.inspector = <span class=\"hljs-literal\">Some</span>(Inspector(&amp;world.days));\n}</code></pre></pre>\n<p>This program is totally sound and compiles today. The fact that <code class=\"hljs\">days</code> does not\nstrictly outlive <code class=\"hljs\">inspector</code> doesn't matter. As long as the <code class=\"hljs\">inspector</code> is\nalive, so is <code class=\"hljs\">days</code>.</p>\n<p>However if we add a destructor, the program will no longer compile!</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust compile_fail edition2021 hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inspector</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">u8</span>);\n\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Inspector&lt;<span class=\"hljs-symbol\">'a</span>&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"I was only {} days from retirement!\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>);\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">World</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; {\n    inspector: <span class=\"hljs-built_in\">Option</span>&lt;Inspector&lt;<span class=\"hljs-symbol\">'a</span>&gt;&gt;,\n    days: <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt;,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> world = World {\n        inspector: <span class=\"hljs-literal\">None</span>,\n        days: <span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">1</span>),\n    };\n    world.inspector = <span class=\"hljs-literal\">Some</span>(Inspector(&amp;world.days));\n    <span class=\"hljs-comment\">// Let's say `days` happens to get dropped first.</span>\n    <span class=\"hljs-comment\">// Then when Inspector is dropped, it will try to read free'd memory!</span>\n}</code></pre></pre>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error[E0597]: `world.days` does not live long enough\n  --&gt; src/main.rs:19:38\n   |\n19 |     world.inspector = Some(Inspector(&amp;world.days));\n   |                                      ^^^^^^^^^^^ borrowed value does not live long enough\n...\n22 | }\n   | -\n   | |\n   | `world.days` dropped here while still borrowed\n   | borrow might be used here, when `world` is dropped and runs the destructor for type `World&lt;'_&gt;`\n</code></pre>\n<p>You can try changing the order of fields or use a tuple instead of the struct,\nit'll still not compile.</p>\n<p>Implementing <code class=\"hljs\">Drop</code> lets the <code class=\"hljs\">Inspector</code> execute some arbitrary code during its\ndeath. This means it can potentially observe that types that are supposed to\nlive as long as it does actually were destroyed first.</p>\n<p>Interestingly, only generic types need to worry about this. If they aren't\ngeneric, then the only lifetimes they can harbor are <code class=\"hljs\">'static</code>, which will truly\nlive <em>forever</em>. This is why this problem is referred to as <em>sound generic drop</em>.\nSound generic drop is enforced by the <em>drop checker</em>. As of this writing, some\nof the finer details of how the drop checker (also called dropck) validates\ntypes is totally up in the air. However The Big Rule is the subtlety that we\nhave focused on this whole section:</p>\n<p><strong>For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it.</strong></p>\n<p>Obeying this rule is (usually) necessary to satisfy the borrow\nchecker; obeying it is sufficient but not necessary to be\nsound. That is, if your type obeys this rule then it's definitely\nsound to drop.</p>\n<p>The reason that it is not always necessary to satisfy the above rule\nis that some Drop implementations will not access borrowed data even\nthough their type gives them the capability for such access, or because we know\nthe specific drop order and the borrowed data is still fine even if the borrow\nchecker doesn't know that.</p>\n<p>For example, this variant of the above <code class=\"hljs\">Inspector</code> example will never\naccess borrowed data:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust compile_fail edition2021 hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inspector</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">u8</span>, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);\n\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Inspector&lt;<span class=\"hljs-symbol\">'a</span>&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Inspector(_, {}) knows when *not* to inspect.\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">1</span>);\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">World</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; {\n    inspector: <span class=\"hljs-built_in\">Option</span>&lt;Inspector&lt;<span class=\"hljs-symbol\">'a</span>&gt;&gt;,\n    days: <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt;,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> world = World {\n        inspector: <span class=\"hljs-literal\">None</span>,\n        days: <span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">1</span>),\n    };\n    world.inspector = <span class=\"hljs-literal\">Some</span>(Inspector(&amp;world.days, <span class=\"hljs-string\">\"gadget\"</span>));\n    <span class=\"hljs-comment\">// Let's say `days` happens to get dropped first.</span>\n    <span class=\"hljs-comment\">// Even when Inspector is dropped, its destructor will not access the</span>\n    <span class=\"hljs-comment\">// borrowed `days`.</span>\n}</code></pre></pre>\n<p>Likewise, this variant will also never access borrowed data:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust compile_fail edition2021 hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inspector</span></span>&lt;T&gt;(T, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Inspector&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Inspector(_, {}) knows when *not* to inspect.\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">1</span>);\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">World</span></span>&lt;T&gt; {\n    inspector: <span class=\"hljs-built_in\">Option</span>&lt;Inspector&lt;T&gt;&gt;,\n    days: <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt;,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> world = World {\n        inspector: <span class=\"hljs-literal\">None</span>,\n        days: <span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">1</span>),\n    };\n    world.inspector = <span class=\"hljs-literal\">Some</span>(Inspector(&amp;world.days, <span class=\"hljs-string\">\"gadget\"</span>));\n    <span class=\"hljs-comment\">// Let's say `days` happens to get dropped first.</span>\n    <span class=\"hljs-comment\">// Even when Inspector is dropped, its destructor will not access the</span>\n    <span class=\"hljs-comment\">// borrowed `days`.</span>\n}</code></pre></pre>\n<p>However, <em>both</em> of the above variants are rejected by the borrow\nchecker during the analysis of <code class=\"hljs\">fn main</code>, saying that <code class=\"hljs\">days</code> does not\nlive long enough.</p>\n<p>The reason is that the borrow checking analysis of <code class=\"hljs\">main</code> does not\nknow about the internals of each <code class=\"hljs\">Inspector</code>'s <code class=\"hljs\">Drop</code> implementation. As\nfar as the borrow checker knows while it is analyzing <code class=\"hljs\">main</code>, the body\nof an inspector's destructor might access that borrowed data.</p>\n<p>Therefore, the drop checker forces all borrowed data in a value to\nstrictly outlive that value.</p>\n<h2 id=\"an-escape-hatch\"><a class=\"header\" href=\"#an-escape-hatch\">An Escape Hatch</a></h2>\n<p>The precise rules that govern drop checking may be less restrictive in\nthe future.</p>\n<p>The current analysis is deliberately conservative and trivial; it forces all\nborrowed data in a value to outlive that value, which is certainly sound.</p>\n<p>Future versions of the language may make the analysis more precise, to\nreduce the number of cases where sound code is rejected as unsafe.\nThis would help address cases such as the two <code class=\"hljs\">Inspector</code>s above that\nknow not to inspect during destruction.</p>\n<p>In the meantime, there is an unstable attribute that one can use to\nassert (unsafely) that a generic type's destructor is <em>guaranteed</em> to\nnot access any expired data, even if its type gives it the capability\nto do so.</p>\n<p>That attribute is called <code class=\"hljs\">may_dangle</code> and was introduced in <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\">RFC 1327</a>.\nTo deploy it on the <code class=\"hljs\">Inspector</code> from above, we would write:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-meta\">#![feature(dropck_eyepatch)]</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inspector</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">u8</span>, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);\n\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-meta\">#[may_dangle]</span> <span class=\"hljs-symbol\">'a</span>&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Inspector&lt;<span class=\"hljs-symbol\">'a</span>&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Inspector(_, {}) knows when *not* to inspect.\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">1</span>);\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">World</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; {\n    days: <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt;,\n    inspector: <span class=\"hljs-built_in\">Option</span>&lt;Inspector&lt;<span class=\"hljs-symbol\">'a</span>&gt;&gt;,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> world = World {\n        inspector: <span class=\"hljs-literal\">None</span>,\n        days: <span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">1</span>),\n    };\n    world.inspector = <span class=\"hljs-literal\">Some</span>(Inspector(&amp;world.days, <span class=\"hljs-string\">\"gadget\"</span>));\n}</code></pre></pre>\n<p>Use of this attribute requires the <code class=\"hljs\">Drop</code> impl to be marked <code class=\"hljs\">unsafe</code> because the\ncompiler is not checking the implicit assertion that no potentially expired data\n(e.g. <code class=\"hljs\">self.0</code> above) is accessed.</p>\n<p>The attribute can be applied to any number of lifetime and type parameters. In\nthe following example, we assert that we access no data behind a reference of\nlifetime <code class=\"hljs\">'b</code> and that the only uses of <code class=\"hljs\">T</code> will be moves or drops, but omit\nthe attribute from <code class=\"hljs\">'a</code> and <code class=\"hljs\">U</code>, because we do access data with that lifetime\nand that type:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-meta\">#![feature(dropck_eyepatch)]</span>\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::fmt::Display;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inspector</span></span>&lt;<span class=\"hljs-symbol\">'a</span>, <span class=\"hljs-symbol\">'b</span>, T, U: Display&gt;(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">u8</span>, &amp;<span class=\"hljs-symbol\">'b</span> <span class=\"hljs-built_in\">u8</span>, T, U);\n\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>, <span class=\"hljs-meta\">#[may_dangle]</span> <span class=\"hljs-symbol\">'b</span>, <span class=\"hljs-meta\">#[may_dangle]</span> T, U: Display&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Inspector&lt;<span class=\"hljs-symbol\">'a</span>, <span class=\"hljs-symbol\">'b</span>, T, U&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Inspector({}, _, _, {})\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">3</span>);\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>It is sometimes obvious that no such access can occur, like the case above.\nHowever, when dealing with a generic type parameter, such access can\noccur indirectly. Examples of such indirect access are:</p>\n<ul>\n<li>invoking a callback,</li>\n<li>via a trait method call.</li>\n</ul>\n<p>(Future changes to the language, such as impl specialization, may add\nother avenues for such indirect access.)</p>\n<p>Here is an example of invoking a callback:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inspector</span></span>&lt;T&gt;(T, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">for</span> &lt;<span class=\"hljs-symbol\">'r</span>&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(&amp;<span class=\"hljs-symbol\">'r</span> T) -&gt; <span class=\"hljs-built_in\">String</span>&gt;);\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Inspector&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-comment\">// The `self.2` call could access a borrow e.g. if `T` is `&amp;'a _`.</span>\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Inspector({}, {}) unwittingly inspects expired data.\"</span>,\n                 (<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">2</span>)(&amp;<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>), <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">1</span>);\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Here is an example of a trait method call:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::fmt;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inspector</span></span>&lt;T: fmt::Display&gt;(T, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);\n\n<span class=\"hljs-keyword\">impl</span>&lt;T: fmt::Display&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Inspector&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-comment\">// There is a hidden call to `&lt;T as Display&gt;::fmt` below, which</span>\n        <span class=\"hljs-comment\">// could access a borrow e.g. if `T` is `&amp;'a _`</span>\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Inspector({}, {}) unwittingly inspects expired data.\"</span>,\n                 <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">1</span>);\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>And of course, all of these accesses could be further hidden within\nsome other method invoked by the destructor, rather than being written\ndirectly within it.</p>\n<p>In all of the above cases where the <code class=\"hljs\">&amp;'a u8</code> is accessed in the\ndestructor, adding the <code class=\"hljs\">#[may_dangle]</code>\nattribute makes the type vulnerable to misuse that the borrow\nchecker will not catch, inviting havoc. It is better to avoid adding\nthe attribute.</p>\n<h2 id=\"a-related-side-note-about-drop-order\"><a class=\"header\" href=\"#a-related-side-note-about-drop-order\">A related side note about drop order</a></h2>\n<p>While the drop order of fields inside a struct is defined, relying on it is\nfragile and subtle. When the order matters, it is better to use the\n<a href=\"../std/mem/struct.ManuallyDrop.html\"><code class=\"hljs\">ManuallyDrop</code></a> wrapper.</p>\n<h2 id=\"is-that-all-about-drop-checker\"><a class=\"header\" href=\"#is-that-all-about-drop-checker\">Is that all about drop checker?</a></h2>\n<p>It turns out that when writing unsafe code, we generally don't need to\nworry at all about doing the right thing for the drop checker. However there\nis one special case that you need to worry about, which we will look at in\nthe next section.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"subtyping.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"phantom-data.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"subtyping.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"phantom-data.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:13:04.411Z"
}