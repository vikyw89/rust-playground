{
	"title": "std::rc - Rust",
	"url": "https://doc.rust-lang.org/stable/std/rc/index.html",
	"markdown": "# std::rc - Rust\n\n## Module [std](../index.html)::[rc](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/lib.rs.html#247) ·\n\nExpand description\n\nSingle-threaded reference-counting pointers. ‘Rc’ stands for ‘Reference Counted’.\n\nThe type [`Rc<T>`](struct.Rc.html \"struct std::rc::Rc\") provides shared ownership of a value of type `T`, allocated in the heap. Invoking [`clone`](about:blank/clone/trait.Clone.html#tymethod.clone \"method std::clone::Clone::clone\") on [`Rc`](struct.Rc.html \"struct std::rc::Rc\") produces a new pointer to the same allocation in the heap. When the last [`Rc`](struct.Rc.html \"struct std::rc::Rc\") pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as “inner value”) is also dropped.\n\nShared references in Rust disallow mutation by default, and [`Rc`](struct.Rc.html \"struct std::rc::Rc\") is no exception: you cannot generally obtain a mutable reference to something inside an [`Rc`](struct.Rc.html \"struct std::rc::Rc\"). If you need mutability, put a [`Cell`](../cell/struct.Cell.html \"struct std::cell::Cell\") or [`RefCell`](../cell/struct.RefCell.html \"struct std::cell::RefCell\") inside the [`Rc`](struct.Rc.html \"struct std::rc::Rc\"); see [an example of mutability inside an `Rc`](about:blank/cell/index.html#introducing-mutability-inside-of-something-immutable \"mod std::cell\").\n\n[`Rc`](struct.Rc.html \"struct std::rc::Rc\") uses non-atomic reference counting. This means that overhead is very low, but an [`Rc`](struct.Rc.html \"struct std::rc::Rc\") cannot be sent between threads, and consequently [`Rc`](struct.Rc.html \"struct std::rc::Rc\") does not implement [`Send`](../marker/trait.Send.html \"trait std::marker::Send\"). As a result, the Rust compiler will check _at compile time_ that you are not sending [`Rc`](struct.Rc.html \"struct std::rc::Rc\")s between threads. If you need multi-threaded, atomic reference counting, use [`sync::Arc`](../sync/struct.Arc.html \"struct std::sync::Arc\").\n\nThe [`downgrade`](about:blank/struct.Rc.html#method.downgrade \"associated function std::rc::Rc::downgrade\") method can be used to create a non-owning [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointer. A [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointer can be [`upgrade`](about:blank/struct.Weak.html#method.upgrade \"method std::rc::Weak::upgrade\")d to an [`Rc`](struct.Rc.html \"struct std::rc::Rc\"), but this will return [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") if the value stored in the allocation has already been dropped. In other words, `Weak` pointers do not keep the value inside the allocation alive; however, they _do_ keep the allocation (the backing store for the inner value) alive.\n\nA cycle between [`Rc`](struct.Rc.html \"struct std::rc::Rc\") pointers will never be deallocated. For this reason, [`Weak`](struct.Weak.html \"struct std::rc::Weak\") is used to break cycles. For example, a tree could have strong [`Rc`](struct.Rc.html \"struct std::rc::Rc\") pointers from parent nodes to children, and [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointers from children back to their parents.\n\n`Rc<T>` automatically dereferences to `T` (via the [`Deref`](../ops/trait.Deref.html \"trait std::ops::Deref\") trait), so you can call `T`’s methods on a value of type [`Rc<T>`](struct.Rc.html \"struct std::rc::Rc\"). To avoid name clashes with `T`’s methods, the methods of [`Rc<T>`](struct.Rc.html \"struct std::rc::Rc\") itself are associated functions, called using [fully qualified syntax](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name):\n\n```\nuse std::rc::Rc;\n\nlet my_rc = Rc::new(());\nlet my_weak = Rc::downgrade(&my_rc);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+my_rc+=+Rc::new(());%0A++++let+my_weak+=+Rc::downgrade(%26my_rc);%0A%7D&edition=2021)\n\n`Rc<T>`’s implementations of traits like `Clone` may also be called using fully qualified syntax. Some people prefer to use fully qualified syntax, while others prefer using method-call syntax.\n\n```\nuse std::rc::Rc;\n\nlet rc = Rc::new(());\n// Method-call syntax\nlet rc2 = rc.clone();\n// Fully qualified syntax\nlet rc3 = Rc::clone(&rc);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+rc+=+Rc::new(());%0A++++//+Method-call+syntax%0A++++let+rc2+=+rc.clone();%0A++++//+Fully+qualified+syntax%0A++++let+rc3+=+Rc::clone(%26rc);%0A%7D&edition=2021)\n\n[`Weak<T>`](struct.Weak.html \"struct std::rc::Weak\") does not auto-dereference to `T`, because the inner value may have already been dropped.\n\n## [§](#cloning-references)Cloning references\n\nCreating a new reference to the same allocation as an existing reference counted pointer is done using the `Clone` trait implemented for [`Rc<T>`](struct.Rc.html \"struct std::rc::Rc\") and [`Weak<T>`](struct.Weak.html \"struct std::rc::Weak\").\n\n```\nuse std::rc::Rc;\n\nlet foo = Rc::new(vec![1.0, 2.0, 3.0]);\n// The two syntaxes below are equivalent.\nlet a = foo.clone();\nlet b = Rc::clone(&foo);\n// a and b both point to the same memory location as foo.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+foo+=+Rc::new(vec!%5B1.0,+2.0,+3.0%5D);%0A++++//+The+two+syntaxes+below+are+equivalent.%0A++++let+a+=+foo.clone();%0A++++let+b+=+Rc::clone(%26foo);%0A++++//+a+and+b+both+point+to+the+same+memory+location+as+foo.%0A%7D&edition=2021)\n\nThe `Rc::clone(&from)` syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.\n\n## [§](#examples)Examples\n\nConsider a scenario where a set of `Gadget`s are owned by a given `Owner`. We want to have our `Gadget`s point to their `Owner`. We can’t do this with unique ownership, because more than one gadget may belong to the same `Owner`. [`Rc`](struct.Rc.html \"struct std::rc::Rc\") allows us to share an `Owner` between multiple `Gadget`s, and have the `Owner` remain allocated as long as any `Gadget` points at it.\n\n```\nuse std::rc::Rc;\n\nstruct Owner {\n    name: String,\n    // ...other fields\n}\n\nstruct Gadget {\n    id: i32,\n    owner: Rc<Owner>,\n    // ...other fields\n}\n\nfn main() {\n    // Create a reference-counted `Owner`.\n    let gadget_owner: Rc<Owner> = Rc::new(\n        Owner {\n            name: \"Gadget Man\".to_string(),\n        }\n    );\n\n    // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n    // gives us a new pointer to the same `Owner` allocation, incrementing\n    // the reference count in the process.\n    let gadget1 = Gadget {\n        id: 1,\n        owner: Rc::clone(&gadget_owner),\n    };\n    let gadget2 = Gadget {\n        id: 2,\n        owner: Rc::clone(&gadget_owner),\n    };\n\n    // Dispose of our local variable `gadget_owner`.\n    drop(gadget_owner);\n\n    // Despite dropping `gadget_owner`, we're still able to print out the name\n    // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n    // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n    // other `Rc<Owner>` pointing at the same `Owner` allocation, it will remain\n    // live. The field projection `gadget1.owner.name` works because\n    // `Rc<Owner>` automatically dereferences to `Owner`.\n    println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n    println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n\n    // At the end of the function, `gadget1` and `gadget2` are destroyed, and\n    // with them the last counted references to our `Owner`. Gadget Man now\n    // gets destroyed as well.\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::rc::Rc;%0A%0Astruct+Owner+%7B%0A++++name:+String,%0A++++//+...other+fields%0A%7D%0A%0Astruct+Gadget+%7B%0A++++id:+i32,%0A++++owner:+Rc%3COwner%3E,%0A++++//+...other+fields%0A%7D%0A%0Afn+main()+%7B%0A++++//+Create+a+reference-counted+%60Owner%60.%0A++++let+gadget_owner:+Rc%3COwner%3E+=+Rc::new(%0A++++++++Owner+%7B%0A++++++++++++name:+%22Gadget+Man%22.to_string(),%0A++++++++%7D%0A++++);%0A%0A++++//+Create+%60Gadget%60s+belonging+to+%60gadget_owner%60.+Cloning+the+%60Rc%3COwner%3E%60%0A++++//+gives+us+a+new+pointer+to+the+same+%60Owner%60+allocation,+incrementing%0A++++//+the+reference+count+in+the+process.%0A++++let+gadget1+=+Gadget+%7B%0A++++++++id:+1,%0A++++++++owner:+Rc::clone(%26gadget_owner),%0A++++%7D;%0A++++let+gadget2+=+Gadget+%7B%0A++++++++id:+2,%0A++++++++owner:+Rc::clone(%26gadget_owner),%0A++++%7D;%0A%0A++++//+Dispose+of+our+local+variable+%60gadget_owner%60.%0A++++drop(gadget_owner);%0A%0A++++//+Despite+dropping+%60gadget_owner%60,+we%27re+still+able+to+print+out+the+name%0A++++//+of+the+%60Owner%60+of+the+%60Gadget%60s.+This+is+because+we%27ve+only+dropped+a%0A++++//+single+%60Rc%3COwner%3E%60,+not+the+%60Owner%60+it+points+to.+As+long+as+there+are%0A++++//+other+%60Rc%3COwner%3E%60+pointing+at+the+same+%60Owner%60+allocation,+it+will+remain%0A++++//+live.+The+field+projection+%60gadget1.owner.name%60+works+because%0A++++//+%60Rc%3COwner%3E%60+automatically+dereferences+to+%60Owner%60.%0A++++println!(%22Gadget+%7B%7D+owned+by+%7B%7D%22,+gadget1.id,+gadget1.owner.name);%0A++++println!(%22Gadget+%7B%7D+owned+by+%7B%7D%22,+gadget2.id,+gadget2.owner.name);%0A%0A++++//+At+the+end+of+the+function,+%60gadget1%60+and+%60gadget2%60+are+destroyed,+and%0A++++//+with+them+the+last+counted+references+to+our+%60Owner%60.+Gadget+Man+now%0A++++//+gets+destroyed+as+well.%0A%7D&edition=2021)\n\nIf our requirements change, and we also need to be able to traverse from `Owner` to `Gadget`, we will run into problems. An [`Rc`](struct.Rc.html \"struct std::rc::Rc\") pointer from `Owner` to `Gadget` introduces a cycle. This means that their reference counts can never reach 0, and the allocation will never be destroyed: a memory leak. In order to get around this, we can use [`Weak`](struct.Weak.html \"struct std::rc::Weak\") pointers.\n\nRust actually makes it somewhat difficult to produce this loop in the first place. In order to end up with two values that point at each other, one of them needs to be mutable. This is difficult because [`Rc`](struct.Rc.html \"struct std::rc::Rc\") enforces memory safety by only giving out shared references to the value it wraps, and these don’t allow direct mutation. We need to wrap the part of the value we wish to mutate in a [`RefCell`](../cell/struct.RefCell.html \"struct std::cell::RefCell\"), which provides _interior mutability_: a method to achieve mutability through a shared reference. [`RefCell`](../cell/struct.RefCell.html \"struct std::cell::RefCell\") enforces Rust’s borrowing rules at runtime.\n\n```\nuse std::rc::Rc;\nuse std::rc::Weak;\nuse std::cell::RefCell;\n\nstruct Owner {\n    name: String,\n    gadgets: RefCell<Vec<Weak<Gadget>>>,\n    // ...other fields\n}\n\nstruct Gadget {\n    id: i32,\n    owner: Rc<Owner>,\n    // ...other fields\n}\n\nfn main() {\n    // Create a reference-counted `Owner`. Note that we've put the `Owner`'s\n    // vector of `Gadget`s inside a `RefCell` so that we can mutate it through\n    // a shared reference.\n    let gadget_owner: Rc<Owner> = Rc::new(\n        Owner {\n            name: \"Gadget Man\".to_string(),\n            gadgets: RefCell::new(vec![]),\n        }\n    );\n\n    // Create `Gadget`s belonging to `gadget_owner`, as before.\n    let gadget1 = Rc::new(\n        Gadget {\n            id: 1,\n            owner: Rc::clone(&gadget_owner),\n        }\n    );\n    let gadget2 = Rc::new(\n        Gadget {\n            id: 2,\n            owner: Rc::clone(&gadget_owner),\n        }\n    );\n\n    // Add the `Gadget`s to their `Owner`.\n    {\n        let mut gadgets = gadget_owner.gadgets.borrow_mut();\n        gadgets.push(Rc::downgrade(&gadget1));\n        gadgets.push(Rc::downgrade(&gadget2));\n\n        // `RefCell` dynamic borrow ends here.\n    }\n\n    // Iterate over our `Gadget`s, printing their details out.\n    for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n\n        // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n        // guarantee the allocation still exists, we need to call\n        // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n        //\n        // In this case we know the allocation still exists, so we simply\n        // `unwrap` the `Option`. In a more complicated program, you might\n        // need graceful error handling for a `None` result.\n\n        let gadget = gadget_weak.upgrade().unwrap();\n        println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n    }\n\n    // At the end of the function, `gadget_owner`, `gadget1`, and `gadget2`\n    // are destroyed. There are now no strong (`Rc`) pointers to the\n    // gadgets, so they are destroyed. This zeroes the reference count on\n    // Gadget Man, so he gets destroyed as well.\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::rc::Rc;%0Ause+std::rc::Weak;%0Ause+std::cell::RefCell;%0A%0Astruct+Owner+%7B%0A++++name:+String,%0A++++gadgets:+RefCell%3CVec%3CWeak%3CGadget%3E%3E%3E,%0A++++//+...other+fields%0A%7D%0A%0Astruct+Gadget+%7B%0A++++id:+i32,%0A++++owner:+Rc%3COwner%3E,%0A++++//+...other+fields%0A%7D%0A%0Afn+main()+%7B%0A++++//+Create+a+reference-counted+%60Owner%60.+Note+that+we%27ve+put+the+%60Owner%60%27s%0A++++//+vector+of+%60Gadget%60s+inside+a+%60RefCell%60+so+that+we+can+mutate+it+through%0A++++//+a+shared+reference.%0A++++let+gadget_owner:+Rc%3COwner%3E+=+Rc::new(%0A++++++++Owner+%7B%0A++++++++++++name:+%22Gadget+Man%22.to_string(),%0A++++++++++++gadgets:+RefCell::new(vec!%5B%5D),%0A++++++++%7D%0A++++);%0A%0A++++//+Create+%60Gadget%60s+belonging+to+%60gadget_owner%60,+as+before.%0A++++let+gadget1+=+Rc::new(%0A++++++++Gadget+%7B%0A++++++++++++id:+1,%0A++++++++++++owner:+Rc::clone(%26gadget_owner),%0A++++++++%7D%0A++++);%0A++++let+gadget2+=+Rc::new(%0A++++++++Gadget+%7B%0A++++++++++++id:+2,%0A++++++++++++owner:+Rc::clone(%26gadget_owner),%0A++++++++%7D%0A++++);%0A%0A++++//+Add+the+%60Gadget%60s+to+their+%60Owner%60.%0A++++%7B%0A++++++++let+mut+gadgets+=+gadget_owner.gadgets.borrow_mut();%0A++++++++gadgets.push(Rc::downgrade(%26gadget1));%0A++++++++gadgets.push(Rc::downgrade(%26gadget2));%0A%0A++++++++//+%60RefCell%60+dynamic+borrow+ends+here.%0A++++%7D%0A%0A++++//+Iterate+over+our+%60Gadget%60s,+printing+their+details+out.%0A++++for+gadget_weak+in+gadget_owner.gadgets.borrow().iter()+%7B%0A%0A++++++++//+%60gadget_weak%60+is+a+%60Weak%3CGadget%3E%60.+Since+%60Weak%60+pointers+can%27t%0A++++++++//+guarantee+the+allocation+still+exists,+we+need+to+call%0A++++++++//+%60upgrade%60,+which+returns+an+%60Option%3CRc%3CGadget%3E%3E%60.%0A++++++++//%0A++++++++//+In+this+case+we+know+the+allocation+still+exists,+so+we+simply%0A++++++++//+%60unwrap%60+the+%60Option%60.+In+a+more+complicated+program,+you+might%0A++++++++//+need+graceful+error+handling+for+a+%60None%60+result.%0A%0A++++++++let+gadget+=+gadget_weak.upgrade().unwrap();%0A++++++++println!(%22Gadget+%7B%7D+owned+by+%7B%7D%22,+gadget.id,+gadget.owner.name);%0A++++%7D%0A%0A++++//+At+the+end+of+the+function,+%60gadget_owner%60,+%60gadget1%60,+and+%60gadget2%60%0A++++//+are+destroyed.+There+are+now+no+strong+(%60Rc%60)+pointers+to+the%0A++++//+gadgets,+so+they+are+destroyed.+This+zeroes+the+reference+count+on%0A++++//+Gadget+Man,+so+he+gets+destroyed+as+well.%0A%7D&edition=2021)\n\n-   A single-threaded reference-counting pointer. ‘Rc’ stands for ‘Reference Counted’.\n    \n-   `Weak` is a version of [`Rc`](struct.Rc.html \"struct std::rc::Rc\") that holds a non-owning reference to the managed allocation. The allocation is accessed by calling [`upgrade`](about:blank/struct.Weak.html#method.upgrade \"method std::rc::Weak::upgrade\") on the `Weak` pointer, which returns an `[Option](../option/enum.Option.html \"enum std::option::Option\")<[Rc](struct.Rc.html \"struct std::rc::Rc\")<T>>`.\n    \n-   A uniquely owned `Rc`",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Single-threaded reference-counting pointers. ‘Rc’ stands for ‘Reference Counted’.\"><title>std::rc - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module rc</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module rc</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">rc</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/lib.rs.html#247\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Single-threaded reference-counting pointers. ‘Rc’ stands for ‘Reference\nCounted’.</p>\n<p>The type <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc&lt;T&gt;</code></a> provides shared ownership of a value of type <code>T</code>,\nallocated in the heap. Invoking <a href=\"../clone/trait.Clone.html#tymethod.clone\" title=\"method std::clone::Clone::clone\"><code>clone</code></a> on <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> produces a new\npointer to the same allocation in the heap. When the last <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> pointer to a\ngiven allocation is destroyed, the value stored in that allocation (often\nreferred to as “inner value”) is also dropped.</p>\n<p>Shared references in Rust disallow mutation by default, and <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a>\nis no exception: you cannot generally obtain a mutable reference to\nsomething inside an <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a>. If you need mutability, put a <a href=\"../cell/struct.Cell.html\" title=\"struct std::cell::Cell\"><code>Cell</code></a>\nor <a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell</code></a> inside the <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a>; see <a href=\"../cell/index.html#introducing-mutability-inside-of-something-immutable\" title=\"mod std::cell\">an example of mutability\ninside an <code>Rc</code></a>.</p>\n<p><a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> uses non-atomic reference counting. This means that overhead is very\nlow, but an <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> cannot be sent between threads, and consequently <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a>\ndoes not implement <a href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\"><code>Send</code></a>. As a result, the Rust compiler\nwill check <em>at compile time</em> that you are not sending <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a>s between\nthreads. If you need multi-threaded, atomic reference counting, use\n<a href=\"../sync/struct.Arc.html\" title=\"struct std::sync::Arc\"><code>sync::Arc</code></a>.</p>\n<p>The <a href=\"struct.Rc.html#method.downgrade\" title=\"associated function std::rc::Rc::downgrade\"><code>downgrade</code></a> method can be used to create a non-owning\n<a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointer. A <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointer can be <a href=\"struct.Weak.html#method.upgrade\" title=\"method std::rc::Weak::upgrade\"><code>upgrade</code></a>d\nto an <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a>, but this will return <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> if the value stored in the allocation has\nalready been dropped. In other words, <code>Weak</code> pointers do not keep the value\ninside the allocation alive; however, they <em>do</em> keep the allocation\n(the backing store for the inner value) alive.</p>\n<p>A cycle between <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> pointers will never be deallocated. For this reason,\n<a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> is used to break cycles. For example, a tree could have strong\n<a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> pointers from parent nodes to children, and <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a> pointers from\nchildren back to their parents.</p>\n<p><code>Rc&lt;T&gt;</code> automatically dereferences to <code>T</code> (via the <a href=\"../ops/trait.Deref.html\" title=\"trait std::ops::Deref\"><code>Deref</code></a> trait),\nso you can call <code>T</code>’s methods on a value of type <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc&lt;T&gt;</code></a>. To avoid name\nclashes with <code>T</code>’s methods, the methods of <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc&lt;T&gt;</code></a> itself are associated\nfunctions, called using <a href=\"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\">fully qualified syntax</a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>my_rc = Rc::new(());\n<span class=\"kw\">let </span>my_weak = Rc::downgrade(<span class=\"kw-2\">&amp;</span>my_rc);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+my_rc+=+Rc::new(());%0A++++let+my_weak+=+Rc::downgrade(%26my_rc);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><code>Rc&lt;T&gt;</code>’s implementations of traits like <code>Clone</code> may also be called using\nfully qualified syntax. Some people prefer to use fully qualified syntax,\nwhile others prefer using method-call syntax.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>rc = Rc::new(());\n<span class=\"comment\">// Method-call syntax\n</span><span class=\"kw\">let </span>rc2 = rc.clone();\n<span class=\"comment\">// Fully qualified syntax\n</span><span class=\"kw\">let </span>rc3 = Rc::clone(<span class=\"kw-2\">&amp;</span>rc);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+rc+=+Rc::new(());%0A++++//+Method-call+syntax%0A++++let+rc2+=+rc.clone();%0A++++//+Fully+qualified+syntax%0A++++let+rc3+=+Rc::clone(%26rc);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak&lt;T&gt;</code></a> does not auto-dereference to <code>T</code>, because the inner value may have\nalready been dropped.</p>\n<h2 id=\"cloning-references\"><a class=\"doc-anchor\" href=\"#cloning-references\">§</a>Cloning references</h2>\n<p>Creating a new reference to the same allocation as an existing reference counted pointer\nis done using the <code>Clone</code> trait implemented for <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc&lt;T&gt;</code></a> and <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak&lt;T&gt;</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">let </span>foo = Rc::new(<span class=\"macro\">vec!</span>[<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>]);\n<span class=\"comment\">// The two syntaxes below are equivalent.\n</span><span class=\"kw\">let </span>a = foo.clone();\n<span class=\"kw\">let </span>b = Rc::clone(<span class=\"kw-2\">&amp;</span>foo);\n<span class=\"comment\">// a and b both point to the same memory location as foo.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++%0A++++let+foo+=+Rc::new(vec!%5B1.0,+2.0,+3.0%5D);%0A++++//+The+two+syntaxes+below+are+equivalent.%0A++++let+a+=+foo.clone();%0A++++let+b+=+Rc::clone(%26foo);%0A++++//+a+and+b+both+point+to+the+same+memory+location+as+foo.%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The <code>Rc::clone(&amp;from)</code> syntax is the most idiomatic because it conveys more explicitly\nthe meaning of the code. In the example above, this syntax makes it easier to see that\nthis code is creating a new reference rather than copying the whole content of foo.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>Consider a scenario where a set of <code>Gadget</code>s are owned by a given <code>Owner</code>.\nWe want to have our <code>Gadget</code>s point to their <code>Owner</code>. We can’t do this with\nunique ownership, because more than one gadget may belong to the same\n<code>Owner</code>. <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> allows us to share an <code>Owner</code> between multiple <code>Gadget</code>s,\nand have the <code>Owner</code> remain allocated as long as any <code>Gadget</code> points at it.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">struct </span>Owner {\n    name: String,\n    <span class=\"comment\">// ...other fields\n</span>}\n\n<span class=\"kw\">struct </span>Gadget {\n    id: i32,\n    owner: Rc&lt;Owner&gt;,\n    <span class=\"comment\">// ...other fields\n</span>}\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"comment\">// Create a reference-counted `Owner`.\n    </span><span class=\"kw\">let </span>gadget_owner: Rc&lt;Owner&gt; = Rc::new(\n        Owner {\n            name: <span class=\"string\">\"Gadget Man\"</span>.to_string(),\n        }\n    );\n\n    <span class=\"comment\">// Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc&lt;Owner&gt;`\n    // gives us a new pointer to the same `Owner` allocation, incrementing\n    // the reference count in the process.\n    </span><span class=\"kw\">let </span>gadget1 = Gadget {\n        id: <span class=\"number\">1</span>,\n        owner: Rc::clone(<span class=\"kw-2\">&amp;</span>gadget_owner),\n    };\n    <span class=\"kw\">let </span>gadget2 = Gadget {\n        id: <span class=\"number\">2</span>,\n        owner: Rc::clone(<span class=\"kw-2\">&amp;</span>gadget_owner),\n    };\n\n    <span class=\"comment\">// Dispose of our local variable `gadget_owner`.\n    </span>drop(gadget_owner);\n\n    <span class=\"comment\">// Despite dropping `gadget_owner`, we're still able to print out the name\n    // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n    // single `Rc&lt;Owner&gt;`, not the `Owner` it points to. As long as there are\n    // other `Rc&lt;Owner&gt;` pointing at the same `Owner` allocation, it will remain\n    // live. The field projection `gadget1.owner.name` works because\n    // `Rc&lt;Owner&gt;` automatically dereferences to `Owner`.\n    </span><span class=\"macro\">println!</span>(<span class=\"string\">\"Gadget {} owned by {}\"</span>, gadget1.id, gadget1.owner.name);\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"Gadget {} owned by {}\"</span>, gadget2.id, gadget2.owner.name);\n\n    <span class=\"comment\">// At the end of the function, `gadget1` and `gadget2` are destroyed, and\n    // with them the last counted references to our `Owner`. Gadget Man now\n    // gets destroyed as well.\n</span>}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::rc::Rc;%0A%0Astruct+Owner+%7B%0A++++name:+String,%0A++++//+...other+fields%0A%7D%0A%0Astruct+Gadget+%7B%0A++++id:+i32,%0A++++owner:+Rc%3COwner%3E,%0A++++//+...other+fields%0A%7D%0A%0Afn+main()+%7B%0A++++//+Create+a+reference-counted+%60Owner%60.%0A++++let+gadget_owner:+Rc%3COwner%3E+=+Rc::new(%0A++++++++Owner+%7B%0A++++++++++++name:+%22Gadget+Man%22.to_string(),%0A++++++++%7D%0A++++);%0A%0A++++//+Create+%60Gadget%60s+belonging+to+%60gadget_owner%60.+Cloning+the+%60Rc%3COwner%3E%60%0A++++//+gives+us+a+new+pointer+to+the+same+%60Owner%60+allocation,+incrementing%0A++++//+the+reference+count+in+the+process.%0A++++let+gadget1+=+Gadget+%7B%0A++++++++id:+1,%0A++++++++owner:+Rc::clone(%26gadget_owner),%0A++++%7D;%0A++++let+gadget2+=+Gadget+%7B%0A++++++++id:+2,%0A++++++++owner:+Rc::clone(%26gadget_owner),%0A++++%7D;%0A%0A++++//+Dispose+of+our+local+variable+%60gadget_owner%60.%0A++++drop(gadget_owner);%0A%0A++++//+Despite+dropping+%60gadget_owner%60,+we're+still+able+to+print+out+the+name%0A++++//+of+the+%60Owner%60+of+the+%60Gadget%60s.+This+is+because+we've+only+dropped+a%0A++++//+single+%60Rc%3COwner%3E%60,+not+the+%60Owner%60+it+points+to.+As+long+as+there+are%0A++++//+other+%60Rc%3COwner%3E%60+pointing+at+the+same+%60Owner%60+allocation,+it+will+remain%0A++++//+live.+The+field+projection+%60gadget1.owner.name%60+works+because%0A++++//+%60Rc%3COwner%3E%60+automatically+dereferences+to+%60Owner%60.%0A++++println!(%22Gadget+%7B%7D+owned+by+%7B%7D%22,+gadget1.id,+gadget1.owner.name);%0A++++println!(%22Gadget+%7B%7D+owned+by+%7B%7D%22,+gadget2.id,+gadget2.owner.name);%0A%0A++++//+At+the+end+of+the+function,+%60gadget1%60+and+%60gadget2%60+are+destroyed,+and%0A++++//+with+them+the+last+counted+references+to+our+%60Owner%60.+Gadget+Man+now%0A++++//+gets+destroyed+as+well.%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If our requirements change, and we also need to be able to traverse from\n<code>Owner</code> to&nbsp;<code>Gadget</code>, we will run into problems. An <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> pointer from <code>Owner</code>\nto <code>Gadget</code> introduces a cycle. This means that their\nreference counts can never reach 0, and the allocation will never be destroyed:\na memory leak. In order to get around this, we can use <a href=\"struct.Weak.html\" title=\"struct std::rc::Weak\"><code>Weak</code></a>\npointers.</p>\n<p>Rust actually makes it somewhat difficult to produce this loop in the first\nplace. In order to end up with two values that point at each other, one of\nthem needs to be mutable. This is difficult because <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> enforces\nmemory safety by only giving out shared references to the value it wraps,\nand these don’t allow direct mutation. We need to wrap the part of the\nvalue we wish to mutate in a <a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell</code></a>, which provides <em>interior\nmutability</em>: a method to achieve mutability through a shared reference.\n<a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell</code></a> enforces Rust’s borrowing rules at runtime.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::rc::Rc;\n<span class=\"kw\">use </span>std::rc::Weak;\n<span class=\"kw\">use </span>std::cell::RefCell;\n\n<span class=\"kw\">struct </span>Owner {\n    name: String,\n    gadgets: RefCell&lt;Vec&lt;Weak&lt;Gadget&gt;&gt;&gt;,\n    <span class=\"comment\">// ...other fields\n</span>}\n\n<span class=\"kw\">struct </span>Gadget {\n    id: i32,\n    owner: Rc&lt;Owner&gt;,\n    <span class=\"comment\">// ...other fields\n</span>}\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"comment\">// Create a reference-counted `Owner`. Note that we've put the `Owner`'s\n    // vector of `Gadget`s inside a `RefCell` so that we can mutate it through\n    // a shared reference.\n    </span><span class=\"kw\">let </span>gadget_owner: Rc&lt;Owner&gt; = Rc::new(\n        Owner {\n            name: <span class=\"string\">\"Gadget Man\"</span>.to_string(),\n            gadgets: RefCell::new(<span class=\"macro\">vec!</span>[]),\n        }\n    );\n\n    <span class=\"comment\">// Create `Gadget`s belonging to `gadget_owner`, as before.\n    </span><span class=\"kw\">let </span>gadget1 = Rc::new(\n        Gadget {\n            id: <span class=\"number\">1</span>,\n            owner: Rc::clone(<span class=\"kw-2\">&amp;</span>gadget_owner),\n        }\n    );\n    <span class=\"kw\">let </span>gadget2 = Rc::new(\n        Gadget {\n            id: <span class=\"number\">2</span>,\n            owner: Rc::clone(<span class=\"kw-2\">&amp;</span>gadget_owner),\n        }\n    );\n\n    <span class=\"comment\">// Add the `Gadget`s to their `Owner`.\n    </span>{\n        <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>gadgets = gadget_owner.gadgets.borrow_mut();\n        gadgets.push(Rc::downgrade(<span class=\"kw-2\">&amp;</span>gadget1));\n        gadgets.push(Rc::downgrade(<span class=\"kw-2\">&amp;</span>gadget2));\n\n        <span class=\"comment\">// `RefCell` dynamic borrow ends here.\n    </span>}\n\n    <span class=\"comment\">// Iterate over our `Gadget`s, printing their details out.\n    </span><span class=\"kw\">for </span>gadget_weak <span class=\"kw\">in </span>gadget_owner.gadgets.borrow().iter() {\n\n        <span class=\"comment\">// `gadget_weak` is a `Weak&lt;Gadget&gt;`. Since `Weak` pointers can't\n        // guarantee the allocation still exists, we need to call\n        // `upgrade`, which returns an `Option&lt;Rc&lt;Gadget&gt;&gt;`.\n        //\n        // In this case we know the allocation still exists, so we simply\n        // `unwrap` the `Option`. In a more complicated program, you might\n        // need graceful error handling for a `None` result.\n\n        </span><span class=\"kw\">let </span>gadget = gadget_weak.upgrade().unwrap();\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"Gadget {} owned by {}\"</span>, gadget.id, gadget.owner.name);\n    }\n\n    <span class=\"comment\">// At the end of the function, `gadget_owner`, `gadget1`, and `gadget2`\n    // are destroyed. There are now no strong (`Rc`) pointers to the\n    // gadgets, so they are destroyed. This zeroes the reference count on\n    // Gadget Man, so he gets destroyed as well.\n</span>}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::rc::Rc;%0Ause+std::rc::Weak;%0Ause+std::cell::RefCell;%0A%0Astruct+Owner+%7B%0A++++name:+String,%0A++++gadgets:+RefCell%3CVec%3CWeak%3CGadget%3E%3E%3E,%0A++++//+...other+fields%0A%7D%0A%0Astruct+Gadget+%7B%0A++++id:+i32,%0A++++owner:+Rc%3COwner%3E,%0A++++//+...other+fields%0A%7D%0A%0Afn+main()+%7B%0A++++//+Create+a+reference-counted+%60Owner%60.+Note+that+we've+put+the+%60Owner%60's%0A++++//+vector+of+%60Gadget%60s+inside+a+%60RefCell%60+so+that+we+can+mutate+it+through%0A++++//+a+shared+reference.%0A++++let+gadget_owner:+Rc%3COwner%3E+=+Rc::new(%0A++++++++Owner+%7B%0A++++++++++++name:+%22Gadget+Man%22.to_string(),%0A++++++++++++gadgets:+RefCell::new(vec!%5B%5D),%0A++++++++%7D%0A++++);%0A%0A++++//+Create+%60Gadget%60s+belonging+to+%60gadget_owner%60,+as+before.%0A++++let+gadget1+=+Rc::new(%0A++++++++Gadget+%7B%0A++++++++++++id:+1,%0A++++++++++++owner:+Rc::clone(%26gadget_owner),%0A++++++++%7D%0A++++);%0A++++let+gadget2+=+Rc::new(%0A++++++++Gadget+%7B%0A++++++++++++id:+2,%0A++++++++++++owner:+Rc::clone(%26gadget_owner),%0A++++++++%7D%0A++++);%0A%0A++++//+Add+the+%60Gadget%60s+to+their+%60Owner%60.%0A++++%7B%0A++++++++let+mut+gadgets+=+gadget_owner.gadgets.borrow_mut();%0A++++++++gadgets.push(Rc::downgrade(%26gadget1));%0A++++++++gadgets.push(Rc::downgrade(%26gadget2));%0A%0A++++++++//+%60RefCell%60+dynamic+borrow+ends+here.%0A++++%7D%0A%0A++++//+Iterate+over+our+%60Gadget%60s,+printing+their+details+out.%0A++++for+gadget_weak+in+gadget_owner.gadgets.borrow().iter()+%7B%0A%0A++++++++//+%60gadget_weak%60+is+a+%60Weak%3CGadget%3E%60.+Since+%60Weak%60+pointers+can't%0A++++++++//+guarantee+the+allocation+still+exists,+we+need+to+call%0A++++++++//+%60upgrade%60,+which+returns+an+%60Option%3CRc%3CGadget%3E%3E%60.%0A++++++++//%0A++++++++//+In+this+case+we+know+the+allocation+still+exists,+so+we+simply%0A++++++++//+%60unwrap%60+the+%60Option%60.+In+a+more+complicated+program,+you+might%0A++++++++//+need+graceful+error+handling+for+a+%60None%60+result.%0A%0A++++++++let+gadget+=+gadget_weak.upgrade().unwrap();%0A++++++++println!(%22Gadget+%7B%7D+owned+by+%7B%7D%22,+gadget.id,+gadget.owner.name);%0A++++%7D%0A%0A++++//+At+the+end+of+the+function,+%60gadget_owner%60,+%60gadget1%60,+and+%60gadget2%60%0A++++//+are+destroyed.+There+are+now+no+strong+(%60Rc%60)+pointers+to+the%0A++++//+gadgets,+so+they+are+destroyed.+This+zeroes+the+reference+count+on%0A++++//+Gadget+Man,+so+he+gets+destroyed+as+well.%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a></div><div class=\"desc docblock-short\">A single-threaded reference-counting pointer. ‘Rc’ stands for ‘Reference\nCounted’.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Weak.html\" title=\"struct std::rc::Weak\">Weak</a></div><div class=\"desc docblock-short\"><code>Weak</code> is a version of <a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc</code></a> that holds a non-owning reference to the\nmanaged allocation. The allocation is accessed by calling <a href=\"struct.Weak.html#method.upgrade\" title=\"method std::rc::Weak::upgrade\"><code>upgrade</code></a> on the <code>Weak</code>\npointer, which returns an <code><a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T&gt;&gt;</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.UniqueRc.html\" title=\"struct std::rc::UniqueRc\">UniqueRc</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">A uniquely owned <code>Rc</code></div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:06.505Z"
}