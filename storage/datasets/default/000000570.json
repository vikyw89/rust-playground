{
	"title": "Arc in std::sync - Rust",
	"url": "https://doc.rust-lang.org/stable/std/sync/struct.Arc.html",
	"markdown": "# Arc in std::sync - Rust\n\n## Struct [std](../index.html)::[sync](index.html)::[Arc](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#246-249) ·\n\n```\npub struct Arc<T, A = Global>where\n    A: Allocator,\n    T: ?Sized,{ /* private fields */ }\n```\n\nExpand description\n\nA thread-safe reference-counting pointer. ‘Arc’ stands for ‘Atomically Reference Counted’.\n\nThe type `Arc<T>` provides shared ownership of a value of type `T`, allocated in the heap. Invoking [`clone`](about:blank/clone/trait.Clone.html#tymethod.clone \"method std::clone::Clone::clone\") on `Arc` produces a new `Arc` instance, which points to the same allocation on the heap as the source `Arc`, while increasing a reference count. When the last `Arc` pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as “inner value”) is also dropped.\n\nShared references in Rust disallow mutation by default, and `Arc` is no exception: you cannot generally obtain a mutable reference to something inside an `Arc`. If you need to mutate through an `Arc`, use [`Mutex`](../../std/sync/struct.Mutex.html), [`RwLock`](../../std/sync/struct.RwLock.html), or one of the [`Atomic`](atomic/index.html \"mod std::sync::atomic\") types.\n\n**Note**: This type is only available on platforms that support atomic loads and stores of pointers, which includes all platforms that support the `std` crate but not all those which only support [`alloc`](https://doc.rust-lang.org/1.80.0/alloc/index.html \"mod alloc\"). This may be detected at compile time using `#[cfg(target_has_atomic = \"ptr\")]`.\n\n### [§](#thread-safety)Thread Safety\n\nUnlike [`Rc<T>`](../rc/struct.Rc.html \"struct std::rc::Rc\"), `Arc<T>` uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted allocations between threads, consider using [`Rc<T>`](../rc/struct.Rc.html \"struct std::rc::Rc\") for lower overhead. [`Rc<T>`](../rc/struct.Rc.html \"struct std::rc::Rc\") is a safe default, because the compiler will catch any attempt to send an [`Rc<T>`](../rc/struct.Rc.html \"struct std::rc::Rc\") between threads. However, a library might choose `Arc<T>` in order to give library consumers more flexibility.\n\n`Arc<T>` will implement [`Send`](../marker/trait.Send.html \"trait std::marker::Send\") and [`Sync`](../marker/trait.Sync.html \"trait std::marker::Sync\") as long as the `T` implements [`Send`](../marker/trait.Send.html \"trait std::marker::Send\") and [`Sync`](../marker/trait.Sync.html \"trait std::marker::Sync\"). Why can’t you put a non-thread-safe type `T` in an `Arc<T>` to make it thread-safe? This may be a bit counter-intuitive at first: after all, isn’t the point of `Arc<T>` thread safety? The key is this: `Arc<T>` makes it thread safe to have multiple ownership of the same data, but it doesn’t add thread safety to its data. Consider `Arc<[RefCell<T>](../cell/struct.RefCell.html \"struct std::cell::RefCell\")>`. [`RefCell<T>`](../cell/struct.RefCell.html \"struct std::cell::RefCell\") isn’t [`Sync`](../marker/trait.Sync.html \"trait std::marker::Sync\"), and if `Arc<T>` was always [`Send`](../marker/trait.Send.html \"trait std::marker::Send\"), `Arc<[RefCell<T>](../cell/struct.RefCell.html \"struct std::cell::RefCell\")>` would be as well. But then we’d have a problem: [`RefCell<T>`](../cell/struct.RefCell.html \"struct std::cell::RefCell\") is not thread safe; it keeps track of the borrowing count using non-atomic operations.\n\nIn the end, this means that you may need to pair `Arc<T>` with some sort of [`std::sync`](../../std/sync/index.html) type, usually [`Mutex<T>`](../../std/sync/struct.Mutex.html).\n\n### [§](#breaking-cycles-with-weak)Breaking cycles with `Weak`\n\nThe [`downgrade`](about:blank/struct.Arc.html#method.downgrade \"associated function std::sync::Arc::downgrade\") method can be used to create a non-owning [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointer. A [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointer can be [`upgrade`](about:blank/struct.Weak.html#method.upgrade \"method std::sync::Weak::upgrade\")d to an `Arc`, but this will return [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") if the value stored in the allocation has already been dropped. In other words, `Weak` pointers do not keep the value inside the allocation alive; however, they _do_ keep the allocation (the backing store for the value) alive.\n\nA cycle between `Arc` pointers will never be deallocated. For this reason, [`Weak`](struct.Weak.html \"struct std::sync::Weak\") is used to break cycles. For example, a tree could have strong `Arc` pointers from parent nodes to children, and [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointers from children back to their parents.\n\n## [§](#cloning-references)Cloning references\n\nCreating a new reference from an existing reference-counted pointer is done using the `Clone` trait implemented for [`Arc<T>`](struct.Arc.html \"struct std::sync::Arc\") and [`Weak<T>`](struct.Weak.html \"struct std::sync::Weak\").\n\n```\nuse std::sync::Arc;\nlet foo = Arc::new(vec![1.0, 2.0, 3.0]);\n// The two syntaxes below are equivalent.\nlet a = foo.clone();\nlet b = Arc::clone(&foo);\n// a, b, and foo are all Arcs that point to the same memory location\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+foo+=+Arc::new(vec!%5B1.0,+2.0,+3.0%5D);%0A++++//+The+two+syntaxes+below+are+equivalent.%0A++++let+a+=+foo.clone();%0A++++let+b+=+Arc::clone(%26foo);%0A++++//+a,+b,+and+foo+are+all+Arcs+that+point+to+the+same+memory+location%0A%7D&edition=2021)\n\n### [§](#deref-behavior)`Deref` behavior\n\n`Arc<T>` automatically dereferences to `T` (via the [`Deref`](../ops/trait.Deref.html \"trait std::ops::Deref\") trait), so you can call `T`’s methods on a value of type `Arc<T>`. To avoid name clashes with `T`’s methods, the methods of `Arc<T>` itself are associated functions, called using [fully qualified syntax](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name):\n\n```\nuse std::sync::Arc;\n\nlet my_arc = Arc::new(());\nlet my_weak = Arc::downgrade(&my_arc);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+my_arc+=+Arc::new(());%0A++++let+my_weak+=+Arc::downgrade(%26my_arc);%0A%7D&edition=2021)\n\n`Arc<T>`’s implementations of traits like `Clone` may also be called using fully qualified syntax. Some people prefer to use fully qualified syntax, while others prefer using method-call syntax.\n\n```\nuse std::sync::Arc;\n\nlet arc = Arc::new(());\n// Method-call syntax\nlet arc2 = arc.clone();\n// Fully qualified syntax\nlet arc3 = Arc::clone(&arc);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+arc+=+Arc::new(());%0A++++//+Method-call+syntax%0A++++let+arc2+=+arc.clone();%0A++++//+Fully+qualified+syntax%0A++++let+arc3+=+Arc::clone(%26arc);%0A%7D&edition=2021)\n\n[`Weak<T>`](struct.Weak.html \"struct std::sync::Weak\") does not auto-dereference to `T`, because the inner value may have already been dropped.\n\n## [§](#examples)Examples\n\nSharing some immutable data between threads:\n\n```\nuse std::sync::Arc;\nuse std::thread;\n\nlet five = Arc::new(5);\n\nfor _ in 0..10 {\n    let five = Arc::clone(&five);\n\n    thread::spawn(move || {\n        println!(\"{five:?}\");\n    });\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::thread;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++for+_+in+0..10+%7B%0A++++++++let+five+=+Arc::clone(%26five);%0A++++%0A++++++++thread::spawn(move+%7C%7C+%7B%0A++++++++++++println!(%22%7Bfive:?%7D%22);%0A++++++++%7D);%0A++++%7D%0A%7D&edition=2021)\n\nSharing a mutable [`AtomicUsize`](atomic/struct.AtomicUsize.html \"sync::atomic::AtomicUsize\"):\n\n```\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::thread;\n\nlet val = Arc::new(AtomicUsize::new(5));\n\nfor _ in 0..10 {\n    let val = Arc::clone(&val);\n\n    thread::spawn(move || {\n        let v = val.fetch_add(1, Ordering::Relaxed);\n        println!(\"{v:?}\");\n    });\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::sync::atomic::%7BAtomicUsize,+Ordering%7D;%0A++++use+std::thread;%0A++++%0A++++let+val+=+Arc::new(AtomicUsize::new(5));%0A++++%0A++++for+_+in+0..10+%7B%0A++++++++let+val+=+Arc::clone(%26val);%0A++++%0A++++++++thread::spawn(move+%7C%7C+%7B%0A++++++++++++let+v+=+val.fetch_add(1,+Ordering::Relaxed);%0A++++++++++++println!(%22%7Bv:?%7D%22);%0A++++++++%7D);%0A++++%7D%0A%7D&edition=2021)\n\nSee the [`rc` documentation](about:blank/rc/index.html#examples \"mod std::rc\") for more examples of reference counting in general.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#377)[§](#impl-Arc%3CT%3E)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#390)\n\nConstructs a new `Arc<T>`.\n\n##### [§](#examples-1)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A%7D&edition=2021)\n\n1.60.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#455-457)\n\nConstructs a new `Arc<T>` while giving you a `Weak<T>` to the allocation, to allow you to construct a `T` which holds a weak pointer to itself.\n\nGenerally, a structure circularly referencing itself, either directly or indirectly, should not hold a strong reference to itself to prevent a memory leak. Using this function, you get access to the weak pointer during the initialization of `T`, before the `Arc<T>` is created, such that you can clone and store it inside the `T`.\n\n`new_cyclic` first allocates the managed allocation for the `Arc<T>`, then calls your closure, giving it a `Weak<T>` to this allocation, and only afterwards completes the construction of the `Arc<T>` by placing the `T` returned from your closure into the allocation.\n\nSince the new `Arc<T>` is not fully-constructed until `Arc<T>::new_cyclic` returns, calling [`upgrade`](about:blank/struct.Weak.html#method.upgrade \"method std::sync::Weak::upgrade\") on the weak reference inside your closure will fail and result in a `None` value.\n\n##### [§](#panics)Panics\n\nIf `data_fn` panics, the panic is propagated to the caller, and the temporary [`Weak<T>`](struct.Weak.html \"struct std::sync::Weak\") is dropped normally.\n\n##### [§](#example)Example\n\n```\nuse std::sync::{Arc, Weak};\n\nstruct Gadget {\n    me: Weak<Gadget>,\n}\n\nimpl Gadget {\n    /// Construct a reference counted Gadget.\n    fn new() -> Arc<Self> {\n        // `me` is a `Weak<Gadget>` pointing at the new allocation of the\n        // `Arc` we're constructing.\n        Arc::new_cyclic(|me| {\n            // Create the actual struct here.\n            Gadget { me: me.clone() }\n        })\n    }\n\n    /// Return a reference counted pointer to Self.\n    fn me(&self) -> Arc<Self> {\n        self.me.upgrade().unwrap()\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Weak%7D;%0A++++%0A++++struct+Gadget+%7B%0A++++++++me:+Weak%3CGadget%3E,%0A++++%7D%0A++++%0A++++impl+Gadget+%7B%0A++++++++///+Construct+a+reference+counted+Gadget.%0A++++++++fn+new()+-%3E+Arc%3CSelf%3E+%7B%0A++++++++++++//+%60me%60+is+a+%60Weak%3CGadget%3E%60+pointing+at+the+new+allocation+of+the%0A++++++++++++//+%60Arc%60+we%27re+constructing.%0A++++++++++++Arc::new_cyclic(%7Cme%7C+%7B%0A++++++++++++++++//+Create+the+actual+struct+here.%0A++++++++++++++++Gadget+%7B+me:+me.clone()+%7D%0A++++++++++++%7D)%0A++++++++%7D%0A++++%0A++++++++///+Return+a+reference+counted+pointer+to+Self.%0A++++++++fn+me(%26self)+-%3E+Arc%3CSelf%3E+%7B%0A++++++++++++self.me.upgrade().unwrap()%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#532)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new `Arc` with uninitialized contents.\n\n##### [§](#examples-2)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::sync::Arc;\n\nlet mut five = Arc::<u32>::new_uninit();\n\n// Deferred initialization:\nArc::get_mut(&mut five).unwrap().write(5);\n\nlet five = unsafe { five.assume_init() };\n\nassert_eq!(*five, 5)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32%3E::new_uninit();%0A++++%0A++++//+Deferred+initialization:%0A++++Arc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#566)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new `Arc` with uninitialized contents, with the memory being filled with `0` bytes.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [§](#examples-3)Examples\n\n```\n#![feature(new_uninit)]\n\nuse std::sync::Arc;\n\nlet zero = Arc::<u32>::new_zeroed();\nlet zero = unsafe { zero.assume_init() };\n\nassert_eq!(*zero, 0)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+zero+=+Arc::%3Cu32%3E::new_zeroed();%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0)%0A%7D&version=nightly&edition=2021)\n\n1.33.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#581)\n\nConstructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then `data` will be pinned in memory and unable to be moved.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#588)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Pin<Arc<T>>`, return an error if allocation fails.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#605)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Arc<T>`, returning an error if allocation fails.\n\n##### [§](#examples-4)Examples\n\n```\n#![feature(allocator_api)]\nuse std::sync::Arc;\n\nlet five = Arc::try_new(5)?;\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::try_new(5)?;%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#639)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Arc` with uninitialized contents, returning an error if allocation fails.\n\n##### [§](#examples-5)Examples\n\n```\n#![feature(new_uninit, allocator_api)]\n#![feature(get_mut_unchecked)]\n\nuse std::sync::Arc;\n\nlet mut five = Arc::<u32>::try_new_uninit()?;\n\n// Deferred initialization:\nArc::get_mut(&mut five).unwrap().write(5);\n\nlet five = unsafe { five.assume_init() };\n\nassert_eq!(*five, 5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit,+allocator_api)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32%3E::try_new_uninit()?;%0A++++%0A++++//+Deferred+initialization:%0A++++Arc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#672)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Arc` with uninitialized contents, with the memory being filled with `0` bytes, returning an error if allocation fails.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [§](#examples-6)Examples\n\n```\n#![feature(new_uninit, allocator_api)]\n\nuse std::sync::Arc;\n\nlet zero = Arc::<u32>::try_new_zeroed()?;\nlet zero = unsafe { zero.assume_init() };\n\nassert_eq!(*zero, 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit,+allocator_api)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+zero+=+Arc::%3Cu32%3E::try_new_zeroed()?;%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#683)[§](#impl-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#691)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nReturns a reference to the underlying allocator.\n\nNote: this is an associated function, which means that you have to call it as `Arc::allocator(&a)` instead of `a.allocator()`. This is so that there is no conflict with a method on the inner type.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#709)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Arc<T>` in the provided allocator.\n\n##### [§](#examples-7)Examples\n\n```\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet five = Arc::new_in(5, System);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Arc::new_in(5,+System);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#751)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Arc` with uninitialized contents in the provided allocator.\n\n##### [§](#examples-8)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet mut five = Arc::<u32, _>::new_uninit_in(System);\n\nlet five = unsafe {\n    // Deferred initialization:\n    Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n\n    five.assume_init()\n};\n\nassert_eq!(*five, 5)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32,+_%3E::new_uninit_in(System);%0A++++%0A++++let+five+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Arc::get_mut_unchecked(%26mut+five).as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#790)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Arc` with uninitialized contents, with the memory being filled with `0` bytes, in the provided allocator.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [§](#examples-9)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet zero = Arc::<u32, _>::new_zeroed_in(System);\nlet zero = unsafe { zero.assume_init() };\n\nassert_eq!(*zero, 0)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+zero+=+Arc::%3Cu32,+_%3E::new_zeroed_in(System);%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#808-810)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Pin<Arc<T, A>>` in the provided allocator. If `T` does not implement `Unpin`, then `data` will be pinned in memory and unable to be moved.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#819-821)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Pin<Arc<T, A>>` in the provided allocator, return an error if allocation fails.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#842)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Arc<T, A>` in the provided allocator, returning an error if allocation fails.\n\n##### [§](#examples-10)Examples\n\n```\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet five = Arc::try_new_in(5, System)?;\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Arc::try_new_in(5,+System)?;%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#884)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Arc` with uninitialized contents, in the provided allocator, returning an error if allocation fails.\n\n##### [§](#examples-11)Examples\n\n```\n#![feature(new_uninit, allocator_api)]\n#![feature(get_mut_unchecked)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet mut five = Arc::<u32, _>::try_new_uninit_in(System)?;\n\nlet five = unsafe {\n    // Deferred initialization:\n    Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n\n    five.assume_init()\n};\n\nassert_eq!(*five, 5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit,+allocator_api)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32,+_%3E::try_new_uninit_in(System)?;%0A++++%0A++++let+five+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Arc::get_mut_unchecked(%26mut+five).as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#923)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs a new `Arc` with uninitialized contents, with the memory being filled with `0` bytes, in the provided allocator, returning an error if allocation fails.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [§](#examples-12)Examples\n\n```\n#![feature(new_uninit, allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet zero = Arc::<u32, _>::try_new_zeroed_in(System)?;\nlet zero = unsafe { zero.assume_init() };\n\nassert_eq!(*zero, 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit,+allocator_api)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+zero+=+Arc::%3Cu32,+_%3E::try_new_zeroed_in(System)?;%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&version=nightly&edition=2021)\n\n1.4.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#967)\n\nReturns the inner value, if the `Arc` has exactly one strong reference.\n\nOtherwise, an [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") is returned with the same `Arc` that was passed in.\n\nThis will succeed even if there are outstanding weak references.\n\nIt is strongly recommended to use [`Arc::into_inner`](about:blank/struct.Arc.html#method.into_inner \"associated function std::sync::Arc::into_inner\") instead if you don’t want to keep the `Arc` in the [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") case. Immediately dropping the [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") payload, like in the expression `Arc::try_unwrap(this).ok()`, can still cause the strong count to drop to zero and the inner value of the `Arc` to be dropped: For instance if two threads each execute this expression in parallel, then there is a race condition. The threads could first both check whether they have the last clone of their `Arc` via `Arc::try_unwrap`, and then both drop their `Arc` in the call to [`ok`](about:blank/result/enum.Result.html#method.ok \"method std::result::Result::ok\"), taking the strong count from two down to zero.\n\n##### [§](#examples-13)Examples\n\n```\nuse std::sync::Arc;\n\nlet x = Arc::new(3);\nassert_eq!(Arc::try_unwrap(x), Ok(3));\n\nlet x = Arc::new(4);\nlet _y = Arc::clone(&x);\nassert_eq!(*Arc::try_unwrap(x).unwrap_err(), 4);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(3);%0A++++assert_eq!(Arc::try_unwrap(x),+Ok(3));%0A++++%0A++++let+x+=+Arc::new(4);%0A++++let+_y+=+Arc::clone(%26x);%0A++++assert_eq!(*Arc::try_unwrap(x).unwrap_err(),+4);%0A%7D&edition=2021)\n\n1.70.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1084)\n\nReturns the inner value, if the `Arc` has exactly one strong reference.\n\nOtherwise, [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned and the `Arc` is dropped.\n\nThis will succeed even if there are outstanding weak references.\n\nIf `Arc::into_inner` is called on every clone of this `Arc`, it is guaranteed that exactly one of the calls returns the inner value. This means in particular that the inner value is not dropped.\n\n[`Arc::try_unwrap`](about:blank/struct.Arc.html#method.try_unwrap \"associated function std::sync::Arc::try_unwrap\") is conceptually similar to `Arc::into_inner`, but it is meant for different use-cases. If used as a direct replacement for `Arc::into_inner` anyway, such as with the expression `[Arc::try_unwrap](about:blank/struct.Arc.html#method.try_unwrap \"associated function std::sync::Arc::try_unwrap\")(this).[ok](about:blank/result/enum.Result.html#method.ok \"method std::result::Result::ok\")()`, then it does **not** give the same guarantee as described in the previous paragraph. For more information, see the examples below and read the documentation of [`Arc::try_unwrap`](about:blank/struct.Arc.html#method.try_unwrap \"associated function std::sync::Arc::try_unwrap\").\n\n##### [§](#examples-14)Examples\n\nMinimal example demonstrating the guarantee that `Arc::into_inner` gives.\n\n```\nuse std::sync::Arc;\n\nlet x = Arc::new(3);\nlet y = Arc::clone(&x);\n\n// Two threads calling `Arc::into_inner` on both clones of an `Arc`:\nlet x_thread = std::thread::spawn(|| Arc::into_inner(x));\nlet y_thread = std::thread::spawn(|| Arc::into_inner(y));\n\nlet x_inner_value = x_thread.join().unwrap();\nlet y_inner_value = y_thread.join().unwrap();\n\n// One of the threads is guaranteed to receive the inner value:\nassert!(matches!(\n    (x_inner_value, y_inner_value),\n    (None, Some(3)) | (Some(3), None)\n));\n// The result could also be `(None, None)` if the threads called\n// `Arc::try_unwrap(x).ok()` and `Arc::try_unwrap(y).ok()` instead.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(3);%0A++++let+y+=+Arc::clone(%26x);%0A++++%0A++++//+Two+threads+calling+%60Arc::into_inner%60+on+both+clones+of+an+%60Arc%60:%0A++++let+x_thread+=+std::thread::spawn(%7C%7C+Arc::into_inner(x));%0A++++let+y_thread+=+std::thread::spawn(%7C%7C+Arc::into_inner(y));%0A++++%0A++++let+x_inner_value+=+x_thread.join().unwrap();%0A++++let+y_inner_value+=+y_thread.join().unwrap();%0A++++%0A++++//+One+of+the+threads+is+guaranteed+to+receive+the+inner+value:%0A++++assert!(matches!(%0A++++++++(x_inner_value,+y_inner_value),%0A++++++++(None,+Some(3))+%7C+(Some(3),+None)%0A++++));%0A++++//+The+result+could+also+be+%60(None,+None)%60+if+the+threads+called%0A++++//+%60Arc::try_unwrap(x).ok()%60+and+%60Arc::try_unwrap(y).ok()%60+instead.%0A%7D&edition=2021)\n\nA more practical example demonstrating the need for `Arc::into_inner`:\n\n```\nuse std::sync::Arc;\n\n// Definition of a simple singly linked list using `Arc`:\n#[derive(Clone)]\nstruct LinkedList<T>(Option<Arc<Node<T>>>);\nstruct Node<T>(T, Option<Arc<Node<T>>>);\n\n// Dropping a long `LinkedList<T>` relying on the destructor of `Arc`\n// can cause a stack overflow. To prevent this, we can provide a\n// manual `Drop` implementation that does the destruction in a loop:\nimpl<T> Drop for LinkedList<T> {\n    fn drop(&mut self) {\n        let mut link = self.0.take();\n        while let Some(arc_node) = link.take() {\n            if let Some(Node(_value, next)) = Arc::into_inner(arc_node) {\n                link = next;\n            }\n        }\n    }\n}\n\n// Implementation of `new` and `push` omitted\nimpl<T> LinkedList<T> {\n    /* ... */\n}\n\n// The following code could have still caused a stack overflow\n// despite the manual `Drop` impl if that `Drop` impl had used\n// `Arc::try_unwrap(arc).ok()` instead of `Arc::into_inner(arc)`.\n\n// Create a long list and clone it\nlet mut x = LinkedList::new();\nlet size = 100000;\nfor i in 0..size {\n    x.push(i); // Adds i to the front of x\n}\nlet y = x.clone();\n\n// Drop the clones in parallel\nlet x_thread = std::thread::spawn(|| drop(x));\nlet y_thread = std::thread::spawn(|| drop(y));\nx_thread.join().unwrap();\ny_thread.join().unwrap();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++//+Definition+of+a+simple+singly+linked+list+using+%60Arc%60:%0A++++%23%5Bderive(Clone)%5D%0A++++struct+LinkedList%3CT%3E(Option%3CArc%3CNode%3CT%3E%3E%3E);%0A++++struct+Node%3CT%3E(T,+Option%3CArc%3CNode%3CT%3E%3E%3E);%0A++++%0A++++//+Dropping+a+long+%60LinkedList%3CT%3E%60+relying+on+the+destructor+of+%60Arc%60%0A++++//+can+cause+a+stack+overflow.+To+prevent+this,+we+can+provide+a%0A++++//+manual+%60Drop%60+implementation+that+does+the+destruction+in+a+loop:%0A++++impl%3CT%3E+Drop+for+LinkedList%3CT%3E+%7B%0A++++++++fn+drop(%26mut+self)+%7B%0A++++++++++++let+mut+link+=+self.0.take();%0A++++++++++++while+let+Some(arc_node)+=+link.take()+%7B%0A++++++++++++++++if+let+Some(Node(_value,+next))+=+Arc::into_inner(arc_node)+%7B%0A++++++++++++++++++++link+=+next;%0A++++++++++++++++%7D%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+Implementation+of+%60new%60+and+%60push%60+omitted%0A++++impl%3CT%3E+LinkedList%3CT%3E+%7B%0A++++++++/*+...+*/%0A++++++fn+new()+-%3E+Self+%7B%0A++++++++++LinkedList(None)%0A++++++%7D%0A++++++fn+push(%26mut+self,+x:+T)+%7B%0A++++++++++self.0+=+Some(Arc::new(Node(x,+self.0.take())));%0A++++++%7D%0A++++%7D%0A++++%0A++++//+The+following+code+could+have+still+caused+a+stack+overflow%0A++++//+despite+the+manual+%60Drop%60+impl+if+that+%60Drop%60+impl+had+used%0A++++//+%60Arc::try_unwrap(arc).ok()%60+instead+of+%60Arc::into_inner(arc)%60.%0A++++%0A++++//+Create+a+long+list+and+clone+it%0A++++let+mut+x+=+LinkedList::new();%0A++++let+size+=+100000;%0A++++let+size+=+if+cfg!(miri)+%7B+100+%7D+else+%7B+size+%7D;%0A++++for+i+in+0..size+%7B%0A++++++++x.push(i);+//+Adds+i+to+the+front+of+x%0A++++%7D%0A++++let+y+=+x.clone();%0A++++%0A++++//+Drop+the+clones+in+parallel%0A++++let+x_thread+=+std::thread::spawn(%7C%7C+drop(x));%0A++++let+y_thread+=+std::thread::spawn(%7C%7C+drop(y));%0A++++x_thread.join().unwrap();%0A++++y_thread.join().unwrap();%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1112)[§](#impl-Arc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1139)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new atomically reference-counted slice with uninitialized contents.\n\n##### [§](#examples-15)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::sync::Arc;\n\nlet mut values = Arc::<[u32]>::new_uninit_slice(3);\n\n// Deferred initialization:\nlet data = Arc::get_mut(&mut values).unwrap();\ndata[0].write(1);\ndata[1].write(2);\ndata[2].write(3);\n\nlet values = unsafe { values.assume_init() };\n\nassert_eq!(*values, [1, 2, 3])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+values+=+Arc::%3C%5Bu32%5D%3E::new_uninit_slice(3);%0A++++%0A++++//+Deferred+initialization:%0A++++let+data+=+Arc::get_mut(%26mut+values).unwrap();%0A++++data%5B0%5D.write(1);%0A++++data%5B1%5D.write(2);%0A++++data%5B2%5D.write(3);%0A++++%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1167)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new atomically reference-counted slice with uninitialized contents, with the memory being filled with `0` bytes.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [§](#examples-16)Examples\n\n```\n#![feature(new_uninit)]\n\nuse std::sync::Arc;\n\nlet values = Arc::<[u32]>::new_zeroed_slice(3);\nlet values = unsafe { values.assume_init() };\n\nassert_eq!(*values, [0, 0, 0])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+values+=+Arc::%3C%5Bu32%5D%3E::new_zeroed_slice(3);%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B0,+0,+0%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1181)[§](#impl-Arc%3C%5BT%5D,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1211)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new atomically reference-counted slice with uninitialized contents in the provided allocator.\n\n##### [§](#examples-17)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet mut values = Arc::<[u32], _>::new_uninit_slice_in(3, System);\n\nlet values = unsafe {\n    // Deferred initialization:\n    Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n    Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n    Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n\n    values.assume_init()\n};\n\nassert_eq!(*values, [1, 2, 3])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+values+=+Arc::%3C%5Bu32%5D,+_%3E::new_uninit_slice_in(3,+System);%0A++++%0A++++let+values+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Arc::get_mut_unchecked(%26mut+values)%5B0%5D.as_mut_ptr().write(1);%0A++++++++Arc::get_mut_unchecked(%26mut+values)%5B1%5D.as_mut_ptr().write(2);%0A++++++++Arc::get_mut_unchecked(%26mut+values)%5B2%5D.as_mut_ptr().write(3);%0A++++%0A++++++++values.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1240)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConstructs a new atomically reference-counted slice with uninitialized contents, with the memory being filled with `0` bytes, in the provided allocator.\n\nSee [`MaybeUninit::zeroed`](about:blank/mem/union.MaybeUninit.html#method.zeroed \"associated function std::mem::MaybeUninit::zeroed\") for examples of correct and incorrect usage of this method.\n\n##### [§](#examples-18)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet values = Arc::<[u32], _>::new_zeroed_slice_in(3, System);\nlet values = unsafe { values.assume_init() };\n\nassert_eq!(*values, [0, 0, 0])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+values+=+Arc::%3C%5Bu32%5D,+_%3E::new_zeroed_slice_in(3,+System);%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B0,+0,+0%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1257)[§](#impl-Arc%3CMaybeUninit%3CT%3E,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1290)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConverts to `Arc<T>`.\n\n##### [§](#safety)Safety\n\nAs with [`MaybeUninit::assume_init`](about:blank/mem/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\"), it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.\n\n##### [§](#examples-19)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::sync::Arc;\n\nlet mut five = Arc::<u32>::new_uninit();\n\n// Deferred initialization:\nArc::get_mut(&mut five).unwrap().write(5);\n\nlet five = unsafe { five.assume_init() };\n\nassert_eq!(*five, 5)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32%3E::new_uninit();%0A++++%0A++++//+Deferred+initialization:%0A++++Arc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1296)[§](#impl-Arc%3C%5BMaybeUninit%3CT%3E%5D,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1332)\n\n🔬This is a nightly-only experimental API. (`new_uninit` [#63291](https://github.com/rust-lang/rust/issues/63291))\n\nConverts to `Arc<[T]>`.\n\n##### [§](#safety-1)Safety\n\nAs with [`MaybeUninit::assume_init`](about:blank/mem/union.MaybeUninit.html#method.assume_init \"method std::mem::MaybeUninit::assume_init\"), it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.\n\n##### [§](#examples-20)Examples\n\n```\n#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\nuse std::sync::Arc;\n\nlet mut values = Arc::<[u32]>::new_uninit_slice(3);\n\n// Deferred initialization:\nlet data = Arc::get_mut(&mut values).unwrap();\ndata[0].write(1);\ndata[1].write(2);\ndata[2].write(3);\n\nlet values = unsafe { values.assume_init() };\n\nassert_eq!(*values, [1, 2, 3])\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+values+=+Arc::%3C%5Bu32%5D%3E::new_uninit_slice(3);%0A++++%0A++++//+Deferred+initialization:%0A++++let+data+=+Arc::get_mut(%26mut+values).unwrap();%0A++++data%5B0%5D.write(1);%0A++++data%5B1%5D.write(2);%0A++++data%5B2%5D.write(3);%0A++++%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1338)[§](#impl-Arc%3CT%3E-1)\n\n1.17.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1400)\n\nConstructs an `Arc<T>` from a raw pointer.\n\nThe raw pointer must have been previously returned by a call to [`Arc<U>::into_raw`](about:blank/struct.Arc.html#method.into_raw \"associated function std::sync::Arc::into_raw\") with the following requirements:\n\n-   If `U` is sized, it must have the same size and alignment as `T`. This is trivially true if `U` is `T`.\n-   If `U` is unsized, its data pointer must have the same size and alignment as `T`. This is trivially true if `Arc<U>` was constructed through `Arc<T>` and then converted to `Arc<U>` through an [unsized coercion](https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions).\n\nNote that if `U` or `U`’s data pointer is not `T` but has the same size and alignment, this is basically like transmuting references of different types. See [`mem::transmute`](../mem/fn.transmute.html \"fn std::mem::transmute\") for more information on what restrictions apply in this case.\n\nThe user of `from_raw` has to make sure a specific value of `T` is only dropped once.\n\nThis function is unsafe because improper use may lead to memory unsafety, even if the returned `Arc<T>` is never accessed.\n\n##### [§](#examples-21)Examples\n\n```\nuse std::sync::Arc;\n\nlet x = Arc::new(\"hello\".to_owned());\nlet x_ptr = Arc::into_raw(x);\n\nunsafe {\n    // Convert back to an `Arc` to prevent leak.\n    let x = Arc::from_raw(x_ptr);\n    assert_eq!(&*x, \"hello\");\n\n    // Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n}\n\n// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(%22hello%22.to_owned());%0A++++let+x_ptr+=+Arc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++//+Convert+back+to+an+%60Arc%60+to+prevent+leak.%0A++++++++let+x+=+Arc::from_raw(x_ptr);%0A++++++++assert_eq!(%26*x,+%22hello%22);%0A++++%0A++++++++//+Further+calls+to+%60Arc::from_raw(x_ptr)%60+would+be+memory-unsafe.%0A++++%7D%0A++++%0A++++//+The+memory+was+freed+when+%60x%60+went+out+of+scope+above,+so+%60x_ptr%60+is+now+dangling!%0A%7D&edition=2021)\n\nConvert a slice back into its original array:\n\n```\nuse std::sync::Arc;\n\nlet x: Arc<[u32]> = Arc::new([1, 2, 3]);\nlet x_ptr: *const [u32] = Arc::into_raw(x);\n\nunsafe {\n    let x: Arc<[u32; 3]> = Arc::from_raw(x_ptr.cast::<[u32; 3]>());\n    assert_eq!(&*x, &[1, 2, 3]);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3C%5Bu32%5D%3E+=+Arc::new(%5B1,+2,+3%5D);%0A++++let+x_ptr:+*const+%5Bu32%5D+=+Arc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++let+x:+Arc%3C%5Bu32;+3%5D%3E+=+Arc::from_raw(x_ptr.cast::%3C%5Bu32;+3%5D%3E());%0A++++++++assert_eq!(%26*x,+%26%5B1,+2,+3%5D);%0A++++%7D%0A%7D&edition=2021)\n\n1.51.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1432)\n\nIncrements the strong reference count on the `Arc<T>` associated with the provided pointer by one.\n\n##### [§](#safety-2)Safety\n\nThe pointer must have been obtained through `Arc::into_raw`, and the associated `Arc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method.\n\n##### [§](#examples-22)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nunsafe {\n    let ptr = Arc::into_raw(five);\n    Arc::increment_strong_count(ptr);\n\n    // This assertion is deterministic because we haven't shared\n    // the `Arc` between threads.\n    let five = Arc::from_raw(ptr);\n    assert_eq!(2, Arc::strong_count(&five));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Arc::into_raw(five);%0A++++++++Arc::increment_strong_count(ptr);%0A++++%0A++++++++//+This+assertion+is+deterministic+because+we+haven%27t+shared%0A++++++++//+the+%60Arc%60+between+threads.%0A++++++++let+five+=+Arc::from_raw(ptr);%0A++++++++assert_eq!(2,+Arc::strong_count(%26five));%0A++++%7D%0A%7D&edition=2021)\n\n1.51.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1468)\n\nDecrements the strong reference count on the `Arc<T>` associated with the provided pointer by one.\n\n##### [§](#safety-3)Safety\n\nThe pointer must have been obtained through `Arc::into_raw`, and the associated `Arc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method. This method can be used to release the final `Arc` and backing storage, but **should not** be called after the final `Arc` has been released.\n\n##### [§](#examples-23)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nunsafe {\n    let ptr = Arc::into_raw(five);\n    Arc::increment_strong_count(ptr);\n\n    // Those assertions are deterministic because we haven't shared\n    // the `Arc` between threads.\n    let five = Arc::from_raw(ptr);\n    assert_eq!(2, Arc::strong_count(&five));\n    Arc::decrement_strong_count(ptr);\n    assert_eq!(1, Arc::strong_count(&five));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Arc::into_raw(five);%0A++++++++Arc::increment_strong_count(ptr);%0A++++%0A++++++++//+Those+assertions+are+deterministic+because+we+haven%27t+shared%0A++++++++//+the+%60Arc%60+between+threads.%0A++++++++let+five+=+Arc::from_raw(ptr);%0A++++++++assert_eq!(2,+Arc::strong_count(%26five));%0A++++++++Arc::decrement_strong_count(ptr);%0A++++++++assert_eq!(1,+Arc::strong_count(%26five));%0A++++%7D%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1473)[§](#impl-Arc%3CT,+A%3E-1)\n\n1.17.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1491)\n\nConsumes the `Arc`, returning the wrapped pointer.\n\nTo avoid a memory leak the pointer must be converted back to an `Arc` using [`Arc::from_raw`](about:blank/struct.Arc.html#method.from_raw \"associated function std::sync::Arc::from_raw\").\n\n##### [§](#examples-24)Examples\n\n```\nuse std::sync::Arc;\n\nlet x = Arc::new(\"hello\".to_owned());\nlet x_ptr = Arc::into_raw(x);\nassert_eq!(unsafe { &*x_ptr }, \"hello\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(%22hello%22.to_owned());%0A++++let+x_ptr+=+Arc::into_raw(x);%0A++++assert_eq!(unsafe+%7B+%26*x_ptr+%7D,+%22hello%22);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1517)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConsumes the `Arc`, returning the wrapped pointer and allocator.\n\nTo avoid a memory leak the pointer must be converted back to an `Arc` using [`Arc::from_raw_in`](about:blank/struct.Arc.html#method.from_raw_in \"associated function std::sync::Arc::from_raw_in\").\n\n##### [§](#examples-25)Examples\n\n```\n#![feature(allocator_api)]\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet x = Arc::new_in(\"hello\".to_owned(), System);\nlet (ptr, alloc) = Arc::into_raw_with_allocator(x);\nassert_eq!(unsafe { &*ptr }, \"hello\");\nlet x = unsafe { Arc::from_raw_in(ptr, alloc) };\nassert_eq!(&*x, \"hello\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x+=+Arc::new_in(%22hello%22.to_owned(),+System);%0A++++let+(ptr,+alloc)+=+Arc::into_raw_with_allocator(x);%0A++++assert_eq!(unsafe+%7B+%26*ptr+%7D,+%22hello%22);%0A++++let+x+=+unsafe+%7B+Arc::from_raw_in(ptr,+alloc)+%7D;%0A++++assert_eq!(%26*x,+%22hello%22);%0A%7D&version=nightly&edition=2021)\n\n1.45.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1544)\n\nProvides a raw pointer to the data.\n\nThe counts are not affected in any way and the `Arc` is not consumed. The pointer is valid for as long as there are strong counts in the `Arc`.\n\n##### [§](#examples-26)Examples\n\n```\nuse std::sync::Arc;\n\nlet x = Arc::new(\"hello\".to_owned());\nlet y = Arc::clone(&x);\nlet x_ptr = Arc::as_ptr(&x);\nassert_eq!(x_ptr, Arc::as_ptr(&y));\nassert_eq!(unsafe { &*x_ptr }, \"hello\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(%22hello%22.to_owned());%0A++++let+y+=+Arc::clone(%26x);%0A++++let+x_ptr+=+Arc::as_ptr(%26x);%0A++++assert_eq!(x_ptr,+Arc::as_ptr(%26y));%0A++++assert_eq!(unsafe+%7B+%26*x_ptr+%7D,+%22hello%22);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1622)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nConstructs an `Arc<T, A>` from a raw pointer.\n\nThe raw pointer must have been previously returned by a call to [`Arc<U, A>::into_raw`](about:blank/struct.Arc.html#method.into_raw \"associated function std::sync::Arc::into_raw\") with the following requirements:\n\n-   If `U` is sized, it must have the same size and alignment as `T`. This is trivially true if `U` is `T`.\n-   If `U` is unsized, its data pointer must have the same size and alignment as `T`. This is trivially true if `Arc<U>` was constructed through `Arc<T>` and then converted to `Arc<U>` through an [unsized coercion](https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions).\n\nNote that if `U` or `U`’s data pointer is not `T` but has the same size and alignment, this is basically like transmuting references of different types. See [`mem::transmute`](../mem/fn.transmute.html \"fn std::mem::transmute\") for more information on what restrictions apply in this case.\n\nThe raw pointer must point to a block of memory allocated by `alloc`\n\nThe user of `from_raw` has to make sure a specific value of `T` is only dropped once.\n\nThis function is unsafe because improper use may lead to memory unsafety, even if the returned `Arc<T>` is never accessed.\n\n##### [§](#examples-27)Examples\n\n```\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet x = Arc::new_in(\"hello\".to_owned(), System);\nlet x_ptr = Arc::into_raw(x);\n\nunsafe {\n    // Convert back to an `Arc` to prevent leak.\n    let x = Arc::from_raw_in(x_ptr, System);\n    assert_eq!(&*x, \"hello\");\n\n    // Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n}\n\n// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x+=+Arc::new_in(%22hello%22.to_owned(),+System);%0A++++let+x_ptr+=+Arc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++//+Convert+back+to+an+%60Arc%60+to+prevent+leak.%0A++++++++let+x+=+Arc::from_raw_in(x_ptr,+System);%0A++++++++assert_eq!(%26*x,+%22hello%22);%0A++++%0A++++++++//+Further+calls+to+%60Arc::from_raw(x_ptr)%60+would+be+memory-unsafe.%0A++++%7D%0A++++%0A++++//+The+memory+was+freed+when+%60x%60+went+out+of+scope+above,+so+%60x_ptr%60+is+now+dangling!%0A%7D&version=nightly&edition=2021)\n\nConvert a slice back into its original array:\n\n```\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet x: Arc<[u32], _> = Arc::new_in([1, 2, 3], System);\nlet x_ptr: *const [u32] = Arc::into_raw(x);\n\nunsafe {\n    let x: Arc<[u32; 3], _> = Arc::from_raw_in(x_ptr.cast::<[u32; 3]>(), System);\n    assert_eq!(&*x, &[1, 2, 3]);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x:+Arc%3C%5Bu32%5D,+_%3E+=+Arc::new_in(%5B1,+2,+3%5D,+System);%0A++++let+x_ptr:+*const+%5Bu32%5D+=+Arc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++let+x:+Arc%3C%5Bu32;+3%5D,+_%3E+=+Arc::from_raw_in(x_ptr.cast::%3C%5Bu32;+3%5D%3E(),+System);%0A++++++++assert_eq!(%26*x,+%26%5B1,+2,+3%5D);%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n1.4.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1647-1649)\n\nCreates a new [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointer to this allocation.\n\n##### [§](#examples-28)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nlet weak_five = Arc::downgrade(&five);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++let+weak_five+=+Arc::downgrade(%26five);%0A%7D&edition=2021)\n\n1.15.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1707)\n\nGets the number of [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointers to this allocation.\n\n##### [§](#safety-4)Safety\n\nThis method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result.\n\n##### [§](#examples-29)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\nlet _weak_five = Arc::downgrade(&five);\n\n// This assertion is deterministic because we haven't shared\n// the `Arc` or `Weak` between threads.\nassert_eq!(1, Arc::weak_count(&five));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++let+_weak_five+=+Arc::downgrade(%26five);%0A++++%0A++++//+This+assertion+is+deterministic+because+we+haven%27t+shared%0A++++//+the+%60Arc%60+or+%60Weak%60+between+threads.%0A++++assert_eq!(1,+Arc::weak_count(%26five));%0A%7D&edition=2021)\n\n1.15.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1737)\n\nGets the number of strong (`Arc`) pointers to this allocation.\n\n##### [§](#safety-5)Safety\n\nThis method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result.\n\n##### [§](#examples-30)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\nlet _also_five = Arc::clone(&five);\n\n// This assertion is deterministic because we haven't shared\n// the `Arc` between threads.\nassert_eq!(2, Arc::strong_count(&five));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++let+_also_five+=+Arc::clone(%26five);%0A++++%0A++++//+This+assertion+is+deterministic+because+we+haven%27t+shared%0A++++//+the+%60Arc%60+between+threads.%0A++++assert_eq!(2,+Arc::strong_count(%26five));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1773-1775)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nIncrements the strong reference count on the `Arc<T>` associated with the provided pointer by one.\n\n##### [§](#safety-6)Safety\n\nThe pointer must have been obtained through `Arc::into_raw`, and the associated `Arc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method,, and `ptr` must point to a block of memory allocated by `alloc`.\n\n##### [§](#examples-31)Examples\n\n```\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet five = Arc::new_in(5, System);\n\nunsafe {\n    let ptr = Arc::into_raw(five);\n    Arc::increment_strong_count_in(ptr, System);\n\n    // This assertion is deterministic because we haven't shared\n    // the `Arc` between threads.\n    let five = Arc::from_raw_in(ptr, System);\n    assert_eq!(2, Arc::strong_count(&five));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Arc::new_in(5,+System);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Arc::into_raw(five);%0A++++++++Arc::increment_strong_count_in(ptr,+System);%0A++++%0A++++++++//+This+assertion+is+deterministic+because+we+haven%27t+shared%0A++++++++//+the+%60Arc%60+between+threads.%0A++++++++let+five+=+Arc::from_raw_in(ptr,+System);%0A++++++++assert_eq!(2,+Arc::strong_count(%26five));%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1819)\n\n🔬This is a nightly-only experimental API. (`allocator_api` [#32838](https://github.com/rust-lang/rust/issues/32838))\n\nDecrements the strong reference count on the `Arc<T>` associated with the provided pointer by one.\n\n##### [§](#safety-7)Safety\n\nThe pointer must have been obtained through `Arc::into_raw`, the associated `Arc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method, and `ptr` must point to a block of memory allocated by `alloc`. This method can be used to release the final `Arc` and backing storage, but **should not** be called after the final `Arc` has been released.\n\n##### [§](#examples-32)Examples\n\n```\n#![feature(allocator_api)]\n\nuse std::sync::Arc;\nuse std::alloc::System;\n\nlet five = Arc::new_in(5, System);\n\nunsafe {\n    let ptr = Arc::into_raw(five);\n    Arc::increment_strong_count_in(ptr, System);\n\n    // Those assertions are deterministic because we haven't shared\n    // the `Arc` between threads.\n    let five = Arc::from_raw_in(ptr, System);\n    assert_eq!(2, Arc::strong_count(&five));\n    Arc::decrement_strong_count_in(ptr, System);\n    assert_eq!(1, Arc::strong_count(&five));\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Arc::new_in(5,+System);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Arc::into_raw(five);%0A++++++++Arc::increment_strong_count_in(ptr,+System);%0A++++%0A++++++++//+Those+assertions+are+deterministic+because+we+haven%27t+shared%0A++++++++//+the+%60Arc%60+between+threads.%0A++++++++let+five+=+Arc::from_raw_in(ptr,+System);%0A++++++++assert_eq!(2,+Arc::strong_count(%26five));%0A++++++++Arc::decrement_strong_count_in(ptr,+System);%0A++++++++assert_eq!(1,+Arc::strong_count(%26five));%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n1.17.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1867)\n\nReturns `true` if the two `Arc`s point to the same allocation in a vein similar to [`ptr::eq`](../ptr/fn.eq.html \"ptr::eq\"). This function ignores the metadata of `dyn Trait` pointers.\n\n##### [§](#examples-33)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\nlet same_five = Arc::clone(&five);\nlet other_five = Arc::new(5);\n\nassert!(Arc::ptr_eq(&five, &same_five));\nassert!(!Arc::ptr_eq(&five, &other_five));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++let+same_five+=+Arc::clone(%26five);%0A++++let+other_five+=+Arc::new(5);%0A++++%0A++++assert!(Arc::ptr_eq(%26five,+%26same_five));%0A++++assert!(!Arc::ptr_eq(%26five,+%26other_five));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2150)[§](#impl-Arc%3CT,+A%3E-2)\n\n1.4.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2204)\n\nMakes a mutable reference into the given `Arc`.\n\nIf there are other `Arc` pointers to the same allocation, then `make_mut` will [`clone`](about:blank/clone/trait.Clone.html#tymethod.clone \"method std::clone::Clone::clone\") the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.\n\nHowever, if there are no other `Arc` pointers to this allocation, but some [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointers, then the [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointers will be dissociated and the inner value will not be cloned.\n\nSee also [`get_mut`](about:blank/struct.Arc.html#method.get_mut \"associated function std::sync::Arc::get_mut\"), which will fail rather than cloning the inner value or dissociating [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointers.\n\n##### [§](#examples-34)Examples\n\n```\nuse std::sync::Arc;\n\nlet mut data = Arc::new(5);\n\n*Arc::make_mut(&mut data) += 1;         // Won't clone anything\nlet mut other_data = Arc::clone(&data); // Won't clone inner data\n*Arc::make_mut(&mut data) += 1;         // Clones inner data\n*Arc::make_mut(&mut data) += 1;         // Won't clone anything\n*Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n\n// Now `data` and `other_data` point to different allocations.\nassert_eq!(*data, 8);\nassert_eq!(*other_data, 12);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+data+=+Arc::new(5);%0A++++%0A++++*Arc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Won%27t+clone+anything%0A++++let+mut+other_data+=+Arc::clone(%26data);+//+Won%27t+clone+inner+data%0A++++*Arc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Clones+inner+data%0A++++*Arc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Won%27t+clone+anything%0A++++*Arc::make_mut(%26mut+other_data)+*=+2;+++//+Won%27t+clone+anything%0A++++%0A++++//+Now+%60data%60+and+%60other_data%60+point+to+different+allocations.%0A++++assert_eq!(*data,+8);%0A++++assert_eq!(*other_data,+12);%0A%7D&edition=2021)\n\n[`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointers will be dissociated:\n\n```\nuse std::sync::Arc;\n\nlet mut data = Arc::new(75);\nlet weak = Arc::downgrade(&data);\n\nassert!(75 == *data);\nassert!(75 == *weak.upgrade().unwrap());\n\n*Arc::make_mut(&mut data) += 1;\n\nassert!(76 == *data);\nassert!(weak.upgrade().is_none());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+data+=+Arc::new(75);%0A++++let+weak+=+Arc::downgrade(%26data);%0A++++%0A++++assert!(75+==+*data);%0A++++assert!(75+==+*weak.upgrade().unwrap());%0A++++%0A++++*Arc::make_mut(%26mut+data)+%2B=+1;%0A++++%0A++++assert!(76+==+*data);%0A++++assert!(weak.upgrade().is_none());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2258)[§](#impl-Arc%3CT,+A%3E-3)\n\n1.76.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2289)\n\nIf we have the only reference to `T` then unwrap it. Otherwise, clone `T` and return the clone.\n\nAssuming `arc_t` is of type `Arc<T>`, this function is functionally equivalent to `(*arc_t).clone()`, but will avoid cloning the inner value where possible.\n\n##### [§](#examples-35)Examples\n\n```\nlet inner = String::from(\"test\");\nlet ptr = inner.as_ptr();\n\nlet arc = Arc::new(inner);\nlet inner = Arc::unwrap_or_clone(arc);\n// The inner value was not cloned\nassert!(ptr::eq(ptr, inner.as_ptr()));\n\nlet arc = Arc::new(inner);\nlet arc2 = arc.clone();\nlet inner = Arc::unwrap_or_clone(arc);\n// Because there were 2 references, we had to clone the inner value.\nassert!(!ptr::eq(ptr, inner.as_ptr()));\n// `arc2` is the last reference, so when we unwrap it we get back\n// the original `String`.\nlet inner = Arc::unwrap_or_clone(arc2);\nassert!(ptr::eq(ptr, inner.as_ptr()));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bptr,+sync::Arc%7D;%0A++++let+inner+=+String::from(%22test%22);%0A++++let+ptr+=+inner.as_ptr();%0A++++%0A++++let+arc+=+Arc::new(inner);%0A++++let+inner+=+Arc::unwrap_or_clone(arc);%0A++++//+The+inner+value+was+not+cloned%0A++++assert!(ptr::eq(ptr,+inner.as_ptr()));%0A++++%0A++++let+arc+=+Arc::new(inner);%0A++++let+arc2+=+arc.clone();%0A++++let+inner+=+Arc::unwrap_or_clone(arc);%0A++++//+Because+there+were+2+references,+we+had+to+clone+the+inner+value.%0A++++assert!(!ptr::eq(ptr,+inner.as_ptr()));%0A++++//+%60arc2%60+is+the+last+reference,+so+when+we+unwrap+it+we+get+back%0A++++//+the+original+%60String%60.%0A++++let+inner+=+Arc::unwrap_or_clone(arc2);%0A++++assert!(ptr::eq(ptr,+inner.as_ptr()));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2294)[§](#impl-Arc%3CT,+A%3E-4)\n\n1.4.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2321)\n\nReturns a mutable reference into the given `Arc`, if there are no other `Arc` or [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointers to the same allocation.\n\nReturns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") otherwise, because it is not safe to mutate a shared value.\n\nSee also [`make_mut`](about:blank/struct.Arc.html#method.make_mut \"associated function std::sync::Arc::make_mut\"), which will [`clone`](about:blank/clone/trait.Clone.html#tymethod.clone \"method std::clone::Clone::clone\") the inner value when there are other `Arc` pointers.\n\n##### [§](#examples-36)Examples\n\n```\nuse std::sync::Arc;\n\nlet mut x = Arc::new(3);\n*Arc::get_mut(&mut x).unwrap() = 4;\nassert_eq!(*x, 4);\n\nlet _y = Arc::clone(&x);\nassert!(Arc::get_mut(&mut x).is_none());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+x+=+Arc::new(3);%0A++++*Arc::get_mut(%26mut+x).unwrap()+=+4;%0A++++assert_eq!(*x,+4);%0A++++%0A++++let+_y+=+Arc::clone(%26x);%0A++++assert!(Arc::get_mut(%26mut+x).is_none());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2396)\n\n🔬This is a nightly-only experimental API. (`get_mut_unchecked` [#63292](https://github.com/rust-lang/rust/issues/63292))\n\nReturns a mutable reference into the given `Arc`, without any check.\n\nSee also [`get_mut`](about:blank/struct.Arc.html#method.get_mut \"associated function std::sync::Arc::get_mut\"), which is safe and does appropriate checks.\n\n##### [§](#safety-8)Safety\n\nIf any other `Arc` or [`Weak`](struct.Weak.html \"struct std::sync::Weak\") pointers to the same allocation exist, then they must not be dereferenced or have active borrows for the duration of the returned borrow, and their inner type must be exactly the same as the inner type of this Rc (including lifetimes). This is trivially the case if no such pointers exist, for example immediately after `Arc::new`.\n\n##### [§](#examples-37)Examples\n\n```\n#![feature(get_mut_unchecked)]\n\nuse std::sync::Arc;\n\nlet mut x = Arc::new(String::new());\nunsafe {\n    Arc::get_mut_unchecked(&mut x).push_str(\"foo\")\n}\nassert_eq!(*x, \"foo\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+x+=+Arc::new(String::new());%0A++++unsafe+%7B%0A++++++++Arc::get_mut_unchecked(%26mut+x).push_str(%22foo%22)%0A++++%7D%0A++++assert_eq!(*x,+%22foo%22);%0A%7D&version=nightly&edition=2021)\n\nOther `Arc` pointers to the same allocation must be to the same type.\n\n```\n#![feature(get_mut_unchecked)]\n\nuse std::sync::Arc;\n\nlet x: Arc<str> = Arc::from(\"Hello, world!\");\nlet mut y: Arc<[u8]> = x.clone().into();\nunsafe {\n    // this is Undefined Behavior, because x's inner type is str, not [u8]\n    Arc::get_mut_unchecked(&mut y).fill(0xff); // 0xff is invalid in UTF-8\n}\nprintln!(\"{}\", &*x); // Invalid UTF-8 in a str\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3Cstr%3E+=+Arc::from(%22Hello,+world!%22);%0A++++let+mut+y:+Arc%3C%5Bu8%5D%3E+=+x.clone().into();%0A++++unsafe+%7B%0A++++++++//+this+is+Undefined+Behavior,+because+x%27s+inner+type+is+str,+not+%5Bu8%5D%0A++++++++Arc::get_mut_unchecked(%26mut+y).fill(0xff);+//+0xff+is+invalid+in+UTF-8%0A++++%7D%0A++++println!(%22%7B%7D%22,+%26*x);+//+Invalid+UTF-8+in+a+str%0A%7D&version=nightly&edition=2021)\n\nOther `Arc` pointers to the same allocation must be to the exact same type, including lifetimes.\n\n```\n#![feature(get_mut_unchecked)]\n\nuse std::sync::Arc;\n\nlet x: Arc<&str> = Arc::new(\"Hello, world!\");\n{\n    let s = String::from(\"Oh, no!\");\n    let mut y: Arc<&str> = x.clone().into();\n    unsafe {\n        // this is Undefined Behavior, because x's inner type\n        // is &'long str, not &'short str\n        *Arc::get_mut_unchecked(&mut y) = &s;\n    }\n}\nprintln!(\"{}\", &*x); // Use-after-free\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3C%26str%3E+=+Arc::new(%22Hello,+world!%22);%0A++++%7B%0A++++++++let+s+=+String::from(%22Oh,+no!%22);%0A++++++++let+mut+y:+Arc%3C%26str%3E+=+x.clone().into();%0A++++++++unsafe+%7B%0A++++++++++++//+this+is+Undefined+Behavior,+because+x%27s+inner+type%0A++++++++++++//+is+%26%27long+str,+not+%26%27short+str%0A++++++++++++*Arc::get_mut_unchecked(%26mut+y)+=+%26s;%0A++++++++%7D%0A++++%7D%0A++++println!(%22%7B%7D%22,+%26*x);+//+Use-after-free%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2511)[§](#impl-Arc%3Cdyn+Any+%2B+Send+%2B+Sync,+A%3E)\n\n1.29.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2532-2534)\n\nAttempt to downcast the `Arc<dyn Any + Send + Sync>` to a concrete type.\n\n##### [§](#examples-38)Examples\n\n```\nuse std::any::Any;\nuse std::sync::Arc;\n\nfn print_if_string(value: Arc<dyn Any + Send + Sync>) {\n    if let Ok(string) = value.downcast::<String>() {\n        println!(\"String ({}): {}\", string.len(), string);\n    }\n}\n\nlet my_string = \"Hello World\".to_string();\nprint_if_string(Arc::new(my_string));\nprint_if_string(Arc::new(0i8));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::any::Any;%0A++++use+std::sync::Arc;%0A++++%0A++++fn+print_if_string(value:+Arc%3Cdyn+Any+%2B+Send+%2B+Sync%3E)+%7B%0A++++++++if+let+Ok(string)+=+value.downcast::%3CString%3E()+%7B%0A++++++++++++println!(%22String+(%7B%7D):+%7B%7D%22,+string.len(),+string);%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+my_string+=+%22Hello+World%22.to_string();%0A++++print_if_string(Arc::new(my_string));%0A++++print_if_string(Arc::new(0i8));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2574-2576)\n\n🔬This is a nightly-only experimental API. (`downcast_unchecked` [#90850](https://github.com/rust-lang/rust/issues/90850))\n\nDowncasts the `Arc<dyn Any + Send + Sync>` to a concrete type.\n\nFor a safe alternative see [`downcast`](about:blank/struct.Arc.html#method.downcast \"method std::sync::Arc::downcast\").\n\n##### [§](#examples-39)Examples\n\n```\n#![feature(downcast_unchecked)]\n\nuse std::any::Any;\nuse std::sync::Arc;\n\nlet x: Arc<dyn Any + Send + Sync> = Arc::new(1_usize);\n\nunsafe {\n    assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(downcast_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::any::Any;%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3Cdyn+Any+%2B+Send+%2B+Sync%3E+=+Arc::new(1_usize);%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(*x.downcast_unchecked::%3Cusize%3E(),+1);%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n##### [§](#safety-9)Safety\n\nThe contained value must be of type `T`. Calling this method with the incorrect type is _undefined behavior_.\n\n1.64.0 · [source](about:blank/src/std/os/fd/owned.rs.html#407-412)[§](#impl-AsFd-for-Arc%3CT%3E)\n\nThis impl allows implementing traits that require `AsFd` on Arc.\n\n```\nuse std::net::UdpSocket;\nuse std::sync::Arc;\n\ntrait MyTrait: AsFd {}\nimpl MyTrait for Arc<UdpSocket> {}\nimpl MyTrait for Box<UdpSocket> {}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(any(unix,+target_os+=+%22wasi%22))%5D+mod+group_cfg+%7B%0A++++%23%5Bcfg(target_os+=+%22wasi%22)%5D%0A++++use+std::os::wasi::io::AsFd;%0A++++%23%5Bcfg(unix)%5D%0A++++use+std::os::unix::io::AsFd;%0A++++use+std::net::UdpSocket;%0A++++use+std::sync::Arc;%0A++++%0A++++trait+MyTrait:+AsFd+%7B%7D%0A++++impl+MyTrait+for+Arc%3CUdpSocket%3E+%7B%7D%0A++++impl+MyTrait+for+Box%3CUdpSocket%3E+%7B%7D%0A++++%7D%0A%7D&edition=2021)\n\n1.71.0 · [source](about:blank/src/std/os/windows/io/handle.rs.html#479-484)[§](#impl-AsHandle-for-Arc%3CT%3E)\n\nAvailable on **Windows** only.\n\nThis impl allows implementing traits that require `AsHandle` on Arc.\n\n```\nuse std::fs::File;\nuse std::sync::Arc;\n\ntrait MyTrait: AsHandle {}\nimpl MyTrait for Arc<File> {}\nimpl MyTrait for Box<File> {}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(windows)%5D+mod+group_cfg+%7B%0A++++use+std::os::windows::io::AsHandle;%0A++++use+std::fs::File;%0A++++use+std::sync::Arc;%0A++++%0A++++trait+MyTrait:+AsHandle+%7B%7D%0A++++impl+MyTrait+for+Arc%3CFile%3E+%7B%7D%0A++++impl+MyTrait+for+Box%3CFile%3E+%7B%7D%0A++++%7D%0A%7D&edition=2021)\n\n1.63.0 · [source](about:blank/src/std/os/fd/raw.rs.html#253-258)[§](#impl-AsRawFd-for-Arc%3CT%3E)\n\nThis impl allows implementing traits that require `AsRawFd` on Arc.\n\n```\nuse std::net::UdpSocket;\nuse std::sync::Arc;\ntrait MyTrait: AsRawFd {\n}\nimpl MyTrait for Arc<UdpSocket> {}\nimpl MyTrait for Box<UdpSocket> {}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(any(unix,+target_os+=+%22wasi%22))%5D+mod+group_cfg+%7B%0A++++%23%5Bcfg(target_os+=+%22wasi%22)%5D%0A++++use+std::os::wasi::io::AsRawFd;%0A++++%23%5Bcfg(unix)%5D%0A++++use+std::os::unix::io::AsRawFd;%0A++++use+std::net::UdpSocket;%0A++++use+std::sync::Arc;%0A++++trait+MyTrait:+AsRawFd+%7B%0A++++%7D%0A++++impl+MyTrait+for+Arc%3CUdpSocket%3E+%7B%7D%0A++++impl+MyTrait+for+Box%3CUdpSocket%3E+%7B%7D%0A++++%7D%0A%7D&edition=2021)\n\n1.5.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3778)[§](#impl-AsRef%3CT%3E-for-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3779)[§](#method.as_ref)\n\nConverts this type into a shared reference of the (usually inferred) input type.\n\n1.71.0 · [source](about:blank/src/std/os/windows/io/socket.rs.html#270-275)[§](#impl-AsSocket-for-Arc%3CT%3E)\n\nAvailable on **Windows** only.\n\nThis impl allows implementing traits that require `AsSocket` on Arc.\n\n```\nuse std::net::UdpSocket;\nuse std::sync::Arc;\n\ntrait MyTrait: AsSocket {}\nimpl MyTrait for Arc<UdpSocket> {}\nimpl MyTrait for Box<UdpSocket> {}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(windows)%5D+mod+group_cfg+%7B%0A++++use+std::os::windows::io::AsSocket;%0A++++use+std::net::UdpSocket;%0A++++use+std::sync::Arc;%0A++++%0A++++trait+MyTrait:+AsSocket+%7B%7D%0A++++impl+MyTrait+for+Arc%3CUdpSocket%3E+%7B%7D%0A++++impl+MyTrait+for+Box%3CUdpSocket%3E+%7B%7D%0A++++%7D%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3771)[§](#impl-Borrow%3CT%3E-for-Arc%3CT,+A%3E)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2081)[§](#impl-Clone-for-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2097)[§](#method.clone)\n\nMakes a clone of the `Arc` pointer.\n\nThis creates another pointer to the same allocation, increasing the strong reference count.\n\n##### [§](#examples-40)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nlet _ = Arc::clone(&five);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++let+_+=+Arc::clone(%26five);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#169)[§](#method.clone_from)\n\nPerforms copy-assignment from `source`. [Read more](about:blank/clone/trait.Clone.html#method.clone_from)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3354)[§](#impl-Debug-for-Arc%3CT,+A%3E)\n\n1.80.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3443)[§](#impl-Default-for-Arc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3448)[§](#method.default)\n\nCreates an empty `[T]` inside an Arc\n\nThis may or may not share an allocation with other Arcs.\n\n1.80.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3424)[§](#impl-Default-for-Arc%3CCStr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3429)[§](#method.default-1)\n\nCreates an empty CStr inside an Arc\n\nThis may or may not share an allocation with other Arcs.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3369)[§](#impl-Default-for-Arc%3CT%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3380)[§](#method.default-2)\n\nCreates a new `Arc<T>`, with the `Default` value for `T`.\n\n##### [§](#examples-43)Examples\n\n```\nuse std::sync::Arc;\n\nlet x: Arc<i32> = Default::default();\nassert_eq!(*x, 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3Ci32%3E+=+Default::default();%0A++++assert_eq!(*x,+0);%0A%7D&edition=2021)\n\n1.80.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3409)[§](#impl-Default-for-Arc%3Cstr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3414)[§](#method.default-3)\n\nCreates an empty str inside an Arc\n\nThis may or may not share an allocation with other Arcs.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2135)[§](#impl-Deref-for-Arc%3CT,+A%3E)\n\n[§](#associatedtype.Target)\n\nThe resulting type after dereferencing.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2139)[§](#method.deref)\n\nDereferences the value.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3347)[§](#impl-Display-for-Arc%3CT,+A%3E)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2432)[§](#impl-Drop-for-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2459)[§](#method.drop)\n\nDrops the `Arc`.\n\nThis will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are [`Weak`](struct.Weak.html \"struct std::sync::Weak\"), so we `drop` the inner value.\n\n##### [§](#examples-44)Examples\n\n```\nuse std::sync::Arc;\n\nstruct Foo;\n\nimpl Drop for Foo {\n    fn drop(&mut self) {\n        println!(\"dropped!\");\n    }\n}\n\nlet foo  = Arc::new(Foo);\nlet foo2 = Arc::clone(&foo);\n\ndrop(foo);    // Doesn't print anything\ndrop(foo2);   // Prints \"dropped!\"\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++struct+Foo;%0A++++%0A++++impl+Drop+for+Foo+%7B%0A++++++++fn+drop(%26mut+self)+%7B%0A++++++++++++println!(%22dropped!%22);%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+foo++=+Arc::new(Foo);%0A++++let+foo2+=+Arc::clone(%26foo);%0A++++%0A++++drop(foo);++++//+Doesn%27t+print+anything%0A++++drop(foo2);+++//+Prints+%22dropped!%22%0A%7D&edition=2021)\n\n1.52.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3810)[§](#impl-Error-for-Arc%3CT%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3812)[§](#method.description)\n\n👎Deprecated since 1.42.0: use the Display impl or to\\_string()\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3817)[§](#method.cause)\n\n👎Deprecated since 1.33.0: replaced by Error::source, which can support downcasting\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3821)[§](#method.source)\n\nThe lower-level source of this error, if any. [Read more](about:blank/error/trait.Error.html#method.source)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3825)[§](#method.provide)\n\n🔬This is a nightly-only experimental API. (`error_generic_member_access` [#99301](https://github.com/rust-lang/rust/issues/99301))\n\nProvides type based access to context intended for error reports. [Read more](about:blank/error/trait.Error.html#method.provide)\n\n1.21.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3520)[§](#impl-From%3C%26%5BT%5D%3E-for-Arc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3532)[§](#method.from-10)\n\nAllocate a reference-counted slice and fill it by cloning `v`’s items.\n\n##### [§](#example-8)Example\n\n```\nlet original: &[i32] = &[1, 2, 3];\nlet shared: Arc<[i32]> = Arc::from(original);\nassert_eq!(&[1, 2, 3], &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+original:+%26%5Bi32%5D+=+%26%5B1,+2,+3%5D;%0A++++let+shared:+Arc%3C%5Bi32%5D%3E+=+Arc::from(original);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.24.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#881)[§](#impl-From%3C%26CStr%3E-for-Arc%3CCStr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#885)[§](#method.from-2)\n\nConverts a `&CStr` into a `Arc<CStr>`, by copying the contents into a newly allocated [`Arc`](struct.Arc.html \"struct std::sync::Arc\").\n\n1.24.0 · [source](about:blank/src/std/ffi/os_str.rs.html#1252-1259)[§](#impl-From%3C%26OsStr%3E-for-Arc%3COsStr%3E)\n\n1.24.0 · [source](about:blank/src/std/path.rs.html#1879-1886)[§](#impl-From%3C%26Path%3E-for-Arc%3CPath%3E)\n\n1.21.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3539)[§](#impl-From%3C%26str%3E-for-Arc%3Cstr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3550)[§](#method.from-1)\n\nAllocate a reference-counted `str` and copy `v` into it.\n\n##### [§](#example-2)Example\n\n```\nlet shared: Arc<str> = Arc::from(\"eggplant\");\nassert_eq!(\"eggplant\", &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(%22eggplant%22);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.74.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3499)[§](#impl-From%3C%5BT;+N%5D%3E-for-Arc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3513)[§](#method.from-3)\n\nConverts a [`[T; N]`](../primitive.array.html \"primitive array\") into an `Arc<[T]>`.\n\nThe conversion moves the array into a newly allocated `Arc`.\n\n##### [§](#example-3)Example\n\n```\nlet original: [i32; 3] = [1, 2, 3];\nlet shared: Arc<[i32]> = Arc::from(original);\nassert_eq!(&[1, 2, 3], &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+original:+%5Bi32;+3%5D+=+%5B1,+2,+3%5D;%0A++++let+shared:+Arc%3C%5Bi32%5D%3E+=+Arc::from(original);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.51.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#121)[§](#impl-From%3CArc%3CW%3E%3E-for-RawWaker)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#125)[§](#method.from-11)\n\nUse a `Wake`\\-able type as a `RawWaker`.\n\nNo heap allocations or atomic operations are used for this conversion.\n\n1.51.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#109)[§](#impl-From%3CArc%3CW%3E%3E-for-Waker)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#113)[§](#method.from-8)\n\nUse a [`Wake`](../task/trait.Wake.html \"trait std::task::Wake\")\\-able type as a `Waker`.\n\nNo heap allocations or atomic operations are used for this conversion.\n\n1.62.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3652)[§](#impl-From%3CArc%3Cstr%3E%3E-for-Arc%3C%5Bu8%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3664)[§](#method.from-4)\n\nConverts an atomically reference-counted string slice into a byte slice.\n\n##### [§](#example-4)Example\n\n```\nlet string: Arc<str> = Arc::from(\"eggplant\");\nlet bytes: Arc<[u8]> = Arc::from(string);\nassert_eq!(\"eggplant\".as_bytes(), bytes.as_ref());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+string:+Arc%3Cstr%3E+=+Arc::from(%22eggplant%22);%0A++++let+bytes:+Arc%3C%5Bu8%5D%3E+=+Arc::from(string);%0A++++assert_eq!(%22eggplant%22.as_bytes(),+bytes.as_ref());%0A%7D&edition=2021)\n\n1.21.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3577)[§](#impl-From%3CBox%3CT,+A%3E%3E-for-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3589)[§](#method.from-6)\n\nMove a boxed object to a new, reference-counted allocation.\n\n##### [§](#example-5)Example\n\n```\nlet unique: Box<str> = Box::from(\"eggplant\");\nlet shared: Arc<str> = Arc::from(unique);\nassert_eq!(\"eggplant\", &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+unique:+Box%3Cstr%3E+=+Box::from(%22eggplant%22);%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(unique);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.24.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#869)[§](#impl-From%3CCString%3E-for-Arc%3CCStr%3E)\n\n1.45.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3625-3628)[§](#impl-From%3CCow%3C'a,+B%3E%3E-for-Arc%3CB%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3643)[§](#method.from-12)\n\nCreate an atomically reference-counted pointer from a clone-on-write pointer by copying its content.\n\n##### [§](#example-9)Example\n\n```\nlet cow: Cow<'_, str> = Cow::Borrowed(\"eggplant\");\nlet shared: Arc<str> = Arc::from(cow);\nassert_eq!(\"eggplant\", &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::borrow::Cow;%0A++++let+cow:+Cow%3C%27_,+str%3E+=+Cow::Borrowed(%22eggplant%22);%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(cow);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.24.0 · [source](about:blank/src/std/ffi/os_str.rs.html#1241-1249)[§](#impl-From%3COsString%3E-for-Arc%3COsStr%3E)\n\n1.24.0 · [source](about:blank/src/std/path.rs.html#1868-1876)[§](#impl-From%3CPathBuf%3E-for-Arc%3CPath%3E)\n\n1.21.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3558)[§](#impl-From%3CString%3E-for-Arc%3Cstr%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3570)[§](#method.from-7)\n\nAllocate a reference-counted `str` and copy `v` into it.\n\n##### [§](#example-6)Example\n\n```\nlet unique: String = \"eggplant\".to_owned();\nlet shared: Arc<str> = Arc::from(unique);\nassert_eq!(\"eggplant\", &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+unique:+String+=+%22eggplant%22.to_owned();%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(unique);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.6.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3477)[§](#impl-From%3CT%3E-for-Arc%3CT%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3492)[§](#method.from-9)\n\nConverts a `T` into an `Arc<T>`\n\nThe conversion moves the value into a newly allocated `Arc`. It is equivalent to calling `Arc::new(t)`.\n\n##### [§](#example-7)Example\n\n```\nlet x = 5;\nlet arc = Arc::new(5);\n\nassert_eq!(Arc::from(x), arc);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+x+=+5;%0A++++let+arc+=+Arc::new(5);%0A++++%0A++++assert_eq!(Arc::from(x),+arc);%0A%7D&edition=2021)\n\n1.21.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3596)[§](#impl-From%3CVec%3CT,+A%3E%3E-for-Arc%3C%5BT%5D,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3608)[§](#method.from)\n\nAllocate a reference-counted slice and move `v`’s items into it.\n\n##### [§](#example-1)Example\n\n```\nlet unique: Vec<i32> = vec![1, 2, 3];\nlet shared: Arc<[i32]> = Arc::from(unique);\nassert_eq!(&[1, 2, 3], &shared[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+unique:+Vec%3Ci32%3E+=+vec!%5B1,+2,+3%5D;%0A++++let+shared:+Arc%3C%5Bi32%5D%3E+=+Arc::from(unique);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&edition=2021)\n\n1.37.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3686)[§](#impl-FromIterator%3CT%3E-for-Arc%3C%5BT%5D%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3725)[§](#method.from_iter)\n\nTakes each element in the `Iterator` and collects it into an `Arc<[T]>`.\n\n##### [§](#performance-characteristics)Performance characteristics\n\n###### [§](#the-general-case)The general case\n\nIn the general case, collecting into `Arc<[T]>` is done by first collecting into a `Vec<T>`. That is, when writing the following:\n\n```\nlet evens: Arc<[u8]> = (0..10).filter(|&x| x % 2 == 0).collect();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+evens:+Arc%3C%5Bu8%5D%3E+=+(0..10).filter(%7C%26x%7C+x+%25+2+==+0).collect();%0A++++assert_eq!(%26*evens,+%26%5B0,+2,+4,+6,+8%5D);%0A%7D&edition=2021)\n\nthis behaves as if we wrote:\n\n```\nlet evens: Arc<[u8]> = (0..10).filter(|&x| x % 2 == 0)\n    .collect::<Vec<_>>() // The first set of allocations happens here.\n    .into(); // A second allocation for `Arc<[T]>` happens here.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+evens:+Arc%3C%5Bu8%5D%3E+=+(0..10).filter(%7C%26x%7C+x+%25+2+==+0)%0A++++++++.collect::%3CVec%3C_%3E%3E()+//+The+first+set+of+allocations+happens+here.%0A++++++++.into();+//+A+second+allocation+for+%60Arc%3C%5BT%5D%3E%60+happens+here.%0A++++assert_eq!(%26*evens,+%26%5B0,+2,+4,+6,+8%5D);%0A%7D&edition=2021)\n\nThis will allocate as many times as needed for constructing the `Vec<T>` and then it will allocate once for turning the `Vec<T>` into the `Arc<[T]>`.\n\n###### [§](#iterators-of-known-length)Iterators of known length\n\nWhen your `Iterator` implements `TrustedLen` and is of an exact size, a single allocation will be made for the `Arc<[T]>`. For example:\n\n```\nlet evens: Arc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+evens:+Arc%3C%5Bu8%5D%3E+=+(0..10).collect();+//+Just+a+single+allocation+happens+here.%0A++++assert_eq!(%26*evens,+%26*(0..10).collect::%3CVec%3C_%3E%3E());%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3469)[§](#impl-Hash-for-Arc%3CT,+A%3E)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3324)[§](#impl-Ord-for-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3339)[§](#method.cmp)\n\nComparison for two `Arc`s.\n\nThe two are compared by calling `cmp()` on their inner values.\n\n##### [§](#examples-50)Examples\n\n```\nuse std::sync::Arc;\nuse std::cmp::Ordering;\n\nlet five = Arc::new(5);\n\nassert_eq!(Ordering::Less, five.cmp(&Arc::new(6)));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert_eq!(Ordering::Less,+five.cmp(%26Arc::new(6)));%0A%7D&edition=2021)\n\n1.21.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#856-858)[§](#method.max)\n\nCompares and returns the maximum of two values. [Read more](about:blank/cmp/trait.Ord.html#method.max)\n\n1.21.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#877-879)[§](#method.min)\n\nCompares and returns the minimum of two values. [Read more](about:blank/cmp/trait.Ord.html#method.min)\n\n1.50.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#903-906)[§](#method.clamp)\n\nRestrict a value to a certain interval. [Read more](about:blank/cmp/trait.Ord.html#method.clamp)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3190)[§](#impl-PartialEq-for-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3209)[§](#method.eq)\n\nEquality for two `Arc`s.\n\nTwo `Arc`s are equal if their inner values are equal, even if they are stored in different allocation.\n\nIf `T` also implements `Eq` (implying reflexivity of equality), two `Arc`s that point to the same allocation are always equal.\n\n##### [§](#examples-41)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nassert!(five == Arc::new(5));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+==+Arc::new(5));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3230)[§](#method.ne)\n\nInequality for two `Arc`s.\n\nTwo `Arc`s are not equal if their inner values are not equal.\n\nIf `T` also implements `Eq` (implying reflexivity of equality), two `Arc`s that point to the same value are always equal.\n\n##### [§](#examples-42)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nassert!(five != Arc::new(6));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+!=+Arc::new(6));%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3236)[§](#impl-PartialOrd-for-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3251)[§](#method.partial_cmp)\n\nPartial comparison for two `Arc`s.\n\nThe two are compared by calling `partial_cmp()` on their inner values.\n\n##### [§](#examples-45)Examples\n\n```\nuse std::sync::Arc;\nuse std::cmp::Ordering;\n\nlet five = Arc::new(5);\n\nassert_eq!(Some(Ordering::Less), five.partial_cmp(&Arc::new(6)));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert_eq!(Some(Ordering::Less),+five.partial_cmp(%26Arc::new(6)));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3268)[§](#method.lt)\n\nLess-than comparison for two `Arc`s.\n\nThe two are compared by calling `<` on their inner values.\n\n##### [§](#examples-46)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nassert!(five < Arc::new(6));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+%3C+Arc::new(6));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3285)[§](#method.le)\n\n‘Less than or equal to’ comparison for two `Arc`s.\n\nThe two are compared by calling `<=` on their inner values.\n\n##### [§](#examples-47)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nassert!(five <= Arc::new(5));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+%3C=+Arc::new(5));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3302)[§](#method.gt)\n\nGreater-than comparison for two `Arc`s.\n\nThe two are compared by calling `>` on their inner values.\n\n##### [§](#examples-48)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nassert!(five > Arc::new(4));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+%3E+Arc::new(4));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3319)[§](#method.ge)\n\n‘Greater than or equal to’ comparison for two `Arc`s.\n\nThe two are compared by calling `>=` on their inner values.\n\n##### [§](#examples-49)Examples\n\n```\nuse std::sync::Arc;\n\nlet five = Arc::new(5);\n\nassert!(five >= Arc::new(5));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+%3E=+Arc::new(5));%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3361)[§](#impl-Pointer-for-Arc%3CT,+A%3E)\n\n1.73.0 · [source](about:blank/src/std/fs.rs.html#954-974)[§](#impl-Read-for-Arc%3CFile%3E)\n\n[source](about:blank/src/std/fs.rs.html#955-957)[§](#method.read)\n\nPull some bytes from this source into the specified buffer, returning how many bytes were read. [Read more](about:blank/io/trait.Read.html#tymethod.read)\n\n[source](about:blank/src/std/fs.rs.html#958-960)[§](#method.read_vectored)\n\nLike `read`, except that it reads into a slice of buffers. [Read more](about:blank/io/trait.Read.html#method.read_vectored)\n\n[source](about:blank/src/std/fs.rs.html#961-963)[§](#method.read_buf)\n\n🔬This is a nightly-only experimental API. (`read_buf` [#78485](https://github.com/rust-lang/rust/issues/78485))\n\nPull some bytes from this source into the specified buffer. [Read more](about:blank/io/trait.Read.html#method.read_buf)\n\n[source](about:blank/src/std/fs.rs.html#965-967)[§](#method.is_read_vectored)\n\n🔬This is a nightly-only experimental API. (`can_vector` [#69941](https://github.com/rust-lang/rust/issues/69941))\n\nDetermines if this `Read`er has an efficient `read_vectored` implementation. [Read more](about:blank/io/trait.Read.html#method.is_read_vectored)\n\n[source](about:blank/src/std/fs.rs.html#968-970)[§](#method.read_to_end)\n\nRead all bytes until EOF in this source, placing them into `buf`. [Read more](about:blank/io/trait.Read.html#method.read_to_end)\n\n[source](about:blank/src/std/fs.rs.html#971-973)[§](#method.read_to_string)\n\nRead all bytes until EOF in this source, appending them to `buf`. [Read more](about:blank/io/trait.Read.html#method.read_to_string)\n\n1.6.0 · [source](about:blank/src/std/io/mod.rs.html#961-963)[§](#method.read_exact)\n\nRead the exact number of bytes required to fill `buf`. [Read more](about:blank/io/trait.Read.html#method.read_exact)\n\n[source](about:blank/src/std/io/mod.rs.html#995-997)[§](#method.read_buf_exact)\n\n🔬This is a nightly-only experimental API. (`read_buf` [#78485](https://github.com/rust-lang/rust/issues/78485))\n\nRead the exact number of bytes required to fill `cursor`. [Read more](about:blank/io/trait.Read.html#method.read_buf_exact)\n\n1.0.0 · [source](about:blank/src/std/io/mod.rs.html#1034-1039)[§](#method.by_ref-1)\n\nCreates a “by reference” adaptor for this instance of `Read`. [Read more](about:blank/io/trait.Read.html#method.by_ref)\n\n1.0.0 · [source](about:blank/src/std/io/mod.rs.html#1077-1082)[§](#method.bytes)\n\nTransforms this `Read` instance to an [`Iterator`](../iter/trait.Iterator.html \"trait std::iter::Iterator\") over its bytes. [Read more](about:blank/io/trait.Read.html#method.bytes)\n\n1.0.0 · [source](about:blank/src/std/io/mod.rs.html#1115-1120)[§](#method.chain)\n\nCreates an adapter which will chain this stream with another. [Read more](about:blank/io/trait.Read.html#method.chain)\n\n1.0.0 · [source](about:blank/src/std/io/mod.rs.html#1154-1159)[§](#method.take)\n\nCreates an adapter which will read at most `limit` bytes from it. [Read more](about:blank/io/trait.Read.html#method.take)\n\n1.73.0 · [source](about:blank/src/std/fs.rs.html#993-997)[§](#impl-Seek-for-Arc%3CFile%3E)\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3671)[§](#impl-TryFrom%3CArc%3C%5BT%5D,+A%3E%3E-for-Arc%3C%5BT;+N%5D,+A%3E)\n\n[§](#associatedtype.Error)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3674)[§](#method.try_from)\n\nPerforms the conversion.\n\n1.73.0 · [source](about:blank/src/std/fs.rs.html#976-991)[§](#impl-Write-for-Arc%3CFile%3E)\n\n[source](about:blank/src/std/fs.rs.html#977-979)[§](#method.write)\n\nWrite a buffer into this writer, returning how many bytes were written. [Read more](about:blank/io/trait.Write.html#tymethod.write)\n\n[source](about:blank/src/std/fs.rs.html#980-982)[§](#method.write_vectored)\n\nLike [`write`](about:blank/io/trait.Write.html#tymethod.write \"method std::io::Write::write\"), except that it writes from a slice of buffers. [Read more](about:blank/io/trait.Write.html#method.write_vectored)\n\n[source](about:blank/src/std/fs.rs.html#984-986)[§](#method.is_write_vectored)\n\n🔬This is a nightly-only experimental API. (`can_vector` [#69941](https://github.com/rust-lang/rust/issues/69941))\n\n[source](about:blank/src/std/fs.rs.html#988-990)[§](#method.flush)\n\nFlush this output stream, ensuring that all intermediately buffered contents reach their destination. [Read more](about:blank/io/trait.Write.html#tymethod.flush)\n\n1.0.0 · [source](about:blank/src/std/io/mod.rs.html#1699-1711)[§](#method.write_all)\n\nAttempts to write an entire buffer into this writer. [Read more](about:blank/io/trait.Write.html#method.write_all)\n\n[source](about:blank/src/std/io/mod.rs.html#1761-1776)[§](#method.write_all_vectored)\n\n🔬This is a nightly-only experimental API. (`write_all_vectored` [#70436](https://github.com/rust-lang/rust/issues/70436))\n\nAttempts to write multiple buffers into this writer. [Read more](about:blank/io/trait.Write.html#method.write_all_vectored)\n\n1.0.0 · [source](about:blank/src/std/io/mod.rs.html#1814-1850)[§](#method.write_fmt)\n\nWrites a formatted string into this writer, returning any error encountered. [Read more](about:blank/io/trait.Write.html#method.write_fmt)\n\n1.0.0 · [source](about:blank/src/std/io/mod.rs.html#1874-1879)[§](#method.by_ref)\n\nCreates a “by reference” adapter for this instance of `Write`. [Read more](about:blank/io/trait.Write.html#method.by_ref)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#264)[§](#impl-CoerceUnsized%3CArc%3CU,+A%3E%3E-for-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2145)[§](#impl-DerefPure-for-Arc%3CT,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#267)[§](#impl-DispatchFromDyn%3CArc%3CU%3E%3E-for-Arc%3CT%3E)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3344)[§](#impl-Eq-for-Arc%3CT,+A%3E)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#256)[§](#impl-Send-for-Arc%3CT,+A%3E)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#258)[§](#impl-Sync-for-Arc%3CT,+A%3E)\n\n1.33.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3785)[§](#impl-Unpin-for-Arc%3CT,+A%3E)\n\n1.9.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#261)[§](#impl-UnwindSafe-for-Arc%3CT,+A%3E)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A thread-safe reference-counting pointer. ‘Arc’ stands for ‘Atomically Reference Counted’.\"><title>Arc in std::sync - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc struct\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Arc</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Arc</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.allocator\">allocator</a></li><li><a href=\"#method.as_ptr\">as_ptr</a></li><li><a href=\"#method.assume_init\">assume_init</a></li><li><a href=\"#method.assume_init-1\">assume_init</a></li><li><a href=\"#method.decrement_strong_count\">decrement_strong_count</a></li><li><a href=\"#method.decrement_strong_count_in\">decrement_strong_count_in</a></li><li><a href=\"#method.downcast\">downcast</a></li><li><a href=\"#method.downcast_unchecked\">downcast_unchecked</a></li><li><a href=\"#method.downgrade\">downgrade</a></li><li><a href=\"#method.from_raw\">from_raw</a></li><li><a href=\"#method.from_raw_in\">from_raw_in</a></li><li><a href=\"#method.get_mut\">get_mut</a></li><li><a href=\"#method.get_mut_unchecked\">get_mut_unchecked</a></li><li><a href=\"#method.increment_strong_count\">increment_strong_count</a></li><li><a href=\"#method.increment_strong_count_in\">increment_strong_count_in</a></li><li><a href=\"#method.into_inner\">into_inner</a></li><li><a href=\"#method.into_raw\">into_raw</a></li><li><a href=\"#method.into_raw_with_allocator\">into_raw_with_allocator</a></li><li><a href=\"#method.make_mut\">make_mut</a></li><li><a href=\"#method.new\">new</a></li><li><a href=\"#method.new_cyclic\">new_cyclic</a></li><li><a href=\"#method.new_in\">new_in</a></li><li><a href=\"#method.new_uninit\">new_uninit</a></li><li><a href=\"#method.new_uninit_in\">new_uninit_in</a></li><li><a href=\"#method.new_uninit_slice\">new_uninit_slice</a></li><li><a href=\"#method.new_uninit_slice_in\">new_uninit_slice_in</a></li><li><a href=\"#method.new_zeroed\">new_zeroed</a></li><li><a href=\"#method.new_zeroed_in\">new_zeroed_in</a></li><li><a href=\"#method.new_zeroed_slice\">new_zeroed_slice</a></li><li><a href=\"#method.new_zeroed_slice_in\">new_zeroed_slice_in</a></li><li><a href=\"#method.pin\">pin</a></li><li><a href=\"#method.pin_in\">pin_in</a></li><li><a href=\"#method.ptr_eq\">ptr_eq</a></li><li><a href=\"#method.strong_count\">strong_count</a></li><li><a href=\"#method.try_new\">try_new</a></li><li><a href=\"#method.try_new_in\">try_new_in</a></li><li><a href=\"#method.try_new_uninit\">try_new_uninit</a></li><li><a href=\"#method.try_new_uninit_in\">try_new_uninit_in</a></li><li><a href=\"#method.try_new_zeroed\">try_new_zeroed</a></li><li><a href=\"#method.try_new_zeroed_in\">try_new_zeroed_in</a></li><li><a href=\"#method.try_pin\">try_pin</a></li><li><a href=\"#method.try_pin_in\">try_pin_in</a></li><li><a href=\"#method.try_unwrap\">try_unwrap</a></li><li><a href=\"#method.unwrap_or_clone\">unwrap_or_clone</a></li><li><a href=\"#method.weak_count\">weak_count</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-AsFd-for-Arc%3CT%3E\">AsFd</a></li><li><a href=\"#impl-AsHandle-for-Arc%3CT%3E\">AsHandle</a></li><li><a href=\"#impl-AsRawFd-for-Arc%3CT%3E\">AsRawFd</a></li><li><a href=\"#impl-AsRef%3CT%3E-for-Arc%3CT,+A%3E\">AsRef&lt;T&gt;</a></li><li><a href=\"#impl-AsSocket-for-Arc%3CT%3E\">AsSocket</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-Arc%3CT,+A%3E\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-Clone-for-Arc%3CT,+A%3E\">Clone</a></li><li><a href=\"#impl-CoerceUnsized%3CArc%3CU,+A%3E%3E-for-Arc%3CT,+A%3E\">CoerceUnsized&lt;Arc&lt;U, A&gt;&gt;</a></li><li><a href=\"#impl-Debug-for-Arc%3CT,+A%3E\">Debug</a></li><li><a href=\"#impl-Default-for-Arc%3C%5BT%5D%3E\">Default</a></li><li><a href=\"#impl-Default-for-Arc%3CCStr%3E\">Default</a></li><li><a href=\"#impl-Default-for-Arc%3CT%3E\">Default</a></li><li><a href=\"#impl-Default-for-Arc%3Cstr%3E\">Default</a></li><li><a href=\"#impl-Deref-for-Arc%3CT,+A%3E\">Deref</a></li><li><a href=\"#impl-DerefPure-for-Arc%3CT,+A%3E\">DerefPure</a></li><li><a href=\"#impl-DispatchFromDyn%3CArc%3CU%3E%3E-for-Arc%3CT%3E\">DispatchFromDyn&lt;Arc&lt;U&gt;&gt;</a></li><li><a href=\"#impl-Display-for-Arc%3CT,+A%3E\">Display</a></li><li><a href=\"#impl-Drop-for-Arc%3CT,+A%3E\">Drop</a></li><li><a href=\"#impl-Eq-for-Arc%3CT,+A%3E\">Eq</a></li><li><a href=\"#impl-Error-for-Arc%3CT%3E\">Error</a></li><li><a href=\"#impl-From%3C%26CStr%3E-for-Arc%3CCStr%3E\">From&lt;&amp;CStr&gt;</a></li><li><a href=\"#impl-From%3C%26OsStr%3E-for-Arc%3COsStr%3E\">From&lt;&amp;OsStr&gt;</a></li><li><a href=\"#impl-From%3C%26Path%3E-for-Arc%3CPath%3E\">From&lt;&amp;Path&gt;</a></li><li><a href=\"#impl-From%3C%26%5BT%5D%3E-for-Arc%3C%5BT%5D%3E\">From&lt;&amp;[T]&gt;</a></li><li><a href=\"#impl-From%3C%26str%3E-for-Arc%3Cstr%3E\">From&lt;&amp;str&gt;</a></li><li><a href=\"#impl-From%3CArc%3CW%3E%3E-for-RawWaker\">From&lt;Arc&lt;W&gt;&gt;</a></li><li><a href=\"#impl-From%3CArc%3CW%3E%3E-for-Waker\">From&lt;Arc&lt;W&gt;&gt;</a></li><li><a href=\"#impl-From%3CArc%3Cstr%3E%3E-for-Arc%3C%5Bu8%5D%3E\">From&lt;Arc&lt;str&gt;&gt;</a></li><li><a href=\"#impl-From%3CBox%3CT,+A%3E%3E-for-Arc%3CT,+A%3E\">From&lt;Box&lt;T, A&gt;&gt;</a></li><li><a href=\"#impl-From%3CCString%3E-for-Arc%3CCStr%3E\">From&lt;CString&gt;</a></li><li><a href=\"#impl-From%3CCow%3C'a,+B%3E%3E-for-Arc%3CB%3E\">From&lt;Cow&lt;'a, B&gt;&gt;</a></li><li><a href=\"#impl-From%3COsString%3E-for-Arc%3COsStr%3E\">From&lt;OsString&gt;</a></li><li><a href=\"#impl-From%3CPathBuf%3E-for-Arc%3CPath%3E\">From&lt;PathBuf&gt;</a></li><li><a href=\"#impl-From%3CString%3E-for-Arc%3Cstr%3E\">From&lt;String&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-Arc%3CT%3E\">From&lt;T&gt;</a></li><li><a href=\"#impl-From%3CVec%3CT,+A%3E%3E-for-Arc%3C%5BT%5D,+A%3E\">From&lt;Vec&lt;T, A&gt;&gt;</a></li><li><a href=\"#impl-From%3C%5BT;+N%5D%3E-for-Arc%3C%5BT%5D%3E\">From&lt;[T; N]&gt;</a></li><li><a href=\"#impl-FromIterator%3CT%3E-for-Arc%3C%5BT%5D%3E\">FromIterator&lt;T&gt;</a></li><li><a href=\"#impl-Hash-for-Arc%3CT,+A%3E\">Hash</a></li><li><a href=\"#impl-Ord-for-Arc%3CT,+A%3E\">Ord</a></li><li><a href=\"#impl-PartialEq-for-Arc%3CT,+A%3E\">PartialEq</a></li><li><a href=\"#impl-PartialOrd-for-Arc%3CT,+A%3E\">PartialOrd</a></li><li><a href=\"#impl-Pointer-for-Arc%3CT,+A%3E\">Pointer</a></li><li><a href=\"#impl-Read-for-Arc%3CFile%3E\">Read</a></li><li><a href=\"#impl-Seek-for-Arc%3CFile%3E\">Seek</a></li><li><a href=\"#impl-Send-for-Arc%3CT,+A%3E\">Send</a></li><li><a href=\"#impl-Sync-for-Arc%3CT,+A%3E\">Sync</a></li><li><a href=\"#impl-TryFrom%3CArc%3C%5BT%5D,+A%3E%3E-for-Arc%3C%5BT;+N%5D,+A%3E\">TryFrom&lt;Arc&lt;[T], A&gt;&gt;</a></li><li><a href=\"#impl-Unpin-for-Arc%3CT,+A%3E\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-Arc%3CT,+A%3E\">UnwindSafe</a></li><li><a href=\"#impl-Write-for-Arc%3CFile%3E\">Write</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-Arc%3CT,+A%3E\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-Arc%3CT,+A%3E\">RefUnwindSafe</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3C!%3E-for-T\">From&lt;!&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-ToOwned-for-T\">ToOwned</a></li><li><a href=\"#impl-ToString-for-T\">ToString</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::sync</a></h2><h3><a href=\"index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"atomic/index.html\">atomic</a></li><li><a href=\"mpsc/index.html\">mpsc</a></li></ul><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Arc.html\">Arc</a></li><li><a href=\"struct.Barrier.html\">Barrier</a></li><li><a href=\"struct.BarrierWaitResult.html\">BarrierWaitResult</a></li><li><a href=\"struct.Condvar.html\">Condvar</a></li><li><a href=\"struct.Exclusive.html\">Exclusive</a></li><li><a href=\"struct.LazyLock.html\">LazyLock</a></li><li><a href=\"struct.MappedMutexGuard.html\">MappedMutexGuard</a></li><li><a href=\"struct.MappedRwLockReadGuard.html\">MappedRwLockReadGuard</a></li><li><a href=\"struct.MappedRwLockWriteGuard.html\">MappedRwLockWriteGuard</a></li><li><a href=\"struct.Mutex.html\">Mutex</a></li><li><a href=\"struct.MutexGuard.html\">MutexGuard</a></li><li><a href=\"struct.Once.html\">Once</a></li><li><a href=\"struct.OnceLock.html\">OnceLock</a></li><li><a href=\"struct.OnceState.html\">OnceState</a></li><li><a href=\"struct.PoisonError.html\">PoisonError</a></li><li><a href=\"struct.ReentrantLock.html\">ReentrantLock</a></li><li><a href=\"struct.ReentrantLockGuard.html\">ReentrantLockGuard</a></li><li><a href=\"struct.RwLock.html\">RwLock</a></li><li><a href=\"struct.RwLockReadGuard.html\">RwLockReadGuard</a></li><li><a href=\"struct.RwLockWriteGuard.html\">RwLockWriteGuard</a></li><li><a href=\"struct.WaitTimeoutResult.html\">WaitTimeoutResult</a></li><li><a href=\"struct.Weak.html\">Weak</a></li></ul><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.TryLockError.html\">TryLockError</a></li></ul><h3><a href=\"index.html#constants\">Constants</a></h3><ul class=\"block constant\"><li><a href=\"constant.ONCE_INIT.html\">ONCE_INIT</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.LockResult.html\">LockResult</a></li><li><a href=\"type.TryLockResult.html\">TryLockResult</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Struct <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">sync</a>::<wbr><a class=\"struct\" href=\"#\">Arc</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#246-249\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub struct Arc&lt;T, A = <a class=\"struct\" href=\"../alloc/struct.Global.html\" title=\"struct std::alloc::Global\">Global</a>&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div>{ <span class=\"comment\">/* private fields */</span> }</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A thread-safe reference-counting pointer. ‘Arc’ stands for ‘Atomically\nReference Counted’.</p>\n<p>The type <code>Arc&lt;T&gt;</code> provides shared ownership of a value of type <code>T</code>,\nallocated in the heap. Invoking <a href=\"../clone/trait.Clone.html#tymethod.clone\" title=\"method std::clone::Clone::clone\"><code>clone</code></a> on <code>Arc</code> produces\na new <code>Arc</code> instance, which points to the same allocation on the heap as the\nsource <code>Arc</code>, while increasing a reference count. When the last <code>Arc</code>\npointer to a given allocation is destroyed, the value stored in that allocation (often\nreferred to as “inner value”) is also dropped.</p>\n<p>Shared references in Rust disallow mutation by default, and <code>Arc</code> is no\nexception: you cannot generally obtain a mutable reference to something\ninside an <code>Arc</code>. If you need to mutate through an <code>Arc</code>, use\n<a href=\"../../std/sync/struct.Mutex.html\"><code>Mutex</code></a>, <a href=\"../../std/sync/struct.RwLock.html\"><code>RwLock</code></a>, or one of the <a href=\"atomic/index.html\" title=\"mod std::sync::atomic\"><code>Atomic</code></a>\ntypes.</p>\n<p><strong>Note</strong>: This type is only available on platforms that support atomic\nloads and stores of pointers, which includes all platforms that support\nthe <code>std</code> crate but not all those which only support <a href=\"https://doc.rust-lang.org/1.80.0/alloc/index.html\" title=\"mod alloc\"><code>alloc</code></a>.\nThis may be detected at compile time using <code>#[cfg(target_has_atomic = \"ptr\")]</code>.</p>\n<h3 id=\"thread-safety\"><a class=\"doc-anchor\" href=\"#thread-safety\">§</a>Thread Safety</h3>\n<p>Unlike <a href=\"../rc/struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc&lt;T&gt;</code></a>, <code>Arc&lt;T&gt;</code> uses atomic operations for its reference\ncounting. This means that it is thread-safe. The disadvantage is that\natomic operations are more expensive than ordinary memory accesses. If you\nare not sharing reference-counted allocations between threads, consider using\n<a href=\"../rc/struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc&lt;T&gt;</code></a> for lower overhead. <a href=\"../rc/struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc&lt;T&gt;</code></a> is a safe default, because the\ncompiler will catch any attempt to send an <a href=\"../rc/struct.Rc.html\" title=\"struct std::rc::Rc\"><code>Rc&lt;T&gt;</code></a> between threads.\nHowever, a library might choose <code>Arc&lt;T&gt;</code> in order to give library consumers\nmore flexibility.</p>\n<p><code>Arc&lt;T&gt;</code> will implement <a href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\"><code>Send</code></a> and <a href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\"><code>Sync</code></a> as long as the <code>T</code> implements\n<a href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\"><code>Send</code></a> and <a href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\"><code>Sync</code></a>. Why can’t you put a non-thread-safe type <code>T</code> in an\n<code>Arc&lt;T&gt;</code> to make it thread-safe? This may be a bit counter-intuitive at\nfirst: after all, isn’t the point of <code>Arc&lt;T&gt;</code> thread safety? The key is\nthis: <code>Arc&lt;T&gt;</code> makes it thread safe to have multiple ownership of the same\ndata, but it  doesn’t add thread safety to its data. Consider\n<code>Arc&lt;<a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\">RefCell&lt;T&gt;</a>&gt;</code>. <a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell&lt;T&gt;</code></a> isn’t <a href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\"><code>Sync</code></a>, and if <code>Arc&lt;T&gt;</code> was always\n<a href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\"><code>Send</code></a>, <code>Arc&lt;<a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\">RefCell&lt;T&gt;</a>&gt;</code> would be as well. But then we’d have a problem:\n<a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell&lt;T&gt;</code></a> is not thread safe; it keeps track of the borrowing count using\nnon-atomic operations.</p>\n<p>In the end, this means that you may need to pair <code>Arc&lt;T&gt;</code> with some sort of\n<a href=\"../../std/sync/index.html\"><code>std::sync</code></a> type, usually <a href=\"../../std/sync/struct.Mutex.html\"><code>Mutex&lt;T&gt;</code></a>.</p>\n<h3 id=\"breaking-cycles-with-weak\"><a class=\"doc-anchor\" href=\"#breaking-cycles-with-weak\">§</a>Breaking cycles with <code>Weak</code></h3>\n<p>The <a href=\"struct.Arc.html#method.downgrade\" title=\"associated function std::sync::Arc::downgrade\"><code>downgrade</code></a> method can be used to create a non-owning\n<a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> pointer. A <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> pointer can be <a href=\"struct.Weak.html#method.upgrade\" title=\"method std::sync::Weak::upgrade\"><code>upgrade</code></a>d\nto an <code>Arc</code>, but this will return <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> if the value stored in the allocation has\nalready been dropped. In other words, <code>Weak</code> pointers do not keep the value\ninside the allocation alive; however, they <em>do</em> keep the allocation\n(the backing store for the value) alive.</p>\n<p>A cycle between <code>Arc</code> pointers will never be deallocated. For this reason,\n<a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> is used to break cycles. For example, a tree could have\nstrong <code>Arc</code> pointers from parent nodes to children, and <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a>\npointers from children back to their parents.</p>\n<h2 id=\"cloning-references\"><a class=\"doc-anchor\" href=\"#cloning-references\">§</a>Cloning references</h2>\n<p>Creating a new reference from an existing reference-counted pointer is done using the\n<code>Clone</code> trait implemented for <a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc&lt;T&gt;</code></a> and <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak&lt;T&gt;</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">let </span>foo = Arc::new(<span class=\"macro\">vec!</span>[<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>]);\n<span class=\"comment\">// The two syntaxes below are equivalent.\n</span><span class=\"kw\">let </span>a = foo.clone();\n<span class=\"kw\">let </span>b = Arc::clone(<span class=\"kw-2\">&amp;</span>foo);\n<span class=\"comment\">// a, b, and foo are all Arcs that point to the same memory location</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+foo+=+Arc::new(vec!%5B1.0,+2.0,+3.0%5D);%0A++++//+The+two+syntaxes+below+are+equivalent.%0A++++let+a+=+foo.clone();%0A++++let+b+=+Arc::clone(%26foo);%0A++++//+a,+b,+and+foo+are+all+Arcs+that+point+to+the+same+memory+location%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"deref-behavior\"><a class=\"doc-anchor\" href=\"#deref-behavior\">§</a><code>Deref</code> behavior</h3>\n<p><code>Arc&lt;T&gt;</code> automatically dereferences to <code>T</code> (via the <a href=\"../ops/trait.Deref.html\" title=\"trait std::ops::Deref\"><code>Deref</code></a> trait),\nso you can call <code>T</code>’s methods on a value of type <code>Arc&lt;T&gt;</code>. To avoid name\nclashes with <code>T</code>’s methods, the methods of <code>Arc&lt;T&gt;</code> itself are associated\nfunctions, called using <a href=\"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\">fully qualified syntax</a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>my_arc = Arc::new(());\n<span class=\"kw\">let </span>my_weak = Arc::downgrade(<span class=\"kw-2\">&amp;</span>my_arc);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+my_arc+=+Arc::new(());%0A++++let+my_weak+=+Arc::downgrade(%26my_arc);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><code>Arc&lt;T&gt;</code>’s implementations of traits like <code>Clone</code> may also be called using\nfully qualified syntax. Some people prefer to use fully qualified syntax,\nwhile others prefer using method-call syntax.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>arc = Arc::new(());\n<span class=\"comment\">// Method-call syntax\n</span><span class=\"kw\">let </span>arc2 = arc.clone();\n<span class=\"comment\">// Fully qualified syntax\n</span><span class=\"kw\">let </span>arc3 = Arc::clone(<span class=\"kw-2\">&amp;</span>arc);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+arc+=+Arc::new(());%0A++++//+Method-call+syntax%0A++++let+arc2+=+arc.clone();%0A++++//+Fully+qualified+syntax%0A++++let+arc3+=+Arc::clone(%26arc);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak&lt;T&gt;</code></a> does not auto-dereference to <code>T</code>, because the inner value may have\nalready been dropped.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>Sharing some immutable data between threads:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n    <span class=\"kw\">let </span>five = Arc::clone(<span class=\"kw-2\">&amp;</span>five);\n\n    thread::spawn(<span class=\"kw\">move </span>|| {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"{five:?}\"</span>);\n    });\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::thread;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++for+_+in+0..10+%7B%0A++++++++let+five+=+Arc::clone(%26five);%0A++++%0A++++++++thread::spawn(move+%7C%7C+%7B%0A++++++++++++println!(%22%7Bfive:?%7D%22);%0A++++++++%7D);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Sharing a mutable <a href=\"atomic/struct.AtomicUsize.html\" title=\"sync::atomic::AtomicUsize\"><code>AtomicUsize</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::sync::atomic::{AtomicUsize, Ordering};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>val = Arc::new(AtomicUsize::new(<span class=\"number\">5</span>));\n\n<span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n    <span class=\"kw\">let </span>val = Arc::clone(<span class=\"kw-2\">&amp;</span>val);\n\n    thread::spawn(<span class=\"kw\">move </span>|| {\n        <span class=\"kw\">let </span>v = val.fetch_add(<span class=\"number\">1</span>, Ordering::Relaxed);\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"{v:?}\"</span>);\n    });\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::sync::atomic::%7BAtomicUsize,+Ordering%7D;%0A++++use+std::thread;%0A++++%0A++++let+val+=+Arc::new(AtomicUsize::new(5));%0A++++%0A++++for+_+in+0..10+%7B%0A++++++++let+val+=+Arc::clone(%26val);%0A++++%0A++++++++thread::spawn(move+%7C%7C+%7B%0A++++++++++++let+v+=+val.fetch_add(1,+Ordering::Relaxed);%0A++++++++++++println!(%22%7Bv:?%7D%22);%0A++++++++%7D);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>See the <a href=\"../rc/index.html#examples\" title=\"mod std::rc\"><code>rc</code> documentation</a> for more examples of reference\ncounting in general.</p>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">§</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#377\">source</a><a href=\"#impl-Arc%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#390\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.new\" class=\"fn\">new</a>(data: T) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T&gt;</code>.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_cyclic\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.60.0\">1.60.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#455-457\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.new_cyclic\" class=\"fn\">new_cyclic</a>&lt;F&gt;(data_fn: F) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>(&amp;<a class=\"struct\" href=\"struct.Weak.html\" title=\"struct std::sync::Weak\">Weak</a>&lt;T&gt;) -&gt; T,</div></h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the allocation,\nto allow you to construct a <code>T</code> which holds a weak pointer to itself.</p>\n<p>Generally, a structure circularly referencing itself, either directly or\nindirectly, should not hold a strong reference to itself to prevent a memory leak.\nUsing this function, you get access to the weak pointer during the\ninitialization of <code>T</code>, before the <code>Arc&lt;T&gt;</code> is created, such that you can\nclone and store it inside the <code>T</code>.</p>\n<p><code>new_cyclic</code> first allocates the managed allocation for the <code>Arc&lt;T&gt;</code>,\nthen calls your closure, giving it a <code>Weak&lt;T&gt;</code> to this allocation,\nand only afterwards completes the construction of the <code>Arc&lt;T&gt;</code> by placing\nthe <code>T</code> returned from your closure into the allocation.</p>\n<p>Since the new <code>Arc&lt;T&gt;</code> is not fully-constructed until <code>Arc&lt;T&gt;::new_cyclic</code>\nreturns, calling <a href=\"struct.Weak.html#method.upgrade\" title=\"method std::sync::Weak::upgrade\"><code>upgrade</code></a> on the weak reference inside your closure will\nfail and result in a <code>None</code> value.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>If <code>data_fn</code> panics, the panic is propagated to the caller, and the\ntemporary <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak&lt;T&gt;</code></a> is dropped normally.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Weak};\n\n<span class=\"kw\">struct </span>Gadget {\n    me: Weak&lt;Gadget&gt;,\n}\n\n<span class=\"kw\">impl </span>Gadget {\n    <span class=\"doccomment\">/// Construct a reference counted Gadget.\n    </span><span class=\"kw\">fn </span>new() -&gt; Arc&lt;<span class=\"self\">Self</span>&gt; {\n        <span class=\"comment\">// `me` is a `Weak&lt;Gadget&gt;` pointing at the new allocation of the\n        // `Arc` we're constructing.\n        </span>Arc::new_cyclic(|me| {\n            <span class=\"comment\">// Create the actual struct here.\n            </span>Gadget { me: me.clone() }\n        })\n    }\n\n    <span class=\"doccomment\">/// Return a reference counted pointer to Self.\n    </span><span class=\"kw\">fn </span>me(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; Arc&lt;<span class=\"self\">Self</span>&gt; {\n        <span class=\"self\">self</span>.me.upgrade().unwrap()\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Weak%7D;%0A++++%0A++++struct+Gadget+%7B%0A++++++++me:+Weak%3CGadget%3E,%0A++++%7D%0A++++%0A++++impl+Gadget+%7B%0A++++++++///+Construct+a+reference+counted+Gadget.%0A++++++++fn+new()+-%3E+Arc%3CSelf%3E+%7B%0A++++++++++++//+%60me%60+is+a+%60Weak%3CGadget%3E%60+pointing+at+the+new+allocation+of+the%0A++++++++++++//+%60Arc%60+we're+constructing.%0A++++++++++++Arc::new_cyclic(%7Cme%7C+%7B%0A++++++++++++++++//+Create+the+actual+struct+here.%0A++++++++++++++++Gadget+%7B+me:+me.clone()+%7D%0A++++++++++++%7D)%0A++++++++%7D%0A++++%0A++++++++///+Return+a+reference+counted+pointer+to+Self.%0A++++++++fn+me(%26self)+-%3E+Arc%3CSelf%3E+%7B%0A++++++++++++self.me.upgrade().unwrap()%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_uninit\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#532\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_uninit\" class=\"fn\">new_uninit</a>() -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Arc::&lt;u32&gt;::new_uninit();\n\n<span class=\"comment\">// Deferred initialization:\n</span>Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>five).unwrap().write(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{ five.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32%3E::new_uninit();%0A++++%0A++++//+Deferred+initialization:%0A++++Arc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_zeroed\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#566\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_zeroed\" class=\"fn\">new_zeroed</a>() -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>zero = Arc::&lt;u32&gt;::new_zeroed();\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+zero+=+Arc::%3Cu32%3E::new_zeroed();%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.pin\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.33.0\">1.33.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#581\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.pin\" class=\"fn\">pin</a>(data: T) -&gt; <a class=\"struct\" href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>, then\n<code>data</code> will be pinned in memory and unable to be moved.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_pin\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#588\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_pin\" class=\"fn\">try_pin</a>(data: T) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>, return an error if allocation fails.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#605\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new\" class=\"fn\">try_new</a>(data: T) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T&gt;</code>, returning an error if allocation fails.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::try_new(<span class=\"number\">5</span>)<span class=\"question-mark\">?</span>;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::try_new(5)?;%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_uninit\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#639\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_uninit\" class=\"fn\">try_new_uninit</a>() -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, returning an error\nif allocation fails.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit, allocator_api)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Arc::&lt;u32&gt;::try_new_uninit()<span class=\"question-mark\">?</span>;\n\n<span class=\"comment\">// Deferred initialization:\n</span>Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>five).unwrap().write(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{ five.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit,+allocator_api)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32%3E::try_new_uninit()?;%0A++++%0A++++//+Deferred+initialization:%0A++++Arc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_zeroed\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#672\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_zeroed\" class=\"fn\">try_new_zeroed</a>() -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes, returning an error if allocation fails.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit, allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>zero = Arc::&lt;u32&gt;::try_new_zeroed()<span class=\"question-mark\">?</span>;\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit,+allocator_api)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+zero+=+Arc::%3Cu32%3E::try_new_zeroed()?;%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3CT,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#683\">source</a><a href=\"#impl-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.allocator\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#691\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.allocator\" class=\"fn\">allocator</a>(this: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;A</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns a reference to the underlying allocator.</p>\n<p>Note: this is an associated function, which means that you have\nto call it as <code>Arc::allocator(&amp;a)</code> instead of <code>a.allocator()</code>. This\nis so that there is no conflict with a method on the inner type.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#709\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_in\" class=\"fn\">new_in</a>(data: T, alloc: A) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T&gt;</code> in the provided allocator.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Arc::new_in(<span class=\"number\">5</span>, System);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Arc::new_in(5,+System);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_uninit_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#751\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_uninit_in\" class=\"fn\">new_uninit_in</a>(alloc: A) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents in the provided allocator.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Arc::&lt;u32, <span class=\"kw\">_</span>&gt;::new_uninit_in(System);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>five).as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32,+_%3E::new_uninit_in(System);%0A++++%0A++++let+five+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Arc::get_mut_unchecked(%26mut+five).as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_zeroed_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#790\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_zeroed_in\" class=\"fn\">new_zeroed_in</a>(alloc: A) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes, in the provided allocator.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>zero = Arc::&lt;u32, <span class=\"kw\">_</span>&gt;::new_zeroed_in(System);\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+zero+=+Arc::%3Cu32,+_%3E::new_zeroed_in(System);%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.pin_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#808-810\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.pin_in\" class=\"fn\">pin_in</a>(data: T, alloc: A) -&gt; <a class=\"struct\" href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;&gt;<div class=\"where\">where\n    A: 'static,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator. If <code>T</code> does not implement <code>Unpin</code>,\nthen <code>data</code> will be pinned in memory and unable to be moved.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_pin_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#819-821\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_pin_in\" class=\"fn\">try_pin_in</a>(data: T, alloc: A) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;<div class=\"where\">where\n    A: 'static,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator, return an error if allocation\nfails.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#842\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_in\" class=\"fn\">try_new_in</a>(data: T, alloc: A) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T, A&gt;</code> in the provided allocator, returning an error if allocation fails.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Arc::try_new_in(<span class=\"number\">5</span>, System)<span class=\"question-mark\">?</span>;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Arc::try_new_in(5,+System)?;%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_uninit_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#884\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_uninit_in\" class=\"fn\">try_new_uninit_in</a>(alloc: A) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, in the provided allocator, returning an\nerror if allocation fails.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit, allocator_api)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Arc::&lt;u32, <span class=\"kw\">_</span>&gt;::try_new_uninit_in(System)<span class=\"question-mark\">?</span>;\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>five).as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit,+allocator_api)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32,+_%3E::try_new_uninit_in(System)?;%0A++++%0A++++let+five+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Arc::get_mut_unchecked(%26mut+five).as_mut_ptr().write(5);%0A++++%0A++++++++five.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*five,+5);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_new_zeroed_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#923\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_new_zeroed_in\" class=\"fn\">try_new_zeroed_in</a>(alloc: A) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;, <a class=\"struct\" href=\"../alloc/struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes, in the provided allocator, returning an error if allocation\nfails.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit, allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>zero = Arc::&lt;u32, <span class=\"kw\">_</span>&gt;::try_new_zeroed_in(System)<span class=\"question-mark\">?</span>;\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit,+allocator_api)%5D%0A%0Afn+main()+%7B+fn+_inner()+-%3E+Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+zero+=+Arc::%3Cu32,+_%3E::try_new_zeroed_in(System)?;%0A++++let+zero+=+unsafe+%7B+zero.assume_init()+%7D;%0A++++%0A++++assert_eq!(*zero,+0);%0A++++Ok::%3C(),+std::alloc::AllocError%3E(())%0A%7D+_inner().unwrap()+%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_unwrap\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#967\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.try_unwrap\" class=\"fn\">try_unwrap</a>(this: <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the inner value, if the <code>Arc</code> has exactly one strong reference.</p>\n<p>Otherwise, an <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> is returned with the same <code>Arc</code> that was\npassed in.</p>\n<p>This will succeed even if there are outstanding weak references.</p>\n<p>It is strongly recommended to use <a href=\"struct.Arc.html#method.into_inner\" title=\"associated function std::sync::Arc::into_inner\"><code>Arc::into_inner</code></a> instead if you don’t\nwant to keep the <code>Arc</code> in the <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> case.\nImmediately dropping the <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> payload, like in the expression\n<code>Arc::try_unwrap(this).ok()</code>, can still cause the strong count to\ndrop to zero and the inner value of the <code>Arc</code> to be dropped:\nFor instance if two threads each execute this expression in parallel, then\nthere is a race condition. The threads could first both check whether they\nhave the last clone of their <code>Arc</code> via <code>Arc::try_unwrap</code>, and then\nboth drop their <code>Arc</code> in the call to <a href=\"../result/enum.Result.html#method.ok\" title=\"method std::result::Result::ok\"><code>ok</code></a>,\ntaking the strong count from two down to zero.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(Arc::try_unwrap(x), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">3</span>));\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"number\">4</span>);\n<span class=\"kw\">let </span>_y = Arc::clone(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>Arc::try_unwrap(x).unwrap_err(), <span class=\"number\">4</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(3);%0A++++assert_eq!(Arc::try_unwrap(x),+Ok(3));%0A++++%0A++++let+x+=+Arc::new(4);%0A++++let+_y+=+Arc::clone(%26x);%0A++++assert_eq!(*Arc::try_unwrap(x).unwrap_err(),+4);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_inner\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.70.0\">1.70.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1084\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_inner\" class=\"fn\">into_inner</a>(this: <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the inner value, if the <code>Arc</code> has exactly one strong reference.</p>\n<p>Otherwise, <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned and the <code>Arc</code> is dropped.</p>\n<p>This will succeed even if there are outstanding weak references.</p>\n<p>If <code>Arc::into_inner</code> is called on every clone of this <code>Arc</code>,\nit is guaranteed that exactly one of the calls returns the inner value.\nThis means in particular that the inner value is not dropped.</p>\n<p><a href=\"struct.Arc.html#method.try_unwrap\" title=\"associated function std::sync::Arc::try_unwrap\"><code>Arc::try_unwrap</code></a> is conceptually similar to <code>Arc::into_inner</code>, but it\nis meant for different use-cases. If used as a direct replacement\nfor <code>Arc::into_inner</code> anyway, such as with the expression\n<code><a href=\"struct.Arc.html#method.try_unwrap\" title=\"associated function std::sync::Arc::try_unwrap\">Arc::try_unwrap</a>(this).<a href=\"../result/enum.Result.html#method.ok\" title=\"method std::result::Result::ok\">ok</a>()</code>, then it does\n<strong>not</strong> give the same guarantee as described in the previous paragraph.\nFor more information, see the examples below and read the documentation\nof <a href=\"struct.Arc.html#method.try_unwrap\" title=\"associated function std::sync::Arc::try_unwrap\"><code>Arc::try_unwrap</code></a>.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">§</a>Examples</h5>\n<p>Minimal example demonstrating the guarantee that <code>Arc::into_inner</code> gives.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"number\">3</span>);\n<span class=\"kw\">let </span>y = Arc::clone(<span class=\"kw-2\">&amp;</span>x);\n\n<span class=\"comment\">// Two threads calling `Arc::into_inner` on both clones of an `Arc`:\n</span><span class=\"kw\">let </span>x_thread = std::thread::spawn(|| Arc::into_inner(x));\n<span class=\"kw\">let </span>y_thread = std::thread::spawn(|| Arc::into_inner(y));\n\n<span class=\"kw\">let </span>x_inner_value = x_thread.join().unwrap();\n<span class=\"kw\">let </span>y_inner_value = y_thread.join().unwrap();\n\n<span class=\"comment\">// One of the threads is guaranteed to receive the inner value:\n</span><span class=\"macro\">assert!</span>(<span class=\"macro\">matches!</span>(\n    (x_inner_value, y_inner_value),\n    (<span class=\"prelude-val\">None</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>)) | (<span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>), <span class=\"prelude-val\">None</span>)\n));\n<span class=\"comment\">// The result could also be `(None, None)` if the threads called\n// `Arc::try_unwrap(x).ok()` and `Arc::try_unwrap(y).ok()` instead.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(3);%0A++++let+y+=+Arc::clone(%26x);%0A++++%0A++++//+Two+threads+calling+%60Arc::into_inner%60+on+both+clones+of+an+%60Arc%60:%0A++++let+x_thread+=+std::thread::spawn(%7C%7C+Arc::into_inner(x));%0A++++let+y_thread+=+std::thread::spawn(%7C%7C+Arc::into_inner(y));%0A++++%0A++++let+x_inner_value+=+x_thread.join().unwrap();%0A++++let+y_inner_value+=+y_thread.join().unwrap();%0A++++%0A++++//+One+of+the+threads+is+guaranteed+to+receive+the+inner+value:%0A++++assert!(matches!(%0A++++++++(x_inner_value,+y_inner_value),%0A++++++++(None,+Some(3))+%7C+(Some(3),+None)%0A++++));%0A++++//+The+result+could+also+be+%60(None,+None)%60+if+the+threads+called%0A++++//+%60Arc::try_unwrap(x).ok()%60+and+%60Arc::try_unwrap(y).ok()%60+instead.%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A more practical example demonstrating the need for <code>Arc::into_inner</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"comment\">// Definition of a simple singly linked list using `Arc`:\n</span><span class=\"attr\">#[derive(Clone)]\n</span><span class=\"kw\">struct </span>LinkedList&lt;T&gt;(<span class=\"prelude-ty\">Option</span>&lt;Arc&lt;Node&lt;T&gt;&gt;&gt;);\n<span class=\"kw\">struct </span>Node&lt;T&gt;(T, <span class=\"prelude-ty\">Option</span>&lt;Arc&lt;Node&lt;T&gt;&gt;&gt;);\n\n<span class=\"comment\">// Dropping a long `LinkedList&lt;T&gt;` relying on the destructor of `Arc`\n// can cause a stack overflow. To prevent this, we can provide a\n// manual `Drop` implementation that does the destruction in a loop:\n</span><span class=\"kw\">impl</span>&lt;T&gt; Drop <span class=\"kw\">for </span>LinkedList&lt;T&gt; {\n    <span class=\"kw\">fn </span>drop(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) {\n        <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>link = <span class=\"self\">self</span>.<span class=\"number\">0</span>.take();\n        <span class=\"kw\">while let </span><span class=\"prelude-val\">Some</span>(arc_node) = link.take() {\n            <span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(Node(_value, next)) = Arc::into_inner(arc_node) {\n                link = next;\n            }\n        }\n    }\n}\n\n<span class=\"comment\">// Implementation of `new` and `push` omitted\n</span><span class=\"kw\">impl</span>&lt;T&gt; LinkedList&lt;T&gt; {\n    <span class=\"comment\">/* ... */\n</span>}\n\n<span class=\"comment\">// The following code could have still caused a stack overflow\n// despite the manual `Drop` impl if that `Drop` impl had used\n// `Arc::try_unwrap(arc).ok()` instead of `Arc::into_inner(arc)`.\n\n// Create a long list and clone it\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = LinkedList::new();\n<span class=\"kw\">let </span>size = <span class=\"number\">100000</span>;\n<span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..size {\n    x.push(i); <span class=\"comment\">// Adds i to the front of x\n</span>}\n<span class=\"kw\">let </span>y = x.clone();\n\n<span class=\"comment\">// Drop the clones in parallel\n</span><span class=\"kw\">let </span>x_thread = std::thread::spawn(|| drop(x));\n<span class=\"kw\">let </span>y_thread = std::thread::spawn(|| drop(y));\nx_thread.join().unwrap();\ny_thread.join().unwrap();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++//+Definition+of+a+simple+singly+linked+list+using+%60Arc%60:%0A++++%23%5Bderive(Clone)%5D%0A++++struct+LinkedList%3CT%3E(Option%3CArc%3CNode%3CT%3E%3E%3E);%0A++++struct+Node%3CT%3E(T,+Option%3CArc%3CNode%3CT%3E%3E%3E);%0A++++%0A++++//+Dropping+a+long+%60LinkedList%3CT%3E%60+relying+on+the+destructor+of+%60Arc%60%0A++++//+can+cause+a+stack+overflow.+To+prevent+this,+we+can+provide+a%0A++++//+manual+%60Drop%60+implementation+that+does+the+destruction+in+a+loop:%0A++++impl%3CT%3E+Drop+for+LinkedList%3CT%3E+%7B%0A++++++++fn+drop(%26mut+self)+%7B%0A++++++++++++let+mut+link+=+self.0.take();%0A++++++++++++while+let+Some(arc_node)+=+link.take()+%7B%0A++++++++++++++++if+let+Some(Node(_value,+next))+=+Arc::into_inner(arc_node)+%7B%0A++++++++++++++++++++link+=+next;%0A++++++++++++++++%7D%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+Implementation+of+%60new%60+and+%60push%60+omitted%0A++++impl%3CT%3E+LinkedList%3CT%3E+%7B%0A++++++++/*+...+*/%0A++++++fn+new()+-%3E+Self+%7B%0A++++++++++LinkedList(None)%0A++++++%7D%0A++++++fn+push(%26mut+self,+x:+T)+%7B%0A++++++++++self.0+=+Some(Arc::new(Node(x,+self.0.take())));%0A++++++%7D%0A++++%7D%0A++++%0A++++//+The+following+code+could+have+still+caused+a+stack+overflow%0A++++//+despite+the+manual+%60Drop%60+impl+if+that+%60Drop%60+impl+had+used%0A++++//+%60Arc::try_unwrap(arc).ok()%60+instead+of+%60Arc::into_inner(arc)%60.%0A++++%0A++++//+Create+a+long+list+and+clone+it%0A++++let+mut+x+=+LinkedList::new();%0A++++let+size+=+100000;%0A++++let+size+=+if+cfg!(miri)+%7B+100+%7D+else+%7B+size+%7D;%0A++++for+i+in+0..size+%7B%0A++++++++x.push(i);+//+Adds+i+to+the+front+of+x%0A++++%7D%0A++++let+y+=+x.clone();%0A++++%0A++++//+Drop+the+clones+in+parallel%0A++++let+x_thread+=+std::thread::spawn(%7C%7C+drop(x));%0A++++let+y_thread+=+std::thread::spawn(%7C%7C+drop(y));%0A++++x_thread.join().unwrap();%0A++++y_thread.join().unwrap();%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3C%5BT%5D%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1112\">source</a><a href=\"#impl-Arc%3C%5BT%5D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_uninit_slice\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1139\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_uninit_slice\" class=\"fn\">new_uninit_slice</a>(len: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new atomically reference-counted slice with uninitialized contents.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>values = Arc::&lt;[u32]&gt;::new_uninit_slice(<span class=\"number\">3</span>);\n\n<span class=\"comment\">// Deferred initialization:\n</span><span class=\"kw\">let </span>data = Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>values).unwrap();\ndata[<span class=\"number\">0</span>].write(<span class=\"number\">1</span>);\ndata[<span class=\"number\">1</span>].write(<span class=\"number\">2</span>);\ndata[<span class=\"number\">2</span>].write(<span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{ values.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+values+=+Arc::%3C%5Bu32%5D%3E::new_uninit_slice(3);%0A++++%0A++++//+Deferred+initialization:%0A++++let+data+=+Arc::get_mut(%26mut+values).unwrap();%0A++++data%5B0%5D.write(1);%0A++++data%5B1%5D.write(2);%0A++++data%5B2%5D.write(3);%0A++++%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_zeroed_slice\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1167\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_zeroed_slice\" class=\"fn\">new_zeroed_slice</a>(len: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new atomically reference-counted slice with uninitialized contents, with the memory being\nfilled with <code>0</code> bytes.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and\nincorrect usage of this method.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>values = Arc::&lt;[u32]&gt;::new_zeroed_slice(<span class=\"number\">3</span>);\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{ values.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+values+=+Arc::%3C%5Bu32%5D%3E::new_zeroed_slice(3);%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B0,+0,+0%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3C%5BT%5D,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1181\">source</a><a href=\"#impl-Arc%3C%5BT%5D,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_uninit_slice_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1211\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_uninit_slice_in\" class=\"fn\">new_uninit_slice_in</a>(len: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, alloc: A) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new atomically reference-counted slice with uninitialized contents in the\nprovided allocator.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>values = Arc::&lt;[u32], <span class=\"kw\">_</span>&gt;::new_uninit_slice_in(<span class=\"number\">3</span>, System);\n\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>values)[<span class=\"number\">0</span>].as_mut_ptr().write(<span class=\"number\">1</span>);\n    Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>values)[<span class=\"number\">1</span>].as_mut_ptr().write(<span class=\"number\">2</span>);\n    Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>values)[<span class=\"number\">2</span>].as_mut_ptr().write(<span class=\"number\">3</span>);\n\n    values.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+mut+values+=+Arc::%3C%5Bu32%5D,+_%3E::new_uninit_slice_in(3,+System);%0A++++%0A++++let+values+=+unsafe+%7B%0A++++++++//+Deferred+initialization:%0A++++++++Arc::get_mut_unchecked(%26mut+values)%5B0%5D.as_mut_ptr().write(1);%0A++++++++Arc::get_mut_unchecked(%26mut+values)%5B1%5D.as_mut_ptr().write(2);%0A++++++++Arc::get_mut_unchecked(%26mut+values)%5B2%5D.as_mut_ptr().write(3);%0A++++%0A++++++++values.assume_init()%0A++++%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_zeroed_slice_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1240\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.new_zeroed_slice_in\" class=\"fn\">new_zeroed_slice_in</a>(len: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, alloc: A) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new atomically reference-counted slice with uninitialized contents, with the memory being\nfilled with <code>0</code> bytes, in the provided allocator.</p>\n<p>See <a href=\"../mem/union.MaybeUninit.html#method.zeroed\" title=\"associated function std::mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and\nincorrect usage of this method.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>values = Arc::&lt;[u32], <span class=\"kw\">_</span>&gt;::new_zeroed_slice_in(<span class=\"number\">3</span>, System);\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{ values.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+values+=+Arc::%3C%5Bu32%5D,+_%3E::new_zeroed_slice_in(3,+System);%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B0,+0,+0%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3CMaybeUninit%3CT%3E,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1257\">source</a><a href=\"#impl-Arc%3CMaybeUninit%3CT%3E,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1290\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.assume_init\" class=\"fn\">assume_init</a>(self) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Converts to <code>Arc&lt;T&gt;</code>.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h5>\n<p>As with <a href=\"../mem/union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>MaybeUninit::assume_init</code></a>,\nit is up to the caller to guarantee that the inner value\nreally is in an initialized state.\nCalling this when the content is not yet fully initialized\ncauses immediate undefined behavior.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Arc::&lt;u32&gt;::new_uninit();\n\n<span class=\"comment\">// Deferred initialization:\n</span>Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>five).unwrap().write(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{ five.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+five+=+Arc::%3Cu32%3E::new_uninit();%0A++++%0A++++//+Deferred+initialization:%0A++++Arc::get_mut(%26mut+five).unwrap().write(5);%0A++++%0A++++let+five+=+unsafe+%7B+five.assume_init()+%7D;%0A++++%0A++++assert_eq!(*five,+5)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3C%5BMaybeUninit%3CT%3E%5D,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1296\">source</a><a href=\"#impl-Arc%3C%5BMaybeUninit%3CT%3E%5D,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;[<a class=\"union\" href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.assume_init-1\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1332\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.assume_init-1\" class=\"fn\">assume_init</a>(self) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63291\">#63291</a>)</span></div></span></summary><div class=\"docblock\"><p>Converts to <code>Arc&lt;[T]&gt;</code>.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">§</a>Safety</h5>\n<p>As with <a href=\"../mem/union.MaybeUninit.html#method.assume_init\" title=\"method std::mem::MaybeUninit::assume_init\"><code>MaybeUninit::assume_init</code></a>,\nit is up to the caller to guarantee that the inner value\nreally is in an initialized state.\nCalling this when the content is not yet fully initialized\ncauses immediate undefined behavior.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>values = Arc::&lt;[u32]&gt;::new_uninit_slice(<span class=\"number\">3</span>);\n\n<span class=\"comment\">// Deferred initialization:\n</span><span class=\"kw\">let </span>data = Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>values).unwrap();\ndata[<span class=\"number\">0</span>].write(<span class=\"number\">1</span>);\ndata[<span class=\"number\">1</span>].write(<span class=\"number\">2</span>);\ndata[<span class=\"number\">2</span>].write(<span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>values = <span class=\"kw\">unsafe </span>{ values.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>values, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(new_uninit)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+values+=+Arc::%3C%5Bu32%5D%3E::new_uninit_slice(3);%0A++++%0A++++//+Deferred+initialization:%0A++++let+data+=+Arc::get_mut(%26mut+values).unwrap();%0A++++data%5B0%5D.write(1);%0A++++data%5B1%5D.write(2);%0A++++data%5B2%5D.write(3);%0A++++%0A++++let+values+=+unsafe+%7B+values.assume_init()+%7D;%0A++++%0A++++assert_eq!(*values,+%5B1,+2,+3%5D)%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3CT%3E-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1338\">source</a><a href=\"#impl-Arc%3CT%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_raw\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1400\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.from_raw\" class=\"fn\">from_raw</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs an <code>Arc&lt;T&gt;</code> from a raw pointer.</p>\n<p>The raw pointer must have been previously returned by a call to\n<a href=\"struct.Arc.html#method.into_raw\" title=\"associated function std::sync::Arc::into_raw\"><code>Arc&lt;U&gt;::into_raw</code></a> with the following requirements:</p>\n<ul>\n<li>If <code>U</code> is sized, it must have the same size and alignment as <code>T</code>. This\nis trivially true if <code>U</code> is <code>T</code>.</li>\n<li>If <code>U</code> is unsized, its data pointer must have the same size and\nalignment as <code>T</code>. This is trivially true if <code>Arc&lt;U&gt;</code> was constructed\nthrough <code>Arc&lt;T&gt;</code> and then converted to <code>Arc&lt;U&gt;</code> through an <a href=\"https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions\">unsized\ncoercion</a>.</li>\n</ul>\n<p>Note that if <code>U</code> or <code>U</code>’s data pointer is not <code>T</code> but has the same size\nand alignment, this is basically like transmuting references of\ndifferent types. See <a href=\"../mem/fn.transmute.html\" title=\"fn std::mem::transmute\"><code>mem::transmute</code></a> for more information\non what restrictions apply in this case.</p>\n<p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only\ndropped once.</p>\n<p>This function is unsafe because improper use may lead to memory unsafety,\neven if the returned <code>Arc&lt;T&gt;</code> is never accessed.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"string\">\"hello\"</span>.to_owned());\n<span class=\"kw\">let </span>x_ptr = Arc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Convert back to an `Arc` to prevent leak.\n    </span><span class=\"kw\">let </span>x = Arc::from_raw(x_ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"string\">\"hello\"</span>);\n\n    <span class=\"comment\">// Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n</span>}\n\n<span class=\"comment\">// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(%22hello%22.to_owned());%0A++++let+x_ptr+=+Arc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++//+Convert+back+to+an+%60Arc%60+to+prevent+leak.%0A++++++++let+x+=+Arc::from_raw(x_ptr);%0A++++++++assert_eq!(%26*x,+%22hello%22);%0A++++%0A++++++++//+Further+calls+to+%60Arc::from_raw(x_ptr)%60+would+be+memory-unsafe.%0A++++%7D%0A++++%0A++++//+The+memory+was+freed+when+%60x%60+went+out+of+scope+above,+so+%60x_ptr%60+is+now+dangling!%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Convert a slice back into its original array:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x: Arc&lt;[u32]&gt; = Arc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"kw\">let </span>x_ptr: <span class=\"kw-2\">*const </span>[u32] = Arc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>x: Arc&lt;[u32; <span class=\"number\">3</span>]&gt; = Arc::from_raw(x_ptr.cast::&lt;[u32; <span class=\"number\">3</span>]&gt;());\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3C%5Bu32%5D%3E+=+Arc::new(%5B1,+2,+3%5D);%0A++++let+x_ptr:+*const+%5Bu32%5D+=+Arc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++let+x:+Arc%3C%5Bu32;+3%5D%3E+=+Arc::from_raw(x_ptr.cast::%3C%5Bu32;+3%5D%3E());%0A++++++++assert_eq!(%26*x,+%26%5B1,+2,+3%5D);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.increment_strong_count\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1432\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.increment_strong_count\" class=\"fn\">increment_strong_count</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>)</h4></section></summary><div class=\"docblock\"><p>Increments the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Arc::into_raw</code>, and the\nassociated <code>Arc</code> instance must be valid (i.e. the strong count must be at\nleast 1) for the duration of this method.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Arc::into_raw(five);\n    Arc::increment_strong_count(ptr);\n\n    <span class=\"comment\">// This assertion is deterministic because we haven't shared\n    // the `Arc` between threads.\n    </span><span class=\"kw\">let </span>five = Arc::from_raw(ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Arc::into_raw(five);%0A++++++++Arc::increment_strong_count(ptr);%0A++++%0A++++++++//+This+assertion+is+deterministic+because+we+haven't+shared%0A++++++++//+the+%60Arc%60+between+threads.%0A++++++++let+five+=+Arc::from_raw(ptr);%0A++++++++assert_eq!(2,+Arc::strong_count(%26five));%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.decrement_strong_count\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1468\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.decrement_strong_count\" class=\"fn\">decrement_strong_count</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>)</h4></section></summary><div class=\"docblock\"><p>Decrements the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Arc::into_raw</code>, and the\nassociated <code>Arc</code> instance must be valid (i.e. the strong count must be at\nleast 1) when invoking this method. This method can be used to release the final\n<code>Arc</code> and backing storage, but <strong>should not</strong> be called after the final <code>Arc</code> has been\nreleased.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Arc::into_raw(five);\n    Arc::increment_strong_count(ptr);\n\n    <span class=\"comment\">// Those assertions are deterministic because we haven't shared\n    // the `Arc` between threads.\n    </span><span class=\"kw\">let </span>five = Arc::from_raw(ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n    Arc::decrement_strong_count(ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Arc::into_raw(five);%0A++++++++Arc::increment_strong_count(ptr);%0A++++%0A++++++++//+Those+assertions+are+deterministic+because+we+haven't+shared%0A++++++++//+the+%60Arc%60+between+threads.%0A++++++++let+five+=+Arc::from_raw(ptr);%0A++++++++assert_eq!(2,+Arc::strong_count(%26five));%0A++++++++Arc::decrement_strong_count(ptr);%0A++++++++assert_eq!(1,+Arc::strong_count(%26five));%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3CT,+A%3E-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1473\">source</a><a href=\"#impl-Arc%3CT,+A%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_raw\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1491\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_raw\" class=\"fn\">into_raw</a>(this: <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a></h4></section></summary><div class=\"docblock\"><p>Consumes the <code>Arc</code>, returning the wrapped pointer.</p>\n<p>To avoid a memory leak the pointer must be converted back to an <code>Arc</code> using\n<a href=\"struct.Arc.html#method.from_raw\" title=\"associated function std::sync::Arc::from_raw\"><code>Arc::from_raw</code></a>.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"string\">\"hello\"</span>.to_owned());\n<span class=\"kw\">let </span>x_ptr = Arc::into_raw(x);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x_ptr }, <span class=\"string\">\"hello\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(%22hello%22.to_owned());%0A++++let+x_ptr+=+Arc::into_raw(x);%0A++++assert_eq!(unsafe+%7B+%26*x_ptr+%7D,+%22hello%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_raw_with_allocator\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1517\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.into_raw_with_allocator\" class=\"fn\">into_raw_with_allocator</a>(this: <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; (<a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>, A)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Consumes the <code>Arc</code>, returning the wrapped pointer and allocator.</p>\n<p>To avoid a memory leak the pointer must be converted back to an <code>Arc</code> using\n<a href=\"struct.Arc.html#method.from_raw_in\" title=\"associated function std::sync::Arc::from_raw_in\"><code>Arc::from_raw_in</code></a>.</p>\n<h5 id=\"examples-25\"><a class=\"doc-anchor\" href=\"#examples-25\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x = Arc::new_in(<span class=\"string\">\"hello\"</span>.to_owned(), System);\n<span class=\"kw\">let </span>(ptr, alloc) = Arc::into_raw_with_allocator(x);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>ptr }, <span class=\"string\">\"hello\"</span>);\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ Arc::from_raw_in(ptr, alloc) };\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"string\">\"hello\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x+=+Arc::new_in(%22hello%22.to_owned(),+System);%0A++++let+(ptr,+alloc)+=+Arc::into_raw_with_allocator(x);%0A++++assert_eq!(unsafe+%7B+%26*ptr+%7D,+%22hello%22);%0A++++let+x+=+unsafe+%7B+Arc::from_raw_in(ptr,+alloc)+%7D;%0A++++assert_eq!(%26*x,+%22hello%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.45.0\">1.45.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1544\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.as_ptr\" class=\"fn\">as_ptr</a>(this: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a></h4></section></summary><div class=\"docblock\"><p>Provides a raw pointer to the data.</p>\n<p>The counts are not affected in any way and the <code>Arc</code> is not consumed. The pointer is valid for\nas long as there are strong counts in the <code>Arc</code>.</p>\n<h5 id=\"examples-26\"><a class=\"doc-anchor\" href=\"#examples-26\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"string\">\"hello\"</span>.to_owned());\n<span class=\"kw\">let </span>y = Arc::clone(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"kw\">let </span>x_ptr = Arc::as_ptr(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"macro\">assert_eq!</span>(x_ptr, Arc::as_ptr(<span class=\"kw-2\">&amp;</span>y));\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x_ptr }, <span class=\"string\">\"hello\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x+=+Arc::new(%22hello%22.to_owned());%0A++++let+y+=+Arc::clone(%26x);%0A++++let+x_ptr+=+Arc::as_ptr(%26x);%0A++++assert_eq!(x_ptr,+Arc::as_ptr(%26y));%0A++++assert_eq!(unsafe+%7B+%26*x_ptr+%7D,+%22hello%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_raw_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1622\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.from_raw_in\" class=\"fn\">from_raw_in</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>, alloc: A) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Constructs an <code>Arc&lt;T, A&gt;</code> from a raw pointer.</p>\n<p>The raw pointer must have been previously returned by a call to <a href=\"struct.Arc.html#method.into_raw\" title=\"associated function std::sync::Arc::into_raw\"><code>Arc&lt;U, A&gt;::into_raw</code></a> with the following requirements:</p>\n<ul>\n<li>If <code>U</code> is sized, it must have the same size and alignment as <code>T</code>. This\nis trivially true if <code>U</code> is <code>T</code>.</li>\n<li>If <code>U</code> is unsized, its data pointer must have the same size and\nalignment as <code>T</code>. This is trivially true if <code>Arc&lt;U&gt;</code> was constructed\nthrough <code>Arc&lt;T&gt;</code> and then converted to <code>Arc&lt;U&gt;</code> through an <a href=\"https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions\">unsized\ncoercion</a>.</li>\n</ul>\n<p>Note that if <code>U</code> or <code>U</code>’s data pointer is not <code>T</code> but has the same size\nand alignment, this is basically like transmuting references of\ndifferent types. See <a href=\"../mem/fn.transmute.html\" title=\"fn std::mem::transmute\"><code>mem::transmute</code></a> for more information\non what restrictions apply in this case.</p>\n<p>The raw pointer must point to a block of memory allocated by <code>alloc</code></p>\n<p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only\ndropped once.</p>\n<p>This function is unsafe because improper use may lead to memory unsafety,\neven if the returned <code>Arc&lt;T&gt;</code> is never accessed.</p>\n<h5 id=\"examples-27\"><a class=\"doc-anchor\" href=\"#examples-27\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x = Arc::new_in(<span class=\"string\">\"hello\"</span>.to_owned(), System);\n<span class=\"kw\">let </span>x_ptr = Arc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Convert back to an `Arc` to prevent leak.\n    </span><span class=\"kw\">let </span>x = Arc::from_raw_in(x_ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"string\">\"hello\"</span>);\n\n    <span class=\"comment\">// Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n</span>}\n\n<span class=\"comment\">// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x+=+Arc::new_in(%22hello%22.to_owned(),+System);%0A++++let+x_ptr+=+Arc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++//+Convert+back+to+an+%60Arc%60+to+prevent+leak.%0A++++++++let+x+=+Arc::from_raw_in(x_ptr,+System);%0A++++++++assert_eq!(%26*x,+%22hello%22);%0A++++%0A++++++++//+Further+calls+to+%60Arc::from_raw(x_ptr)%60+would+be+memory-unsafe.%0A++++%7D%0A++++%0A++++//+The+memory+was+freed+when+%60x%60+went+out+of+scope+above,+so+%60x_ptr%60+is+now+dangling!%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Convert a slice back into its original array:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x: Arc&lt;[u32], <span class=\"kw\">_</span>&gt; = Arc::new_in([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], System);\n<span class=\"kw\">let </span>x_ptr: <span class=\"kw-2\">*const </span>[u32] = Arc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>x: Arc&lt;[u32; <span class=\"number\">3</span>], <span class=\"kw\">_</span>&gt; = Arc::from_raw_in(x_ptr.cast::&lt;[u32; <span class=\"number\">3</span>]&gt;(), System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+x:+Arc%3C%5Bu32%5D,+_%3E+=+Arc::new_in(%5B1,+2,+3%5D,+System);%0A++++let+x_ptr:+*const+%5Bu32%5D+=+Arc::into_raw(x);%0A++++%0A++++unsafe+%7B%0A++++++++let+x:+Arc%3C%5Bu32;+3%5D,+_%3E+=+Arc::from_raw_in(x_ptr.cast::%3C%5Bu32;+3%5D%3E(),+System);%0A++++++++assert_eq!(%26*x,+%26%5B1,+2,+3%5D);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.downgrade\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1647-1649\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.downgrade\" class=\"fn\">downgrade</a>(this: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"struct\" href=\"struct.Weak.html\" title=\"struct std::sync::Weak\">Weak</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates a new <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> pointer to this allocation.</p>\n<h5 id=\"examples-28\"><a class=\"doc-anchor\" href=\"#examples-28\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>weak_five = Arc::downgrade(<span class=\"kw-2\">&amp;</span>five);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++let+weak_five+=+Arc::downgrade(%26five);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.weak_count\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1707\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.weak_count\" class=\"fn\">weak_count</a>(this: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Gets the number of <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> pointers to this allocation.</p>\n<h5 id=\"safety-4\"><a class=\"doc-anchor\" href=\"#safety-4\">§</a>Safety</h5>\n<p>This method by itself is safe, but using it correctly requires extra care.\nAnother thread can change the weak count at any time,\nincluding potentially between calling this method and acting on the result.</p>\n<h5 id=\"examples-29\"><a class=\"doc-anchor\" href=\"#examples-29\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>_weak_five = Arc::downgrade(<span class=\"kw-2\">&amp;</span>five);\n\n<span class=\"comment\">// This assertion is deterministic because we haven't shared\n// the `Arc` or `Weak` between threads.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, Arc::weak_count(<span class=\"kw-2\">&amp;</span>five));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++let+_weak_five+=+Arc::downgrade(%26five);%0A++++%0A++++//+This+assertion+is+deterministic+because+we+haven't+shared%0A++++//+the+%60Arc%60+or+%60Weak%60+between+threads.%0A++++assert_eq!(1,+Arc::weak_count(%26five));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.strong_count\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1737\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.strong_count\" class=\"fn\">strong_count</a>(this: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Gets the number of strong (<code>Arc</code>) pointers to this allocation.</p>\n<h5 id=\"safety-5\"><a class=\"doc-anchor\" href=\"#safety-5\">§</a>Safety</h5>\n<p>This method by itself is safe, but using it correctly requires extra care.\nAnother thread can change the strong count at any time,\nincluding potentially between calling this method and acting on the result.</p>\n<h5 id=\"examples-30\"><a class=\"doc-anchor\" href=\"#examples-30\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>_also_five = Arc::clone(<span class=\"kw-2\">&amp;</span>five);\n\n<span class=\"comment\">// This assertion is deterministic because we haven't shared\n// the `Arc` between threads.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++let+_also_five+=+Arc::clone(%26five);%0A++++%0A++++//+This+assertion+is+deterministic+because+we+haven't+shared%0A++++//+the+%60Arc%60+between+threads.%0A++++assert_eq!(2,+Arc::strong_count(%26five));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.increment_strong_count_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1773-1775\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.increment_strong_count_in\" class=\"fn\">increment_strong_count_in</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>, alloc: A)<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Increments the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-6\"><a class=\"doc-anchor\" href=\"#safety-6\">§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Arc::into_raw</code>, and the\nassociated <code>Arc</code> instance must be valid (i.e. the strong count must be at\nleast 1) for the duration of this method,, and <code>ptr</code> must point to a block of memory\nallocated by <code>alloc</code>.</p>\n<h5 id=\"examples-31\"><a class=\"doc-anchor\" href=\"#examples-31\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Arc::new_in(<span class=\"number\">5</span>, System);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Arc::into_raw(five);\n    Arc::increment_strong_count_in(ptr, System);\n\n    <span class=\"comment\">// This assertion is deterministic because we haven't shared\n    // the `Arc` between threads.\n    </span><span class=\"kw\">let </span>five = Arc::from_raw_in(ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Arc::new_in(5,+System);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Arc::into_raw(five);%0A++++++++Arc::increment_strong_count_in(ptr,+System);%0A++++%0A++++++++//+This+assertion+is+deterministic+because+we+haven't+shared%0A++++++++//+the+%60Arc%60+between+threads.%0A++++++++let+five+=+Arc::from_raw_in(ptr,+System);%0A++++++++assert_eq!(2,+Arc::strong_count(%26five));%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.decrement_strong_count_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1819\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.decrement_strong_count_in\" class=\"fn\">decrement_strong_count_in</a>(ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*const T</a>, alloc: A)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Decrements the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-7\"><a class=\"doc-anchor\" href=\"#safety-7\">§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Arc::into_raw</code>,  the\nassociated <code>Arc</code> instance must be valid (i.e. the strong count must be at\nleast 1) when invoking this method, and <code>ptr</code> must point to a block of memory\nallocated by <code>alloc</code>. This method can be used to release the final\n<code>Arc</code> and backing storage, but <strong>should not</strong> be called after the final <code>Arc</code> has been\nreleased.</p>\n<h5 id=\"examples-32\"><a class=\"doc-anchor\" href=\"#examples-32\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Arc::new_in(<span class=\"number\">5</span>, System);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Arc::into_raw(five);\n    Arc::increment_strong_count_in(ptr, System);\n\n    <span class=\"comment\">// Those assertions are deterministic because we haven't shared\n    // the `Arc` between threads.\n    </span><span class=\"kw\">let </span>five = Arc::from_raw_in(ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n    Arc::decrement_strong_count_in(ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::alloc::System;%0A++++%0A++++let+five+=+Arc::new_in(5,+System);%0A++++%0A++++unsafe+%7B%0A++++++++let+ptr+=+Arc::into_raw(five);%0A++++++++Arc::increment_strong_count_in(ptr,+System);%0A++++%0A++++++++//+Those+assertions+are+deterministic+because+we+haven't+shared%0A++++++++//+the+%60Arc%60+between+threads.%0A++++++++let+five+=+Arc::from_raw_in(ptr,+System);%0A++++++++assert_eq!(2,+Arc::strong_count(%26five));%0A++++++++Arc::decrement_strong_count_in(ptr,+System);%0A++++++++assert_eq!(1,+Arc::strong_count(%26five));%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ptr_eq\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#1867\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.ptr_eq\" class=\"fn\">ptr_eq</a>(this: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;, other: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the two <code>Arc</code>s point to the same allocation in a vein similar to\n<a href=\"../ptr/fn.eq.html\" title=\"ptr::eq\"><code>ptr::eq</code></a>. This function ignores the metadata of  <code>dyn Trait</code> pointers.</p>\n<h5 id=\"examples-33\"><a class=\"doc-anchor\" href=\"#examples-33\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>same_five = Arc::clone(<span class=\"kw-2\">&amp;</span>five);\n<span class=\"kw\">let </span>other_five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(Arc::ptr_eq(<span class=\"kw-2\">&amp;</span>five, <span class=\"kw-2\">&amp;</span>same_five));\n<span class=\"macro\">assert!</span>(!Arc::ptr_eq(<span class=\"kw-2\">&amp;</span>five, <span class=\"kw-2\">&amp;</span>other_five));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++let+same_five+=+Arc::clone(%26five);%0A++++let+other_five+=+Arc::new(5);%0A++++%0A++++assert!(Arc::ptr_eq(%26five,+%26same_five));%0A++++assert!(!Arc::ptr_eq(%26five,+%26other_five));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3CT,+A%3E-2\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2150\">source</a><a href=\"#impl-Arc%3CT,+A%3E-2\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.make_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2204\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.make_mut\" class=\"fn\">make_mut</a>(this: &amp;mut <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\"><p>Makes a mutable reference into the given <code>Arc</code>.</p>\n<p>If there are other <code>Arc</code> pointers to the same allocation, then <code>make_mut</code> will\n<a href=\"../clone/trait.Clone.html#tymethod.clone\" title=\"method std::clone::Clone::clone\"><code>clone</code></a> the inner value to a new allocation to ensure unique ownership.  This is also\nreferred to as clone-on-write.</p>\n<p>However, if there are no other <code>Arc</code> pointers to this allocation, but some <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a>\npointers, then the <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> pointers will be dissociated and the inner value will not\nbe cloned.</p>\n<p>See also <a href=\"struct.Arc.html#method.get_mut\" title=\"associated function std::sync::Arc::get_mut\"><code>get_mut</code></a>, which will fail rather than cloning the inner value\nor dissociating <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> pointers.</p>\n<h5 id=\"examples-34\"><a class=\"doc-anchor\" href=\"#examples-34\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;         <span class=\"comment\">// Won't clone anything\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>other_data = Arc::clone(<span class=\"kw-2\">&amp;</span>data); <span class=\"comment\">// Won't clone inner data\n</span><span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;         <span class=\"comment\">// Clones inner data\n</span><span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;         <span class=\"comment\">// Won't clone anything\n</span><span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>other_data) <span class=\"kw-2\">*</span>= <span class=\"number\">2</span>;   <span class=\"comment\">// Won't clone anything\n\n// Now `data` and `other_data` point to different allocations.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>data, <span class=\"number\">8</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>other_data, <span class=\"number\">12</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+data+=+Arc::new(5);%0A++++%0A++++*Arc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Won't+clone+anything%0A++++let+mut+other_data+=+Arc::clone(%26data);+//+Won't+clone+inner+data%0A++++*Arc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Clones+inner+data%0A++++*Arc::make_mut(%26mut+data)+%2B=+1;+++++++++//+Won't+clone+anything%0A++++*Arc::make_mut(%26mut+other_data)+*=+2;+++//+Won't+clone+anything%0A++++%0A++++//+Now+%60data%60+and+%60other_data%60+point+to+different+allocations.%0A++++assert_eq!(*data,+8);%0A++++assert_eq!(*other_data,+12);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> pointers will be dissociated:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data = Arc::new(<span class=\"number\">75</span>);\n<span class=\"kw\">let </span>weak = Arc::downgrade(<span class=\"kw-2\">&amp;</span>data);\n\n<span class=\"macro\">assert!</span>(<span class=\"number\">75 </span>== <span class=\"kw-2\">*</span>data);\n<span class=\"macro\">assert!</span>(<span class=\"number\">75 </span>== <span class=\"kw-2\">*</span>weak.upgrade().unwrap());\n\n<span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;\n\n<span class=\"macro\">assert!</span>(<span class=\"number\">76 </span>== <span class=\"kw-2\">*</span>data);\n<span class=\"macro\">assert!</span>(weak.upgrade().is_none());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+data+=+Arc::new(75);%0A++++let+weak+=+Arc::downgrade(%26data);%0A++++%0A++++assert!(75+==+*data);%0A++++assert!(75+==+*weak.upgrade().unwrap());%0A++++%0A++++*Arc::make_mut(%26mut+data)+%2B=+1;%0A++++%0A++++assert!(76+==+*data);%0A++++assert!(weak.upgrade().is_none());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3CT,+A%3E-3\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2258\">source</a><a href=\"#impl-Arc%3CT,+A%3E-3\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.unwrap_or_clone\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.76.0\">1.76.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2289\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.unwrap_or_clone\" class=\"fn\">unwrap_or_clone</a>(this: <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; T</h4></section></summary><div class=\"docblock\"><p>If we have the only reference to <code>T</code> then unwrap it. Otherwise, clone <code>T</code> and return the\nclone.</p>\n<p>Assuming <code>arc_t</code> is of type <code>Arc&lt;T&gt;</code>, this function is functionally equivalent to\n<code>(*arc_t).clone()</code>, but will avoid cloning the inner value where possible.</p>\n<h5 id=\"examples-35\"><a class=\"doc-anchor\" href=\"#examples-35\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>inner = String::from(<span class=\"string\">\"test\"</span>);\n<span class=\"kw\">let </span>ptr = inner.as_ptr();\n\n<span class=\"kw\">let </span>arc = Arc::new(inner);\n<span class=\"kw\">let </span>inner = Arc::unwrap_or_clone(arc);\n<span class=\"comment\">// The inner value was not cloned\n</span><span class=\"macro\">assert!</span>(ptr::eq(ptr, inner.as_ptr()));\n\n<span class=\"kw\">let </span>arc = Arc::new(inner);\n<span class=\"kw\">let </span>arc2 = arc.clone();\n<span class=\"kw\">let </span>inner = Arc::unwrap_or_clone(arc);\n<span class=\"comment\">// Because there were 2 references, we had to clone the inner value.\n</span><span class=\"macro\">assert!</span>(!ptr::eq(ptr, inner.as_ptr()));\n<span class=\"comment\">// `arc2` is the last reference, so when we unwrap it we get back\n// the original `String`.\n</span><span class=\"kw\">let </span>inner = Arc::unwrap_or_clone(arc2);\n<span class=\"macro\">assert!</span>(ptr::eq(ptr, inner.as_ptr()));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bptr,+sync::Arc%7D;%0A++++let+inner+=+String::from(%22test%22);%0A++++let+ptr+=+inner.as_ptr();%0A++++%0A++++let+arc+=+Arc::new(inner);%0A++++let+inner+=+Arc::unwrap_or_clone(arc);%0A++++//+The+inner+value+was+not+cloned%0A++++assert!(ptr::eq(ptr,+inner.as_ptr()));%0A++++%0A++++let+arc+=+Arc::new(inner);%0A++++let+arc2+=+arc.clone();%0A++++let+inner+=+Arc::unwrap_or_clone(arc);%0A++++//+Because+there+were+2+references,+we+had+to+clone+the+inner+value.%0A++++assert!(!ptr::eq(ptr,+inner.as_ptr()));%0A++++//+%60arc2%60+is+the+last+reference,+so+when+we+unwrap+it+we+get+back%0A++++//+the+original+%60String%60.%0A++++let+inner+=+Arc::unwrap_or_clone(arc2);%0A++++assert!(ptr::eq(ptr,+inner.as_ptr()));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3CT,+A%3E-4\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2294\">source</a><a href=\"#impl-Arc%3CT,+A%3E-4\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2321\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.get_mut\" class=\"fn\">get_mut</a>(this: &amp;mut <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference into the given <code>Arc</code>, if there are\nno other <code>Arc</code> or <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> pointers to the same allocation.</p>\n<p>Returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> otherwise, because it is not safe to\nmutate a shared value.</p>\n<p>See also <a href=\"struct.Arc.html#method.make_mut\" title=\"associated function std::sync::Arc::make_mut\"><code>make_mut</code></a>, which will <a href=\"../clone/trait.Clone.html#tymethod.clone\" title=\"method std::clone::Clone::clone\"><code>clone</code></a>\nthe inner value when there are other <code>Arc</code> pointers.</p>\n<h5 id=\"examples-36\"><a class=\"doc-anchor\" href=\"#examples-36\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = Arc::new(<span class=\"number\">3</span>);\n<span class=\"kw-2\">*</span>Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>x).unwrap() = <span class=\"number\">4</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">4</span>);\n\n<span class=\"kw\">let </span>_y = Arc::clone(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"macro\">assert!</span>(Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>x).is_none());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+x+=+Arc::new(3);%0A++++*Arc::get_mut(%26mut+x).unwrap()+=+4;%0A++++assert_eq!(*x,+4);%0A++++%0A++++let+_y+=+Arc::clone(%26x);%0A++++assert!(Arc::get_mut(%26mut+x).is_none());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_mut_unchecked\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2396\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.get_mut_unchecked\" class=\"fn\">get_mut_unchecked</a>(this: &amp;mut <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>get_mut_unchecked</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63292\">#63292</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns a mutable reference into the given <code>Arc</code>,\nwithout any check.</p>\n<p>See also <a href=\"struct.Arc.html#method.get_mut\" title=\"associated function std::sync::Arc::get_mut\"><code>get_mut</code></a>, which is safe and does appropriate checks.</p>\n<h5 id=\"safety-8\"><a class=\"doc-anchor\" href=\"#safety-8\">§</a>Safety</h5>\n<p>If any other <code>Arc</code> or <a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a> pointers to the same allocation exist, then\nthey must not be dereferenced or have active borrows for the duration\nof the returned borrow, and their inner type must be exactly the same as the\ninner type of this Rc (including lifetimes). This is trivially the case if no\nsuch pointers exist, for example immediately after <code>Arc::new</code>.</p>\n<h5 id=\"examples-37\"><a class=\"doc-anchor\" href=\"#examples-37\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = Arc::new(String::new());\n<span class=\"kw\">unsafe </span>{\n    Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>x).push_str(<span class=\"string\">\"foo\"</span>)\n}\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"string\">\"foo\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+mut+x+=+Arc::new(String::new());%0A++++unsafe+%7B%0A++++++++Arc::get_mut_unchecked(%26mut+x).push_str(%22foo%22)%0A++++%7D%0A++++assert_eq!(*x,+%22foo%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Other <code>Arc</code> pointers to the same allocation must be to the same type.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x: Arc&lt;str&gt; = Arc::from(<span class=\"string\">\"Hello, world!\"</span>);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>y: Arc&lt;[u8]&gt; = x.clone().into();\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// this is Undefined Behavior, because x's inner type is str, not [u8]\n    </span>Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>y).fill(<span class=\"number\">0xff</span>); <span class=\"comment\">// 0xff is invalid in UTF-8\n</span>}\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"kw-2\">&amp;*</span>x); <span class=\"comment\">// Invalid UTF-8 in a str</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3Cstr%3E+=+Arc::from(%22Hello,+world!%22);%0A++++let+mut+y:+Arc%3C%5Bu8%5D%3E+=+x.clone().into();%0A++++unsafe+%7B%0A++++++++//+this+is+Undefined+Behavior,+because+x's+inner+type+is+str,+not+%5Bu8%5D%0A++++++++Arc::get_mut_unchecked(%26mut+y).fill(0xff);+//+0xff+is+invalid+in+UTF-8%0A++++%7D%0A++++println!(%22%7B%7D%22,+%26*x);+//+Invalid+UTF-8+in+a+str%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Other <code>Arc</code> pointers to the same allocation must be to the exact same type, including lifetimes.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x: Arc&lt;<span class=\"kw-2\">&amp;</span>str&gt; = Arc::new(<span class=\"string\">\"Hello, world!\"</span>);\n{\n    <span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"Oh, no!\"</span>);\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>y: Arc&lt;<span class=\"kw-2\">&amp;</span>str&gt; = x.clone().into();\n    <span class=\"kw\">unsafe </span>{\n        <span class=\"comment\">// this is Undefined Behavior, because x's inner type\n        // is &amp;'long str, not &amp;'short str\n        </span><span class=\"kw-2\">*</span>Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>y) = <span class=\"kw-2\">&amp;</span>s;\n    }\n}\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"kw-2\">&amp;*</span>x); <span class=\"comment\">// Use-after-free</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(get_mut_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3C%26str%3E+=+Arc::new(%22Hello,+world!%22);%0A++++%7B%0A++++++++let+s+=+String::from(%22Oh,+no!%22);%0A++++++++let+mut+y:+Arc%3C%26str%3E+=+x.clone().into();%0A++++++++unsafe+%7B%0A++++++++++++//+this+is+Undefined+Behavior,+because+x's+inner+type%0A++++++++++++//+is+%26'long+str,+not+%26'short+str%0A++++++++++++*Arc::get_mut_unchecked(%26mut+y)+=+%26s;%0A++++++++%7D%0A++++%7D%0A++++println!(%22%7B%7D%22,+%26*x);+//+Use-after-free%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Arc%3Cdyn+Any+%2B+Send+%2B+Sync,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2511\">source</a><a href=\"#impl-Arc%3Cdyn+Any+%2B+Send+%2B+Sync,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;dyn <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> + <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.downcast\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.29.0\">1.29.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2532-2534\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.downcast\" class=\"fn\">downcast</a>&lt;T&gt;(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;, <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;dyn <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> + <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>, A&gt;&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a>,</div></h4></section></summary><div class=\"docblock\"><p>Attempt to downcast the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete type.</p>\n<h5 id=\"examples-38\"><a class=\"doc-anchor\" href=\"#examples-38\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::any::Any;\n<span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">fn </span>print_if_string(value: Arc&lt;<span class=\"kw\">dyn </span>Any + Send + Sync&gt;) {\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Ok</span>(string) = value.downcast::&lt;String&gt;() {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"String ({}): {}\"</span>, string.len(), string);\n    }\n}\n\n<span class=\"kw\">let </span>my_string = <span class=\"string\">\"Hello World\"</span>.to_string();\nprint_if_string(Arc::new(my_string));\nprint_if_string(Arc::new(<span class=\"number\">0i8</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::any::Any;%0A++++use+std::sync::Arc;%0A++++%0A++++fn+print_if_string(value:+Arc%3Cdyn+Any+%2B+Send+%2B+Sync%3E)+%7B%0A++++++++if+let+Ok(string)+=+value.downcast::%3CString%3E()+%7B%0A++++++++++++println!(%22String+(%7B%7D):+%7B%7D%22,+string.len(),+string);%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+my_string+=+%22Hello+World%22.to_string();%0A++++print_if_string(Arc::new(my_string));%0A++++print_if_string(Arc::new(0i8));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.downcast_unchecked\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2574-2576\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.downcast_unchecked\" class=\"fn\">downcast_unchecked</a>&lt;T&gt;(self) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>downcast_unchecked</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/90850\">#90850</a>)</span></div></span></summary><div class=\"docblock\"><p>Downcasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete type.</p>\n<p>For a safe alternative see <a href=\"struct.Arc.html#method.downcast\" title=\"method std::sync::Arc::downcast\"><code>downcast</code></a>.</p>\n<h5 id=\"examples-39\"><a class=\"doc-anchor\" href=\"#examples-39\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(downcast_unchecked)]\n\n</span><span class=\"kw\">use </span>std::any::Any;\n<span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x: Arc&lt;<span class=\"kw\">dyn </span>Any + Send + Sync&gt; = Arc::new(<span class=\"number\">1_usize</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x.downcast_unchecked::&lt;usize&gt;(), <span class=\"number\">1</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(downcast_unchecked)%5D%0A%0Afn+main()+%7B%0A++++use+std::any::Any;%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3Cdyn+Any+%2B+Send+%2B+Sync%3E+=+Arc::new(1_usize);%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(*x.downcast_unchecked::%3Cusize%3E(),+1);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<h5 id=\"safety-9\"><a class=\"doc-anchor\" href=\"#safety-9\">§</a>Safety</h5>\n<p>The contained value must be of type <code>T</code>. Calling this method\nwith the incorrect type is <em>undefined behavior</em>.</p>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">§</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsFd-for-Arc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.64.0\">1.64.0</span> · <a class=\"src\" href=\"../../src/std/os/fd/owned.rs.html#407-412\">source</a></span><a href=\"#impl-AsFd-for-Arc%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: <a class=\"trait\" href=\"../os/fd/trait.AsFd.html\" title=\"trait std::os::fd::AsFd\">AsFd</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>&gt; <a class=\"trait\" href=\"../os/fd/trait.AsFd.html\" title=\"trait std::os::fd::AsFd\">AsFd</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h3></section></summary><div class=\"docblock\"><p>This impl allows implementing traits that require <code>AsFd</code> on Arc.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::UdpSocket;\n<span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">trait </span>MyTrait: AsFd {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Arc&lt;UdpSocket&gt; {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Box&lt;UdpSocket&gt; {}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(any(unix,+target_os+=+%22wasi%22))%5D+mod+group_cfg+%7B%0A++++%23%5Bcfg(target_os+=+%22wasi%22)%5D%0A++++use+std::os::wasi::io::AsFd;%0A++++%23%5Bcfg(unix)%5D%0A++++use+std::os::unix::io::AsFd;%0A++++use+std::net::UdpSocket;%0A++++use+std::sync::Arc;%0A++++%0A++++trait+MyTrait:+AsFd+%7B%7D%0A++++impl+MyTrait+for+Arc%3CUdpSocket%3E+%7B%7D%0A++++impl+MyTrait+for+Box%3CUdpSocket%3E+%7B%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_fd\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/os/fd/owned.rs.html#409-411\">source</a><a href=\"#method.as_fd\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../os/fd/trait.AsFd.html#tymethod.as_fd\" class=\"fn\">as_fd</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../os/fd/struct.BorrowedFd.html\" title=\"struct std::os::fd::BorrowedFd\">BorrowedFd</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\">Borrows the file descriptor. <a href=\"../os/fd/trait.AsFd.html#tymethod.as_fd\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsHandle-for-Arc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.71.0\">1.71.0</span> · <a class=\"src\" href=\"../../src/std/os/windows/io/handle.rs.html#479-484\">source</a></span><a href=\"#impl-AsHandle-for-Arc%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: <a class=\"trait\" href=\"../os/windows/io/trait.AsHandle.html\" title=\"trait std::os::windows::io::AsHandle\">AsHandle</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>&gt; <a class=\"trait\" href=\"../os/windows/io/trait.AsHandle.html\" title=\"trait std::os::windows::io::AsHandle\">AsHandle</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h3><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>Windows</strong> only.</div></span></section></summary><div class=\"docblock\"><p>This impl allows implementing traits that require <code>AsHandle</code> on Arc.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">trait </span>MyTrait: AsHandle {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Arc&lt;File&gt; {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Box&lt;File&gt; {}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(windows)%5D+mod+group_cfg+%7B%0A++++use+std::os::windows::io::AsHandle;%0A++++use+std::fs::File;%0A++++use+std::sync::Arc;%0A++++%0A++++trait+MyTrait:+AsHandle+%7B%7D%0A++++impl+MyTrait+for+Arc%3CFile%3E+%7B%7D%0A++++impl+MyTrait+for+Box%3CFile%3E+%7B%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_handle\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/os/windows/io/handle.rs.html#481-483\">source</a><a href=\"#method.as_handle\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../os/windows/io/trait.AsHandle.html#tymethod.as_handle\" class=\"fn\">as_handle</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../os/windows/io/struct.BorrowedHandle.html\" title=\"struct std::os::windows::io::BorrowedHandle\">BorrowedHandle</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\">Borrows the handle. <a href=\"../os/windows/io/trait.AsHandle.html#tymethod.as_handle\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsRawFd-for-Arc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.63.0\">1.63.0</span> · <a class=\"src\" href=\"../../src/std/os/fd/raw.rs.html#253-258\">source</a></span><a href=\"#impl-AsRawFd-for-Arc%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: <a class=\"trait\" href=\"../os/fd/trait.AsRawFd.html\" title=\"trait std::os::fd::AsRawFd\">AsRawFd</a>&gt; <a class=\"trait\" href=\"../os/fd/trait.AsRawFd.html\" title=\"trait std::os::fd::AsRawFd\">AsRawFd</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h3></section></summary><div class=\"docblock\"><p>This impl allows implementing traits that require <code>AsRawFd</code> on Arc.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::UdpSocket;\n<span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">trait </span>MyTrait: AsRawFd {\n}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Arc&lt;UdpSocket&gt; {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Box&lt;UdpSocket&gt; {}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(any(unix,+target_os+=+%22wasi%22))%5D+mod+group_cfg+%7B%0A++++%23%5Bcfg(target_os+=+%22wasi%22)%5D%0A++++use+std::os::wasi::io::AsRawFd;%0A++++%23%5Bcfg(unix)%5D%0A++++use+std::os::unix::io::AsRawFd;%0A++++use+std::net::UdpSocket;%0A++++use+std::sync::Arc;%0A++++trait+MyTrait:+AsRawFd+%7B%0A++++%7D%0A++++impl+MyTrait+for+Arc%3CUdpSocket%3E+%7B%7D%0A++++impl+MyTrait+for+Box%3CUdpSocket%3E+%7B%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_raw_fd\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/os/fd/raw.rs.html#255-257\">source</a><a href=\"#method.as_raw_fd\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../os/fd/trait.AsRawFd.html#tymethod.as_raw_fd\" class=\"fn\">as_raw_fd</a>(&amp;self) -&gt; <a class=\"type\" href=\"../os/fd/type.RawFd.html\" title=\"type std::os::fd::RawFd\">RawFd</a></h4></section></summary><div class=\"docblock\">Extracts the raw file descriptor. <a href=\"../os/fd/trait.AsRawFd.html#tymethod.as_raw_fd\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsRef%3CT%3E-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3778\">source</a></span><a href=\"#impl-AsRef%3CT%3E-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_ref\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3779\">source</a><a href=\"#method.as_ref\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.AsRef.html#tymethod.as_ref\" class=\"fn\">as_ref</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsSocket-for-Arc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.71.0\">1.71.0</span> · <a class=\"src\" href=\"../../src/std/os/windows/io/socket.rs.html#270-275\">source</a></span><a href=\"#impl-AsSocket-for-Arc%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: <a class=\"trait\" href=\"../os/windows/io/trait.AsSocket.html\" title=\"trait std::os::windows::io::AsSocket\">AsSocket</a>&gt; <a class=\"trait\" href=\"../os/windows/io/trait.AsSocket.html\" title=\"trait std::os::windows::io::AsSocket\">AsSocket</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h3><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>Windows</strong> only.</div></span></section></summary><div class=\"docblock\"><p>This impl allows implementing traits that require <code>AsSocket</code> on Arc.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::UdpSocket;\n<span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">trait </span>MyTrait: AsSocket {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Arc&lt;UdpSocket&gt; {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Box&lt;UdpSocket&gt; {}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(windows)%5D+mod+group_cfg+%7B%0A++++use+std::os::windows::io::AsSocket;%0A++++use+std::net::UdpSocket;%0A++++use+std::sync::Arc;%0A++++%0A++++trait+MyTrait:+AsSocket+%7B%7D%0A++++impl+MyTrait+for+Arc%3CUdpSocket%3E+%7B%7D%0A++++impl+MyTrait+for+Box%3CUdpSocket%3E+%7B%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_socket\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/os/windows/io/socket.rs.html#272-274\">source</a><a href=\"#method.as_socket\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../os/windows/io/trait.AsSocket.html#tymethod.as_socket\" class=\"fn\">as_socket</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../os/windows/io/struct.BorrowedSocket.html\" title=\"struct std::os::windows::io::BorrowedSocket\">BorrowedSocket</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\">Borrows the socket.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Borrow%3CT%3E-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3771\">source</a></span><a href=\"#impl-Borrow%3CT%3E-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3772\">source</a><a href=\"#method.borrow\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Clone-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2081\">source</a></span><a href=\"#impl-Clone-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2097\">source</a><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Makes a clone of the <code>Arc</code> pointer.</p>\n<p>This creates another pointer to the same allocation, increasing the\nstrong reference count.</p>\n<h5 id=\"examples-40\"><a class=\"doc-anchor\" href=\"#examples-40\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let _ </span>= Arc::clone(<span class=\"kw-2\">&amp;</span>five);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++let+_+=+Arc::clone(%26five);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#169\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Self</a>)</h4></section></summary><div class=\"docblock\">Performs copy-assignment from <code>source</code>. <a href=\"../clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3354\">source</a></span><a href=\"#impl-Debug-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3355\">source</a><a href=\"#method.fmt-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-Arc%3C%5BT%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3443\">source</a></span><a href=\"#impl-Default-for-Arc%3C%5BT%5D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3448\">source</a><a href=\"#method.default\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty <code>[T]</code> inside an Arc</p>\n<p>This may or may not share an allocation with other Arcs.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-Arc%3CCStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3424\">source</a></span><a href=\"#impl-Default-for-Arc%3CCStr%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3429\">source</a><a href=\"#method.default-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty CStr inside an Arc</p>\n<p>This may or may not share an allocation with other Arcs.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-Arc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3369\">source</a></span><a href=\"#impl-Default-for-Arc%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3380\">source</a><a href=\"#method.default-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>Arc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.</p>\n<h5 id=\"examples-43\"><a class=\"doc-anchor\" href=\"#examples-43\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x: Arc&lt;i32&gt; = Default::default();\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+x:+Arc%3Ci32%3E+=+Default::default();%0A++++assert_eq!(*x,+0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-Arc%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3409\">source</a></span><a href=\"#impl-Default-for-Arc%3Cstr%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3414\">source</a><a href=\"#method.default-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty str inside an Arc</p>\n<p>This may or may not share an allocation with other Arcs.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Deref-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2135\">source</a></span><a href=\"#impl-Deref-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../ops/trait.Deref.html\" title=\"trait std::ops::Deref\">Deref</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Target\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Target\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.Deref.html#associatedtype.Target\" class=\"associatedtype\">Target</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after dereferencing.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.deref\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2139\">source</a><a href=\"#method.deref\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.Deref.html#tymethod.deref\" class=\"fn\">deref</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Dereferences the value.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Display-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3347\">source</a></span><a href=\"#impl-Display-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3348\">source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Display.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Display.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Drop-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2432\">source</a></span><a href=\"#impl-Drop-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../ops/trait.Drop.html\" title=\"trait std::ops::Drop\">Drop</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.drop\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2459\">source</a><a href=\"#method.drop\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.Drop.html#tymethod.drop\" class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Drops the <code>Arc</code>.</p>\n<p>This will decrement the strong reference count. If the strong reference\ncount reaches zero then the only other references (if any) are\n<a href=\"struct.Weak.html\" title=\"struct std::sync::Weak\"><code>Weak</code></a>, so we <code>drop</code> the inner value.</p>\n<h5 id=\"examples-44\"><a class=\"doc-anchor\" href=\"#examples-44\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">struct </span>Foo;\n\n<span class=\"kw\">impl </span>Drop <span class=\"kw\">for </span>Foo {\n    <span class=\"kw\">fn </span>drop(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"dropped!\"</span>);\n    }\n}\n\n<span class=\"kw\">let </span>foo  = Arc::new(Foo);\n<span class=\"kw\">let </span>foo2 = Arc::clone(<span class=\"kw-2\">&amp;</span>foo);\n\ndrop(foo);    <span class=\"comment\">// Doesn't print anything\n</span>drop(foo2);   <span class=\"comment\">// Prints \"dropped!\"</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++struct+Foo;%0A++++%0A++++impl+Drop+for+Foo+%7B%0A++++++++fn+drop(%26mut+self)+%7B%0A++++++++++++println!(%22dropped!%22);%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+foo++=+Arc::new(Foo);%0A++++let+foo2+=+Arc::clone(%26foo);%0A++++%0A++++drop(foo);++++//+Doesn't+print+anything%0A++++drop(foo2);+++//+Prints+%22dropped!%22%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Error-for-Arc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.52.0\">1.52.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3810\">source</a></span><a href=\"#impl-Error-for-Arc%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../error/trait.Error.html\" title=\"trait std::error::Error\">Error</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../error/trait.Error.html\" title=\"trait std::error::Error\">Error</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.description\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3812\">source</a><a href=\"#method.description\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../error/trait.Error.html#method.description\" class=\"fn\">description</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.42.0: use the Display impl or to_string()</span></div></span><div class=\"docblock\"> <a href=\"../error/trait.Error.html#method.description\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cause\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3817\">source</a><a href=\"#method.cause\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../error/trait.Error.html#method.cause\" class=\"fn\">cause</a>(&amp;self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;dyn <a class=\"trait\" href=\"../error/trait.Error.html\" title=\"trait std::error::Error\">Error</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.33.0: replaced by Error::source, which can support downcasting</span></div></span></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.source\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3821\">source</a><a href=\"#method.source\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../error/trait.Error.html#method.source\" class=\"fn\">source</a>(&amp;self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;(dyn <a class=\"trait\" href=\"../error/trait.Error.html\" title=\"trait std::error::Error\">Error</a> + 'static)&gt;</h4></section></summary><div class=\"docblock\">The lower-level source of this error, if any. <a href=\"../error/trait.Error.html#method.source\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.provide\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3825\">source</a><a href=\"#method.provide\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../error/trait.Error.html#method.provide\" class=\"fn\">provide</a>&lt;'a&gt;(&amp;'a self, req: &amp;mut <a class=\"struct\" href=\"../error/struct.Request.html\" title=\"struct std::error::Request\">Request</a>&lt;'a&gt;)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>error_generic_member_access</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/99301\">#99301</a>)</span></div></span><div class=\"docblock\">Provides type based access to context intended for error reports. <a href=\"../error/trait.Error.html#method.provide\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26%5BT%5D%3E-for-Arc%3C%5BT%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3520\">source</a></span><a href=\"#impl-From%3C%26%5BT%5D%3E-for-Arc%3C%5BT%5D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-10\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3532\">source</a><a href=\"#method.from-10\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted slice and fill it by cloning <code>v</code>’s items.</p>\n<h5 id=\"example-8\"><a class=\"doc-anchor\" href=\"#example-8\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>original: <span class=\"kw-2\">&amp;</span>[i32] = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>shared: Arc&lt;[i32]&gt; = Arc::from(original);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+original:+%26%5Bi32%5D+=+%26%5B1,+2,+3%5D;%0A++++let+shared:+Arc%3C%5Bi32%5D%3E+=+Arc::from(original);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26CStr%3E-for-Arc%3CCStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#881\">source</a></span><a href=\"#impl-From%3C%26CStr%3E-for-Arc%3CCStr%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#885\">source</a><a href=\"#method.from-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <code>&amp;CStr</code> into a <code>Arc&lt;CStr&gt;</code>,\nby copying the contents into a newly allocated <a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a>.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26OsStr%3E-for-Arc%3COsStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> · <a class=\"src\" href=\"../../src/std/ffi/os_str.rs.html#1252-1259\">source</a></span><a href=\"#impl-From%3C%26OsStr%3E-for-Arc%3COsStr%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-14\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/ffi/os_str.rs.html#1255-1258\">source</a><a href=\"#method.from-14\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Copies the string into a newly allocated <code><a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</code>.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26Path%3E-for-Arc%3CPath%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> · <a class=\"src\" href=\"../../src/std/path.rs.html#1879-1886\">source</a></span><a href=\"#impl-From%3C%26Path%3E-for-Arc%3CPath%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-15\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/path.rs.html#1882-1885\">source</a><a href=\"#method.from-15\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: &amp;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"../path/struct.Path.html\" title=\"struct std::path::Path\"><code>Path</code></a> into an <a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a> by copying the <a href=\"../path/struct.Path.html\" title=\"struct std::path::Path\"><code>Path</code></a> data into a new <a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a> buffer.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%26str%3E-for-Arc%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3539\">source</a></span><a href=\"#impl-From%3C%26str%3E-for-Arc%3Cstr%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3550\">source</a><a href=\"#method.from-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted <code>str</code> and copy <code>v</code> into it.</p>\n<h5 id=\"example-2\"><a class=\"doc-anchor\" href=\"#example-2\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>shared: Arc&lt;str&gt; = Arc::from(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(%22eggplant%22);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%5BT;+N%5D%3E-for-Arc%3C%5BT%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.74.0\">1.74.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3499\">source</a></span><a href=\"#impl-From%3C%5BT;+N%5D%3E-for-Arc%3C%5BT%5D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3513\">source</a><a href=\"#method.from-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"../primitive.array.html\" title=\"primitive array\"><code>[T; N]</code></a> into an <code>Arc&lt;[T]&gt;</code>.</p>\n<p>The conversion moves the array into a newly allocated <code>Arc</code>.</p>\n<h5 id=\"example-3\"><a class=\"doc-anchor\" href=\"#example-3\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>original: [i32; <span class=\"number\">3</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>shared: Arc&lt;[i32]&gt; = Arc::from(original);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+original:+%5Bi32;+3%5D+=+%5B1,+2,+3%5D;%0A++++let+shared:+Arc%3C%5Bi32%5D%3E+=+Arc::from(original);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CArc%3CW%3E%3E-for-RawWaker\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#121\">source</a></span><a href=\"#impl-From%3CArc%3CW%3E%3E-for-RawWaker\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;W&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;W&gt;&gt; for <a class=\"struct\" href=\"../task/struct.RawWaker.html\" title=\"struct std::task::RawWaker\">RawWaker</a><div class=\"where\">where\n    W: <a class=\"trait\" href=\"../task/trait.Wake.html\" title=\"trait std::task::Wake\">Wake</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> + 'static,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-11\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#125\">source</a><a href=\"#method.from-11\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(waker: <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;W&gt;) -&gt; <a class=\"struct\" href=\"../task/struct.RawWaker.html\" title=\"struct std::task::RawWaker\">RawWaker</a></h4></section></summary><div class=\"docblock\"><p>Use a <code>Wake</code>-able type as a <code>RawWaker</code>.</p>\n<p>No heap allocations or atomic operations are used for this conversion.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CArc%3CW%3E%3E-for-Waker\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#109\">source</a></span><a href=\"#impl-From%3CArc%3CW%3E%3E-for-Waker\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;W&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;W&gt;&gt; for <a class=\"struct\" href=\"../task/struct.Waker.html\" title=\"struct std::task::Waker\">Waker</a><div class=\"where\">where\n    W: <a class=\"trait\" href=\"../task/trait.Wake.html\" title=\"trait std::task::Wake\">Wake</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> + 'static,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-8\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/task.rs.html#113\">source</a><a href=\"#method.from-8\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(waker: <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;W&gt;) -&gt; <a class=\"struct\" href=\"../task/struct.Waker.html\" title=\"struct std::task::Waker\">Waker</a></h4></section></summary><div class=\"docblock\"><p>Use a <a href=\"../task/trait.Wake.html\" title=\"trait std::task::Wake\"><code>Wake</code></a>-able type as a <code>Waker</code>.</p>\n<p>No heap allocations or atomic operations are used for this conversion.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CArc%3Cstr%3E%3E-for-Arc%3C%5Bu8%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.62.0\">1.62.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3652\">source</a></span><a href=\"#impl-From%3CArc%3Cstr%3E%3E-for-Arc%3C%5Bu8%5D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3664\">source</a><a href=\"#method.from-4\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(rc: <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;</h4></section></summary><div class=\"docblock\"><p>Converts an atomically reference-counted string slice into a byte slice.</p>\n<h5 id=\"example-4\"><a class=\"doc-anchor\" href=\"#example-4\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>string: Arc&lt;str&gt; = Arc::from(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"kw\">let </span>bytes: Arc&lt;[u8]&gt; = Arc::from(string);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>.as_bytes(), bytes.as_ref());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+string:+Arc%3Cstr%3E+=+Arc::from(%22eggplant%22);%0A++++let+bytes:+Arc%3C%5Bu8%5D%3E+=+Arc::from(string);%0A++++assert_eq!(%22eggplant%22.as_bytes(),+bytes.as_ref());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CBox%3CT,+A%3E%3E-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3577\">source</a></span><a href=\"#impl-From%3CBox%3CT,+A%3E%3E-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;T, A&gt;&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-6\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3589\">source</a><a href=\"#method.from-6\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;T, A&gt;) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Move a boxed object to a new, reference-counted allocation.</p>\n<h5 id=\"example-5\"><a class=\"doc-anchor\" href=\"#example-5\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>unique: Box&lt;str&gt; = Box::from(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"kw\">let </span>shared: Arc&lt;str&gt; = Arc::from(unique);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+unique:+Box%3Cstr%3E+=+Box::from(%22eggplant%22);%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(unique);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CCString%3E-for-Arc%3CCStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#869\">source</a></span><a href=\"#impl-From%3CCString%3E-for-Arc%3CCStr%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CString.html\" title=\"struct std::ffi::CString\">CString</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#873\">source</a><a href=\"#method.from-5\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"../ffi/struct.CString.html\" title=\"struct std::ffi::CString\">CString</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"../ffi/struct.CString.html\" title=\"struct std::ffi::CString\"><code>CString</code></a> into an <code><a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt;</code> by moving the <a href=\"../ffi/struct.CString.html\" title=\"struct std::ffi::CString\"><code>CString</code></a>\ndata into a new <a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a> buffer.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CCow%3C'a,+B%3E%3E-for-Arc%3CB%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.45.0\">1.45.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3625-3628\">source</a></span><a href=\"#impl-From%3CCow%3C'a,+B%3E%3E-for-Arc%3CB%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, B&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, B&gt;&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;B&gt;<div class=\"where\">where\n    B: <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;B&gt;: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a B</a>&gt; + <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;&lt;B as <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a>&gt;::<a class=\"associatedtype\" href=\"../borrow/trait.ToOwned.html#associatedtype.Owned\" title=\"type std::borrow::ToOwned::Owned\">Owned</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-12\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3643\">source</a><a href=\"#method.from-12\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(cow: <a class=\"enum\" href=\"../borrow/enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, B&gt;) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;B&gt;</h4></section></summary><div class=\"docblock\"><p>Create an atomically reference-counted pointer from\na clone-on-write pointer by copying its content.</p>\n<h5 id=\"example-9\"><a class=\"doc-anchor\" href=\"#example-9\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>cow: Cow&lt;<span class=\"lifetime\">'_</span>, str&gt; = Cow::Borrowed(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"kw\">let </span>shared: Arc&lt;str&gt; = Arc::from(cow);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::borrow::Cow;%0A++++let+cow:+Cow%3C'_,+str%3E+=+Cow::Borrowed(%22eggplant%22);%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(cow);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3COsString%3E-for-Arc%3COsStr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> · <a class=\"src\" href=\"../../src/std/ffi/os_str.rs.html#1241-1249\">source</a></span><a href=\"#impl-From%3COsString%3E-for-Arc%3COsStr%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-16\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/ffi/os_str.rs.html#1245-1248\">source</a><a href=\"#method.from-16\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts an <a href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a> into an <code><a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;</code> by moving the <a href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\"><code>OsString</code></a>\ndata into a new <a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a> buffer.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CPathBuf%3E-for-Arc%3CPath%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> · <a class=\"src\" href=\"../../src/std/path.rs.html#1868-1876\">source</a></span><a href=\"#impl-From%3CPathBuf%3E-for-Arc%3CPath%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\">PathBuf</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-13\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/path.rs.html#1872-1875\">source</a><a href=\"#method.from-13\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(s: <a class=\"struct\" href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\">PathBuf</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\"><code>PathBuf</code></a> into an <code><a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;</code> by moving the <a href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\"><code>PathBuf</code></a> data\ninto a new <a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a> buffer.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CString%3E-for-Arc%3Cstr%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3558\">source</a></span><a href=\"#impl-From%3CString%3E-for-Arc%3Cstr%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a>&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-7\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3570\">source</a><a href=\"#method.from-7\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted <code>str</code> and copy <code>v</code> into it.</p>\n<h5 id=\"example-6\"><a class=\"doc-anchor\" href=\"#example-6\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>unique: String = <span class=\"string\">\"eggplant\"</span>.to_owned();\n<span class=\"kw\">let </span>shared: Arc&lt;str&gt; = Arc::from(unique);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+unique:+String+=+%22eggplant%22.to_owned();%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(unique);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CT%3E-for-Arc%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3477\">source</a></span><a href=\"#impl-From%3CT%3E-for-Arc%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-9\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3492\">source</a><a href=\"#method.from-9\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <code>T</code> into an <code>Arc&lt;T&gt;</code></p>\n<p>The conversion moves the value into a\nnewly allocated <code>Arc</code>. It is equivalent to\ncalling <code>Arc::new(t)</code>.</p>\n<h5 id=\"example-7\"><a class=\"doc-anchor\" href=\"#example-7\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">5</span>;\n<span class=\"kw\">let </span>arc = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(Arc::from(x), arc);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+x+=+5;%0A++++let+arc+=+Arc::new(5);%0A++++%0A++++assert_eq!(Arc::from(x),+arc);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CVec%3CT,+A%3E%3E-for-Arc%3C%5BT%5D,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3596\">source</a></span><a href=\"#impl-From%3CVec%3CT,+A%3E%3E-for-Arc%3C%5BT%5D,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3608\">source</a><a href=\"#method.from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(v: <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;</h4></section></summary><div class=\"docblock\"><p>Allocate a reference-counted slice and move <code>v</code>’s items into it.</p>\n<h5 id=\"example-1\"><a class=\"doc-anchor\" href=\"#example-1\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>unique: Vec&lt;i32&gt; = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>shared: Arc&lt;[i32]&gt; = Arc::from(unique);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+unique:+Vec%3Ci32%3E+=+vec!%5B1,+2,+3%5D;%0A++++let+shared:+Arc%3C%5Bi32%5D%3E+=+Arc::from(unique);%0A++++assert_eq!(%26%5B1,+2,+3%5D,+%26shared%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3CT%3E-for-Arc%3C%5BT%5D%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.37.0\">1.37.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3686\">source</a></span><a href=\"#impl-FromIterator%3CT%3E-for-Arc%3C%5BT%5D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3725\">source</a><a href=\"#method.from_iter\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Takes each element in the <code>Iterator</code> and collects it into an <code>Arc&lt;[T]&gt;</code>.</p>\n<h5 id=\"performance-characteristics\"><a class=\"doc-anchor\" href=\"#performance-characteristics\">§</a>Performance characteristics</h5><h6 id=\"the-general-case\"><a class=\"doc-anchor\" href=\"#the-general-case\">§</a>The general case</h6>\n<p>In the general case, collecting into <code>Arc&lt;[T]&gt;</code> is done by first\ncollecting into a <code>Vec&lt;T&gt;</code>. That is, when writing the following:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>evens: Arc&lt;[u8]&gt; = (<span class=\"number\">0</span>..<span class=\"number\">10</span>).filter(|<span class=\"kw-2\">&amp;</span>x| x % <span class=\"number\">2 </span>== <span class=\"number\">0</span>).collect();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+evens:+Arc%3C%5Bu8%5D%3E+=+(0..10).filter(%7C%26x%7C+x+%25+2+==+0).collect();%0A++++assert_eq!(%26*evens,+%26%5B0,+2,+4,+6,+8%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>this behaves as if we wrote:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>evens: Arc&lt;[u8]&gt; = (<span class=\"number\">0</span>..<span class=\"number\">10</span>).filter(|<span class=\"kw-2\">&amp;</span>x| x % <span class=\"number\">2 </span>== <span class=\"number\">0</span>)\n    .collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;() <span class=\"comment\">// The first set of allocations happens here.\n    </span>.into(); <span class=\"comment\">// A second allocation for `Arc&lt;[T]&gt;` happens here.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+evens:+Arc%3C%5Bu8%5D%3E+=+(0..10).filter(%7C%26x%7C+x+%25+2+==+0)%0A++++++++.collect::%3CVec%3C_%3E%3E()+//+The+first+set+of+allocations+happens+here.%0A++++++++.into();+//+A+second+allocation+for+%60Arc%3C%5BT%5D%3E%60+happens+here.%0A++++assert_eq!(%26*evens,+%26%5B0,+2,+4,+6,+8%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will allocate as many times as needed for constructing the <code>Vec&lt;T&gt;</code>\nand then it will allocate once for turning the <code>Vec&lt;T&gt;</code> into the <code>Arc&lt;[T]&gt;</code>.</p>\n<h6 id=\"iterators-of-known-length\"><a class=\"doc-anchor\" href=\"#iterators-of-known-length\">§</a>Iterators of known length</h6>\n<p>When your <code>Iterator</code> implements <code>TrustedLen</code> and is of an exact size,\na single allocation will be made for the <code>Arc&lt;[T]&gt;</code>. For example:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>evens: Arc&lt;[u8]&gt; = (<span class=\"number\">0</span>..<span class=\"number\">10</span>).collect(); <span class=\"comment\">// Just a single allocation happens here.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+evens:+Arc%3C%5Bu8%5D%3E+=+(0..10).collect();+//+Just+a+single+allocation+happens+here.%0A++++assert_eq!(%26*evens,+%26*(0..10).collect::%3CVec%3C_%3E%3E());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Hash-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3469\">source</a></span><a href=\"#impl-Hash-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3470\">source</a><a href=\"#method.hash\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../hash/trait.Hash.html#tymethod.hash\" class=\"fn\">hash</a>&lt;H&gt;(&amp;self, state: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,</div></h4></section></summary><div class=\"docblock\">Feeds this value into the given <a href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../hash/trait.Hash.html#tymethod.hash\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/hash/mod.rs.html#238-240\">source</a></span><a href=\"#method.hash_slice\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../hash/trait.Hash.html#method.hash_slice\" class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[Self]</a>, state: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Feeds a slice of this type into the given <a href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../hash/trait.Hash.html#method.hash_slice\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Ord-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3324\">source</a></span><a href=\"#impl-Ord-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3339\">source</a><a href=\"#method.cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#tymethod.cmp\" class=\"fn\">cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></h4></section></summary><div class=\"docblock\"><p>Comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>cmp()</code> on their inner values.</p>\n<h5 id=\"examples-50\"><a class=\"doc-anchor\" href=\"#examples-50\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(Ordering::Less, five.cmp(<span class=\"kw-2\">&amp;</span>Arc::new(<span class=\"number\">6</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert_eq!(Ordering::Less,+five.cmp(%26Arc::new(6)));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#856-858\">source</a></span><a href=\"#method.max\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.max\" class=\"fn\">max</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the maximum of two values. <a href=\"../cmp/trait.Ord.html#method.max\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#877-879\">source</a></span><a href=\"#method.min\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.min\" class=\"fn\">min</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the minimum of two values. <a href=\"../cmp/trait.Ord.html#method.min\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clamp\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.50.0\">1.50.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#903-906\">source</a></span><a href=\"#method.clamp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.clamp\" class=\"fn\">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section></summary><div class=\"docblock\">Restrict a value to a certain interval. <a href=\"../cmp/trait.Ord.html#method.clamp\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3190\">source</a></span><a href=\"#impl-PartialEq-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3209\">source</a><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Equality for two <code>Arc</code>s.</p>\n<p>Two <code>Arc</code>s are equal if their inner values are equal, even if they are\nstored in different allocation.</p>\n<p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality),\ntwo <code>Arc</code>s that point to the same allocation are always equal.</p>\n<h5 id=\"examples-41\"><a class=\"doc-anchor\" href=\"#examples-41\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five == Arc::new(<span class=\"number\">5</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+==+Arc::new(5));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3230\">source</a><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Inequality for two <code>Arc</code>s.</p>\n<p>Two <code>Arc</code>s are not equal if their inner values are not equal.</p>\n<p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality),\ntwo <code>Arc</code>s that point to the same value are always equal.</p>\n<h5 id=\"examples-42\"><a class=\"doc-anchor\" href=\"#examples-42\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five != Arc::new(<span class=\"number\">6</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+!=+Arc::new(6));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialOrd-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3236\">source</a></span><a href=\"#impl-PartialOrd-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3251\">source</a><a href=\"#method.partial_cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Partial comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>partial_cmp()</code> on their inner values.</p>\n<h5 id=\"examples-45\"><a class=\"doc-anchor\" href=\"#examples-45\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(Ordering::Less), five.partial_cmp(<span class=\"kw-2\">&amp;</span>Arc::new(<span class=\"number\">6</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert_eq!(Some(Ordering::Less),+five.partial_cmp(%26Arc::new(6)));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3268\">source</a><a href=\"#method.lt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Less-than comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>&lt;</code> on their inner values.</p>\n<h5 id=\"examples-46\"><a class=\"doc-anchor\" href=\"#examples-46\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &lt; Arc::new(<span class=\"number\">6</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+%3C+Arc::new(6));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3285\">source</a><a href=\"#method.le\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>‘Less than or equal to’ comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>&lt;=</code> on their inner values.</p>\n<h5 id=\"examples-47\"><a class=\"doc-anchor\" href=\"#examples-47\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &lt;= Arc::new(<span class=\"number\">5</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+%3C=+Arc::new(5));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3302\">source</a><a href=\"#method.gt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Greater-than comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>&gt;</code> on their inner values.</p>\n<h5 id=\"examples-48\"><a class=\"doc-anchor\" href=\"#examples-48\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &gt; Arc::new(<span class=\"number\">4</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+%3E+Arc::new(4));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3319\">source</a><a href=\"#method.ge\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>‘Greater than or equal to’ comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>&gt;=</code> on their inner values.</p>\n<h5 id=\"examples-49\"><a class=\"doc-anchor\" href=\"#examples-49\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &gt;= Arc::new(<span class=\"number\">5</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++%0A++++let+five+=+Arc::new(5);%0A++++%0A++++assert!(five+%3E=+Arc::new(5));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Pointer-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3361\">source</a></span><a href=\"#impl-Pointer-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../fmt/trait.Pointer.html\" title=\"trait std::fmt::Pointer\">Pointer</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3362\">source</a><a href=\"#method.fmt-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Pointer.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Pointer.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Read-for-Arc%3CFile%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/fs.rs.html#954-974\">source</a></span><a href=\"#impl-Read-for-Arc%3CFile%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../fs/struct.File.html\" title=\"struct std::fs::File\">File</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#955-957\">source</a><a href=\"#method.read\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#tymethod.read\" class=\"fn\">read</a>(&amp;mut self, buf: &amp;mut [<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\">Pull some bytes from this source into the specified buffer, returning\nhow many bytes were read. <a href=\"../io/trait.Read.html#tymethod.read\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read_vectored\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#958-960\">source</a><a href=\"#method.read_vectored\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.read_vectored\" class=\"fn\">read_vectored</a>(&amp;mut self, bufs: &amp;mut [<a class=\"struct\" href=\"../io/struct.IoSliceMut.html\" title=\"struct std::io::IoSliceMut\">IoSliceMut</a>&lt;'_&gt;]) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\">Like <code>read</code>, except that it reads into a slice of buffers. <a href=\"../io/trait.Read.html#method.read_vectored\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read_buf\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#961-963\">source</a><a href=\"#method.read_buf\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.read_buf\" class=\"fn\">read_buf</a>(&amp;mut self, cursor: <a class=\"struct\" href=\"../io/struct.BorrowedCursor.html\" title=\"struct std::io::BorrowedCursor\">BorrowedCursor</a>&lt;'_&gt;) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>read_buf</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/78485\">#78485</a>)</span></div></span><div class=\"docblock\">Pull some bytes from this source into the specified buffer. <a href=\"../io/trait.Read.html#method.read_buf\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_read_vectored\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#965-967\">source</a><a href=\"#method.is_read_vectored\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.is_read_vectored\" class=\"fn\">is_read_vectored</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/69941\">#69941</a>)</span></div></span><div class=\"docblock\">Determines if this <code>Read</code>er has an efficient <code>read_vectored</code>\nimplementation. <a href=\"../io/trait.Read.html#method.is_read_vectored\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read_to_end\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#968-970\">source</a><a href=\"#method.read_to_end\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.read_to_end\" class=\"fn\">read_to_end</a>(&amp;mut self, buf: &amp;mut <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\">Read all bytes until EOF in this source, placing them into <code>buf</code>. <a href=\"../io/trait.Read.html#method.read_to_end\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read_to_string\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#971-973\">source</a><a href=\"#method.read_to_string\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.read_to_string\" class=\"fn\">read_to_string</a>(&amp;mut self, buf: &amp;mut <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a>) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\">Read all bytes until EOF in this source, appending them to <code>buf</code>. <a href=\"../io/trait.Read.html#method.read_to_string\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read_exact\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#961-963\">source</a></span><a href=\"#method.read_exact\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.read_exact\" class=\"fn\">read_exact</a>(&amp;mut self, buf: &amp;mut [<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\">Read the exact number of bytes required to fill <code>buf</code>. <a href=\"../io/trait.Read.html#method.read_exact\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read_buf_exact\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/io/mod.rs.html#995-997\">source</a><a href=\"#method.read_buf_exact\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.read_buf_exact\" class=\"fn\">read_buf_exact</a>(&amp;mut self, cursor: <a class=\"struct\" href=\"../io/struct.BorrowedCursor.html\" title=\"struct std::io::BorrowedCursor\">BorrowedCursor</a>&lt;'_&gt;) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>read_buf</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/78485\">#78485</a>)</span></div></span><div class=\"docblock\">Read the exact number of bytes required to fill <code>cursor</code>. <a href=\"../io/trait.Read.html#method.read_buf_exact\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.by_ref-1\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#1034-1039\">source</a></span><a href=\"#method.by_ref-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.by_ref\" class=\"fn\">by_ref</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut Self</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Creates a “by reference” adaptor for this instance of <code>Read</code>. <a href=\"../io/trait.Read.html#method.by_ref\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bytes\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#1077-1082\">source</a></span><a href=\"#method.bytes\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.bytes\" class=\"fn\">bytes</a>(self) -&gt; <a class=\"struct\" href=\"../io/struct.Bytes.html\" title=\"struct std::io::Bytes\">Bytes</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Bytes<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Transforms this <code>Read</code> instance to an <a href=\"../iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> over its bytes. <a href=\"../io/trait.Read.html#method.bytes\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.chain\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#1115-1120\">source</a></span><a href=\"#method.chain\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.chain\" class=\"fn\">chain</a>&lt;R: <a class=\"trait\" href=\"../io/trait.Read.html\" title=\"trait std::io::Read\">Read</a>&gt;(self, next: R) -&gt; <a class=\"struct\" href=\"../io/struct.Chain.html\" title=\"struct std::io::Chain\">Chain</a>&lt;Self, R&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Chain<Self, R>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Creates an adapter which will chain this stream with another. <a href=\"../io/trait.Read.html#method.chain\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.take\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#1154-1159\">source</a></span><a href=\"#method.take\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Read.html#method.take\" class=\"fn\">take</a>(self, limit: <a class=\"primitive\" href=\"../primitive.u64.html\">u64</a>) -&gt; <a class=\"struct\" href=\"../io/struct.Take.html\" title=\"struct std::io::Take\">Take</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Take<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Creates an adapter which will read at most <code>limit</code> bytes from it. <a href=\"../io/trait.Read.html#method.take\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Seek-for-Arc%3CFile%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/fs.rs.html#993-997\">source</a></span><a href=\"#impl-Seek-for-Arc%3CFile%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../io/trait.Seek.html\" title=\"trait std::io::Seek\">Seek</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../fs/struct.File.html\" title=\"struct std::fs::File\">File</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.seek\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#994-996\">source</a><a href=\"#method.seek\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Seek.html#tymethod.seek\" class=\"fn\">seek</a>(&amp;mut self, pos: <a class=\"enum\" href=\"../io/enum.SeekFrom.html\" title=\"enum std::io::SeekFrom\">SeekFrom</a>) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.u64.html\">u64</a>&gt;</h4></section></summary><div class=\"docblock\">Seek to an offset, in bytes, in a stream. <a href=\"../io/trait.Seek.html#tymethod.seek\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rewind\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.55.0\">1.55.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#1957-1960\">source</a></span><a href=\"#method.rewind\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Seek.html#method.rewind\" class=\"fn\">rewind</a>(&amp;mut self) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\">Rewind to the beginning of a stream. <a href=\"../io/trait.Seek.html#method.rewind\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.stream_len\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/io/mod.rs.html#1997-2008\">source</a><a href=\"#method.stream_len\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Seek.html#method.stream_len\" class=\"fn\">stream_len</a>(&amp;mut self) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.u64.html\">u64</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>seek_stream_len</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/59359\">#59359</a>)</span></div></span><div class=\"docblock\">Returns the length of this stream (in bytes). <a href=\"../io/trait.Seek.html#method.stream_len\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.stream_position\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#2034-2036\">source</a></span><a href=\"#method.stream_position\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Seek.html#method.stream_position\" class=\"fn\">stream_position</a>(&amp;mut self) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.u64.html\">u64</a>&gt;</h4></section></summary><div class=\"docblock\">Returns the current seek position from the start of the stream. <a href=\"../io/trait.Seek.html#method.stream_position\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.seek_relative\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#2062-2065\">source</a></span><a href=\"#method.seek_relative\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Seek.html#method.seek_relative\" class=\"fn\">seek_relative</a>(&amp;mut self, offset: <a class=\"primitive\" href=\"../primitive.i64.html\">i64</a>) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\">Seeks relative to the current position. <a href=\"../io/trait.Seek.html#method.seek_relative\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-TryFrom%3CArc%3C%5BT%5D,+A%3E%3E-for-Arc%3C%5BT;+N%5D,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3671\">source</a></span><a href=\"#impl-TryFrom%3CArc%3C%5BT%5D,+A%3E%3E-for-Arc%3C%5BT;+N%5D,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;</h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3674\">source</a><a href=\"#method.try_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(\n    boxed_slice: <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;,\n) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>, A&gt;, &lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>, A&gt; as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>, A&gt;&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Write-for-Arc%3CFile%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/fs.rs.html#976-991\">source</a></span><a href=\"#impl-Write-for-Arc%3CFile%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"../fs/struct.File.html\" title=\"struct std::fs::File\">File</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#977-979\">source</a><a href=\"#method.write\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Write.html#tymethod.write\" class=\"fn\">write</a>(&amp;mut self, buf: &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\">Write a buffer into this writer, returning how many bytes were written. <a href=\"../io/trait.Write.html#tymethod.write\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_vectored\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#980-982\">source</a><a href=\"#method.write_vectored\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Write.html#method.write_vectored\" class=\"fn\">write_vectored</a>(&amp;mut self, bufs: &amp;[<a class=\"struct\" href=\"../io/struct.IoSlice.html\" title=\"struct std::io::IoSlice\">IoSlice</a>&lt;'_&gt;]) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\">Like <a href=\"../io/trait.Write.html#tymethod.write\" title=\"method std::io::Write::write\"><code>write</code></a>, except that it writes from a slice of buffers. <a href=\"../io/trait.Write.html#method.write_vectored\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_write_vectored\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#984-986\">source</a><a href=\"#method.is_write_vectored\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Write.html#method.is_write_vectored\" class=\"fn\">is_write_vectored</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/69941\">#69941</a>)</span></div></span><div class=\"docblock\">Determines if this <code>Write</code>r has an efficient <a href=\"../io/trait.Write.html#method.write_vectored\" title=\"method std::io::Write::write_vectored\"><code>write_vectored</code></a>\nimplementation. <a href=\"../io/trait.Write.html#method.is_write_vectored\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.flush\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/fs.rs.html#988-990\">source</a><a href=\"#method.flush\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Write.html#tymethod.flush\" class=\"fn\">flush</a>(&amp;mut self) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\">Flush this output stream, ensuring that all intermediately buffered\ncontents reach their destination. <a href=\"../io/trait.Write.html#tymethod.flush\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_all\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#1699-1711\">source</a></span><a href=\"#method.write_all\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Write.html#method.write_all\" class=\"fn\">write_all</a>(&amp;mut self, buf: &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\">Attempts to write an entire buffer into this writer. <a href=\"../io/trait.Write.html#method.write_all\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_all_vectored\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/io/mod.rs.html#1761-1776\">source</a><a href=\"#method.write_all_vectored\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Write.html#method.write_all_vectored\" class=\"fn\">write_all_vectored</a>(&amp;mut self, bufs: &amp;mut [<a class=\"struct\" href=\"../io/struct.IoSlice.html\" title=\"struct std::io::IoSlice\">IoSlice</a>&lt;'_&gt;]) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>write_all_vectored</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/70436\">#70436</a>)</span></div></span><div class=\"docblock\">Attempts to write multiple buffers into this writer. <a href=\"../io/trait.Write.html#method.write_all_vectored\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_fmt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#1814-1850\">source</a></span><a href=\"#method.write_fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Write.html#method.write_fmt\" class=\"fn\">write_fmt</a>(&amp;mut self, fmt: <a class=\"struct\" href=\"../fmt/struct.Arguments.html\" title=\"struct std::fmt::Arguments\">Arguments</a>&lt;'_&gt;) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\">Writes a formatted string into this writer, returning any error\nencountered. <a href=\"../io/trait.Write.html#method.write_fmt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.by_ref\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#1874-1879\">source</a></span><a href=\"#method.by_ref\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../io/trait.Write.html#method.by_ref\" class=\"fn\">by_ref</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut Self</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Creates a “by reference” adapter for this instance of <code>Write</code>. <a href=\"../io/trait.Write.html#method.by_ref\">Read more</a></div></details></div></details><section id=\"impl-CoerceUnsized%3CArc%3CU,+A%3E%3E-for-Arc%3CT,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#264\">source</a><a href=\"#impl-CoerceUnsized%3CArc%3CU,+A%3E%3E-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U, A&gt; <a class=\"trait\" href=\"../ops/trait.CoerceUnsized.html\" title=\"trait std::ops::CoerceUnsized\">CoerceUnsized</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;U, A&gt;&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Unsize.html\" title=\"trait std::marker::Unsize\">Unsize</a>&lt;U&gt; + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    U: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-DerefPure-for-Arc%3CT,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#2145\">source</a><a href=\"#impl-DerefPure-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../ops/trait.DerefPure.html\" title=\"trait std::ops::DerefPure\">DerefPure</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-DispatchFromDyn%3CArc%3CU%3E%3E-for-Arc%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#267\">source</a><a href=\"#impl-DispatchFromDyn%3CArc%3CU%3E%3E-for-Arc%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../ops/trait.DispatchFromDyn.html\" title=\"trait std::ops::DispatchFromDyn\">DispatchFromDyn</a>&lt;<a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;U&gt;&gt; for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Unsize.html\" title=\"trait std::marker::Unsize\">Unsize</a>&lt;U&gt; + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    U: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Eq-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3344\">source</a></span><a href=\"#impl-Eq-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section><section id=\"impl-Send-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#256\">source</a></span><a href=\"#impl-Send-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>,</div></h3></section><section id=\"impl-Sync-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#258\">source</a></span><a href=\"#impl-Sync-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a>,</div></h3></section><section id=\"impl-Unpin-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.33.0\">1.33.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3785\">source</a></span><a href=\"#impl-Unpin-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-UnwindSafe-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.9.0\">1.9.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#261\">source</a></span><a href=\"#impl-UnwindSafe-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a>,</div></h3></section></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-Arc%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Freeze-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-RefUnwindSafe-for-Arc%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a>,\n    T: <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3C!%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#782\">source</a><a href=\"#impl-From%3C!%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.never.html\">!</a>&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-17\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#783\">source</a><a href=\"#method.from-17\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: <a class=\"primitive\" href=\"../primitive.never.html\">!</a>) -&gt; T</h4></section></summary><div class=\"docblock\">Converts to this type from the input type.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-18\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from-18\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToOwned-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85\">source</a><a href=\"#impl-ToOwned-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Owned\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88\">source</a><a href=\"#method.to_owned\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\">Creates owned data from borrowed data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92\">source</a><a href=\"#method.clone_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>)</h4></section></summary><div class=\"docblock\">Uses borrowed data to replace owned data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToString-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2552\">source</a><a href=\"#impl-ToString-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../string/trait.ToString.html\" title=\"trait std::string::ToString\">ToString</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_string\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2558\">source</a><a href=\"#method.to_string\" class=\"anchor\">§</a><h4 class=\"code-header\">default fn <a href=\"../string/trait.ToString.html#tymethod.to_string\" class=\"fn\">to_string</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\">Converts the given value to a <code>String</code>. <a href=\"../string/trait.ToString.html#tymethod.to_string\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-2\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-2\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div><script type=\"text/json\" id=\"notable-traits-data\">{\"Bytes<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../io/struct.Bytes.html\\\" title=\\\"struct std::io::Bytes\\\">Bytes</a>&lt;R&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;R: <a class=\\\"trait\\\" href=\\\"../io/trait.Read.html\\\" title=\\\"trait std::io::Read\\\">Read</a>&gt; <a class=\\\"trait\\\" href=\\\"../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"../io/struct.Bytes.html\\\" title=\\\"struct std::io::Bytes\\\">Bytes</a>&lt;R&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"type\\\" href=\\\"../io/type.Result.html\\\" title=\\\"type std::io::Result\\\">Result</a>&lt;<a class=\\\"primitive\\\" href=\\\"../primitive.u8.html\\\">u8</a>&gt;;</div>\",\"Chain<Self, R>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../io/struct.Chain.html\\\" title=\\\"struct std::io::Chain\\\">Chain</a>&lt;T, U&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;T: <a class=\\\"trait\\\" href=\\\"../io/trait.Read.html\\\" title=\\\"trait std::io::Read\\\">Read</a>, U: <a class=\\\"trait\\\" href=\\\"../io/trait.Read.html\\\" title=\\\"trait std::io::Read\\\">Read</a>&gt; <a class=\\\"trait\\\" href=\\\"../io/trait.Read.html\\\" title=\\\"trait std::io::Read\\\">Read</a> for <a class=\\\"struct\\\" href=\\\"../io/struct.Chain.html\\\" title=\\\"struct std::io::Chain\\\">Chain</a>&lt;T, U&gt;</div>\",\"Take<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"../io/struct.Take.html\\\" title=\\\"struct std::io::Take\\\">Take</a>&lt;T&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;T: <a class=\\\"trait\\\" href=\\\"../io/trait.Read.html\\\" title=\\\"trait std::io::Read\\\">Read</a>&gt; <a class=\\\"trait\\\" href=\\\"../io/trait.Read.html\\\" title=\\\"trait std::io::Read\\\">Read</a> for <a class=\\\"struct\\\" href=\\\"../io/struct.Take.html\\\" title=\\\"struct std::io::Take\\\">Take</a>&lt;T&gt;</div>\"}</script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:12:23.693Z"
}