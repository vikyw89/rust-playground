{
	"title": "Handling Zero-Sized Types - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/vec/vec-zsts.html",
	"markdown": "# Handling Zero-Sized Types - The Rustonomicon\n\nIt's time. We're going to fight the specter that is zero-sized types. Safe Rust _never_ needs to care about this, but Vec is very intensive on raw pointers and raw allocations, which are exactly the two things that care about zero-sized types. We need to be careful of two things:\n\n-   The raw allocator API has undefined behavior if you pass in 0 for an allocation size.\n-   raw pointer offsets are no-ops for zero-sized types, which will break our C-style pointer iterator.\n\nThankfully we abstracted out pointer-iterators and allocating handling into `RawValIter` and `RawVec` respectively. How mysteriously convenient.\n\n## [Allocating Zero-Sized Types](#allocating-zero-sized-types)\n\nSo if the allocator API doesn't support zero-sized allocations, what on earth do we store as our allocation? `NonNull::dangling()` of course! Almost every operation with a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs to be considered to store or load them. This actually extends to `ptr::read` and `ptr::write`: they won't actually look at the pointer at all. As such we never need to change the pointer.\n\nNote however that our previous reliance on running out of memory before overflow is no longer valid with zero-sized types. We must explicitly guard against capacity overflow for zero-sized types.\n\nDue to our current architecture, all this means is writing 3 guards, one in each method of `RawVec`.\n\n```rust\nimpl<T> RawVec<T> {\n    fn new() -> Self {\n        // This branch should be stripped at compile time.\n        let cap = if mem::size_of::<T>() == 0 { usize::MAX } else { 0 };\n\n        // `NonNull::dangling()` doubles as \"unallocated\" and \"zero-sized allocation\"\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap,\n        }\n    }\n\n    fn grow(&mut self) {\n        // since we set the capacity to usize::MAX when T has size 0,\n        // getting to here necessarily means the Vec is overfull.\n        assert!(mem::size_of::<T>() != 0, \"capacity overflow\");\n\n        let (new_cap, new_layout) = if self.cap == 0 {\n            (1, Layout::array::<T>(1).unwrap())\n        } else {\n            // This can't overflow because we ensure self.cap <= isize::MAX.\n            let new_cap = 2 * self.cap;\n\n            // `Layout::array` checks that the number of bytes is <= usize::MAX,\n            // but this is redundant since old_layout.size() <= isize::MAX,\n            // so the `unwrap` should never fail.\n            let new_layout = Layout::array::<T>(new_cap).unwrap();\n            (new_cap, new_layout)\n        };\n\n        // Ensure that the new allocation doesn't exceed `isize::MAX` bytes.\n        assert!(new_layout.size() <= isize::MAX as usize, \"Allocation too large\");\n\n        let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        // If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}\n\nimpl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        let elem_size = mem::size_of::<T>();\n\n        if self.cap != 0 && elem_size != 0 {\n            unsafe {\n                alloc::dealloc(\n                    self.ptr.as_ptr() as *mut u8,\n                    Layout::array::<T>(self.cap).unwrap(),\n                );\n            }\n        }\n    }\n}\n```\n\nThat's it. We support pushing and popping zero-sized types now. Our iterators (that aren't provided by slice Deref) are still busted, though.\n\n## [Iterating Zero-Sized Types](#iterating-zero-sized-types)\n\nZero-sized offsets are no-ops. This means that our current design will always initialize `start` and `end` as the same value, and our iterators will yield nothing. The current solution to this is to cast the pointers to integers, increment, and then cast them back:\n\n```rust\nimpl<T> RawValIter<T> {\n    unsafe fn new(slice: &[T]) -> Self {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: if mem::size_of::<T>() == 0 {\n                ((slice.as_ptr() as usize) + slice.len()) as *const _\n            } else if slice.len() == 0 {\n                slice.as_ptr()\n            } else {\n                slice.as_ptr().add(slice.len())\n            },\n        }\n    }\n}\n```\n\nNow we have a different bug. Instead of our iterators not running at all, our iterators now run _forever_. We need to do the same trick in our iterator impls. Also, our size\\_hint computation code will divide by 0 for ZSTs. Since we'll basically be treating the two pointers as if they point to bytes, we'll just map size 0 to divide by 1. Here's what `next` will be:\n\n```rust\nfn next(&mut self) -> Option<T> {\n    if self.start == self.end {\n        None\n    } else {\n        unsafe {\n            let result = ptr::read(self.start);\n            self.start = if mem::size_of::<T>() == 0 {\n                (self.start as usize + 1) as *const _\n            } else {\n                self.start.offset(1)\n            };\n            Some(result)\n        }\n    }\n}\n```\n\nDo you see the \"bug\"? No one else did! The original author only noticed the problem when linking to this page years later. This code is kind of dubious because abusing the iterator pointers to be _counters_ makes them unaligned! Our _one job_ when using ZSTs is to keep pointers aligned! _forehead slap_\n\nRaw pointers don't need to be aligned at all times, so the basic trick of using pointers as counters is _fine_, but they _should_ definitely be aligned when passed to `ptr::read`! This is _possibly_ needless pedantry because `ptr::read` is a noop for a ZST, but let's be a _little_ more responsible and read from `NonNull::dangling` on the ZST path.\n\n(Alternatively you could call `read_unaligned` on the ZST path. Either is fine, because either way we're making up a value from nothing and it all compiles to doing nothing.)\n\n```rust\nimpl<T> Iterator for RawValIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.start = (self.start as usize + 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    let old_ptr = self.start;\n                    self.start = self.start.offset(1);\n                    Some(ptr::read(old_ptr))\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let elem_size = mem::size_of::<T>();\n        let len = (self.end as usize - self.start as usize)\n                  / if elem_size == 0 { 1 } else { elem_size };\n        (len, Some(len))\n    }\n}\n\nimpl<T> DoubleEndedIterator for RawValIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.end = (self.end as usize - 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    self.end = self.end.offset(-1);\n                    Some(ptr::read(self.end))\n                }\n            }\n        }\n    }\n}\n```\n\nAnd that's it. Iteration works!",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Handling Zero-Sized Types - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"../favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"../theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"../intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"../meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"../what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"../working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"../exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"../other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"../aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"../unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"../hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"../subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"../dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"../phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"../borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"../dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"../casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"../transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"../drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"../unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"../destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"../leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"../poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"../send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"../atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-zsts.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"../beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"handling-zero-sized-types\"><a class=\"header\" href=\"#handling-zero-sized-types\">Handling Zero-Sized Types</a></h1>\n<p>It's time. We're going to fight the specter that is zero-sized types. Safe Rust\n<em>never</em> needs to care about this, but Vec is very intensive on raw pointers and\nraw allocations, which are exactly the two things that care about\nzero-sized types. We need to be careful of two things:</p>\n<ul>\n<li>The raw allocator API has undefined behavior if you pass in 0 for an\nallocation size.</li>\n<li>raw pointer offsets are no-ops for zero-sized types, which will break our\nC-style pointer iterator.</li>\n</ul>\n<p>Thankfully we abstracted out pointer-iterators and allocating handling into\n<code class=\"hljs\">RawValIter</code> and <code class=\"hljs\">RawVec</code> respectively. How mysteriously convenient.</p>\n<h2 id=\"allocating-zero-sized-types\"><a class=\"header\" href=\"#allocating-zero-sized-types\">Allocating Zero-Sized Types</a></h2>\n<p>So if the allocator API doesn't support zero-sized allocations, what on earth\ndo we store as our allocation? <code class=\"hljs\">NonNull::dangling()</code> of course! Almost every operation\nwith a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs\nto be considered to store or load them. This actually extends to <code class=\"hljs\">ptr::read</code> and\n<code class=\"hljs\">ptr::write</code>: they won't actually look at the pointer at all. As such we never need\nto change the pointer.</p>\n<p>Note however that our previous reliance on running out of memory before overflow is\nno longer valid with zero-sized types. We must explicitly guard against capacity\noverflow for zero-sized types.</p>\n<p>Due to our current architecture, all this means is writing 3 guards, one in each\nmethod of <code class=\"hljs\">RawVec</code>.</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; RawVec&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>() -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-comment\">// This branch should be stripped at compile time.</span>\n        <span class=\"hljs-keyword\">let</span> cap = <span class=\"hljs-keyword\">if</span> mem::size_of::&lt;T&gt;() == <span class=\"hljs-number\">0</span> { <span class=\"hljs-built_in\">usize</span>::MAX } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-number\">0</span> };\n\n        <span class=\"hljs-comment\">// `NonNull::dangling()` doubles as \"unallocated\" and \"zero-sized allocation\"</span>\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap,\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">grow</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-comment\">// since we set the capacity to usize::MAX when T has size 0,</span>\n        <span class=\"hljs-comment\">// getting to here necessarily means the Vec is overfull.</span>\n        <span class=\"hljs-built_in\">assert!</span>(mem::size_of::&lt;T&gt;() != <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">\"capacity overflow\"</span>);\n\n        <span class=\"hljs-keyword\">let</span> (new_cap, new_layout) = <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.cap == <span class=\"hljs-number\">0</span> {\n            (<span class=\"hljs-number\">1</span>, Layout::array::&lt;T&gt;(<span class=\"hljs-number\">1</span>).unwrap())\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// This can't overflow because we ensure self.cap &lt;= isize::MAX.</span>\n            <span class=\"hljs-keyword\">let</span> new_cap = <span class=\"hljs-number\">2</span> * <span class=\"hljs-keyword\">self</span>.cap;\n\n            <span class=\"hljs-comment\">// `Layout::array` checks that the number of bytes is &lt;= usize::MAX,</span>\n            <span class=\"hljs-comment\">// but this is redundant since old_layout.size() &lt;= isize::MAX,</span>\n            <span class=\"hljs-comment\">// so the `unwrap` should never fail.</span>\n            <span class=\"hljs-keyword\">let</span> new_layout = Layout::array::&lt;T&gt;(new_cap).unwrap();\n            (new_cap, new_layout)\n        };\n\n        <span class=\"hljs-comment\">// Ensure that the new allocation doesn't exceed `isize::MAX` bytes.</span>\n        <span class=\"hljs-built_in\">assert!</span>(new_layout.size() &lt;= <span class=\"hljs-built_in\">isize</span>::MAX <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>, <span class=\"hljs-string\">\"Allocation too large\"</span>);\n\n        <span class=\"hljs-keyword\">let</span> new_ptr = <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.cap == <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-keyword\">unsafe</span> { alloc::alloc(new_layout) }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">let</span> old_layout = Layout::array::&lt;T&gt;(<span class=\"hljs-keyword\">self</span>.cap).unwrap();\n            <span class=\"hljs-keyword\">let</span> old_ptr = <span class=\"hljs-keyword\">self</span>.ptr.as_ptr() <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>;\n            <span class=\"hljs-keyword\">unsafe</span> { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        <span class=\"hljs-comment\">// If allocation fails, `new_ptr` will be null, in which case we abort.</span>\n        <span class=\"hljs-keyword\">self</span>.ptr = <span class=\"hljs-keyword\">match</span> NonNull::new(new_ptr <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> T) {\n            <span class=\"hljs-literal\">Some</span>(p) =&gt; p,\n            <span class=\"hljs-literal\">None</span> =&gt; alloc::handle_alloc_error(new_layout),\n        };\n        <span class=\"hljs-keyword\">self</span>.cap = new_cap;\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> RawVec&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">let</span> elem_size = mem::size_of::&lt;T&gt;();\n\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.cap != <span class=\"hljs-number\">0</span> &amp;&amp; elem_size != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-keyword\">unsafe</span> {\n                alloc::dealloc(\n                    <span class=\"hljs-keyword\">self</span>.ptr.as_ptr() <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>,\n                    Layout::array::&lt;T&gt;(<span class=\"hljs-keyword\">self</span>.cap).unwrap(),\n                );\n            }\n        }\n    }\n}</code></pre>\n<p>That's it. We support pushing and popping zero-sized types now. Our iterators\n(that aren't provided by slice Deref) are still busted, though.</p>\n<h2 id=\"iterating-zero-sized-types\"><a class=\"header\" href=\"#iterating-zero-sized-types\">Iterating Zero-Sized Types</a></h2>\n<p>Zero-sized offsets are no-ops. This means that our current design will always\ninitialize <code class=\"hljs\">start</code> and <code class=\"hljs\">end</code> as the same value, and our iterators will yield\nnothing. The current solution to this is to cast the pointers to integers,\nincrement, and then cast them back:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; RawValIter&lt;T&gt; {\n    <span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(slice: &amp;[T]) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: <span class=\"hljs-keyword\">if</span> mem::size_of::&lt;T&gt;() == <span class=\"hljs-number\">0</span> {\n                ((slice.as_ptr() <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>) + slice.len()) <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> slice.len() == <span class=\"hljs-number\">0</span> {\n                slice.as_ptr()\n            } <span class=\"hljs-keyword\">else</span> {\n                slice.as_ptr().add(slice.len())\n            },\n        }\n    }\n}</code></pre>\n<p>Now we have a different bug. Instead of our iterators not running at all, our\niterators now run <em>forever</em>. We need to do the same trick in our iterator impls.\nAlso, our size_hint computation code will divide by 0 for ZSTs. Since we'll\nbasically be treating the two pointers as if they point to bytes, we'll just\nmap size 0 to divide by 1. Here's what <code class=\"hljs\">next</code> will be:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.start == <span class=\"hljs-keyword\">self</span>.end {\n        <span class=\"hljs-literal\">None</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-keyword\">let</span> result = ptr::read(<span class=\"hljs-keyword\">self</span>.start);\n            <span class=\"hljs-keyword\">self</span>.start = <span class=\"hljs-keyword\">if</span> mem::size_of::&lt;T&gt;() == <span class=\"hljs-number\">0</span> {\n                (<span class=\"hljs-keyword\">self</span>.start <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span> + <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">self</span>.start.offset(<span class=\"hljs-number\">1</span>)\n            };\n            <span class=\"hljs-literal\">Some</span>(result)\n        }\n    }\n}</code></pre>\n<p>Do you see the \"bug\"? No one else did! The original author only noticed the\nproblem when linking to this page years later. This code is kind of dubious\nbecause abusing the iterator pointers to be <em>counters</em> makes them unaligned!\nOur <em>one job</em> when using ZSTs is to keep pointers aligned! <em>forehead slap</em></p>\n<p>Raw pointers don't need to be aligned at all times, so the basic trick of\nusing pointers as counters is <em>fine</em>, but they <em>should</em> definitely be aligned\nwhen passed to <code class=\"hljs\">ptr::read</code>! This is <em>possibly</em> needless pedantry\nbecause <code class=\"hljs\">ptr::read</code> is a noop for a ZST, but let's be a <em>little</em> more\nresponsible and read from <code class=\"hljs\">NonNull::dangling</code> on the ZST path.</p>\n<p>(Alternatively you could call <code class=\"hljs\">read_unaligned</code> on the ZST path. Either is fine,\nbecause either way we're making up a value from nothing and it all compiles\nto doing nothing.)</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Iterator</span> <span class=\"hljs-keyword\">for</span> RawValIter&lt;T&gt; {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span> = T;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.start == <span class=\"hljs-keyword\">self</span>.end {\n            <span class=\"hljs-literal\">None</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">unsafe</span> {\n                <span class=\"hljs-keyword\">if</span> mem::size_of::&lt;T&gt;() == <span class=\"hljs-number\">0</span> {\n                    <span class=\"hljs-keyword\">self</span>.start = (<span class=\"hljs-keyword\">self</span>.start <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span> + <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _;\n                    <span class=\"hljs-literal\">Some</span>(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-keyword\">let</span> old_ptr = <span class=\"hljs-keyword\">self</span>.start;\n                    <span class=\"hljs-keyword\">self</span>.start = <span class=\"hljs-keyword\">self</span>.start.offset(<span class=\"hljs-number\">1</span>);\n                    <span class=\"hljs-literal\">Some</span>(ptr::read(old_ptr))\n                }\n            }\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">size_hint</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; (<span class=\"hljs-built_in\">usize</span>, <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">usize</span>&gt;) {\n        <span class=\"hljs-keyword\">let</span> elem_size = mem::size_of::&lt;T&gt;();\n        <span class=\"hljs-keyword\">let</span> len = (<span class=\"hljs-keyword\">self</span>.end <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span> - <span class=\"hljs-keyword\">self</span>.start <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>)\n                  / <span class=\"hljs-keyword\">if</span> elem_size == <span class=\"hljs-number\">0</span> { <span class=\"hljs-number\">1</span> } <span class=\"hljs-keyword\">else</span> { elem_size };\n        (len, <span class=\"hljs-literal\">Some</span>(len))\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">DoubleEndedIterator</span> <span class=\"hljs-keyword\">for</span> RawValIter&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next_back</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.start == <span class=\"hljs-keyword\">self</span>.end {\n            <span class=\"hljs-literal\">None</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">unsafe</span> {\n                <span class=\"hljs-keyword\">if</span> mem::size_of::&lt;T&gt;() == <span class=\"hljs-number\">0</span> {\n                    <span class=\"hljs-keyword\">self</span>.end = (<span class=\"hljs-keyword\">self</span>.end <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span> - <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _;\n                    <span class=\"hljs-literal\">Some</span>(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-keyword\">self</span>.end = <span class=\"hljs-keyword\">self</span>.end.offset(-<span class=\"hljs-number\">1</span>);\n                    <span class=\"hljs-literal\">Some</span>(ptr::read(<span class=\"hljs-keyword\">self</span>.end))\n                }\n            }\n        }\n    }\n}</code></pre>\n<p>And that's it. Iteration works!</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../vec/vec-drain.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../vec/vec-final.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../vec/vec-drain.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../vec/vec-final.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:10.983Z"
}