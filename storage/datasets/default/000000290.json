{
	"title": "std::option - Rust",
	"url": "https://doc.rust-lang.org/stable/std/option/index.html",
	"markdown": "# std::option - Rust\n\n## Module [std](../index.html)::[option](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/lib.rs.html#400) ·\n\nExpand description\n\nOptional values.\n\nType [`Option`](enum.Option.html \"enum std::option::Option\") represents an optional value: every [`Option`](enum.Option.html \"enum std::option::Option\") is either [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") and contains a value, or [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\"), and does not. [`Option`](enum.Option.html \"enum std::option::Option\") types are very common in Rust code, as they have a number of uses:\n\n-   Initial values\n-   Return values for functions that are not defined over their entire input range (partial functions)\n-   Return value for otherwise reporting simple errors, where [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned on error\n-   Optional struct fields\n-   Struct fields that can be loaned or “taken”\n-   Optional function arguments\n-   Nullable pointers\n-   Swapping things out of difficult situations\n\n[`Option`](enum.Option.html \"enum std::option::Option\")s are commonly paired with pattern matching to query the presence of a value and take action, always accounting for the [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") case.\n\n```\nfn divide(numerator: f64, denominator: f64) -> Option<f64> {\n    if denominator == 0.0 {\n        None\n    } else {\n        Some(numerator / denominator)\n    }\n}\n\n// The return value of the function is an option\nlet result = divide(2.0, 3.0);\n\n// Pattern match to retrieve the value\nmatch result {\n    // The division was valid\n    Some(x) => println!(\"Result: {x}\"),\n    // The division was invalid\n    None    => println!(\"Cannot divide by 0\"),\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+divide(numerator:+f64,+denominator:+f64)+-%3E+Option%3Cf64%3E+%7B%0A++++++++if+denominator+==+0.0+%7B%0A++++++++++++None%0A++++++++%7D+else+%7B%0A++++++++++++Some(numerator+/+denominator)%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+The+return+value+of+the+function+is+an+option%0A++++let+result+=+divide(2.0,+3.0);%0A++++%0A++++//+Pattern+match+to+retrieve+the+value%0A++++match+result+%7B%0A++++++++//+The+division+was+valid%0A++++++++Some(x)+=%3E+println!(%22Result:+%7Bx%7D%22),%0A++++++++//+The+division+was+invalid%0A++++++++None++++=%3E+println!(%22Cannot+divide+by+0%22),%0A++++%7D%0A%7D&edition=2021)\n\n## [§](#options-and-pointers-nullable-pointers)Options and pointers (“nullable” pointers)\n\nRust’s pointer types must always point to a valid location; there are no “null” references. Instead, Rust has _optional_ pointers, like the optional owned box, `[Option](enum.Option.html \"enum std::option::Option\")<[Box<T>](../../std/boxed/struct.Box.html)>`.\n\nThe following example uses [`Option`](enum.Option.html \"enum std::option::Option\") to create an optional box of [`i32`](../primitive.i32.html \"primitive i32\"). Notice that in order to use the inner [`i32`](../primitive.i32.html \"primitive i32\") value, the `check_optional` function first needs to use pattern matching to determine whether the box has a value (i.e., it is [`Some(...)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\")) or not ([`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")).\n\n```\nlet optional = None;\ncheck_optional(optional);\n\nlet optional = Some(Box::new(9000));\ncheck_optional(optional);\n\nfn check_optional(optional: Option<Box<i32>>) {\n    match optional {\n        Some(p) => println!(\"has value {p}\"),\n        None => println!(\"has no value\"),\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+optional+=+None;%0A++++check_optional(optional);%0A++++%0A++++let+optional+=+Some(Box::new(9000));%0A++++check_optional(optional);%0A++++%0A++++fn+check_optional(optional:+Option%3CBox%3Ci32%3E%3E)+%7B%0A++++++++match+optional+%7B%0A++++++++++++Some(p)+=%3E+println!(%22has+value+%7Bp%7D%22),%0A++++++++++++None+=%3E+println!(%22has+no+value%22),%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n## [§](#the-question-mark-operator-)The question mark operator, `?`\n\nSimilar to the [`Result`](../result/enum.Result.html \"enum std::result::Result\") type, when writing code that calls many functions that return the [`Option`](enum.Option.html \"enum std::option::Option\") type, handling `Some`/`None` can be tedious. The question mark operator, [`?`](../ops/trait.Try.html \"trait std::ops::Try\"), hides some of the boilerplate of propagating values up the call stack.\n\nIt replaces this:\n\n```\nfn add_last_numbers(stack: &mut Vec<i32>) -> Option<i32> {\n    let a = stack.pop();\n    let b = stack.pop();\n\n    match (a, b) {\n        (Some(x), Some(y)) => Some(x + y),\n        _ => None,\n    }\n}\n\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++fn+add_last_numbers(stack:+%26mut+Vec%3Ci32%3E)+-%3E+Option%3Ci32%3E+%7B%0A++++++++let+a+=+stack.pop();%0A++++++++let+b+=+stack.pop();%0A++++%0A++++++++match+(a,+b)+%7B%0A++++++++++++(Some(x),+Some(y))+=%3E+Some(x+%2B+y),%0A++++++++++++_+=%3E+None,%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\nWith this:\n\n```\nfn add_last_numbers(stack: &mut Vec<i32>) -> Option<i32> {\n    Some(stack.pop()? + stack.pop()?)\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++fn+add_last_numbers(stack:+%26mut+Vec%3Ci32%3E)+-%3E+Option%3Ci32%3E+%7B%0A++++++++Some(stack.pop()?+%2B+stack.pop()?)%0A++++%7D%0A%7D&edition=2021)\n\n_It’s much nicer!_\n\nEnding the expression with [`?`](../ops/trait.Try.html \"trait std::ops::Try\") will result in the [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\")’s unwrapped value, unless the result is [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\"), in which case [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned early from the enclosing function.\n\n[`?`](../ops/trait.Try.html \"trait std::ops::Try\") can be used in functions that return [`Option`](enum.Option.html \"enum std::option::Option\") because of the early return of [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") that it provides.\n\n## [§](#representation)Representation\n\nRust guarantees to optimize the following types `T` such that [`Option<T>`](enum.Option.html \"enum std::option::Option\") has the same size, alignment, and [function call ABI](about:blank/primitive.fn.html#abi-compatibility) as `T`. In some of these cases, Rust further guarantees that `transmute::<_, Option<T>>([0u8; size_of::<T>()])` is sound and produces `Option::<T>::None`. These cases are identified by the second column:\n\n| `T` | `transmute::<_, Option<T>>([0u8; size_of::<T>()])` sound? |\n| --- | --- |\n| [`Box<U>`](../../std/boxed/struct.Box.html) (specifically, only `Box<U, Global>`) | when `U: Sized` |\n| `&U` | when `U: Sized` |\n| `&mut U` | when `U: Sized` |\n| `fn`, `extern \"C\" fn`[1](#fn1) | always |\n| [`num::NonZero*`](https://doc.rust-lang.org/1.80.0/core/num/index.html \"mod core::num\") | always |\n| [`ptr::NonNull<U>`](../ptr/struct.NonNull.html \"struct std::ptr::NonNull\") | when `U: Sized` |\n| `#[repr(transparent)]` struct around one of the types in this list. | when it holds for the inner type |\n\nUnder some conditions the above types `T` are also null pointer optimized when wrapped in a [`Result`](about:blank/result/index.html#representation \"mod std::result\").\n\nThis is called the “null pointer optimization” or NPO.\n\nIt is further guaranteed that, for the cases above, one can [`mem::transmute`](../mem/fn.transmute.html \"fn std::mem::transmute\") from all valid values of `T` to `Option<T>` and from `Some::<T>(_)` to `T` (but transmuting `None::<T>` to `T` is undefined behaviour).\n\n## [§](#method-overview)Method overview\n\nIn addition to working with pattern matching, [`Option`](enum.Option.html \"enum std::option::Option\") provides a wide variety of different methods.\n\n### [§](#querying-the-variant)Querying the variant\n\nThe [`is_some`](about:blank/enum.Option.html#method.is_some \"method std::option::Option::is_some\") and [`is_none`](about:blank/enum.Option.html#method.is_none \"method std::option::Option::is_none\") methods return [`true`](../primitive.bool.html \"primitive bool\") if the [`Option`](enum.Option.html \"enum std::option::Option\") is [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") or [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\"), respectively.\n\n### [§](#adapters-for-working-with-references)Adapters for working with references\n\n-   [`as_ref`](about:blank/enum.Option.html#method.as_ref \"method std::option::Option::as_ref\") converts from `[&](../primitive.reference.html \"shared reference\")[Option](enum.Option.html \"enum std::option::Option\")<T>` to `[Option](enum.Option.html \"enum std::option::Option\")<[&](../primitive.reference.html \"shared reference\")T>`\n-   [`as_mut`](about:blank/enum.Option.html#method.as_mut \"method std::option::Option::as_mut\") converts from `[&mut](../primitive.reference.html \"mutable reference\") [Option](enum.Option.html \"enum std::option::Option\")<T>` to `[Option](enum.Option.html \"enum std::option::Option\")<[&mut](../primitive.reference.html \"mutable reference\") T>`\n-   [`as_deref`](about:blank/enum.Option.html#method.as_deref \"method std::option::Option::as_deref\") converts from `[&](../primitive.reference.html \"shared reference\")[Option](enum.Option.html \"enum std::option::Option\")<T>` to `[Option](enum.Option.html \"enum std::option::Option\")<[&](../primitive.reference.html \"shared reference\")T::[Target](about:blank/ops/trait.Deref.html#associatedtype.Target \"ops::Deref::Target\")>`\n-   [`as_deref_mut`](about:blank/enum.Option.html#method.as_deref_mut \"method std::option::Option::as_deref_mut\") converts from `[&mut](../primitive.reference.html \"mutable reference\") [Option](enum.Option.html \"enum std::option::Option\")<T>` to `[Option](enum.Option.html \"enum std::option::Option\")<[&mut](../primitive.reference.html \"mutable reference\") T::[Target](about:blank/ops/trait.Deref.html#associatedtype.Target \"ops::Deref::Target\")>`\n-   [`as_pin_ref`](about:blank/enum.Option.html#method.as_pin_ref \"method std::option::Option::as_pin_ref\") converts from `[Pin](../pin/struct.Pin.html \"struct std::pin::Pin\")<[&](../primitive.reference.html \"shared reference\")[Option](enum.Option.html \"enum std::option::Option\")<T>>` to `[Option](enum.Option.html \"enum std::option::Option\")<[Pin](../pin/struct.Pin.html \"struct std::pin::Pin\")<[&](../primitive.reference.html \"shared reference\")T>>`\n-   [`as_pin_mut`](about:blank/enum.Option.html#method.as_pin_mut \"method std::option::Option::as_pin_mut\") converts from `[Pin](../pin/struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") [Option](enum.Option.html \"enum std::option::Option\")<T>>` to `[Option](enum.Option.html \"enum std::option::Option\")<[Pin](../pin/struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") T>>`\n\nThese methods extract the contained value in an [`Option<T>`](enum.Option.html \"enum std::option::Option\") when it is the [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") variant. If the [`Option`](enum.Option.html \"enum std::option::Option\") is [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\"):\n\n-   [`expect`](about:blank/enum.Option.html#method.expect \"method std::option::Option::expect\") panics with a provided custom message\n-   [`unwrap`](about:blank/enum.Option.html#method.unwrap \"method std::option::Option::unwrap\") panics with a generic message\n-   [`unwrap_or`](about:blank/enum.Option.html#method.unwrap_or \"method std::option::Option::unwrap_or\") returns the provided default value\n-   [`unwrap_or_default`](about:blank/enum.Option.html#method.unwrap_or_default \"method std::option::Option::unwrap_or_default\") returns the default value of the type `T` (which must implement the [`Default`](../default/trait.Default.html \"trait std::default::Default\") trait)\n-   [`unwrap_or_else`](about:blank/enum.Option.html#method.unwrap_or_else \"method std::option::Option::unwrap_or_else\") returns the result of evaluating the provided function\n\n### [§](#transforming-contained-values)Transforming contained values\n\nThese methods transform [`Option`](enum.Option.html \"enum std::option::Option\") to [`Result`](../result/enum.Result.html \"enum std::result::Result\"):\n\n-   [`ok_or`](about:blank/enum.Option.html#method.ok_or \"method std::option::Option::ok_or\") transforms [`Some(v)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") to [`Ok(v)`](about:blank/result/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\"), and [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") to [`Err(err)`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") using the provided default `err` value\n-   [`ok_or_else`](about:blank/enum.Option.html#method.ok_or_else \"method std::option::Option::ok_or_else\") transforms [`Some(v)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") to [`Ok(v)`](about:blank/result/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\"), and [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") to a value of [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") using the provided function\n-   [`transpose`](about:blank/enum.Option.html#method.transpose \"method std::option::Option::transpose\") transposes an [`Option`](enum.Option.html \"enum std::option::Option\") of a [`Result`](../result/enum.Result.html \"enum std::result::Result\") into a [`Result`](../result/enum.Result.html \"enum std::result::Result\") of an [`Option`](enum.Option.html \"enum std::option::Option\")\n\nThese methods transform the [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") variant:\n\n-   [`filter`](about:blank/enum.Option.html#method.filter \"method std::option::Option::filter\") calls the provided predicate function on the contained value `t` if the [`Option`](enum.Option.html \"enum std::option::Option\") is [`Some(t)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\"), and returns [`Some(t)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") if the function returns `true`; otherwise, returns [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")\n-   [`flatten`](about:blank/enum.Option.html#method.flatten \"method std::option::Option::flatten\") removes one level of nesting from an [`Option<Option<T>>`](enum.Option.html \"enum std::option::Option\")\n-   [`map`](about:blank/enum.Option.html#method.map \"method std::option::Option::map\") transforms [`Option<T>`](enum.Option.html \"enum std::option::Option\") to [`Option<U>`](enum.Option.html \"enum std::option::Option\") by applying the provided function to the contained value of [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") and leaving [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") values unchanged\n\nThese methods transform [`Option<T>`](enum.Option.html \"enum std::option::Option\") to a value of a possibly different type `U`:\n\n-   [`map_or`](about:blank/enum.Option.html#method.map_or \"method std::option::Option::map_or\") applies the provided function to the contained value of [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\"), or returns the provided default value if the [`Option`](enum.Option.html \"enum std::option::Option\") is [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")\n-   [`map_or_else`](about:blank/enum.Option.html#method.map_or_else \"method std::option::Option::map_or_else\") applies the provided function to the contained value of [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\"), or returns the result of evaluating the provided fallback function if the [`Option`](enum.Option.html \"enum std::option::Option\") is [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")\n\nThese methods combine the [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") variants of two [`Option`](enum.Option.html \"enum std::option::Option\") values:\n\n-   [`zip`](about:blank/enum.Option.html#method.zip \"method std::option::Option::zip\") returns [`Some((s, o))`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") if `self` is [`Some(s)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") and the provided [`Option`](enum.Option.html \"enum std::option::Option\") value is [`Some(o)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\"); otherwise, returns [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")\n-   [`zip_with`](about:blank/enum.Option.html#method.zip_with \"method std::option::Option::zip_with\") calls the provided function `f` and returns [`Some(f(s, o))`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") if `self` is [`Some(s)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") and the provided [`Option`](enum.Option.html \"enum std::option::Option\") value is [`Some(o)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\"); otherwise, returns [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")\n\n### [§](#boolean-operators)Boolean operators\n\nThese methods treat the [`Option`](enum.Option.html \"enum std::option::Option\") as a boolean value, where [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") acts like [`true`](../primitive.bool.html \"primitive bool\") and [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") acts like [`false`](../primitive.bool.html \"primitive bool\"). There are two categories of these methods: ones that take an [`Option`](enum.Option.html \"enum std::option::Option\") as input, and ones that take a function as input (to be lazily evaluated).\n\nThe [`and`](about:blank/enum.Option.html#method.and \"method std::option::Option::and\"), [`or`](about:blank/enum.Option.html#method.or \"method std::option::Option::or\"), and [`xor`](about:blank/enum.Option.html#method.xor \"method std::option::Option::xor\") methods take another [`Option`](enum.Option.html \"enum std::option::Option\") as input, and produce an [`Option`](enum.Option.html \"enum std::option::Option\") as output. Only the [`and`](about:blank/enum.Option.html#method.and \"method std::option::Option::and\") method can produce an [`Option<U>`](enum.Option.html \"enum std::option::Option\") value having a different inner type `U` than [`Option<T>`](enum.Option.html \"enum std::option::Option\").\n\n| method | self | input | output |\n| --- | --- | --- | --- |\n| [`and`](about:blank/enum.Option.html#method.and \"method std::option::Option::and\") | `None` | (ignored) | `None` |\n| [`and`](about:blank/enum.Option.html#method.and \"method std::option::Option::and\") | `Some(x)` | `None` | `None` |\n| [`and`](about:blank/enum.Option.html#method.and \"method std::option::Option::and\") | `Some(x)` | `Some(y)` | `Some(y)` |\n| [`or`](about:blank/enum.Option.html#method.or \"method std::option::Option::or\") | `None` | `None` | `None` |\n| [`or`](about:blank/enum.Option.html#method.or \"method std::option::Option::or\") | `None` | `Some(y)` | `Some(y)` |\n| [`or`](about:blank/enum.Option.html#method.or \"method std::option::Option::or\") | `Some(x)` | (ignored) | `Some(x)` |\n| [`xor`](about:blank/enum.Option.html#method.xor \"method std::option::Option::xor\") | `None` | `None` | `None` |\n| [`xor`](about:blank/enum.Option.html#method.xor \"method std::option::Option::xor\") | `None` | `Some(y)` | `Some(y)` |\n| [`xor`](about:blank/enum.Option.html#method.xor \"method std::option::Option::xor\") | `Some(x)` | `None` | `Some(x)` |\n| [`xor`](about:blank/enum.Option.html#method.xor \"method std::option::Option::xor\") | `Some(x)` | `Some(y)` | `None` |\n\nThe [`and_then`](about:blank/enum.Option.html#method.and_then \"method std::option::Option::and_then\") and [`or_else`](about:blank/enum.Option.html#method.or_else \"method std::option::Option::or_else\") methods take a function as input, and only evaluate the function when they need to produce a new value. Only the [`and_then`](about:blank/enum.Option.html#method.and_then \"method std::option::Option::and_then\") method can produce an [`Option<U>`](enum.Option.html \"enum std::option::Option\") value having a different inner type `U` than [`Option<T>`](enum.Option.html \"enum std::option::Option\").\n\n| method | self | function input | function result | output |\n| --- | --- | --- | --- | --- |\n| [`and_then`](about:blank/enum.Option.html#method.and_then \"method std::option::Option::and_then\") | `None` | (not provided) | (not evaluated) | `None` |\n| [`and_then`](about:blank/enum.Option.html#method.and_then \"method std::option::Option::and_then\") | `Some(x)` | `x` | `None` | `None` |\n| [`and_then`](about:blank/enum.Option.html#method.and_then \"method std::option::Option::and_then\") | `Some(x)` | `x` | `Some(y)` | `Some(y)` |\n| [`or_else`](about:blank/enum.Option.html#method.or_else \"method std::option::Option::or_else\") | `None` | (not provided) | `None` | `None` |\n| [`or_else`](about:blank/enum.Option.html#method.or_else \"method std::option::Option::or_else\") | `None` | (not provided) | `Some(y)` | `Some(y)` |\n| [`or_else`](about:blank/enum.Option.html#method.or_else \"method std::option::Option::or_else\") | `Some(x)` | (not provided) | (not evaluated) | `Some(x)` |\n\nThis is an example of using methods like [`and_then`](about:blank/enum.Option.html#method.and_then \"method std::option::Option::and_then\") and [`or`](about:blank/enum.Option.html#method.or \"method std::option::Option::or\") in a pipeline of method calls. Early stages of the pipeline pass failure values ([`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")) through unchanged, and continue processing on success values ([`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\")). Toward the end, [`or`](about:blank/enum.Option.html#method.or \"method std::option::Option::or\") substitutes an error message if it receives [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\").\n\n```\nlet mut bt = BTreeMap::new();\nbt.insert(20u8, \"foo\");\nbt.insert(42u8, \"bar\");\nlet res = [0u8, 1, 11, 200, 22]\n    .into_iter()\n    .map(|x| {\n        // `checked_sub()` returns `None` on error\n        x.checked_sub(1)\n            // same with `checked_mul()`\n            .and_then(|x| x.checked_mul(2))\n            // `BTreeMap::get` returns `None` on error\n            .and_then(|x| bt.get(&x))\n            // Substitute an error message if we have `None` so far\n            .or(Some(&\"error!\"))\n            .copied()\n            // Won't panic because we unconditionally used `Some` above\n            .unwrap()\n    })\n    .collect::<Vec<_>>();\nassert_eq!(res, [\"error!\", \"error!\", \"foo\", \"error!\", \"bar\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++let+mut+bt+=+BTreeMap::new();%0A++++bt.insert(20u8,+%22foo%22);%0A++++bt.insert(42u8,+%22bar%22);%0A++++let+res+=+%5B0u8,+1,+11,+200,+22%5D%0A++++++++.into_iter()%0A++++++++.map(%7Cx%7C+%7B%0A++++++++++++//+%60checked_sub()%60+returns+%60None%60+on+error%0A++++++++++++x.checked_sub(1)%0A++++++++++++++++//+same+with+%60checked_mul()%60%0A++++++++++++++++.and_then(%7Cx%7C+x.checked_mul(2))%0A++++++++++++++++//+%60BTreeMap::get%60+returns+%60None%60+on+error%0A++++++++++++++++.and_then(%7Cx%7C+bt.get(%26x))%0A++++++++++++++++//+Substitute+an+error+message+if+we+have+%60None%60+so+far%0A++++++++++++++++.or(Some(%26%22error!%22))%0A++++++++++++++++.copied()%0A++++++++++++++++//+Won%27t+panic+because+we+unconditionally+used+%60Some%60+above%0A++++++++++++++++.unwrap()%0A++++++++%7D)%0A++++++++.collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(res,+%5B%22error!%22,+%22error!%22,+%22foo%22,+%22error!%22,+%22bar%22%5D);%0A%7D&edition=2021)\n\n### [§](#comparison-operators)Comparison operators\n\nIf `T` implements [`PartialOrd`](../cmp/trait.PartialOrd.html \"trait std::cmp::PartialOrd\") then [`Option<T>`](enum.Option.html \"enum std::option::Option\") will derive its [`PartialOrd`](../cmp/trait.PartialOrd.html \"trait std::cmp::PartialOrd\") implementation. With this order, [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") compares as less than any [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\"), and two [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") compare the same way as their contained values would in `T`. If `T` also implements [`Ord`](../cmp/trait.Ord.html \"trait std::cmp::Ord\"), then so does [`Option<T>`](enum.Option.html \"enum std::option::Option\").\n\n```\nassert!(None < Some(0));\nassert!(Some(0) < Some(1));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!(None+%3C+Some(0));%0A++++assert!(Some(0)+%3C+Some(1));%0A%7D&edition=2021)\n\n### [§](#iterating-over-option)Iterating over `Option`\n\nAn [`Option`](enum.Option.html \"enum std::option::Option\") can be iterated over. This can be helpful if you need an iterator that is conditionally empty. The iterator will either produce a single value (when the [`Option`](enum.Option.html \"enum std::option::Option\") is [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\")), or produce no values (when the [`Option`](enum.Option.html \"enum std::option::Option\") is [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")). For example, [`into_iter`](about:blank/enum.Option.html#method.into_iter \"method std::option::Option::into_iter\") acts like [`once(v)`](../iter/fn.once.html \"fn std::iter::once\") if the [`Option`](enum.Option.html \"enum std::option::Option\") is [`Some(v)`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\"), and like [`empty()`](../iter/fn.empty.html \"fn std::iter::empty\") if the [`Option`](enum.Option.html \"enum std::option::Option\") is [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\").\n\nIterators over [`Option<T>`](enum.Option.html \"enum std::option::Option\") come in three types:\n\n-   [`into_iter`](about:blank/enum.Option.html#method.into_iter \"method std::option::Option::into_iter\") consumes the [`Option`](enum.Option.html \"enum std::option::Option\") and produces the contained value\n-   [`iter`](about:blank/enum.Option.html#method.iter \"method std::option::Option::iter\") produces an immutable reference of type `&T` to the contained value\n-   [`iter_mut`](about:blank/enum.Option.html#method.iter_mut \"method std::option::Option::iter_mut\") produces a mutable reference of type `&mut T` to the contained value\n\nAn iterator over [`Option`](enum.Option.html \"enum std::option::Option\") can be useful when chaining iterators, for example, to conditionally insert items. (It’s not always necessary to explicitly call an iterator constructor: many [`Iterator`](../iter/trait.Iterator.html \"trait std::iter::Iterator\") methods that accept other iterators will also accept iterable types that implement [`IntoIterator`](../iter/trait.IntoIterator.html \"trait std::iter::IntoIterator\"), which includes [`Option`](enum.Option.html \"enum std::option::Option\").)\n\n```\nlet yep = Some(42);\nlet nope = None;\n// chain() already calls into_iter(), so we don't have to do so\nlet nums: Vec<i32> = (0..4).chain(yep).chain(4..8).collect();\nassert_eq!(nums, [0, 1, 2, 3, 42, 4, 5, 6, 7]);\nlet nums: Vec<i32> = (0..4).chain(nope).chain(4..8).collect();\nassert_eq!(nums, [0, 1, 2, 3, 4, 5, 6, 7]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+yep+=+Some(42);%0A++++let+nope+=+None;%0A++++//+chain()+already+calls+into_iter(),+so+we+don%27t+have+to+do+so%0A++++let+nums:+Vec%3Ci32%3E+=+(0..4).chain(yep).chain(4..8).collect();%0A++++assert_eq!(nums,+%5B0,+1,+2,+3,+42,+4,+5,+6,+7%5D);%0A++++let+nums:+Vec%3Ci32%3E+=+(0..4).chain(nope).chain(4..8).collect();%0A++++assert_eq!(nums,+%5B0,+1,+2,+3,+4,+5,+6,+7%5D);%0A%7D&edition=2021)\n\nOne reason to chain iterators in this way is that a function returning `impl Iterator` must have all possible return values be of the same concrete type. Chaining an iterated [`Option`](enum.Option.html \"enum std::option::Option\") can help with that.\n\n```\nfn make_iter(do_insert: bool) -> impl Iterator<Item = i32> {\n    // Explicit returns to illustrate return types matching\n    match do_insert {\n        true => return (0..4).chain(Some(42)).chain(4..8),\n        false => return (0..4).chain(None).chain(4..8),\n    }\n}\nprintln!(\"{:?}\", make_iter(true).collect::<Vec<_>>());\nprintln!(\"{:?}\", make_iter(false).collect::<Vec<_>>());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+make_iter(do_insert:+bool)+-%3E+impl+Iterator%3CItem+=+i32%3E+%7B%0A++++++++//+Explicit+returns+to+illustrate+return+types+matching%0A++++++++match+do_insert+%7B%0A++++++++++++true+=%3E+return+(0..4).chain(Some(42)).chain(4..8),%0A++++++++++++false+=%3E+return+(0..4).chain(None).chain(4..8),%0A++++++++%7D%0A++++%7D%0A++++println!(%22%7B:?%7D%22,+make_iter(true).collect::%3CVec%3C_%3E%3E());%0A++++println!(%22%7B:?%7D%22,+make_iter(false).collect::%3CVec%3C_%3E%3E());%0A%7D&edition=2021)\n\nIf we try to do the same thing, but using [`once()`](../iter/fn.once.html \"fn std::iter::once\") and [`empty()`](../iter/fn.empty.html \"fn std::iter::empty\"), we can’t return `impl Iterator` anymore because the concrete types of the return values differ.\n\n[ⓘ](# \"This example deliberately fails to compile\")\n\n```\n// This won't compile because all possible returns from the function\n// must have the same concrete type.\nfn make_iter(do_insert: bool) -> impl Iterator<Item = i32> {\n    // Explicit returns to illustrate return types not matching\n    match do_insert {\n        true => return (0..4).chain(once(42)).chain(4..8),\n        false => return (0..4).chain(empty()).chain(4..8),\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::iter::%7Bempty,+once%7D;%0A++++//+This+won%27t+compile+because+all+possible+returns+from+the+function%0A++++//+must+have+the+same+concrete+type.%0A++++fn+make_iter(do_insert:+bool)+-%3E+impl+Iterator%3CItem+=+i32%3E+%7B%0A++++++++//+Explicit+returns+to+illustrate+return+types+not+matching%0A++++++++match+do_insert+%7B%0A++++++++++++true+=%3E+return+(0..4).chain(once(42)).chain(4..8),%0A++++++++++++false+=%3E+return+(0..4).chain(empty()).chain(4..8),%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n### [§](#collecting-into-option)Collecting into `Option`\n\n[`Option`](enum.Option.html \"enum std::option::Option\") implements the [`FromIterator`](about:blank/enum.Option.html#impl-FromIterator%3COption%3CA%3E%3E-for-Option%3CV%3E \"enum std::option::Option\") trait, which allows an iterator over [`Option`](enum.Option.html \"enum std::option::Option\") values to be collected into an [`Option`](enum.Option.html \"enum std::option::Option\") of a collection of each contained value of the original [`Option`](enum.Option.html \"enum std::option::Option\") values, or [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") if any of the elements was [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\").\n\n```\nlet v = [Some(2), Some(4), None, Some(8)];\nlet res: Option<Vec<_>> = v.into_iter().collect();\nassert_eq!(res, None);\nlet v = [Some(2), Some(4), Some(8)];\nlet res: Option<Vec<_>> = v.into_iter().collect();\nassert_eq!(res, Some(vec![2, 4, 8]));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5BSome(2),+Some(4),+None,+Some(8)%5D;%0A++++let+res:+Option%3CVec%3C_%3E%3E+=+v.into_iter().collect();%0A++++assert_eq!(res,+None);%0A++++let+v+=+%5BSome(2),+Some(4),+Some(8)%5D;%0A++++let+res:+Option%3CVec%3C_%3E%3E+=+v.into_iter().collect();%0A++++assert_eq!(res,+Some(vec!%5B2,+4,+8%5D));%0A%7D&edition=2021)\n\n[`Option`](enum.Option.html \"enum std::option::Option\") also implements the [`Product`](about:blank/enum.Option.html#impl-Product%3COption%3CU%3E%3E-for-Option%3CT%3E \"enum std::option::Option\") and [`Sum`](about:blank/enum.Option.html#impl-Sum%3COption%3CU%3E%3E-for-Option%3CT%3E \"enum std::option::Option\") traits, allowing an iterator over [`Option`](enum.Option.html \"enum std::option::Option\") values to provide the [`product`](about:blank/iter/trait.Iterator.html#method.product \"method std::iter::Iterator::product\") and [`sum`](about:blank/iter/trait.Iterator.html#method.sum \"method std::iter::Iterator::sum\") methods.\n\n```\nlet v = [None, Some(1), Some(2), Some(3)];\nlet res: Option<i32> = v.into_iter().sum();\nassert_eq!(res, None);\nlet v = [Some(1), Some(2), Some(21)];\nlet res: Option<i32> = v.into_iter().product();\nassert_eq!(res, Some(42));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5BNone,+Some(1),+Some(2),+Some(3)%5D;%0A++++let+res:+Option%3Ci32%3E+=+v.into_iter().sum();%0A++++assert_eq!(res,+None);%0A++++let+v+=+%5BSome(1),+Some(2),+Some(21)%5D;%0A++++let+res:+Option%3Ci32%3E+=+v.into_iter().product();%0A++++assert_eq!(res,+Some(42));%0A%7D&edition=2021)\n\n### [§](#modifying-an-option-in-place)Modifying an [`Option`](enum.Option.html \"enum std::option::Option\") in-place\n\nThese methods return a mutable reference to the contained value of an [`Option<T>`](enum.Option.html \"enum std::option::Option\"):\n\n-   [`insert`](about:blank/enum.Option.html#method.insert \"method std::option::Option::insert\") inserts a value, dropping any old contents\n-   [`get_or_insert`](about:blank/enum.Option.html#method.get_or_insert \"method std::option::Option::get_or_insert\") gets the current value, inserting a provided default value if it is [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")\n-   [`get_or_insert_default`](about:blank/enum.Option.html#method.get_or_insert_default \"method std::option::Option::get_or_insert_default\") gets the current value, inserting the default value of type `T` (which must implement [`Default`](../default/trait.Default.html \"trait std::default::Default\")) if it is [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")\n-   [`get_or_insert_with`](about:blank/enum.Option.html#method.get_or_insert_with \"method std::option::Option::get_or_insert_with\") gets the current value, inserting a default computed by the provided function if it is [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")\n\nThese methods transfer ownership of the contained value of an [`Option`](enum.Option.html \"enum std::option::Option\"):\n\n-   [`take`](about:blank/enum.Option.html#method.take \"method std::option::Option::take\") takes ownership of the contained value of an [`Option`](enum.Option.html \"enum std::option::Option\"), if any, replacing the [`Option`](enum.Option.html \"enum std::option::Option\") with [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\")\n-   [`replace`](about:blank/enum.Option.html#method.replace \"method std::option::Option::replace\") takes ownership of the contained value of an [`Option`](enum.Option.html \"enum std::option::Option\"), if any, replacing the [`Option`](enum.Option.html \"enum std::option::Option\") with a [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") containing the provided value\n\n## [§](#examples)Examples\n\nBasic pattern matching on [`Option`](enum.Option.html \"enum std::option::Option\"):\n\n```\nlet msg = Some(\"howdy\");\n\n// Take a reference to the contained string\nif let Some(m) = &msg {\n    println!(\"{}\", *m);\n}\n\n// Remove the contained string, destroying the Option\nlet unwrapped_msg = msg.unwrap_or(\"default message\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+msg+=+Some(%22howdy%22);%0A++++%0A++++//+Take+a+reference+to+the+contained+string%0A++++if+let+Some(m)+=+%26msg+%7B%0A++++++++println!(%22%7B%7D%22,+*m);%0A++++%7D%0A++++%0A++++//+Remove+the+contained+string,+destroying+the+Option%0A++++let+unwrapped_msg+=+msg.unwrap_or(%22default+message%22);%0A%7D&edition=2021)\n\nInitialize a result to [`None`](about:blank/enum.Option.html#variant.None \"variant std::option::Option::None\") before a loop:\n\n```\nenum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n\n// A list of data to search through.\nlet all_the_big_things = [\n    Kingdom::Plant(250, \"redwood\"),\n    Kingdom::Plant(230, \"noble fir\"),\n    Kingdom::Plant(229, \"sugar pine\"),\n    Kingdom::Animal(25, \"blue whale\"),\n    Kingdom::Animal(19, \"fin whale\"),\n    Kingdom::Animal(15, \"north pacific right whale\"),\n];\n\n// We're going to search for the name of the biggest animal,\n// but to start with we've just got `None`.\nlet mut name_of_biggest_animal = None;\nlet mut size_of_biggest_animal = 0;\nfor big_thing in &all_the_big_things {\n    match *big_thing {\n        Kingdom::Animal(size, name) if size > size_of_biggest_animal => {\n            // Now we've found the name of some big animal\n            size_of_biggest_animal = size;\n            name_of_biggest_animal = Some(name);\n        }\n        Kingdom::Animal(..) | Kingdom::Plant(..) => ()\n    }\n}\n\nmatch name_of_biggest_animal {\n    Some(name) => println!(\"the biggest animal is {name}\"),\n    None => println!(\"there are no animals :(\"),\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++enum+Kingdom+%7B+Plant(u32,+%26%27static+str),+Animal(u32,+%26%27static+str)+%7D%0A++++%0A++++//+A+list+of+data+to+search+through.%0A++++let+all_the_big_things+=+%5B%0A++++++++Kingdom::Plant(250,+%22redwood%22),%0A++++++++Kingdom::Plant(230,+%22noble+fir%22),%0A++++++++Kingdom::Plant(229,+%22sugar+pine%22),%0A++++++++Kingdom::Animal(25,+%22blue+whale%22),%0A++++++++Kingdom::Animal(19,+%22fin+whale%22),%0A++++++++Kingdom::Animal(15,+%22north+pacific+right+whale%22),%0A++++%5D;%0A++++%0A++++//+We%27re+going+to+search+for+the+name+of+the+biggest+animal,%0A++++//+but+to+start+with+we%27ve+just+got+%60None%60.%0A++++let+mut+name_of_biggest_animal+=+None;%0A++++let+mut+size_of_biggest_animal+=+0;%0A++++for+big_thing+in+%26all_the_big_things+%7B%0A++++++++match+*big_thing+%7B%0A++++++++++++Kingdom::Animal(size,+name)+if+size+%3E+size_of_biggest_animal+=%3E+%7B%0A++++++++++++++++//+Now+we%27ve+found+the+name+of+some+big+animal%0A++++++++++++++++size_of_biggest_animal+=+size;%0A++++++++++++++++name_of_biggest_animal+=+Some(name);%0A++++++++++++%7D%0A++++++++++++Kingdom::Animal(..)+%7C+Kingdom::Plant(..)+=%3E+()%0A++++++++%7D%0A++++%7D%0A++++%0A++++match+name_of_biggest_animal+%7B%0A++++++++Some(name)+=%3E+println!(%22the+biggest+animal+is+%7Bname%7D%22),%0A++++++++None+=%3E+println!(%22there+are+no+animals+:(%22),%0A++++%7D%0A%7D&edition=2021)\n\n-   An iterator over the value in [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") variant of an [`Option`](enum.Option.html \"enum std::option::Option\").\n    \n-   An iterator over a reference to the [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") variant of an [`Option`](enum.Option.html \"enum std::option::Option\").\n    \n-   An iterator over a mutable reference to the [`Some`](about:blank/enum.Option.html#variant.Some \"variant std::option::Option::Some\") variant of an [`Option`](enum.Option.html \"enum std::option::Option\").",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Optional values.\"><title>std::option - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module option</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module option</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li><li><a href=\"#enums\">Enums</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">option</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/lib.rs.html#400\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Optional values.</p>\n<p>Type <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> represents an optional value: every <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>\nis either <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> and contains a value, or <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>, and\ndoes not. <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> types are very common in Rust code, as\nthey have a number of uses:</p>\n<ul>\n<li>Initial values</li>\n<li>Return values for functions that are not defined\nover their entire input range (partial functions)</li>\n<li>Return value for otherwise reporting simple errors, where <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is\nreturned on error</li>\n<li>Optional struct fields</li>\n<li>Struct fields that can be loaned or “taken”</li>\n<li>Optional function arguments</li>\n<li>Nullable pointers</li>\n<li>Swapping things out of difficult situations</li>\n</ul>\n<p><a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>s are commonly paired with pattern matching to query the presence\nof a value and take action, always accounting for the <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> case.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>divide(numerator: f64, denominator: f64) -&gt; <span class=\"prelude-ty\">Option</span>&lt;f64&gt; {\n    <span class=\"kw\">if </span>denominator == <span class=\"number\">0.0 </span>{\n        <span class=\"prelude-val\">None\n    </span>} <span class=\"kw\">else </span>{\n        <span class=\"prelude-val\">Some</span>(numerator / denominator)\n    }\n}\n\n<span class=\"comment\">// The return value of the function is an option\n</span><span class=\"kw\">let </span>result = divide(<span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>);\n\n<span class=\"comment\">// Pattern match to retrieve the value\n</span><span class=\"kw\">match </span>result {\n    <span class=\"comment\">// The division was valid\n    </span><span class=\"prelude-val\">Some</span>(x) =&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"Result: {x}\"</span>),\n    <span class=\"comment\">// The division was invalid\n    </span><span class=\"prelude-val\">None    </span>=&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"Cannot divide by 0\"</span>),\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+divide(numerator:+f64,+denominator:+f64)+-%3E+Option%3Cf64%3E+%7B%0A++++++++if+denominator+==+0.0+%7B%0A++++++++++++None%0A++++++++%7D+else+%7B%0A++++++++++++Some(numerator+/+denominator)%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+The+return+value+of+the+function+is+an+option%0A++++let+result+=+divide(2.0,+3.0);%0A++++%0A++++//+Pattern+match+to+retrieve+the+value%0A++++match+result+%7B%0A++++++++//+The+division+was+valid%0A++++++++Some(x)+=%3E+println!(%22Result:+%7Bx%7D%22),%0A++++++++//+The+division+was+invalid%0A++++++++None++++=%3E+println!(%22Cannot+divide+by+0%22),%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"options-and-pointers-nullable-pointers\"><a class=\"doc-anchor\" href=\"#options-and-pointers-nullable-pointers\">§</a>Options and pointers (“nullable” pointers)</h2>\n<p>Rust’s pointer types must always point to a valid location; there are\nno “null” references. Instead, Rust has <em>optional</em> pointers, like\nthe optional owned box, <code><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"../../std/boxed/struct.Box.html\">Box&lt;T&gt;</a>&gt;</code>.</p>\n<p>The following example uses <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> to create an optional box of\n<a href=\"../primitive.i32.html\" title=\"primitive i32\"><code>i32</code></a>. Notice that in order to use the inner <a href=\"../primitive.i32.html\" title=\"primitive i32\"><code>i32</code></a> value, the\n<code>check_optional</code> function first needs to use pattern matching to\ndetermine whether the box has a value (i.e., it is <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(...)</code></a>) or\nnot (<a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>).</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>optional = <span class=\"prelude-val\">None</span>;\ncheck_optional(optional);\n\n<span class=\"kw\">let </span>optional = <span class=\"prelude-val\">Some</span>(Box::new(<span class=\"number\">9000</span>));\ncheck_optional(optional);\n\n<span class=\"kw\">fn </span>check_optional(optional: <span class=\"prelude-ty\">Option</span>&lt;Box&lt;i32&gt;&gt;) {\n    <span class=\"kw\">match </span>optional {\n        <span class=\"prelude-val\">Some</span>(p) =&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"has value {p}\"</span>),\n        <span class=\"prelude-val\">None </span>=&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"has no value\"</span>),\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+optional+=+None;%0A++++check_optional(optional);%0A++++%0A++++let+optional+=+Some(Box::new(9000));%0A++++check_optional(optional);%0A++++%0A++++fn+check_optional(optional:+Option%3CBox%3Ci32%3E%3E)+%7B%0A++++++++match+optional+%7B%0A++++++++++++Some(p)+=%3E+println!(%22has+value+%7Bp%7D%22),%0A++++++++++++None+=%3E+println!(%22has+no+value%22),%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"the-question-mark-operator-\"><a class=\"doc-anchor\" href=\"#the-question-mark-operator-\">§</a>The question mark operator, <code>?</code></h2>\n<p>Similar to the <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> type, when writing code that calls many functions that return the\n<a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> type, handling <code>Some</code>/<code>None</code> can be tedious. The question mark\noperator, <a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>?</code></a>, hides some of the boilerplate of propagating values\nup the call stack.</p>\n<p>It replaces this:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>add_last_numbers(stack: <span class=\"kw-2\">&amp;mut </span>Vec&lt;i32&gt;) -&gt; <span class=\"prelude-ty\">Option</span>&lt;i32&gt; {\n    <span class=\"kw\">let </span>a = stack.pop();\n    <span class=\"kw\">let </span>b = stack.pop();\n\n    <span class=\"kw\">match </span>(a, b) {\n        (<span class=\"prelude-val\">Some</span>(x), <span class=\"prelude-val\">Some</span>(y)) =&gt; <span class=\"prelude-val\">Some</span>(x + y),\n        <span class=\"kw\">_ </span>=&gt; <span class=\"prelude-val\">None</span>,\n    }\n}\n</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++fn+add_last_numbers(stack:+%26mut+Vec%3Ci32%3E)+-%3E+Option%3Ci32%3E+%7B%0A++++++++let+a+=+stack.pop();%0A++++++++let+b+=+stack.pop();%0A++++%0A++++++++match+(a,+b)+%7B%0A++++++++++++(Some(x),+Some(y))+=%3E+Some(x+%2B+y),%0A++++++++++++_+=%3E+None,%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>With this:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>add_last_numbers(stack: <span class=\"kw-2\">&amp;mut </span>Vec&lt;i32&gt;) -&gt; <span class=\"prelude-ty\">Option</span>&lt;i32&gt; {\n    <span class=\"prelude-val\">Some</span>(stack.pop()<span class=\"question-mark\">? </span>+ stack.pop()<span class=\"question-mark\">?</span>)\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++fn+add_last_numbers(stack:+%26mut+Vec%3Ci32%3E)+-%3E+Option%3Ci32%3E+%7B%0A++++++++Some(stack.pop()?+%2B+stack.pop()?)%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p><em>It’s much nicer!</em></p>\n<p>Ending the expression with <a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>?</code></a> will result in the <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a>’s unwrapped value, unless the\nresult is <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>, in which case <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned early from the enclosing function.</p>\n<p><a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>?</code></a> can be used in functions that return <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> because of the\nearly return of <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> that it provides.</p>\n<h2 id=\"representation\"><a class=\"doc-anchor\" href=\"#representation\">§</a>Representation</h2>\n<p>Rust guarantees to optimize the following types <code>T</code> such that\n<a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a> has the same size, alignment, and <a href=\"../primitive.fn.html#abi-compatibility\">function call ABI</a> as <code>T</code>. In some\nof these cases, Rust further guarantees that\n<code>transmute::&lt;_, Option&lt;T&gt;&gt;([0u8; size_of::&lt;T&gt;()])</code> is sound and\nproduces <code>Option::&lt;T&gt;::None</code>. These cases are identified by the\nsecond column:</p>\n<div><table><thead><tr><th><code>T</code></th><th><code>transmute::&lt;_, Option&lt;T&gt;&gt;([0u8; size_of::&lt;T&gt;()])</code> sound?</th></tr></thead><tbody>\n<tr><td><a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;U&gt;</code></a> (specifically, only <code>Box&lt;U, Global&gt;</code>)</td><td>when <code>U: Sized</code></td></tr>\n<tr><td><code>&amp;U</code></td><td>when <code>U: Sized</code></td></tr>\n<tr><td><code>&amp;mut U</code></td><td>when <code>U: Sized</code></td></tr>\n<tr><td><code>fn</code>, <code>extern \"C\" fn</code><sup id=\"fnref1\"><a href=\"#fn1\">1</a></sup></td><td>always</td></tr>\n<tr><td><a href=\"https://doc.rust-lang.org/1.80.0/core/num/index.html\" title=\"mod core::num\"><code>num::NonZero*</code></a></td><td>always</td></tr>\n<tr><td><a href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\"><code>ptr::NonNull&lt;U&gt;</code></a></td><td>when <code>U: Sized</code></td></tr>\n<tr><td><code>#[repr(transparent)]</code> struct around one of the types in this list.</td><td>when it holds for the inner type</td></tr>\n</tbody></table>\n</div>\n<p>Under some conditions the above types <code>T</code> are also null pointer optimized when wrapped in a <a href=\"../result/index.html#representation\" title=\"mod std::result\"><code>Result</code></a>.</p>\n<p>This is called the “null pointer optimization” or NPO.</p>\n<p>It is further guaranteed that, for the cases above, one can\n<a href=\"../mem/fn.transmute.html\" title=\"fn std::mem::transmute\"><code>mem::transmute</code></a> from all valid values of <code>T</code> to <code>Option&lt;T&gt;</code> and\nfrom <code>Some::&lt;T&gt;(_)</code> to <code>T</code> (but transmuting <code>None::&lt;T&gt;</code> to <code>T</code>\nis undefined behaviour).</p>\n<h2 id=\"method-overview\"><a class=\"doc-anchor\" href=\"#method-overview\">§</a>Method overview</h2>\n<p>In addition to working with pattern matching, <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> provides a wide\nvariety of different methods.</p>\n<h3 id=\"querying-the-variant\"><a class=\"doc-anchor\" href=\"#querying-the-variant\">§</a>Querying the variant</h3>\n<p>The <a href=\"enum.Option.html#method.is_some\" title=\"method std::option::Option::is_some\"><code>is_some</code></a> and <a href=\"enum.Option.html#method.is_none\" title=\"method std::option::Option::is_none\"><code>is_none</code></a> methods return <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>\nis <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> or <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>, respectively.</p>\n<h3 id=\"adapters-for-working-with-references\"><a class=\"doc-anchor\" href=\"#adapters-for-working-with-references\">§</a>Adapters for working with references</h3>\n<ul>\n<li><a href=\"enum.Option.html#method.as_ref\" title=\"method std::option::Option::as_ref\"><code>as_ref</code></a> converts from <code><a href=\"../primitive.reference.html\" title=\"shared reference\">&amp;</a><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;</code> to <code><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"../primitive.reference.html\" title=\"shared reference\">&amp;</a>T&gt;</code></li>\n<li><a href=\"enum.Option.html#method.as_mut\" title=\"method std::option::Option::as_mut\"><code>as_mut</code></a> converts from <code><a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> <a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;</code> to <code><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> T&gt;</code></li>\n<li><a href=\"enum.Option.html#method.as_deref\" title=\"method std::option::Option::as_deref\"><code>as_deref</code></a> converts from <code><a href=\"../primitive.reference.html\" title=\"shared reference\">&amp;</a><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;</code> to\n<code><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"../primitive.reference.html\" title=\"shared reference\">&amp;</a>T::<a href=\"../ops/trait.Deref.html#associatedtype.Target\" title=\"ops::Deref::Target\">Target</a>&gt;</code></li>\n<li><a href=\"enum.Option.html#method.as_deref_mut\" title=\"method std::option::Option::as_deref_mut\"><code>as_deref_mut</code></a> converts from <code><a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> <a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;</code> to\n<code><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> T::<a href=\"../ops/trait.Deref.html#associatedtype.Target\" title=\"ops::Deref::Target\">Target</a>&gt;</code></li>\n<li><a href=\"enum.Option.html#method.as_pin_ref\" title=\"method std::option::Option::as_pin_ref\"><code>as_pin_ref</code></a> converts from <code><a href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"shared reference\">&amp;</a><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;&gt;</code> to\n<code><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"shared reference\">&amp;</a>T&gt;&gt;</code></li>\n<li><a href=\"enum.Option.html#method.as_pin_mut\" title=\"method std::option::Option::as_pin_mut\"><code>as_pin_mut</code></a> converts from <code><a href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> <a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;&gt;</code> to\n<code><a href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"../pin/struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> T&gt;&gt;</code></li>\n</ul>\n<h3 id=\"extracting-the-contained-value\"><a class=\"doc-anchor\" href=\"#extracting-the-contained-value\">§</a>Extracting the contained value</h3>\n<p>These methods extract the contained value in an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a> when it\nis the <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> variant. If the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> is <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>:</p>\n<ul>\n<li><a href=\"enum.Option.html#method.expect\" title=\"method std::option::Option::expect\"><code>expect</code></a> panics with a provided custom message</li>\n<li><a href=\"enum.Option.html#method.unwrap\" title=\"method std::option::Option::unwrap\"><code>unwrap</code></a> panics with a generic message</li>\n<li><a href=\"enum.Option.html#method.unwrap_or\" title=\"method std::option::Option::unwrap_or\"><code>unwrap_or</code></a> returns the provided default value</li>\n<li><a href=\"enum.Option.html#method.unwrap_or_default\" title=\"method std::option::Option::unwrap_or_default\"><code>unwrap_or_default</code></a> returns the default value of the type <code>T</code>\n(which must implement the <a href=\"../default/trait.Default.html\" title=\"trait std::default::Default\"><code>Default</code></a> trait)</li>\n<li><a href=\"enum.Option.html#method.unwrap_or_else\" title=\"method std::option::Option::unwrap_or_else\"><code>unwrap_or_else</code></a> returns the result of evaluating the provided\nfunction</li>\n</ul>\n<h3 id=\"transforming-contained-values\"><a class=\"doc-anchor\" href=\"#transforming-contained-values\">§</a>Transforming contained values</h3>\n<p>These methods transform <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> to <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>:</p>\n<ul>\n<li><a href=\"enum.Option.html#method.ok_or\" title=\"method std::option::Option::ok_or\"><code>ok_or</code></a> transforms <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(v)</code></a> to <a href=\"../result/enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok(v)</code></a>, and <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> to\n<a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err(err)</code></a> using the provided default <code>err</code> value</li>\n<li><a href=\"enum.Option.html#method.ok_or_else\" title=\"method std::option::Option::ok_or_else\"><code>ok_or_else</code></a> transforms <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(v)</code></a> to <a href=\"../result/enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok(v)</code></a>, and <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> to\na value of <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> using the provided function</li>\n<li><a href=\"enum.Option.html#method.transpose\" title=\"method std::option::Option::transpose\"><code>transpose</code></a> transposes an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> of a <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> into a\n<a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> of an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a></li>\n</ul>\n<p>These methods transform the <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> variant:</p>\n<ul>\n<li><a href=\"enum.Option.html#method.filter\" title=\"method std::option::Option::filter\"><code>filter</code></a> calls the provided predicate function on the contained\nvalue <code>t</code> if the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> is <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(t)</code></a>, and returns <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(t)</code></a>\nif the function returns <code>true</code>; otherwise, returns <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n<li><a href=\"enum.Option.html#method.flatten\" title=\"method std::option::Option::flatten\"><code>flatten</code></a> removes one level of nesting from an\n<a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;Option&lt;T&gt;&gt;</code></a></li>\n<li><a href=\"enum.Option.html#method.map\" title=\"method std::option::Option::map\"><code>map</code></a> transforms <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a> to <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;U&gt;</code></a> by applying the\nprovided function to the contained value of <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> and leaving\n<a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> values unchanged</li>\n</ul>\n<p>These methods transform <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a> to a value of a possibly\ndifferent type <code>U</code>:</p>\n<ul>\n<li><a href=\"enum.Option.html#method.map_or\" title=\"method std::option::Option::map_or\"><code>map_or</code></a> applies the provided function to the contained value of\n<a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a>, or returns the provided default value if the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> is\n<a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n<li><a href=\"enum.Option.html#method.map_or_else\" title=\"method std::option::Option::map_or_else\"><code>map_or_else</code></a> applies the provided function to the contained value\nof <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a>, or returns the result of evaluating the provided\nfallback function if the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> is <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n</ul>\n<p>These methods combine the <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> variants of two <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> values:</p>\n<ul>\n<li><a href=\"enum.Option.html#method.zip\" title=\"method std::option::Option::zip\"><code>zip</code></a> returns <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some((s, o))</code></a> if <code>self</code> is <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(s)</code></a> and the\nprovided <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> value is <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(o)</code></a>; otherwise, returns <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n<li><a href=\"enum.Option.html#method.zip_with\" title=\"method std::option::Option::zip_with\"><code>zip_with</code></a> calls the provided function <code>f</code> and returns\n<a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(f(s, o))</code></a> if <code>self</code> is <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(s)</code></a> and the provided\n<a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> value is <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(o)</code></a>; otherwise, returns <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n</ul>\n<h3 id=\"boolean-operators\"><a class=\"doc-anchor\" href=\"#boolean-operators\">§</a>Boolean operators</h3>\n<p>These methods treat the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> as a boolean value, where <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a>\nacts like <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> and <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> acts like <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>false</code></a>. There are two\ncategories of these methods: ones that take an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> as input, and\nones that take a function as input (to be lazily evaluated).</p>\n<p>The <a href=\"enum.Option.html#method.and\" title=\"method std::option::Option::and\"><code>and</code></a>, <a href=\"enum.Option.html#method.or\" title=\"method std::option::Option::or\"><code>or</code></a>, and <a href=\"enum.Option.html#method.xor\" title=\"method std::option::Option::xor\"><code>xor</code></a> methods take another <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> as\ninput, and produce an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> as output. Only the <a href=\"enum.Option.html#method.and\" title=\"method std::option::Option::and\"><code>and</code></a> method can\nproduce an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;U&gt;</code></a> value having a different inner type <code>U</code> than\n<a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a>.</p>\n<div><table><thead><tr><th>method</th><th>self</th><th>input</th><th>output</th></tr></thead><tbody>\n<tr><td><a href=\"enum.Option.html#method.and\" title=\"method std::option::Option::and\"><code>and</code></a></td><td><code>None</code></td><td>(ignored)</td><td><code>None</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.and\" title=\"method std::option::Option::and\"><code>and</code></a></td><td><code>Some(x)</code></td><td><code>None</code></td><td><code>None</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.and\" title=\"method std::option::Option::and\"><code>and</code></a></td><td><code>Some(x)</code></td><td><code>Some(y)</code></td><td><code>Some(y)</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.or\" title=\"method std::option::Option::or\"><code>or</code></a></td><td><code>None</code></td><td><code>None</code></td><td><code>None</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.or\" title=\"method std::option::Option::or\"><code>or</code></a></td><td><code>None</code></td><td><code>Some(y)</code></td><td><code>Some(y)</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.or\" title=\"method std::option::Option::or\"><code>or</code></a></td><td><code>Some(x)</code></td><td>(ignored)</td><td><code>Some(x)</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.xor\" title=\"method std::option::Option::xor\"><code>xor</code></a></td><td><code>None</code></td><td><code>None</code></td><td><code>None</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.xor\" title=\"method std::option::Option::xor\"><code>xor</code></a></td><td><code>None</code></td><td><code>Some(y)</code></td><td><code>Some(y)</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.xor\" title=\"method std::option::Option::xor\"><code>xor</code></a></td><td><code>Some(x)</code></td><td><code>None</code></td><td><code>Some(x)</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.xor\" title=\"method std::option::Option::xor\"><code>xor</code></a></td><td><code>Some(x)</code></td><td><code>Some(y)</code></td><td><code>None</code></td></tr>\n</tbody></table>\n</div>\n<p>The <a href=\"enum.Option.html#method.and_then\" title=\"method std::option::Option::and_then\"><code>and_then</code></a> and <a href=\"enum.Option.html#method.or_else\" title=\"method std::option::Option::or_else\"><code>or_else</code></a> methods take a function as input, and\nonly evaluate the function when they need to produce a new value. Only\nthe <a href=\"enum.Option.html#method.and_then\" title=\"method std::option::Option::and_then\"><code>and_then</code></a> method can produce an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;U&gt;</code></a> value having a\ndifferent inner type <code>U</code> than <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a>.</p>\n<div><table><thead><tr><th>method</th><th>self</th><th>function input</th><th>function result</th><th>output</th></tr></thead><tbody>\n<tr><td><a href=\"enum.Option.html#method.and_then\" title=\"method std::option::Option::and_then\"><code>and_then</code></a></td><td><code>None</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>None</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.and_then\" title=\"method std::option::Option::and_then\"><code>and_then</code></a></td><td><code>Some(x)</code></td><td><code>x</code></td><td><code>None</code></td><td><code>None</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.and_then\" title=\"method std::option::Option::and_then\"><code>and_then</code></a></td><td><code>Some(x)</code></td><td><code>x</code></td><td><code>Some(y)</code></td><td><code>Some(y)</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.or_else\" title=\"method std::option::Option::or_else\"><code>or_else</code></a></td><td><code>None</code></td><td>(not provided)</td><td><code>None</code></td><td><code>None</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.or_else\" title=\"method std::option::Option::or_else\"><code>or_else</code></a></td><td><code>None</code></td><td>(not provided)</td><td><code>Some(y)</code></td><td><code>Some(y)</code></td></tr>\n<tr><td><a href=\"enum.Option.html#method.or_else\" title=\"method std::option::Option::or_else\"><code>or_else</code></a></td><td><code>Some(x)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Some(x)</code></td></tr>\n</tbody></table>\n</div>\n<p>This is an example of using methods like <a href=\"enum.Option.html#method.and_then\" title=\"method std::option::Option::and_then\"><code>and_then</code></a> and <a href=\"enum.Option.html#method.or\" title=\"method std::option::Option::or\"><code>or</code></a> in a\npipeline of method calls. Early stages of the pipeline pass failure\nvalues (<a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>) through unchanged, and continue processing on\nsuccess values (<a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a>). Toward the end, <a href=\"enum.Option.html#method.or\" title=\"method std::option::Option::or\"><code>or</code></a> substitutes an error\nmessage if it receives <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>bt = BTreeMap::new();\nbt.insert(<span class=\"number\">20u8</span>, <span class=\"string\">\"foo\"</span>);\nbt.insert(<span class=\"number\">42u8</span>, <span class=\"string\">\"bar\"</span>);\n<span class=\"kw\">let </span>res = [<span class=\"number\">0u8</span>, <span class=\"number\">1</span>, <span class=\"number\">11</span>, <span class=\"number\">200</span>, <span class=\"number\">22</span>]\n    .into_iter()\n    .map(|x| {\n        <span class=\"comment\">// `checked_sub()` returns `None` on error\n        </span>x.checked_sub(<span class=\"number\">1</span>)\n            <span class=\"comment\">// same with `checked_mul()`\n            </span>.and_then(|x| x.checked_mul(<span class=\"number\">2</span>))\n            <span class=\"comment\">// `BTreeMap::get` returns `None` on error\n            </span>.and_then(|x| bt.get(<span class=\"kw-2\">&amp;</span>x))\n            <span class=\"comment\">// Substitute an error message if we have `None` so far\n            </span>.or(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"string\">\"error!\"</span>))\n            .copied()\n            <span class=\"comment\">// Won't panic because we unconditionally used `Some` above\n            </span>.unwrap()\n    })\n    .collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(res, [<span class=\"string\">\"error!\"</span>, <span class=\"string\">\"error!\"</span>, <span class=\"string\">\"foo\"</span>, <span class=\"string\">\"error!\"</span>, <span class=\"string\">\"bar\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++let+mut+bt+=+BTreeMap::new();%0A++++bt.insert(20u8,+%22foo%22);%0A++++bt.insert(42u8,+%22bar%22);%0A++++let+res+=+%5B0u8,+1,+11,+200,+22%5D%0A++++++++.into_iter()%0A++++++++.map(%7Cx%7C+%7B%0A++++++++++++//+%60checked_sub()%60+returns+%60None%60+on+error%0A++++++++++++x.checked_sub(1)%0A++++++++++++++++//+same+with+%60checked_mul()%60%0A++++++++++++++++.and_then(%7Cx%7C+x.checked_mul(2))%0A++++++++++++++++//+%60BTreeMap::get%60+returns+%60None%60+on+error%0A++++++++++++++++.and_then(%7Cx%7C+bt.get(%26x))%0A++++++++++++++++//+Substitute+an+error+message+if+we+have+%60None%60+so+far%0A++++++++++++++++.or(Some(%26%22error!%22))%0A++++++++++++++++.copied()%0A++++++++++++++++//+Won't+panic+because+we+unconditionally+used+%60Some%60+above%0A++++++++++++++++.unwrap()%0A++++++++%7D)%0A++++++++.collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(res,+%5B%22error!%22,+%22error!%22,+%22foo%22,+%22error!%22,+%22bar%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"comparison-operators\"><a class=\"doc-anchor\" href=\"#comparison-operators\">§</a>Comparison operators</h3>\n<p>If <code>T</code> implements <a href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\"><code>PartialOrd</code></a> then <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a> will derive its\n<a href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\"><code>PartialOrd</code></a> implementation.  With this order, <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> compares as\nless than any <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a>, and two <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> compare the same way as their\ncontained values would in <code>T</code>.  If <code>T</code> also implements\n<a href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\"><code>Ord</code></a>, then so does <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert!</span>(<span class=\"prelude-val\">None </span>&lt; <span class=\"prelude-val\">Some</span>(<span class=\"number\">0</span>));\n<span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"number\">0</span>) &lt; <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!(None+%3C+Some(0));%0A++++assert!(Some(0)+%3C+Some(1));%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"iterating-over-option\"><a class=\"doc-anchor\" href=\"#iterating-over-option\">§</a>Iterating over <code>Option</code></h3>\n<p>An <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> can be iterated over. This can be helpful if you need an\niterator that is conditionally empty. The iterator will either produce\na single value (when the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> is <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a>), or produce no values\n(when the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> is <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>). For example, <a href=\"enum.Option.html#method.into_iter\" title=\"method std::option::Option::into_iter\"><code>into_iter</code></a> acts like\n<a href=\"../iter/fn.once.html\" title=\"fn std::iter::once\"><code>once(v)</code></a> if the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> is <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(v)</code></a>, and like <a href=\"../iter/fn.empty.html\" title=\"fn std::iter::empty\"><code>empty()</code></a> if\nthe <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> is <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.</p>\n<p>Iterators over <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a> come in three types:</p>\n<ul>\n<li><a href=\"enum.Option.html#method.into_iter\" title=\"method std::option::Option::into_iter\"><code>into_iter</code></a> consumes the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> and produces the contained\nvalue</li>\n<li><a href=\"enum.Option.html#method.iter\" title=\"method std::option::Option::iter\"><code>iter</code></a> produces an immutable reference of type <code>&amp;T</code> to the\ncontained value</li>\n<li><a href=\"enum.Option.html#method.iter_mut\" title=\"method std::option::Option::iter_mut\"><code>iter_mut</code></a> produces a mutable reference of type <code>&amp;mut T</code> to the\ncontained value</li>\n</ul>\n<p>An iterator over <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> can be useful when chaining iterators, for\nexample, to conditionally insert items. (It’s not always necessary to\nexplicitly call an iterator constructor: many <a href=\"../iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> methods that\naccept other iterators will also accept iterable types that implement\n<a href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a>, which includes <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>.)</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>yep = <span class=\"prelude-val\">Some</span>(<span class=\"number\">42</span>);\n<span class=\"kw\">let </span>nope = <span class=\"prelude-val\">None</span>;\n<span class=\"comment\">// chain() already calls into_iter(), so we don't have to do so\n</span><span class=\"kw\">let </span>nums: Vec&lt;i32&gt; = (<span class=\"number\">0</span>..<span class=\"number\">4</span>).chain(yep).chain(<span class=\"number\">4</span>..<span class=\"number\">8</span>).collect();\n<span class=\"macro\">assert_eq!</span>(nums, [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">42</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>]);\n<span class=\"kw\">let </span>nums: Vec&lt;i32&gt; = (<span class=\"number\">0</span>..<span class=\"number\">4</span>).chain(nope).chain(<span class=\"number\">4</span>..<span class=\"number\">8</span>).collect();\n<span class=\"macro\">assert_eq!</span>(nums, [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+yep+=+Some(42);%0A++++let+nope+=+None;%0A++++//+chain()+already+calls+into_iter(),+so+we+don't+have+to+do+so%0A++++let+nums:+Vec%3Ci32%3E+=+(0..4).chain(yep).chain(4..8).collect();%0A++++assert_eq!(nums,+%5B0,+1,+2,+3,+42,+4,+5,+6,+7%5D);%0A++++let+nums:+Vec%3Ci32%3E+=+(0..4).chain(nope).chain(4..8).collect();%0A++++assert_eq!(nums,+%5B0,+1,+2,+3,+4,+5,+6,+7%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>One reason to chain iterators in this way is that a function returning\n<code>impl Iterator</code> must have all possible return values be of the same\nconcrete type. Chaining an iterated <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> can help with that.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>make_iter(do_insert: bool) -&gt; <span class=\"kw\">impl </span>Iterator&lt;Item = i32&gt; {\n    <span class=\"comment\">// Explicit returns to illustrate return types matching\n    </span><span class=\"kw\">match </span>do_insert {\n        <span class=\"bool-val\">true </span>=&gt; <span class=\"kw\">return </span>(<span class=\"number\">0</span>..<span class=\"number\">4</span>).chain(<span class=\"prelude-val\">Some</span>(<span class=\"number\">42</span>)).chain(<span class=\"number\">4</span>..<span class=\"number\">8</span>),\n        <span class=\"bool-val\">false </span>=&gt; <span class=\"kw\">return </span>(<span class=\"number\">0</span>..<span class=\"number\">4</span>).chain(<span class=\"prelude-val\">None</span>).chain(<span class=\"number\">4</span>..<span class=\"number\">8</span>),\n    }\n}\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{:?}\"</span>, make_iter(<span class=\"bool-val\">true</span>).collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;());\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{:?}\"</span>, make_iter(<span class=\"bool-val\">false</span>).collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+make_iter(do_insert:+bool)+-%3E+impl+Iterator%3CItem+=+i32%3E+%7B%0A++++++++//+Explicit+returns+to+illustrate+return+types+matching%0A++++++++match+do_insert+%7B%0A++++++++++++true+=%3E+return+(0..4).chain(Some(42)).chain(4..8),%0A++++++++++++false+=%3E+return+(0..4).chain(None).chain(4..8),%0A++++++++%7D%0A++++%7D%0A++++println!(%22%7B:?%7D%22,+make_iter(true).collect::%3CVec%3C_%3E%3E());%0A++++println!(%22%7B:?%7D%22,+make_iter(false).collect::%3CVec%3C_%3E%3E());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If we try to do the same thing, but using <a href=\"../iter/fn.once.html\" title=\"fn std::iter::once\"><code>once()</code></a> and <a href=\"../iter/fn.empty.html\" title=\"fn std::iter::empty\"><code>empty()</code></a>,\nwe can’t return <code>impl Iterator</code> anymore because the concrete types of\nthe return values differ.</p>\n\n<div class=\"example-wrap compile_fail\"><a href=\"#\" class=\"tooltip\" title=\"This example deliberately fails to compile\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// This won't compile because all possible returns from the function\n// must have the same concrete type.\n</span><span class=\"kw\">fn </span>make_iter(do_insert: bool) -&gt; <span class=\"kw\">impl </span>Iterator&lt;Item = i32&gt; {\n    <span class=\"comment\">// Explicit returns to illustrate return types not matching\n    </span><span class=\"kw\">match </span>do_insert {\n        <span class=\"bool-val\">true </span>=&gt; <span class=\"kw\">return </span>(<span class=\"number\">0</span>..<span class=\"number\">4</span>).chain(once(<span class=\"number\">42</span>)).chain(<span class=\"number\">4</span>..<span class=\"number\">8</span>),\n        <span class=\"bool-val\">false </span>=&gt; <span class=\"kw\">return </span>(<span class=\"number\">0</span>..<span class=\"number\">4</span>).chain(empty()).chain(<span class=\"number\">4</span>..<span class=\"number\">8</span>),\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::iter::%7Bempty,+once%7D;%0A++++//+This+won't+compile+because+all+possible+returns+from+the+function%0A++++//+must+have+the+same+concrete+type.%0A++++fn+make_iter(do_insert:+bool)+-%3E+impl+Iterator%3CItem+=+i32%3E+%7B%0A++++++++//+Explicit+returns+to+illustrate+return+types+not+matching%0A++++++++match+do_insert+%7B%0A++++++++++++true+=%3E+return+(0..4).chain(once(42)).chain(4..8),%0A++++++++++++false+=%3E+return+(0..4).chain(empty()).chain(4..8),%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"collecting-into-option\"><a class=\"doc-anchor\" href=\"#collecting-into-option\">§</a>Collecting into <code>Option</code></h3>\n<p><a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> implements the <a href=\"enum.Option.html#impl-FromIterator%3COption%3CA%3E%3E-for-Option%3CV%3E\" title=\"enum std::option::Option\"><code>FromIterator</code></a> trait,\nwhich allows an iterator over <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> values to be collected into an\n<a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> of a collection of each contained value of the original\n<a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> values, or <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> if any of the elements was <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>), <span class=\"prelude-val\">None</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">8</span>)];\n<span class=\"kw\">let </span>res: <span class=\"prelude-ty\">Option</span>&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt; = v.into_iter().collect();\n<span class=\"macro\">assert_eq!</span>(res, <span class=\"prelude-val\">None</span>);\n<span class=\"kw\">let </span>v = [<span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">8</span>)];\n<span class=\"kw\">let </span>res: <span class=\"prelude-ty\">Option</span>&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt; = v.into_iter().collect();\n<span class=\"macro\">assert_eq!</span>(res, <span class=\"prelude-val\">Some</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>]));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5BSome(2),+Some(4),+None,+Some(8)%5D;%0A++++let+res:+Option%3CVec%3C_%3E%3E+=+v.into_iter().collect();%0A++++assert_eq!(res,+None);%0A++++let+v+=+%5BSome(2),+Some(4),+Some(8)%5D;%0A++++let+res:+Option%3CVec%3C_%3E%3E+=+v.into_iter().collect();%0A++++assert_eq!(res,+Some(vec!%5B2,+4,+8%5D));%0A%7D&amp;edition=2021\">Run</a></div>\n<p><a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> also implements the <a href=\"enum.Option.html#impl-Product%3COption%3CU%3E%3E-for-Option%3CT%3E\" title=\"enum std::option::Option\"><code>Product</code></a> and\n<a href=\"enum.Option.html#impl-Sum%3COption%3CU%3E%3E-for-Option%3CT%3E\" title=\"enum std::option::Option\"><code>Sum</code></a> traits, allowing an iterator over <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> values\nto provide the <a href=\"../iter/trait.Iterator.html#method.product\" title=\"method std::iter::Iterator::product\"><code>product</code></a> and\n<a href=\"../iter/trait.Iterator.html#method.sum\" title=\"method std::iter::Iterator::sum\"><code>sum</code></a> methods.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"prelude-val\">None</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>)];\n<span class=\"kw\">let </span>res: <span class=\"prelude-ty\">Option</span>&lt;i32&gt; = v.into_iter().sum();\n<span class=\"macro\">assert_eq!</span>(res, <span class=\"prelude-val\">None</span>);\n<span class=\"kw\">let </span>v = [<span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">21</span>)];\n<span class=\"kw\">let </span>res: <span class=\"prelude-ty\">Option</span>&lt;i32&gt; = v.into_iter().product();\n<span class=\"macro\">assert_eq!</span>(res, <span class=\"prelude-val\">Some</span>(<span class=\"number\">42</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5BNone,+Some(1),+Some(2),+Some(3)%5D;%0A++++let+res:+Option%3Ci32%3E+=+v.into_iter().sum();%0A++++assert_eq!(res,+None);%0A++++let+v+=+%5BSome(1),+Some(2),+Some(21)%5D;%0A++++let+res:+Option%3Ci32%3E+=+v.into_iter().product();%0A++++assert_eq!(res,+Some(42));%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"modifying-an-option-in-place\"><a class=\"doc-anchor\" href=\"#modifying-an-option-in-place\">§</a>Modifying an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> in-place</h3>\n<p>These methods return a mutable reference to the contained value of an\n<a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a>:</p>\n<ul>\n<li><a href=\"enum.Option.html#method.insert\" title=\"method std::option::Option::insert\"><code>insert</code></a> inserts a value, dropping any old contents</li>\n<li><a href=\"enum.Option.html#method.get_or_insert\" title=\"method std::option::Option::get_or_insert\"><code>get_or_insert</code></a> gets the current value, inserting a provided\ndefault value if it is <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n<li><a href=\"enum.Option.html#method.get_or_insert_default\" title=\"method std::option::Option::get_or_insert_default\"><code>get_or_insert_default</code></a> gets the current value, inserting the\ndefault value of type <code>T</code> (which must implement <a href=\"../default/trait.Default.html\" title=\"trait std::default::Default\"><code>Default</code></a>) if it is\n<a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n<li><a href=\"enum.Option.html#method.get_or_insert_with\" title=\"method std::option::Option::get_or_insert_with\"><code>get_or_insert_with</code></a> gets the current value, inserting a default\ncomputed by the provided function if it is <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n</ul>\n<p>These methods transfer ownership of the contained value of an\n<a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>:</p>\n<ul>\n<li><a href=\"enum.Option.html#method.take\" title=\"method std::option::Option::take\"><code>take</code></a> takes ownership of the contained value of an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>, if\nany, replacing the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> with <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n<li><a href=\"enum.Option.html#method.replace\" title=\"method std::option::Option::replace\"><code>replace</code></a> takes ownership of the contained value of an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>,\nif any, replacing the <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> with a <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> containing the\nprovided value</li>\n</ul>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>Basic pattern matching on <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>msg = <span class=\"prelude-val\">Some</span>(<span class=\"string\">\"howdy\"</span>);\n\n<span class=\"comment\">// Take a reference to the contained string\n</span><span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(m) = <span class=\"kw-2\">&amp;</span>msg {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"kw-2\">*</span>m);\n}\n\n<span class=\"comment\">// Remove the contained string, destroying the Option\n</span><span class=\"kw\">let </span>unwrapped_msg = msg.unwrap_or(<span class=\"string\">\"default message\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+msg+=+Some(%22howdy%22);%0A++++%0A++++//+Take+a+reference+to+the+contained+string%0A++++if+let+Some(m)+=+%26msg+%7B%0A++++++++println!(%22%7B%7D%22,+*m);%0A++++%7D%0A++++%0A++++//+Remove+the+contained+string,+destroying+the+Option%0A++++let+unwrapped_msg+=+msg.unwrap_or(%22default+message%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Initialize a result to <a href=\"enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> before a loop:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">enum </span>Kingdom { Plant(u32, <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'static </span>str), Animal(u32, <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'static </span>str) }\n\n<span class=\"comment\">// A list of data to search through.\n</span><span class=\"kw\">let </span>all_the_big_things = [\n    Kingdom::Plant(<span class=\"number\">250</span>, <span class=\"string\">\"redwood\"</span>),\n    Kingdom::Plant(<span class=\"number\">230</span>, <span class=\"string\">\"noble fir\"</span>),\n    Kingdom::Plant(<span class=\"number\">229</span>, <span class=\"string\">\"sugar pine\"</span>),\n    Kingdom::Animal(<span class=\"number\">25</span>, <span class=\"string\">\"blue whale\"</span>),\n    Kingdom::Animal(<span class=\"number\">19</span>, <span class=\"string\">\"fin whale\"</span>),\n    Kingdom::Animal(<span class=\"number\">15</span>, <span class=\"string\">\"north pacific right whale\"</span>),\n];\n\n<span class=\"comment\">// We're going to search for the name of the biggest animal,\n// but to start with we've just got `None`.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>name_of_biggest_animal = <span class=\"prelude-val\">None</span>;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>size_of_biggest_animal = <span class=\"number\">0</span>;\n<span class=\"kw\">for </span>big_thing <span class=\"kw\">in </span><span class=\"kw-2\">&amp;</span>all_the_big_things {\n    <span class=\"kw\">match </span><span class=\"kw-2\">*</span>big_thing {\n        Kingdom::Animal(size, name) <span class=\"kw\">if </span>size &gt; size_of_biggest_animal =&gt; {\n            <span class=\"comment\">// Now we've found the name of some big animal\n            </span>size_of_biggest_animal = size;\n            name_of_biggest_animal = <span class=\"prelude-val\">Some</span>(name);\n        }\n        Kingdom::Animal(..) | Kingdom::Plant(..) =&gt; ()\n    }\n}\n\n<span class=\"kw\">match </span>name_of_biggest_animal {\n    <span class=\"prelude-val\">Some</span>(name) =&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"the biggest animal is {name}\"</span>),\n    <span class=\"prelude-val\">None </span>=&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"there are no animals :(\"</span>),\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++enum+Kingdom+%7B+Plant(u32,+%26'static+str),+Animal(u32,+%26'static+str)+%7D%0A++++%0A++++//+A+list+of+data+to+search+through.%0A++++let+all_the_big_things+=+%5B%0A++++++++Kingdom::Plant(250,+%22redwood%22),%0A++++++++Kingdom::Plant(230,+%22noble+fir%22),%0A++++++++Kingdom::Plant(229,+%22sugar+pine%22),%0A++++++++Kingdom::Animal(25,+%22blue+whale%22),%0A++++++++Kingdom::Animal(19,+%22fin+whale%22),%0A++++++++Kingdom::Animal(15,+%22north+pacific+right+whale%22),%0A++++%5D;%0A++++%0A++++//+We're+going+to+search+for+the+name+of+the+biggest+animal,%0A++++//+but+to+start+with+we've+just+got+%60None%60.%0A++++let+mut+name_of_biggest_animal+=+None;%0A++++let+mut+size_of_biggest_animal+=+0;%0A++++for+big_thing+in+%26all_the_big_things+%7B%0A++++++++match+*big_thing+%7B%0A++++++++++++Kingdom::Animal(size,+name)+if+size+%3E+size_of_biggest_animal+=%3E+%7B%0A++++++++++++++++//+Now+we've+found+the+name+of+some+big+animal%0A++++++++++++++++size_of_biggest_animal+=+size;%0A++++++++++++++++name_of_biggest_animal+=+Some(name);%0A++++++++++++%7D%0A++++++++++++Kingdom::Animal(..)+%7C+Kingdom::Plant(..)+=%3E+()%0A++++++++%7D%0A++++%7D%0A++++%0A++++match+name_of_biggest_animal+%7B%0A++++++++Some(name)+=%3E+println!(%22the+biggest+animal+is+%7Bname%7D%22),%0A++++++++None+=%3E+println!(%22there+are+no+animals+:(%22),%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<div class=\"footnotes\"><hr><ol><li id=\"fn1\"><p>this remains true for any argument/return types and any other ABI: <code>extern \"abi\" fn</code> (<em>e.g.</em>, <code>extern \"system\" fn</code>)&nbsp;<a href=\"#fnref1\">↩</a></p></li></ol></div></div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.IntoIter.html\" title=\"struct std::option::IntoIter\">IntoIter</a></div><div class=\"desc docblock-short\">An iterator over the value in <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> variant of an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct std::option::Iter\">Iter</a></div><div class=\"desc docblock-short\">An iterator over a reference to the <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> variant of an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct std::option::IterMut\">IterMut</a></div><div class=\"desc docblock-short\">An iterator over a mutable reference to the <a href=\"enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a> variant of an <a href=\"enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>.</div></li></ul><h2 id=\"enums\" class=\"section-header\">Enums<a href=\"#enums\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.Option.html\" title=\"enum std::option::Option\">Option</a></div><div class=\"desc docblock-short\">The <code>Option</code> type. See <a href=\"index.html\" title=\"mod std::option\">the module level documentation</a> for more.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:04.055Z"
}